<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a843af2a42f97f60607422cb1877655f0a217d552d73b97850917ea8f301695031d12571f33c7db908396d9c804e733aa8eb01e9c1d67e0de72a191ac1c3915b355b35bfa889c5be2f245dce390f38c9100df47551be54949da7f8f5b1b19e3aba62949ab99401cfd09382f1b71a580754e8139780ebc57af3ee2a47ddeedcd82f48b1b768ea3bf0c4ac6a3c8e9db5a328d1c015659daebcce917770dda2a0926c345a527c7184dfa6a37222e233182fc053ff43978e1a6614b95d927f847d7179dc5987ce6d0e767de169ac0554b86a13eac08c1030933c51850be5b0a394b569581474e357a820605fb7f748910e15674875da4e34778b421f09291ccc885b87ae3e973e1898ed8f0102c688fb05d39b2c0733d770e9272fd2a3615ec44f87d53ca68ab373d4990120bce4ca19a0f8e92af2ae724b4d317452bc294a40dff4cc43975edbc37efec5efe0843039776d2d97b0578ea0712f28fc581c95d3f80ae466d128eaf842980b64747d16d58b19638bf06f2ee5708baf5077badb4980bc9462c3993c499c92241151a84a93062f08ca4f0d4181e88ab9b57adf238136ed03d99d69128331dc3ceafbc0a82cc6de40c6edc608bff4e957e9f19bbf1e790d1544450be135bba9c190b84b7b3fc0f01fd8acf8b6d3ac7ce130a97871f495e39bee5487c9f34fb9a227bc6ac265d5751ba2b1acb3fb33399ce23442e08e53ac5d52e46592fe81b2f001da8e2e6150f5b583f4c758d5720eef62fdac221113584656864e4e3d3b1746a8ba8a2e57f9e9a756ddbac0211b084899819d76ce280dabb94b58a03fd62ab78d9f1837531dd07c44365122a9b51fe512cd0e5316f8eba81dba5347894b8fb9b7864e9c9879cdc379f94b85bb674d706dceaa1710da6a735f386c77d0ac008811b91656bab0dc04ab53631ac0fedef895b3fa445ce001325ccc95651a0e149d20b8eb261dc20050ff9f068388f8c7b9cb72e35b9564f57f06d43237ca5e53d44cde4a446d93bd5833ce3b057faf54a75f3601d8a8134598092715f237730068ca63e9059efe29b34df72405de443d5482ddfedeab69c720906f6040abcdc0c9d7b29b685765f0660e064bbeef2521a77aa356012a9882528d4292583907879d01fb7cd02b24adaa0f1629b5245d8134c1080ca429324483416111e9dfdd257fa82516b1e2564258d5ce525a401ee7c99e2aa2ecfc6a5a5464f24db029b979e5a3dc53d1410400881b92be3865fe5314b34e8b65258306ce030b19d6802b108557dfbd218491dd6ff84b1a455ae6b210cfa71a5a96e7fa3c35a6efbafd922a6a1d5ea16c6c2384c07ac0de81602b047dc539fac281d457e1ef25e237ef086827d1a3367ea08d9cfc2b98a5fe48ae20ec6e3bf36f853e510cb8a8e8aeca0e74018a5f09da2ba9f91420e8566b9775f46377eae336cdf03d127f38693173ceb1f43431a8590baca11fbd1a115fe99e9a7df5a914cd0f17b6f59017963e8ec7724d510f85c903ebd9fcc0be2a40cbc25c9b5d4ef5191184c65053d0c57343ee6863dc0ba1043fc4111b757e38ba6fcf8047e05df1d1ee550789e86f437d365d33068e69fde0b825d587305694ad114c0d5c792684bf819fecb9312f225c87ab89846a1c69889b359eba2260187bf5febfcf0a920802d3bc46f072c04a6cc4e5abd7e698ef7227eb70a6cb3a1895696b8cf899f4551a1a0e3afb3aec1506e10ff57a00e41ec08f07ce58810b5449d996ca6ff3daf290d56402690e30b14ad6c6e11945235c4c7331dbfc560b4cd5834b212ef9977b352c66e73d5a351bff3bed374902423d45089926f3694b81a0b21c33c3ad2414e47dbc594e2e586e1b2974b1e1cfdc038c28c6aa74d15419aa6ef1b3a1b2e70036b2d4c37a7d40db03ba80e03f8f28a21c36e376f6683ac533cdb3d6f230c820fe639f9868738e36ef9c9f77a18b5327f70735ac2cbdda031291d52987fe64ced655cc81959c8b81d64db425f6830b8962a7c66dce4523451679572bad15332e54576324774f5b52d8617116049f37c75ddeb3137f89ffd248203253b776f58d934be0019ad7ff9f310420648ff29f9e9bc13c279615024687aad1b397b1120802f1485968f0e9a0c549b5fb7e26550da9ad0738c5a0317ef75029a5eca07aaf94665577bd2a5ead1889a63367f5690bac33fb0aa2b213385477444dd1307270542c1dc777a99474e95761b994d7ad3a896137501c1ae4e47c12c309d7834837b90bf6370ec85f9aea120be630bbacac817becfe67507d2867d716f1fa3bf7751fb6ecd329cf827852fc9c0368ce57a626879a050b8fdb07d8ef22a955112e3e55e76e111bd07e6d87db8bad8b89725e60f9649bbdc4878eea0fa36b0c59db7546b5b9dc91ae79e2a9cc513ab0751e7108d749f997d5942116f2b5bc57644fde25f763d1fa86d3476adae1e52d1dc936b9db55384fbba8e5f164efdfabe281d0ef70c03af1dfc73028e2ade93356ad2b95c3ba167340a51d19472435f933f7507e98e94a6c313dfb49a9fa54798464571745eeb7b9f6b5b48bc5c2580aa9f25f749c4e6a7fa67a953814dfdea638be14cffb29a89e9c76166559574da1e363f4e5fbe02ffcfcea94b9ef9b73052ca8532edfd29f686adc0dd3955b9c900b4d996898118b5ce0260b97dbe8fec00274131edf89c95f52297ef1c54459f49bec0f88b6e8a87ce52a6b8f4e3e3a072dbd8d5f2534f5dcc6be6e03aacb85c4ea3a8daf77af4d8f1107b2526abf88543cbfb59667882085c0fd613b9914d559d2707828c9f7231812653dc333a446299c66cd04eb7b684a0ab5926072c7e52f9fbe3e56707f5f84695be90606ff24d1db721ca1ae7ee76295628abc782942748c3602e3cd38ee919ac69c64e4254e2ffb10fa4732d3eac163cb19218c7d0593f3e9f3ac67bf71846014bf451ea08024d1e3535c2ed4b800419fa31da2bc5aa133bfc369961a624737fbd93fcc340df918cdbc578581ceccd6905c25216aad67f3ea4aad557a63668c73a8814c39df8c81869c01ec22e6f239019c621f13103df18be78d5e70d0cb4d9c4ae4aa5efe1f19b0f64f5578b47c8575766b029348e699cb46b96e3370deef4062da900ea8baeacc18f5aff4e654e1f7cd2cea3c3d56ae46ecb3d52ecaa859118b343489ebbe0f7b362965eb5c4dc6e822d13a87db504f896c7b61a8245a4daf4d222963868218ca6d5d1bbbc93b9f9950ce82bebc070402ae7e947e20b2281f01a5241c7679bfa2c8ed5ca9f07c34d8d0dbb698eb34f5e35edf314098a282b09a2b1b64938d71129260d1fb48e4596dfcc588ae6d3376092be413f3107600e090fc1a644494a39a8ac1468a31a2a296d0d94f085f3e3aa1ff7d6ffbfad0ed4989871d38518fdbfaecc8fea279e7689f2caf79ac40b3ba1a7e5e91a789b243fe2debe1cf5eb8ff27b25d78ccba882c5eef6b916ad01832a4760efca4c2f84ebc429b4199bab2f52f242f9279231904bae65d411aa719c1e4a9a484b8ba5742f328add1e3a85ab6f86cf51b38ccb0d950d751bd43d738bbb23b3678d689bbfde6d1653b966615730360ed40dfc32406e086cbb0c8c1da771a608251d06d37cb68df333aa1c97672e1615903007964467453020c1d4f9e89d9cd377297c0ad4f2a52bee3cb59821e95d9754a7e9b9e9a3c0d2dac7a7ede3f6f110b2144c75c732ecf94a0a229aa269827bc56c2cae934c75b1b90ff4de3edf9231d6490e8b099e695ef672f6ed42b89685a6b267c5c6bdf702643768fdc91d62129ed56928f41dacb11794e2751a5e2a2b3c6097810c2414b9ece99d51b0bd596d6ad839f123fbaf1d9898ddfaadf42a27b61b33fdb807e7865892ee6f238c7f1681c1435c5cafcfd097891b69a70027884e11cb9694554be9aa253f26cee6bcad6239839be799363fb2695e7a0cb8351505ee32a7c44112b5ccd69f9b46a3c702ebecb7ce52ba2b6849d315c130992cb662a949940b29e364aa26c67988c38fff8f8208383d2ed5630f7799974cd02ac2a922d8e10384399eb1cf26f96280aca4271cc89e54f35d7f566bae3d758a971f1fa5080fecb027981fba606896fd2ba6741b882d9b8f61819fa0dac83ff54508875a1244866dad0f214c757fb6f9bdc16f72dce648c981671097bbd093379fbad23652d0d4d6aa8cb7797655b4704e4170a74d089812bd53e1b2a0083951c2407efcf4f7e5a2c0d022d34ff8c539edb6db34044150a321ff517d56b8c085c988d58da217c22bf0d2b3d733b85bc7853cc698ee1f21dfdef9cfd12d1a1c0365aa4a3365362392a18684e45fd868289ec342368272e0a8a1d088adfe31b442b6ba1ca1b41a6df586cc4a7d011b81411e11eebc3d031ae666474dc860d59a6d1ac6b1c375ae57109d5b9ac02bc12a73a481e9cc3ee0edc8b475b235fbffeaa28e36091c627eb45fbdb53aa4bd1d7d7c92627a484c779c78ef5199f62d8ae7e63bdf393cb053b3429982de23bf00c5787ccc9eb904ec0bd54bb2b1ac711f3201a3828654052468aed0be44938bd2f4f70024d11447a05293084fa479be96075af1cf5b77ae086cf198bd044f50e389bcd83b9e604e7db7b33569be9b18144d0606130d9e9ce7e95ef4b7c99510c568d584107d20bc3e0eaf1b28b5ac0a7efefe3478075d7e5b1244873b771bc87cdbea8908e8de8943e4057c6d332d42d7c0501b65661e23f976e2a5b5541d97323fe0c8d9f9122b6648b9d35b1d6e53de9ae2e068031534b50aed890007cbf48db6f5ddce77d4f31383c725d084c876b5ff55421318a16becfb9f641b5dac158cff98cfa26ee031476636dfd694374f38f6c7e3a2a81fd3d8962d914d88e9b3e7ae39742ac9ff35e4809624bd7c34c99b776d45cf5de96989885d687db15225913dd7264c67fdf85054c1270e2efbcc36f4764530e8bc1bac6bc609c89271abc72dd2d6d44445afe41059d925a370c4c36bc1556d62742928ac5225679f173e72ab80fecdb522c0f65b8d3ae77850c77e35da1af6262e88978418195c1328b10316fd858cfdc0e7cbf31f740a23305fae5b632d0a7f28b9edb198f5f3898e6718f0624f9f88725750d1108455a0b260b7b69fb3cc7e335cb146f541ce2c77a77f78b1c7f3722e5b91b291676c472d514b101d8db8d24de12e61ed7a82219121568eb34e973945f8f31af52801026ab64e45df9003d8372d9649aeffc9e8b7a33a2659c8e29c0d8c646710ac49110a750bb6ff9e338e690d2fdd4d1f5d1dd367716b59d92f61b62ae783fd912b876a13801729024bba2bfc2e54243076bbd981df3041d0a9ab16bf8a61c98d3994456867cd60f4973717dd8b89f4613d3868ed41d162eeb65549edff0cbde585080bc032463254e6245cfb8a64641f852f4d530d80f7588ae9ee8f4690c05b35776e50ce872422aab2faff69bd5b37ef806624630bc093098e430803a5610565f940d9325e13cf407fa98794cbbbc8689d02f1faa30e9aa5658dbd47873de25c46804ed856a8cc17dff5df082527f2b025113e95fda46cc7bbc196c8d968cc15cd170439d0651b24c02802f6e634fc8b082d0a61751faa2089cbf338781f0e565a1b47faa55151f63bd26370fec6a7e499fa885ce75ac597d27dfb1f43e170e6ed5548f0f4faa52bd598874de535fe30e79957e87e619d94dc87e0d8d31a1e72884172dfb5661f37176fb2fa72a5d782242cd0f4615c17f8b5e55d72e61fa21a4f1d91dd8f398d486397579daa5ca165abf898fbbfe227798132f731a7ca90bef877d948fa6fb8be1fe64b2356d06847500d73e83897086197aace81e0644e9979627af85635339afe3c73db9af0cc21506aef222ea919adcd397ad8da7d2a08b2bb479f89c5857edfa6ab4633828c5175e3f5e5756a5969bf032f9c790d5678cd9419f2679376ea8de40b1c427649c3681f7274ccb1579bdd4635a9b9946999d30996f5eebb4b67d6acc28d2fb85d90d039567b648883e2ada180f443592f3b17a8a54000baa943904270e578ae104c5b1917a3a52c5d6680049ec8e2b74221775d83e8c424a2987fe98178cc0a3c4ba374cdcaa28412a16005a504b12b460f654ae7165a320ff818b261bc34e2552440ccecbf0d9ff60e5289f7ff47f83dc211ce567eec960c1269f6513db6d5fd1089648eb43c759c9a7f9253fda9f0c28cfec57e47c5fd6dcfe6e17e5e30ea6edc8a0524806e9336a0e27defdc3851bbb6ab05becc4990bbb7f2eee8baf3639974e73931c79c2700778b0eede458d7afa11d21df6c4b05f495a3819b637eb49cf2fec0b5f3e93a73b085389638c7e68bfdc41202acf203f5d0459adc5b20fa9734a9eaf7b6609c5ca933ce4e604cc52b037e47c65108b7510df6396e9c9fdb540a69f29c87f219895ba6a1056d48cda59878687fe510fce8ad40d4337c2ce7539f264c6cf7baf8dfeaa77364a8c3e8a3220d00b5bfae11ed1c5ef9ae806bc0dfd4efa9e1faa6f0cdf9b23066a60aea2ef0250d987ed2e15042df1cc5d767e6c4b29c6edf97588043beab57bdf98441ac225f027dbe056e3dcc8286a2a5dbe33aefc05d0b9971c7e8aa8606073a36b87e4c6c0e0782fc6f06b058125c3cd8ddaea55d34f6df475235ed49918ebeb14801ab74227a71041a950cc30faa5b15cc800de82ae13c7075aa4f156af831ba1ccb5d1bb4fc6a72e0344c29c056bbd631a96846b02d2885547bd3389237c97f4a437ebf76f33017e10569492f33c23017b7b341f76848372b3b682cb8dbd7dc62ae51378e372b0a3da5009323e3c7a48279819db98ecc300e88f2a919011b7716fc83ef12d3b19c8a9076cbec076c5b7b67492b3ba820e586c72d1ed06cf6889d77c1bc9e8f5e50ced12acfb7ec2561b49427efdfc6743860ed49f85dd23b17e34234af72509d2acadc573fec15716362be75c9a76f981b12207c82b69a7e5bbaee595a93b8dc0e38c06938997323c072e462056c8d38f86861a54481670a5e3b28e252d8080ab57afd1168d1df7a0b00bfdf76f7d8125260b48104f6c5c516df161c3a053612e3159adb9b4a93207e4fe2e3d668175cd1b9d5e451df2b930164997336d1dac019326c77cd79bd9d73f99a956c4621306816fda3309dc0c95c8aa4d930966f6571b8ba84a57472d9bf960d193f488a343353b934852c26f5df92ac1131a18b8afb3d7d72096bab4344fd83d8cb80b22038bad8ed9ed1c54600d9c8b78211c005391dd5a88ad5a7ae01683ff84f6c049498bad4537be801c63c798a93327182f2eda7d1bfbaa2d38447283b900313a6285dcd1fa27712015e4813d86dd91c0c2769dbc58ac85235d6ace3db3e1a03c8a916ac086d61ca5c344d4c4a81b0e4ffbad117f5fdc486cabd7ddc6b309ad594fc6e0769268f7a9d3a4cbba3a5cc34df51fe16cd06c1e7081cd6d5389645fd422d1efa6a00db9b1df68e2bd95cf2344adbf651e8e00d05e7fb352263ca53de965b1b73b9c71d566045bb581c1410617b43388e694593dc7a9ff5246fa55c4c0f5128bc74cab3e10d8293e62fdd1fad8488c857e94fb078f7d4fe14e5821be71ef8590e82e3a430c3cecfbab80ee4f2e631c5de9e8a88a5c8bad0795f5c78e1341907ca14a416a836b6ce8c4e7414d5a23eacca74c51608c0705f8b0b2ff80d6d895f06ef1a8b0b2f55bf5eec64be49402bdd21015d5a5497f16340d32faece14e1f046f5fbeb5a9429c4ecb06f8a2f0e94974b7615754287e38f3b787d777da7a2ef15fa2385182cf10c0ff651cef05377768ec72631aa39ef87597c17572436843505458b2d3a6dfcc6ab55a2c061e28931f3901148bfa3babb9e5056f75153cb8a0c8c10ec5aedf241e8cccef28acef716e85ec77c5108d4ab2e292afdbc906c7efc10e179319c44654a2cef712d7193fd369173c2de7813811233af73f08def2a104c115859fc8d01ae8dded144fcb4774e2e265def4e120e12631c1c6e6c58e0b0b178e592414adf7ec4728828e9f721f8296d9ff9d828a2108e34a430ae16bd01581656e3b64530d690e3cceb6dc422b4c7973a0f2037846dd9521e3213185ac2e9ce50eacbecc8c3d41de8163e97fd04a3d80029b436e0abc108f5f87975a3c7ddccd8d7ee97b9616fe99dacf7a3ccd9e643f80b0b27a5c10fcea63ced96e2a0c4d84c447784a75ec24f606e7c4396226e42718c76e4dd76daa3fa53ccde8cb9084725ee6174543159ea9ef8e29814283faf9f7e5eb8c75b0065d7f1f2f9285f75b4b911525b627055feabc69ab1878e1c876355bb8e3b6e1163518ebcc85f89b826efc9b621bbdd26e6472a99278ca300b576e7c1c2a4d271ee9a00b4600394ce590566dafea9e2f02e4651d0235bb84174e5704d4a11dc5f622fff6e5de27a37cb0bfcb49476996dc0c20f6a654f4ff53aa30bbef1c4df1cbf94f33d6ab8acf6aecab2956e627d7f9b51e4d95332065ed06b381cf3eebe5d3a57060831cc8be7e462dbfd48c464f0371d7377ab3e075cab4b058ae762ffa925eaff456e59b32654886086c3ed8667556d2bbb9900f2404b4f1b70e25df6479e2a0d3b1283efd04a72b4d2bbc32e8dbcad1714a17bed2d4b372ed5c80c81111e0691777f39ed8e07b47823d6e365cccd5a8f1326f27c9a3c8aa441a9da155f2c4e7d0a4e8d0aa05093bed7e01b23a90511f6998a8d301eceb6ddd71b9a1ba7e5328914393c4786f32dd500781047e742b93373e0eb98bade39f08fa48b4db0ff5bacd548e894d9e7bb1045fb3eb039d7f6eb347ed5efde03f0badae3e171e222df33a0b328f849f9786833bac40580ccc7c30056c75a9a785c5beb2c929947ccb0ffdfcb850e3acb71599276f5a1abbbf2b05649281071ff9923d91b73fd6e81e809529c704b77e9001b75595e68bee775e1b022f2f0b13a3dbf01608300282f2c690b1613da8a69bd3cd46a3b943d0554b35463cf9e13568b64907b6e9d28eab3536be46b7ea529fff60bc59be6cd661565c5bfa295290c1b5c0957f48ba76b51d3866f265e453e88500259beb6e372e1a1483f02f53d6eaa9aaa72e83e20d7a4a79fc200cf9f21e56965edbf0a7bc38e0be8d770df0954eb1877c102b3a7d6195e0ea23ed61ab6026047c0df5076a663f2bc4af8c85b758aac6354d70d4f7d497e56cb1748fb547a383dc62f7db05095c15ba13eddc2c5491046243cbae8178e17467bed2cc2b6c70c6c01997474ed05a7086768f6e22d12691f607e79648f22b226e8f0d88498ae1a78398902d9396ab139e433ebb5b1145f5582c608e16fe4f94cf7e2e60e2d5cda7ce07834c6de39484719cdbca6bec1a7934a2930ce522bf009a1ca9a20ab10b9f813f91d917503c5ce3b7ae16b9ea6a0181246ac6ee8883a11bb6713d7012fe8c4734a085205cbbc2b1f2efd7855cedfd17a3f4014f82f3dc55489946b286a3bc38a5f696e58da0d03df4694d7096881c690c5765a9a8a942ef9b7faeccbcf10a6d1ffebb73c11b63bf782e54c5a2370c3933e5818d61b7def5a192fc93e6c93c343f9b098bd965ec50da2ac0b8cef5ef0d6cdafbf5f097828d2aa7a61172a7b602e08921d218e668f791ea2cdeb4f441474d2336a26bc753334e5241baca5bbf7e3f247ad64a8d9187ebba89f2cf57031105bb0c1f14aea28aabf041397f108653a5943f17d037d9454ef0d9c05f8b90b48937dc2cbdc6cc12014c0d3d797cd895d7a41a625d5184120107d42293296d6109f7d55ce16d80b02cd593a46e07e48e15763784a331422830b8ae6d4b871c89cabd711fb97bd06eb35ca5b0b15a81ec8235783015abafbb90ba7e7ff3f2676017d0d76c41a9ade630fbeff6a6ec3fc09436e310fdca98d43f7b69edcf751df2437419137b998c8858d48808bd8b0ff517f01bfa78cd253eca5e559e2ac2580e62bb0992c1c1738d65d2b101a71d73bfbf92f4ce950ce9ce5fde7ecab24e5b657ba26fabf6eed63bb510490680aea5e966dfe6e212632f77d035be2414bc9580eb07269813cb827bb5805825f692f364da0c11e4dbcc4787c555774488551a578fd6ad1198404e93b20b418dcbd88acd3d54adac2ee99f75139b8f9aa8a02d07eec603f58b99b0d91cee3cd261e0e39849740bd143ced3721a19eed04d5f2bd2123215d72b30684ad908324ccad0e168f2a8edb6e4f9cbb0c40b190d152d7314b60eab7c8d302a31c58e56e3798192e83bdfc2759513b786d2799248ba1525c01bdbc9db68ebcb8b93d84fed7806c464597f749bc1e1a08f594ee81037cff324f1ef4cfbc28c46df29a5dc616780e9ccf898b5bda7f781e153cd88e351a045eb00b9963eaa9a7da51e9222d6908dbd2da7a974a2260640ec506497bd111a78c99745c80c13c6d7985c12b4d64a28ab3e064556966e5d45e8b6103dd567de046058efc4210c9011bb00fca0fe3266c94cef11d2790031cfba77934f18584c3511cb3cbaff10e684bd3c5a95ed242d4fb52ded9c5805a60d11460d9fbf8442340ec3642d9e4db6300ce59711d4850df22e15252a1418204328f6940407dcb5b3fd523cc2950943aa46c175c572cd6d0a7b8829acea8c21aa8a83ad8b941445b81bce8171d72605d50a7e4f943bfac407189138e1b8d17afc9565abb89c173dddc7fe142d3b95a2bd2128244f5bfbc6cfd7de53ca5d2c979a1ea86a366cc31e38a58e97302e6f6a3786428bc7ca8fa90f1d93e5fdc9c27e5b2c874b8963ec3a95a509c23e4ef32c0901e740d973b608efd0bb371b8e3ee32765c784a8d0632a696534a9747fe203cd1b08e3e8bfaf842efabc52c379e176312acb08862b1212161d236304e81310b08ec7380982d1a32e894c77d8e4509a4f92ec7b336cb4625e3432c6b3a90cd79ab84fa94db3c6dfc1d19151d73fea90448ec15edc4e731b12ec3f175ea5dcc04fc288ef55ce73c1686e9781b391666e828371735e7fc50b93be75e872974dbeb91eadf4296e078cc1bdc5e4d23bb77f489dd58e2c620f7312315f607d8473d26434df167998f5c277964221316f19d92adcee3043406caf398d39075138960ad0f452aeeb031dbc2d1d36194affc1636b3a9d2620a4214ff38f2f97b501a6ac448352e8c8a94297834b442395a34b485e597df135cebec61997c748ed1102f15ea1f34b32ad68a22f45e4138b430fb4ebacb4ad8dbbedc1b45e2ec7e595229cdeed4ba69b0f49c39140e827d5ff82a2b851320a18df0c95ecbf7414c8567dba3297052fb5b215f717b3a7533eb7a04ca76265e030ae54b541fd2c5b2eb0f56e46461e99534343105802edd91e8e98921501ecd8936384300ed739e8fe81562e89eebffeb911afe13c4b73deaa4c189a79dd4004b76431e24cacdb882664e72cc90fdf1741a9ef9a39b9519d4f07a2507ee0d4bb987c68bad327c47c48dc3daae1b1d8187268f3c05c3f8c79ff0ad80f8094c3d97775530c6cb17d8a81eec1e29ae0f0db579541257baeb440328a3097194e49038bb46369d815eb37d71688abe376b7279492aff3f93d8fe7961447edb6184f71070ff54b418873679089c31280454bf66a7024a5da3d6959c41928877d098e7ae875ac353a7d79af2b9773bc2f73419fdae6268606ca529aa19043fa61bfbcc0f0b767564ae7fe6a2b6e24ee9d918b78d058844a0b6718c7a0c19d5296a425efdcbfa2d21b494eb543616713c5259c810fe77e5e0d8b727b2b31eca7c89e76cb1dfaa0bef9038f09034f9933087d88e66d00e39b5b23fc1ba6503884509782dbee322e594422dd0591d73189c5e679413116c506544774ca3a84c35b917cf8fa6c1059c23986695d7ea9e5a967972ae26ff8c9652ce577d4c333bbea02a33eb844657b83f8751c26f55b6c1f0c2d08b79f90f55e85151f7d037e87712424714c3b829e2525326ad518951f14746bce0bf9b5d5d81a6bbd5cc7d33e5bcf3d4690b62668b94b11f60c34a14baa5bd645c9acd79d4f1e1adcfe4ccfab017149269a74a351ac770bd938195996eb338e99ad669e32155ae5858c0fdfededfa2e8815c64c9bfe380584987a930e3ea2fe7c33958dc747cee45403bf23ad5e972dffad86dc603f90adbc90718cc99006dd45cea1bce7f9aa848c457c4650761eacc278b6ac2e4cb801db7c3629b3ec32e6d41ea45a631924e7a40a36711f700a622d1f05610649419b986042da9201c5e7463f6963b7c0b49288ac516f77b5f1b3592bf5b23904770ab1a0e64bc7bc10c10a434ebcbd0d9709859a6bf638af17f9cd240396b2235c4fedbd2e41312f9c3380f743672619298cf00ad182dc73c47e67f0f1183dc22bb7edc377f0b1b9521cc0b57abdc0cc6ef66cb3d17a39a4a893507fa0fe626d5d2cd3f9ac363733a5982d9d2d873342f398dddb3d6fc724ee5b881803d9a59c7e87ab8dac7a87bcf3b955e13c788627d4eb18e2c0a848f6ab0f0f7d3a7c852716e945acf337d7c8ead55598b051f3ee564387a91d4c766be8602f2f037c31d884d35355cc9b3403c5c63b49440693d731c752735b02fc3b32a16978d12bf097df5dacee1a46c688c5b4cd0c70701023386d73f63ed87956835b7c33536371807ee49dec9b32ecb72d2c7a883798577fdb82791af69711e0f5172f5aee59d08228ddb4f920b39d3922f5473844ed5773a7f9412602c68ce98267bdf49b72d45e2e72547c112502dd54adad816f3b0075245e7a58915c143643fc122d830c25757d20678c90bde096401bf1fc7efaff77ebf16310f43185794de3a0f7a648ffd1cfcdfa6f15a6ab62d023bd2f73e08be341c35ab6b29b422eb4d4971885d0788221f10c6492a885a640d525bafc7ef2a949f393b32691b64364101e0fa43418b855b1fce7ab781b7910ab656c88afe2834d6a067d3bec5ad13fca66acf3d592353927e9fa18689ca3d3f9a13f05894bf02747728af9f7d79700aecd6ea574594d6bced685f2fd6015859f39967e3d0e6195e7ef4c7e8d2019cc1224f6670cc8bdd15f2d639d611516ac52349b29a376d186a1a6274b10f4d395ae682188cf685e970fe90e9577e8688503bd3799e4f964826b0098d548cf1a6c3a435d656b2083f71e2a131b506b4ffd3deb22be9edb5737c4b352c655307395441dafa28592b32b0f66713a7a0c4a9968e7a50d529bdeb7680fec5b859c8e362a2ccd15bfe83720dab4661569301892d0b8f29a038ad94bdf706b5951277f9125b203753320b3f5638e4819ec75c800d83c52f79dd3cfdef39d0e4110ef0591b37cbd59f8bcb6129fec1a553c111adc01635500b6757b8be29fdb72fee3d903804265e870dced11b8ef2c9b8b0bfbff103491d0f12da475580907dffff99f849b22b825c96a6b282ffca6351f2ca8842ea516bb691a94b0a03f6dbaa74a775cae839f24fdb948ddf7d76850561b9a8b305558170852a1af46e7fdb4093fc01d556a1ca063c70b86d82c302811356a6ce2dbbc5633c5e8188872ff64eb630b680ebd3ad287a6eaaec09e5b95108910ba09c982bf69f8be8290387cb05ed04b18c91b83201d429b510c3070dcbd9e9fb53aca7213ad0b7516e91c0899237e20f293dfad2841bd773983811a325d6536b1a29f01c9cd5b43402382d542b1e90fe9f26efb723a132248c140a052b70f21adab27f4f9cb032cb667a3ac506d88b3979642b1cc221ac4b2b33b3818e20dbdcb1756202f1c6beed96c97bd68d5772e19a9523ac29b18da870641193d53c0faa8d8517f9155171663f87f53fdcd11cf662b0a38c0e6f1bee94e2f95993ce1282a972b6538f76d6cef651fa5f66e1b4dad1721068f80ec8da58f81424c6a9f4eda2fb387424eb95be2559e5e3df8c9aaae39c3eaa6bf0dee1ebc240c3d35cf91ea1ffb93da528d8d1b68e35f48833f68cfac1583ba5cb259a9bfd99558a9e338f26633b9c28ff744171ac48d9c73710a62b42e8ddc32d5129dc2ed9dfd9f0bab9b5a26a9729014e9105e618268cc1bb9bc164d38c1e6a7815556ade78af63438748bafcd73489eb20a53402d7f622a5ea0fc834b1c4aec864b944b144b31684dd448f3fd78a723f80e8fd743bc2cd427ab456db1d6510581e3b604f1f006042e7348fe74e3f731f476266400f89e5cd142f9ba145e03b6dc629de48ea519160fa12709dc4f011e962347246a4095e8dc80220b98cef083ee7a58daaa4414cc2fbd8e555ef7d34855d03140eb60e33fafc3847e2afaa21245f719e3cc82091a97c1d39cf45e66e7c3e6eb841b7c9ad781297896b58947826b8e8ef46e41f284b87f19a8072ee880d2728cafa3274184897a4b74b37d3970a949bb42d23baa19da934893428ba5c4a78524a5096cf53c90d057155deafbf94440c137678b2bc44c08920bb31fa2fb214d471185adc08c247f33b7a455b658c6e1062d940c3d2eeb169075abbb9ae5cbdb5354b418499c5a5a326314e7e5cba37c08be417faec88fce128130b8e6af58e41ceb685125ebb20564f35af389944ddbe868bd43bbcf393e2016c476abfbf154e878bc0941c5c224655b76fee8d955085128511e43f2ec6a0bc5b7231ce04d3ad0475d3f05a778fe505b44785d469c42a52efde74c3184d9223938d15ea2fbb0c5d318374baffa849592777991ff171cd799603b177e11394f9c533c2848468c49240541150352369283fc1266d973a7caacd2c47f20d8903e595ad334c939836e44565dfffc0cbfae4c697a4435be5282b685b13ca476745148d77960ca05332bcf4c925329f047660103833e7584a199f144d1e77be45afa444e50e941ea4f0462c1dd81ee155685b7dafa0f18b97beec47f3afeeb634b4f1d769bf1a8a067cf87766317c80fe3cdba3e512043edcf3ef95babd9f3e4b07b646101d45a08c9c6d6daa0f3f7cf6acf4c8b235b00cd19caf4fdbe29700e3b756a449266f3b3f59d4cbe189f344661700b409150ad80069eb5312c8a19ff3ea305e80a86943ae4c47244eb278cfe74457090672b316f8adafd115d8b5cc8f7b34a5896ba97a33b4a3ea152645acbdc1f269b6e8f898962636eb9f36d7eaf3718dcad26ff8a7ff72e576beb0bce97cc92a2ddfb3dc0627aa00495c941e4d7f5790e3e36fd6d2f38dd8c29532a7d7d6f292889fa16fb508cec0c58f5b4558ee4d987d03db1f795b5cb79113ba8930d8a9ac83688e4851778852b51e555b728ae3b19baf9d1c736af23ab7041c1f576bfda8f8d60fc0ab50d4788b9dbb310127304e255dfe57ae6be96a6dc1da3d3d9d78a6702c2d30ab5b9b336e3a1eb1b7c56b3b3977d5063e0625f12c3b4df5ccbac4176c3aaecd870cb398f1b382d5dfdcf2d615bcf82206bbd33c6e60520495a6e4c6aa290aa4f8143bffe0e0b768b43dd373d99050b303548881f4e2904014f468cc085f518b22279503811054c796c0511b9b9644adc91e795c020f0e55d94f71934cb19b197e5719e6761767baa4d07449bbce907428975bc327465cdd045e0426a423d9a6e863e75b4a1ff42f396c4a529ab8abf20a28fb7ca54a9f5706f849f7c7bea72c492e54579520dd058ef39e420f96a5f6d2b23ce3b6013cc16c5b22e839531faa2ab33d4a52615a183abef56cd6e2751d34d5d25c3299a7d9607a9a7f71250b357b5638d1d381503a23674a3911a33ac771a5dda8bc9c0fa9bd8153a6ab0d88b8c1cbe25b55a55eb1ed88a7f26035384b0aedc5b36692539b1a469d5a5c70ad7c8e01b78944c0b7372e046070447bcb9a11dbe864390ba814cc8129c0ece1ea39ef1090fa3e4b2265cb335c11f2e083716fdef357422d64d8fd0df6af1057fefa9187d2a2c1909265a767eefdd046768972808c6b1c0f94589d1a617ee0782f36ef233a2123494a5642902a7a06524551792a67585903f29101fbcc418d7d91a203aa13b08e88a68bb44a3ffe116998394a40e76bff1c9802ef0808596466730d314e2f70d05cf6c44e8f858601c37af6d1215bd9f8d69d45409ca391508cac82ef98c0bdf67e8eac78110fdeb4debde8ed25d46a64d9ba1b3a8eaabe4d151cc2b880cfa37c99f051ded289b4657f633de315441a90bf4cb5f621e819ad5965ee1627e162f3cf039eb071534dc3ff791e69e7b31bc1f92a3c644f76ed0eef24a6499ffa74c31f7b31cab1e63ac13f0b66dc7acc5db81675fa84091dd82fc6b5ef930775418fdfaafece84353dcd79038581c1c4e7b7c2c6f4d5269df01e79c7f6299a602718c1845e7f71bd8ab66f89a4f2bc90bc31d390585bcf7fcf0ca6047d2388d64ca287f79a724ad28176500867693b315a23a950ec296c0efbae3177283ba525d20053dbfa154c1dbd9635cc8508f840d1f6bcba0eed10d147f611ca956c9d0b3154fc6076a012a0513157681c19e266aae773ac6ad88ac4e6870a932b0a2087324b0e07e9381ea6354a1e17be620c5633568be995fc66ba2ecb1c03d63007b03e9f0f7aadd894a884cc865a276ca7eb819a1abf4b0f50c343990e48e1fbb0d791d1ea05e367d746da8a9fe0d9eb2a80645e1573d799ba0f27021b3961fe1d1f8651e98a859c8b8c08ce185c7c339ed8812cd49eb946152a33efcbed25a1697bd7506613b66b1b037449bfd5a45cab190ccdabbf072c7fa18b28490c5b82eb68cd2cc1016b1ed969810d793e30ad8e0d37b17ec3d04890d8622e5d443919d5699a94bc41cf0ec2e4b802fe28059b588657d5b33912ab59534a36a8a3f913458fed8894d024e83a43fcf1244469121c874d8509fd0cb2a9ddfb9ef3182c4a7e9f393e6503a3f9b9d773062961702786624a0529d406350211c150400c31026d9ed23c12c74d6ec2314e5e2853a6c37303736344964736c33fb78c3e0550a877e6c61d4d184acf5bea14d548697d5ff5347545891945361b7b06ba30a186aa24c43fcb1397630c04b322fb96f6a6a38f889380ea14716c45b5e8e187130a788408c66d7f30176eb639719457c4e32d784b8550f183b60f4d9a9b396d33baef24e28bbe30436314198d470f7b817ca976bb3f3161a3fad1084c2f4f6ab9191db1bc4326b5750d164c6b4a3d7699f615803ce5f91e7ed02342d64b6310ccd5bac73a35b1adc7944fe0f0066ebf4b434cac7438a2fe4a6f9a6109e02f04967ac13fc9769d33dc28efda07f771985d42f1dfee06be8a57e093816f8227d1993cfb59a2f83aff3c686ff79f5028fa6ed2fae022fcad3661d44915ac2c17f895593486b1a7e13f0d6f0d4f72862ec223610547ae657ca9dce381d625e5c353115a8b90a158f8d5ed7fb1986567492af8a2e98f96682413c27dccae0d854f75ab7134b719e63a51e24f17d87c29082cea2ba6daa513750a19da70e6c237560a9e1a0577e1c9183ca507bdc32f70f0504fd592f441ec3b7b08ce03869926bb8d8ca52e3909ccdd2996cb822c6042d09ae03d92c7d2f342fcd0b69c9e21f52530893a0e5c243f6756247938dea4d3ced561ebcb6daf8ec06e501845df44aba7974321f879e6d40eecec446a95a06f10e0def284f16c3d0c661e3b6b62db5e82e85e823b4d4fea6133acd9ebeb1e4f4021aa9b3bbf13e17fe51c534a7a95cfde4a2b98dbffe6900beeed09af6cc8891fdf27e3e538154162ed7d4401e8f8bf460f814ca9b045b65fc6b803f1c69cf83d57cc2c056b2525bbdad440f83d15a2bf84adc4efbcb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"191ca14a92f2a4ec566bfce5e2938f28"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
