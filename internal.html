<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bbde4b51af4ab0764bbf3cec99ba729281d22e9b50a0d4fbbac3ca633ce1b3a3346febf2b3e4efdcbcc8446594740a9a4c53487307acb6437fb1a95c92dbda8272b5e2e64b46de608b98c1fbe454194960eb42e51a539f495e810be45382f1d656bd214e1c39a43955caac32849b76ab784c5889b561886574daa877f58f957c6a1a60f6622b1fdb009258366f68de80b1ff947625d01e0e92d1eac52275677d77923f86b7ac48f37133489a83651a27cd20db37efb1175b6cbb5a183fba1097295b1df51d020ebb80fa7469e71563ea5a6decf571e4c781909c309390e74b3143e64e89c4ba1df1938f1fba9a1bc56ae7c4e513b9310d496318cc3936f1f79a0732a81cb835507f0fad37d720c9b7a49be3ed355e64d8f986563b767313857c7f3dc08816ffe89caf3323b65a64de659a821a5d06ed9794135beed24db0f87b94a375ebb3d2622dcb0e11246e99ed8e499efc5d95f730cb135081b6c6fc3a56882478a81e1902f4e72ef8fb1998e3b3be6319b8fe25bf1c9eee852f2c8b61dff87cf8a5ad0d6d3b25d043d1e6dca735b1847946bec2f26cb3d0ff9166cf22380243cebe24c53e73c3ce92bbd70bec59382cacde3627c045cb1532177ca1681bc26cab01b60a20844f91cc16edde1f8ac3bba2906c4cf4f5afbd23342c2da2a4d74e51fffc7456c454d18ec32e21af2d687f9abcaa88ffc98cd8a9305469b0027a1678246bef92ee7d9bc6e8e9ed28988f9a45b6289792f4830f37cfa795bc17d8dfdad9dfb50becd2884d0010d139f436eb7eb2519c881c30ee1ba26bc0aeaccd994442d01198248b52bc7fcd869ad67fbc81b4746b49416f71877039b707aba4e6eb4e18f47a031e72f9820f517603fb07bd9ae43a3c00109f54d67d81f8e6586599ded0b0819c1d2050c8891269e6a5355d9efb9c65d4fd06fe231d6ecdb71d7af989fc85e9701d43db7d17bad70b9c947cbcd7adba36d376263e6e2ec4faa688cff9c6d975f74b89df34bead229d8bddf40bbf901e45eec89542099827f2499525ad80ce4c86c6f2230e7799c14fa27dda5d42380aa2a6c165e1313c89179e13c7714451d733ab3adc48bcd234ba4250fac6a4033930be74869aaa6440cbcdad82eac5c9cea753db6767ff7e363a5f7284b1b3e04eab9879585cbe839e348d5166f79c49e62ba1bb5f3b063fd7710eafc3db9f1b3e33ef42c668af905b8369717d5a05d54dd5921abb82fa0bb48b57216aaf6ffd388024d45a8cee92d4602fba0602465128b83b63f9d1a96d903fad5b16121a8ff4594babb7365085f94866a872ca7737d43f5f01d175fd2440d9b185e6bb3c3479b60f6441bfad4c7eb2fdae6d8a1c5a346d9d61ddfdbed610640b3b4569a95147059457c67c7428210ed25419824f0305408a58ed91d384ffdfb91c358a2e853fd41c4b4d39dadd3415b4ba5218db97cff11d88348c39f7846d3e54d10fc5fb2e0886b82239e264c9dafaf3b2706c8f07fd82e13328f92be8903658fee37ffc64d46bba856f766edd8b0497625614620bf54475be9e4e42af9ec95b50bedd8d7c8e9cd7dfad086c47c9354086938d8b32351b02e5dd9b7d496ece5fa8081cc66b1b3af3c8077d6280b8e55f8f505557de3af28354aaa8c52ee4cc6e060a9cc38d967d28bd2ae2633fbdd89f90e34d74d3be6e2ae5183a829fb0a672fb2a14210e919aa8d5d8668f4c8064aa53e2d1fe7e049d9375288a0e401c499f7ff650deb170589925343726bd7202a0a5b1613e494c74a203e74f648c97e6737ca2615bc3c3a4b489b367d1bd9c7e69d15c3cf942beb30b5ef2d9609159192bec5d74b64d4f9e69685179e61be81e8314b36ecbba0b64e577bd645b10c56d7e2648c26db1a9bd9149a12dd5532abdfe39fbd3a756383a0b22ff2681276ddc57485259e6c60895667eb60d3af06a98f42ab86b25dbb6b32a08cd8affaedf533dc35535fa07897d4c981d4cb2d4b693d9eab3577c853305202724f09e3cd85d8ba6d9a4dfb61cfd35c5a7f85373a9cd5d1bd50e3dc8621a1e9847275803e40a426e073dba60ece705cfdd024f74bff9682cf0bcad4e502c8ca4215f7ff598033fb3cc13063fa9c67ee4db284d189454fad462b0f7616eb565ac2c60478f3b21537bb3adadfcbbe3c0c67e2a0d09c10714b72dad6ef05b637323ebc95a3da70c3f30a05fd872fa838506b4b91a4343a4bcff2855e042996e8da47f1daa33cf83c68a9c338dc8068592c920eb2c76ba85399db59fd0cc6969ea072cd777c730791348b538ceadd00b88c9934bd1957245b953c6e482832c57657381571253090c5c7f465b0cce3ac1a860d3a920d9ef0306e6ac16966ce1e62b72c5d817f697f44d8b884674a34014e44f303303af157c4572e93bc444882d86060dd51aabeb53b7270769d576f48bc472e662b27c2754e494234234d1cddec5da71b68e263d5b108b8aee27eaa81f22521682d57fb7cd585de9ddc541b0a2c01675b02da7186793204d44376d43fa4a503fe72a23ed6dca7d5ea253ebfdba947d575021c8143928c897f56d0cd0d89957651278898b0e646bccc3cd718c88855bc81f78ae80d6a647f9c5978a27d941ae3b41c089f69f2c5871785218c275dce1e471d610ebc78955eebe2c497569ad83ad5df601b268d3a4d7c65042658ff49946a095b4e7fedad3384f0ac5316052c4ae27972cb51d8236c0fb004ba5b2f6ace6e318e1e248bcab7b5860e6abf5f8fbcb0dda26672bb09519c26b5aeea96130d827aa07968fc15f9e163998cabe7496cb2097b87e12b9f7e6dfdde57b617a2974bbb97f9131931445a953d64673e9cb0183a25143682ba946c07560f7635ead24b1391c0d54a541e4a8a2494c5000a9505f5f66703b321cfb46356b02713c58a9d62754ebad16ac34d2a403f16d19df29e4c0c977102b4beddd6d7108d202f2930327f377f3203d4996544c147cc926f5ac9a13c5ec2f843bfd4d3325f95c7cfc5ea0dda5a39b5dcd60bc9252e6ef136c1679ec03b311a42beff02f7c8c28db5f245f9c9727cc9bc352462823ae98eaf98437b3619733a7332acae211348e0c66e905e0512df6944e3b1e2d17ca5717cf688a180f462ac36394d1a4582f68cf759f196e0c80f52a35dc6ce2c536f64877e806095991cd75a656c4e7291212f7b2dc24c37418d79b169f40c5ae46db1535944a57ea3c6b8ba590ba76de9ad71f373dd6778e8016e99e0ce47050100c3ab9bb82d4d17dc01f0c5a845ccabe4ea4bea4f14d07bdd4c172b164582f67e1b1bda1a882652124db68d0c4243e231e8e961f5f4f82a05ea648bf4e0cac1edaa4ce73e7b0a28a8833f9429c7b293adf222cd36c976c4747693cfb748c3ea265da6574d19f1d25979007b0342e5557c255791730fb5602d680752c7a5adeaa1f7410ca9f91ecc37150a858d98b5def4acbadeffc143e011f775e39a27937729bd1e29bb40152eecb286bdf6493e85df9804821a329aa1a9f9821d1f8b5e1d14327507a117108c4688805388798331725deb28eb310ac706e1bfe7efb74d7e46ea906a5c1d62fa74a21b288650df8bd615f3182d6bbdf5e6afa533fe9439218cebdc7d9e8be07342d182a3b744dccbfa23120c33fdbdf0a8e4f19f004c87c7a47f7a451aa2567d53cfecc0daadb9371af4a848a3a2ff724346fbcacffa86303fe3f7cf7fcb2847f47b8a975e953fa168e3953e3e6a810fd5e9fe0870ad568d939557436a973762a31b0c783e42b9e9fc90fc3114324bdceb6e0eca9798a95b8bb0f9c4710ef1067ecad399e2f55a7e0959c2b5866cb6b4ab8d7e63dae386f2c17f425a2923e8fc912a2e0253b5651f59d3cf5728d7a80486a2223f45274a6fecb130bae94c089629dadaf294513ca2f1c61e421638293438e26a513a068a97a7b2c5147dad12c822a72825cbf8f9e8a6777db71c19a3935692bfdecdd00d0a0e0809cf2ec27b6b2f104c2d39dffc0f33ba81976e706b136dd784d2867a23fcacead3d76cf057f49a512d70bbbcab18445e2ce4a8801ef7cf9aa21d530dd520a13cdc1fde9a84d659769c26c9be3f3c2da05f06323f1c9737e55818674069c036d456694cda743283f9ab21ab2865d881d43324601dece33545060d7062d7ba849dec6aa36b98b01d4a9761fb4cdd858a7decaa098a4da6f644486464479f54b2989b5498281c9bb35320c009afac49e792436c8fbd75a165da8ecd8fac08865753fed3be65e637116dedd173327d00b7773dbe78e87c6b03bf16ba66af55a341e039b37a0d618c875d25398257ea2d1c95a8f85f11690133913d4f06f2902610b2b5fff5a4a6948977a837ec10427b128d5f0455ac96b292ec3e1e54c96b828ea92dedded731dbd02b05cce0aab04e1d7334177ede2bb5628dc88b9846b3e154e563574b82dfa7de410bbfe626d8e9ca32cd47c62bbefd3449586dd8fd9720f36d8e84fdd1be73f232890b42fad5116814e82060edbd8ee44ed25df9fe1e8925ca0af5c34fc82be32553c5249e71144744ac5d95e3596b8df770bdb3e633bfa227e54456b002aba1c216846361062668043b36511ce900dc2d372b1da4c4b9d72c15a49762d87d9158c2f8cb73fd9b8b6951bc64bdf5e15fe724e52284156e6a7d7c206b3354a9deef6d781b599091a5b346f7ea20816ced667ffd055a9a4602c941601fa83e6e6ac2226b1c6f9e4abacccd64059ff3afae251f880e656199ab8bcfc9b5045f6104fbf5be8efa4fd178f87b690fbc0a628d6d8354f26c0f423d3e7a6b611446bce062abffb44eba1714064b836d181dacf59e75a87c4c05134c6aa70f0cae58cb0baa1b31dcbf8e02e33dd79f34c6e4291e192e6e08b215b35775dcfe80416a5e78b8dedec9ac14190ea063251a24a27ffc181b8b6880921580d83f9cd3f4439dc5b772380216c85d9836c2092e8fd911d6ad8077107501d295df4cffa482a116e1b3043aa1701cbb5c109880633d3abcfb5253942fa11b7490884dd69d348a3bfcdaf4549eee62887aefb2e256a3899e9a7cd5426e27fc92689ddcf521d653e673035108bec2a11fd8884b33f88287d5ada25c496c01f3998a14169990b4fc73e26da0624771d294df654981a23549a44d3915cb06cad6fa2bb3124494317b85bc3f56b4bd91a6fa251ebeba6e881c1e78abfa5dcdf00a74722c1a2f94badf8d9b327ebf712f1eeb6ccb5a810e1dd1974bb763b0e9b0a70ed36015af659b74b69a6f641224441d3589c50149c84c3b9296a18cd5026fbdd99c3f2070fae1e91ae065597e5546a9afde8dd2faad6c72f7f9306d6c805930ab28ef562e5392850b216adc2829188a2a7a9191b0a38a6fff38673bb10ee9d45586b4471fe9f165a79c9d925ddeaa8347ac63e1664b52cdb23ef8c0ef37cbbaa4e537e74c92f0c99746b3643838e9972652876ff563e63ce627fca78c6f7de8b20393f2b47ba43f2117a270191087d5c9df7407bb163a44255ba54974e60ba30879f4f01b3376671bbc76ac4c2fad9fe26dddb7c3f177afd2235fe5239a46fd07f69587fe535537a71ea0e6dde3dcf1ccb54270694f03355467feb088ae64c364030c477f35ec042c760fe1a7dea912f98944e4f7fa6fbd2219aeda26d07944545db705687a93c54d46dc3e99b6da21ce5aeaf37c9acc2ae11052c41c1fbd5d9b61ead93db4b169f275915c52b7806f1c317656f1610cad9a2d3402e8920d18056a3e998ff73acdb83ae9549b29b44736db076a230d2b5dd8b2d22e16bdc679cf5ddbc3eaaaa8cd3ef97c8119172ca18ecd27a4f0a6d47cc353fb98a15e96f5cce803e6f3e793c524beff2ae93ae384ce7b472f079e9f3e87a50fa5547f9e572af1b259dc602d4dbf5ee8abceebd8e79888c1e0f7e435a9d0fa2fad811b78775468b9dd0798c6623d0a295b5689dc782a6c44fd2c4eeae9fe4fb33bd0f99839a4a1c79c1cfa2bf156240232d016642670dd51233f76d8474a83c1e66d5cb947b408f71209ee0688266a3190427032b5227429938bd21421239e6df71db51d0898c2ba4187c9733b02869d31c4b799fc3d1315aeae0ba7d5fea9bc7254c25a5a9091f5c851bd63b44eaa3e71191da75d259996cdb79a2a146ae82f69856a89b739a469f501c428072dfd80a3594d4ce075cc672e45943a629f1f14dd63dc8cff281fbcb7f2ea3500e59f0dbd0353a7c3eedc8bccd12247469ef7d26df60799978c3a4b9f495256fb70954f464ad9a346a69a7eae14f32fd8957b9a479755e0565ce7d58bd6af7cc9b320a156f8ae8755925467ef5d0fa4aac5bb2e1c3b6bd877896682a162757b70feae4ba543958be16a0650eb1590edb194a13a09d32952975129b04639d75085944dbe2b924566b36c53cc63a26f765aa05fe51f92b95daca2b3ba45603104d4172b37dead02c43ba016dfce061ccbabcebe070e9a625515b3829455612c676aa92becc3b63fcaf72220d3cf50034becf2e1c9650db48f1cadf2c0ee6fe864d2c1b016927a8561e70adedf63ed2c1adf9a427cfa52adee1a2e1602436e3659845733f496ffb916fe5cac3c72033aea917bf91660ef1be1dc36327adac94ea31307ec1ba793934c48db9778861a767b0c7c01f401bddc3cc2121fe5ce1202189437527227d22ab0e247f601a9a424adee611550d531021d682cfbdfde807bcc4aec0eb9a2a574e7463c5ce785bc56dffad1b39e36bd5bbf4041584eb04f932a1d4d973b58bd1c054dc0e2c23e5af7199172ef41e5cf1ff104d6dcab3c1a32c3e23d44b4fea7d975c2eb49986ad318dd88d88ef7844e1f404acb35b3b0064030d4749b9c251293849ad1f3e114e8f33f514b693e620a7145a1a57dcc68a901a50ff488ddd761177f42f1b0a56bfdfe851af6f4d96869ee4ba731ce3281c6d7b818c1c17fe81b1b3ff50d64ed1762c7b77aa646988a1d48eebe95f7e2e243f89358f85c4c91abd647db5aad0692049c622b06afa221872d0ea55e5087e6bb9c59db53c28cc6dd5b669f8077a1a2e5734704ca218cbff7d2bc5af9fef62d11259f46cc43c090d8199e85e7d6ad4a9ba491dac118c2ef2966aad40836f8e9c86b4cea50b6575228074e19226195571bda9567068d5d69d3348c4917cff65223ff60973d93a304aaa98095c71cbcbfa981d4c43f8a56172d1458ee49afad52bebb645643f636a9ff552bcbce553e3113bd907f64f075044bea3c885f239796e19a5813d351d32016c9c00e53a8e2f27ee0cb4b2c2d35db5947d9f548b3ede41d9235d072f941c12701bbba996f6722847d4a40b93da5ad92bb09bb3e85b59d0b63f3d2dd44d29b80b17197357d17191feb2ba1931bcd776acfae30fd74a41d78738eef5d388e201e6e127a44d32aecbaeafb2a8e80e4c40e882d86dea3db54f08df78fa016d0aa48173f623c4350ebb589298240458888acffc7a1c3da34256331834c47906b7b5ca99aafad80b0ba336e3fd0ee3b19228bc249d0bed722c717e5d1d187c4e150b4bfaef0d28dddd0c3b1f803a36856fa23d6139924733c49d29fb273089dc3a35d8296df170edece0ef3aa488a51afb2529432185cc243e70387d9aa6179fe6d9987f6e6fd5a5407d0c192dbda24b1a9b41939b04685a06e140ab4aba1d6f919c38b4b8d046ff2606c9b6a80ba25aaa44f01637b12952f08cc4e391daa56cb29b3c55fb35a9fa8ced7be5514d1aac7a94a12860abb6ded6bf917459f46e109e8ee9149f1ea88021c9909a5da34a57f3a9817fc125f811a6d5de7e4469cbf8aa119c8c7b3f3abcf9ca2fcc62bd236d4b209a2965bed04d216e30f20533772c6a1232f95b7252053778005a2127e0603702b950b80097f3f1690af7f377dd0174c242c632d81855b60f9825edffffd1c4801de852e3e5125ee7a7812d0f14e02dc7764e1dfcde7c3dd4099b09e080b8ab4a2c54710ce4e5d46135492e6234a91d96f66f9dba5cc917e906e4d6fed6f31377e2496fb1fb7376d1dc3e860b942cb9c79cc944afbe7e17f1c9c74fc9c0cd7db8bc6f432f301242aec674177b92ebd62b1c15653725b0b4add61900fbc9b54a4274d91cee23343a0f31ee059274892a9c01373b644f6c8ff098742a9136fd64051de6b722bbd2883543bc93f0c2517640d0ad8e692d676deef64a9220d452eaab939350280a2da4e8805324442a1440710e6b5cd666b61bd7e535f9a6622fdcad3787585bc01c5c7aea0ae42b313b3e175348dded7f9f7401eca21670d39c6c8573f2a3b34623324ced52888a7d6ea3f3e60aca124133c724064817b7211ef0a3714bacd849c220305f824aaa7da027115a9da862f87107fab1827e8f6dd3180b2eccf31c22475f8efb6e95d8c80e26cbb097e725450ec107d87e4e83517aad04023423e44bed6103ec887b299e6d536a5166813916e121e20a58d3143fd5f165938170a3d69dab62f45704872cf772fba7c62537957794f3a1768fc990aa39e5273b36d887d629e453d389fdc394c7a0f4579d6c1d83a4310a0aeaf347c7ca58b61a63161b0abea1fbe500506c29053cc2d6c236ff2cef0e792ff1283b7703ab82c8c0dbb0189467d7e538d36047121e09dfacc8009d7507a38d5eada0be799a9e7a199a91af458ef39bd12c16da3a2f8a3703793b86810c5e53202036b649c760d3102da633052fc8529042d6e7abc6f20ed3dfe1f7e293d49181019ec6120f62ef0001a8c92b21ef6e3a6d454a2448e8aad914681a656a52c2e0613fbd66a872dcec392f6202cc59dcb3d7a4026341be4d41c4156ea78c4040c1cda345315e1a886d054c3d96407f119bd64b949cb028187303d6e4b270c300a70a0365233932d247f4930151403e3210830b3ee059c685551b31e31c077ec140726a77288b1fe65535c05f7c506c3df3f6c27859c315f098e1247d917b74d8dbb90261e45add5626d25782ff90bfb4e859e6f9496516caba29c4253cc33a5b37739c10916d0501810836460bf509d077f5c596467849d19c9bfe8b72b1132dd021ebf57610eec936a8379fae3a2aa31a119973d1352e48964ef4a3d87420f4b12595d47700ea8eaea28c24acaeb5f54f9729de7e9595817141cb90c0c30a1a64398201e48155e7ed9e1e5f6a2aa6062f4ae03b2bc461e572e6aee7c8da5f5ccc41733a6b487b5bc39e038043d4e0da3f8f59b6c98512f100db94c0eae02a770df718f46bb8b345b350abb7771ffa42377cef21aafb161dbee5fbe1591a394d6cb081023925c24a16e5cef87ef5061def1628353fc9a27244bb5729ff4969047ba0fe596174c2f4d02dbbab7565bab6d11fd3be8a85a38207b3b98398b1887715810d79f080baa245ce38e4cefbbc8ea44d5a6e387c78d70918742e67e085c54aaa615620e281ba0ea3df3734c8ebe47992f3f96eb69513b107391397f077fe25e6f7ae144ab734b2dd3f9b7ebdfbac451d06f6565dbdab2584200e83e7387829eeca824d4942f6efb5e0a724d4203c13cbf2c5435882e7e2e81c8d045757ff2ab4a0d6d832cfc2798810d124bee10a6fbf984c7f15ac8e77c6e565302548e57e88cc316b22cd7b037cee7b1ae80cd5f9280039353f053beb2ae4205e5e21caa174d59ce4c02a62df94f3e20073d97c8ddb02ce0c8e8589d8af843144eb8aa55af51bb59a994611a57100e575b11bb6120a883ee9e9ef1ca07d933ea0949fdbda7308eaa0b598a33f5626cc92801e6d5925d9160ee8aa62a4cac11a05376d41f030e91d6f8e973d24028e848fc1605a36d70221ac6d8f2bab29070e451ab419a51239ba013a89da666692d22f018475aa3968d179ab602550baed61e38784358638793da25f3ec382339e7146862a6d6c259fa5c3dfb2ec75f1bb98dc3bba78c70e1040fd9988e906f5b772b7f50b110b0e4d46df36f1fda914ff70b8b1d36941b1226cdbb3fbe14d102eef73683ea3718bf70b14f625803c992c4fdddb134b4d9432a4da5aa8e5cc8b003d4a59ccdb5ce808fa251b0e4e098878bc25fe0d3dc84a1f049f877c68cb86dca44e8e511df59c49854537adabbd01d364226ec40436da2610056f30c6ef1c982f373921f99ed120a50547ff1d5024a18d8b6a9a7790c5eee2212723cbd2258dc349fa2a34f9633406151c035ae1260c9ab60215e5e3c52c274c9b4cc8e597452bf5c6bbe30f7ca688996b96b252bfd83093ba62ea8d10b09b9d911bede404f839aa7fc0036375c4cdfea7ad345ec89568c67c83e24ce3ba597074cec5ca6983c5d5509ea518cd4ae1f8c57ad5760ad12c3f375c41ee35e8e31d779642dbaf880a6844f7f475e27241476fbe972df01b5ecd8242d6e85dc7cc52044c9fe647189ccd4fb89ea6b1e820f5e7adb366845b2fa0eb8cc09317bb94a1f08088e85c9703abb64a3ed5c19dccdc9c38aefc21331a8510a0d1ac3c7fc71ffef2399e288be99c5f9549cfe5cd67cdd3311b2dffda47f43f42aa5e9c7fe7552d78949292ad4a1426cc8bf7f280dfc97f2507b0e64fa9655a1bce9ca5604dc0042cdd62736b0b68fcb2c3ed4689ad3a87810c6611f54efc51cf577a71b18ec1cb0c75f3bfdddea8a260e85c0b0dceda3ad8fb1ad8e926c98ccf24581aa61a3a436b4a6a1eb40e2e40c60aa6e2695f108f4a07e31823dbc462036bc4ac51045eb044f0e6ba71f5f447a42c53dfe09b98ae05e0f96d5f883b4d4918ced0aac2b9468c76e26d70b5a892dfbb95296b54d3f34075d7821ff2eef3944bddbedf7724caa82ecdf31e67458466945185b5402e1665ac2d509346425c93ff0e3a57959cd6b66b84407f0549e88e1761e1b8d237d160e199e66b76ef87e61afcbbe23ea14aae6d19c34e572c4d0c280c4d0b65dd3240725581994707e413df6b64e7b66c972c264c1e124e4f76740d1cf4c9acfc6858c242fe7c351013610bc6fba3bef5ac95cc29031a00235ebc1f679ef9c6f39f5077f92adfd10996e5cfaf5c7da1b73e66bcfc3c4d36af350914789310926c7191cd669762778371d6478f082f63066e8bf206bedcfce235d16c94a9e2d69cf28223271711702cbd9c9fd4c4eff51df30cf6badb7af684c6d6969ab4e9d55461a28bd09a8532b9cc2399875cbed6fda1efb41a2912c1fec7829a3e78de8082408b460c25c51980f0fa36675c44191af7e7fee5988c7d490d4c65c3115a42a7b045f78b670aeb3ba9f2e64e9d879c600889b6447229aaccddc7f216cad1f4c47bd7eb14eb43b0de48580cfabb8e4c2cf3df8c7da00738aa40120f8b9b59228f3bae4b940bc5638d2d71652de2d648f9224cbdf65a511260fd63c9282a9a28630ac8118aa054b033bbdc7c5e51dc36c63174619286c3436e3dab3d7015d976fe6ed1d5caacfe146d2a00eed09dbde1382a8e1d48cafa85ba41ad13ca10d212b697058329f645f0912b3f73222ac08a3540baa912e3efd7de3165c60ca264fc9d2059b25c265235332cf0abec1dc6f15747724e0407be30472852034bf3a43e7b96f9469151343f2d3b05a70b70d90c91770382cd4f113b81dc7843bf196672760bb5fdb59f7dbb56a08d648bf1397d3ab7d10d5d7ef9fb5c79ddfd4546313b9e481b092bcc967358dd6894c81066e211cb46eb22983fa74beb5d00833f18d5b1e466cd359f6ae6541fe060abf27abfaec3323ba90fda2bff3c927acd5bc07ba4e13f8e264bc0c9e754b6b3d8979b0f17102bb9343ab6ad646be35da6ac95d76f243dfc013780787253d8f27b8c21ddc0f28dedeea0f69a97269ec98280c71522d7de55b32c035ec45b7ff807d85b6d32ef12a7234d65063b4bc1082ce715b8463eee9e838c189519cb7290cb7e45c19127cf11c02043a5e7a044d49bf4dd5b27e55adefce94039a3a97ce446c8fa0c8d6fb00d39cd32e38bfca749150d18bdeaee623ab1094bc3b6180eb55b03ed9d600b15746c358f098470cfb728cc49cc0761fefbfc1054acb932a27fc2edccf3fedea2cf6c77dcc7ddf5221869d0a36943fb1040ce3c37a437fc8f503d41ed78b0bf7d614b035a353f04bdc506ad719373d7a6f6b70ad1ea28d812fcd4137e923fe0b739b58a75911e3afff44d5d9421adc1d6c8afd0f2d88a4d3bfa933c8e638bdffe5b0fcb81d6ae020161550776e5ed78a12c52b3aa3565bc7de4a8c396adbdc072084e9be2a06eca3fd139771f2e5fcb62fd5723382dd52ec7e4fbadbf66e3cd46effc394209dce04d712e7f13729bf6fd1299bf7edc00da3ad1d9c58fc34ef69cebd2d8c6686a3cecc7ca487baf649479b6fc56984aabdb7a47f2dd9fbe0e4ef049ddca6ceb2ae58cf692ae31fdc4ee18441c91eccfe1d57d095952cfa1b788f3cafa633f28ebb070db690a5a43805db20bb22b2827a68a70edd9a252627e6bbf8a7efe6416211753adf65a29a4226e500243a33fc6a565c45d5b60387b39161085dbd2ea784cb55e82620cacb62468aa7dcc2c5c0b272bf0cfadfd3ad095f45c6a85b03654f68db4dd924839da3f58373e0b4b5a062c37905c3ce97eb53de07d46367b0b23458f3920f638feaa5dfed91f0884a4837d42569c3bacbae295352c7991d08438993c40b031e488a95876602cdddacb0d4a0346b0019ee04cfce3fa67509232face328f35009b0b4a45112deb35890a7c4b98b9a9e01345871152742f009ec8faf75350459317778560870e9744411bbcf2daff0d8e63de0e44f43ae93949a91f2b169be4a1f3e5e182e4e4829f1d7308cc4c775cd11264eb0c4fd9674f2f39c539c60c882b6c3fce50c98e5a51bd53f7f7fdb88dabe6ed31db61db9b8e089ba48b604088c72a26f7e36af47f1bc7528e7e3ebb731fbd5d48b3f763f7fb66ee93bb8478ef6d3eae904a566bda0ba3c3dd1d21758a53d228db3facfb09fd543a5b525b8ad157d08de9ff81682e1671f6fdacaeaa262b02758f4bf917e34315303f69912a3a92ca036e1acf5f495270cd406ddac05740fff73307adb9791d981b4db7d958c2a71b63d86ecc58fb2766e70f92f0632f9df37c2cf2c3bc650a877df6e8f29de769c1239cfee4890b00afc92eab0fe078dd431bb529e3161b55a2cbcd023c4e478a371168814b8697b560aa285a1b7e666ef0c86414a8eba00e3ac54de00b7e9492f681a91e85d90610f2b870988b2f44bf11f7a4e15a42a8dc8714129431cbcd25c7689f810c348a2ca3ac51daea8347dbf895981be5bc2eb6774dde76a522a7e8561984d6bc856a4f0eaa9fd64487876de19bb15828c61dd0bc52a3f5f813a80b1a07db15daf34ed8192ae2317a85eb4b824568f56ad3cb17169fb1771a437b59bb2259f91c0d0310f100eda5db35a4fbcc40656b9e4078c4635b3869cfffbc64de304e0b673181f6ebc563b7558c04af99eecdaac35630af020dd55f05eafa0b7693fa928b3cde8a3f41f076c490ed4b7f3bd124f74ef8df90d721fa76503304885e13452bad08455403446c5a55b0d60aeab1d6ab6e65ea04060ea35229739a478715862f647a1cab5c43bdf96c2df15df56ad550d83256478f642977ccd5f7aa8566e251f4c709cb50632e0e792796664cdb9dac03eacd1e04730fa985dd48803e98ef4ee8299516a7d4971bdb0a78c5985034e28b34bda267be229d28cc6454e7916a5bb18a705864091c87c255b2c7a6bc857dc7590e4599ef7219863b830ce7ea1238e56d0ce864a4c79daed730058e4f504e33a2a4ef4b500bf69389e4de12ab9e110de1e8b0c04d948e2c20209c94a592f819fd558abd008ff03ec7a8ae1e9deea8632a6b639f6aa4ee3da0252c95e00154db5e527be5ccc6ee33861cf769f833f3e44613a5265b5caa2fa11f14f9206092cf61b2bb288b520d93c191f1060677e63ba394f862b3e611e693adfb53b2972bb0079816e4530d9a4d5e8639768b54c7a01a0fc862b4a9d7fa7c11a7842cf02bc07f4f85873be2d326985339b41f13c8fe4ce76d72ee37069c00f5cc0fa50cb5d5abbb90d6b058f92e6cebcdec719dc01aeba16d05889fbdf598d2e5baaaa5b26f160dec9f6b21386120466eef66edc8c389afc32d528f650938a2ee106cc8982b170f8f5c3e0c90b1a1f69a3bba3d4871285e8c263e6cf592cc2fc4bedc8bce213e9b90e11daa1fa3ed083fb7a2fb1fc0aa376d604ed8aa8d5018ad1fa7c43b591ee9ead71064d5f30f4601b39bb8685f703784decfb07e9925c7daba35d8094056847ff6e60fd9a23f535ecb7eb8549a31d3e96656634397bd542a6947865a50893d340c1b4d0daeff821e2f34771c22c1be3b18da66f0fa1ee7231d2d70b59f5cab1c6a22a90b9d28a1f83b1ffb80da2453e33004eb71469344180a5305675b1b71f0e3803036d4f6cca93dffc61ea4ab8082196ec865f60cb82132919b549f6c74711a00a3c105b7c24593fd5496c9f03d995a2fbfaf3a473297478920925e3ba2467fc7b63d92462ec055c85c353a057be371b541c5ab03e4f0734366d573c1f4a629de2c25459d4f3bc0af4989b00d4758f168dcb9e92f1c3e7925094f6f9b3a0e9ac05ccf745fc232aca03e1b8f29a11b67e2b0966276c89b1fa2e65beb6e1068104078828ec58e52800b91bd6f46b10512c6da52149b1f73267a795b7546f18ab4ad7cad2e65db4d8bcdffa9afdcfd417bef8ea0abeb6bed4293380df80a838284566d2683c08ca4b8c8e58c62798e8f3e700ef9c22a95dbed327ed69f382fb852da895a1e018001c9807228e83ba9ba80a5d5977fd8fca63b01616e00f29bcba97780ca2ef3fc7be6cd27536e2f53f0f8b7f33cd767b03153890a5e2ec262e24eb588f20cca9c10474525778d8124d25681dc6df1d84e61af1e661bfce678c13335e1e7fe2f388ff64711ad9e41c5362c91f0ddc2daae30e6bf09002d4ec3b058e07cc2cc3db67951c13ffd271929af9b3977b6e8e99486cdfb5bee9abbc46b038c3c556404906fb174ed40684c6568f2eada890852a2f2ea0cc29f1c85de1267a2216dbc259dc4e5d46fe7e7e7708d1c79ee045cd50c88d2fe7affdee60cd4d5ef115fb5e180da6b8dde57dfda1d19f7004deb079faa8cb23eb174ebc9aae90e86b403856c6b3fc94cb8bb1488edea452d40ad5ed0dfefbc0cf32f08e79e7d8bcd5475fa07c501d831f07aaf7a4756faa5167407ad1f1e013faf2dff930bf30755c1630ec1f07a4a87013be192a38e76e5f53cc0192313da243125389e9529e5278bd7b3fb439e10d3e56073c1ceb0f85c8b988659d067f6107543611a22dc12214b1cd8aa309eea88d2e21b1a65c3d010c66fa078c0cf1a21f0c7201e2d39b8bcad6c9287e6622ff0febc613f14d98569d6b37a50f03183d0c3ded2d463da27c8d9ad601214ecab04b5f26f98a4c7ca56f043e347fe6e61d067895c8625d7ad41a39bc6c6ac67cc0162b9cb480584f7f8e21947009dc17f36f0bbf922d9d80a20445d250981015fb984a8b8b998736cd45a1e11f579aec9b3b708bd055905b1b9f50336de756c67a98bb6c32bc1f0b9bde2eb095a05b9ec4ce8033a6fb6f7fda6d4ffd653c1a0b8da5e951927758332f67988c3e61d104c99fd4173d8d95c2c53b2d84235deda2b39514a00266de01b752c1b857f5755e16b56cf4db107fd03986ac42cba47c453d566831246f7e7841ea609aa7ed1e53cfe3f741febcc1180069290bbbf02e96faf7c6fd09dfd54e42f62cb2dcb9b50814cbb587209b5cc2308c6886e93a8810b9d69eb8f8d74398f5ea6c33f1e7e99cf204a8e4c928cc2b27f64e10a558a899e087eeef177dedc78a45df5dc0904eabcf73cb943393445fb2b1614f7d2cfc3f19c9fc144df2d99c029fc42a56eba3fbfa2cbdd449e807b890f4671f544bdfb7351504cef49afda580a058615334237e0669d479d70651bf2c8a47de8009d4249548c00f150f42e8f1cae7404945d808224aefe24f322bdb8b50c86b2934b86ba482fb96cf94556b90c732455c698990913aad47f63a8e6ed2df96ef9fa98d738deb9956badbacad132f7bec844756e853ea599e09dff9f26a920a6a8a9ff10d7fcafe42128d01e1193955633e61d198a3236103ae1ed4422d5860c3d1506e26101cc4ed5274275369a40bc1d9b081731f026067f533083dc634e1ec5572d1371d106e808043d54b8defd7c085236aff13b605fd3dbede4fc9b21a4a13003468ab2b43cea8222bdf435dcfc623ddd322e1b1e2f0287059847449d109802e1ff71aab6c1ebc1fba976353342dd3fe6eb3640ef4266b4bb928f58bf15f9d549ca06d50e9635d546ba76d6576b7ab2136182af044236ad26a8857fe0ed8ebef8b7372ff77ba2eed801c035f8c94d89deeda2ea9f5fbf8dc6abe83a26e32cd123cd389d2f21dc91abb2ba20a11c2ea84c05948b877b90f09f45c88e6b8047a1e736abc66ad410e39e1f4573d0e2d20cc77d0805b9b995bfb2cd50041bd824fbfa26eb74b6c217d5ce4a5769ec2ddbeb2b1195d51d768ffec60ba47ac01eed80a7ec68d732d03906c4e901682975ced39f2d09acc19b61ec13a6f5f5c11bf0fb4ff862d76299e4613c60ec415d14ce29a7fc8bceb5e284ec8019fbdde20d73517d5efaefbadb43d9f85bb7474c8519fb283e78c98873e42279674b56c97bbbb8fdb3ec37959a713c6b59117184608375f086593fbe3d324607e5a424a9a7482587b6091cd993ab07f825d5249d9282630dce67e11fdb344515bf07ad04f97a60dc894b84c85b08a7ba9afe58d41318599d9508d2e9172c2cac09387b82d1637f74e00da0e215ca382290d72d5daf1aa155da8c302c05d238d75055b7f800673dccbb7682ca62f39e3e1c09f8df0943a4704b47f4cd5980cce4e3d07ff3d25057de7b3dfae648c7e95038a5ec14dd46b3e4228db849317a448c2d6cd7baac9a618445eb6e54fea068db4f1ddd3338302122c24ada53c2f755825c4985c0e4c65bccf376890e4868d7f1db09abb8334f9eab778650408c2d0d72823cb1d839cb95ed2a3f22240e7afd78ab32a3668231c9a38ea59c0f5c93f982da80762a9f626b0b31413007f136e63a265c4d0cf2712eb889823c5ea8f79afc7dc117e0415e8820e8dfdf2780e330391dc456e3273542a4a027ba0ba20c92b06f9b114f4b98e9e23ac6ba17d972a57cfffe4ce89e953646ff968083ffe9d3907dfa0bf641bd6e4675cbf144bb122690d6e2a9bee04a51ed6d744a2d8232d0efe82d15edf3b6663b93ec12deff9977c3164f04fbcc982b827426e65e90a6829028c38b2fb542db23e12674bdd885df4f257f089ec9a6d2b680a745487e098a4134923da1299ee12a4473fab029702e3decf9a8d25f1a2840dcb77b3df13d28aad397e30796d1a7c39e157abb6628e96d52a61268f38d5300121bad9a4a872240ddc886aa8f2b85b1c0bfd47df1a243c9221427dd488f835abc0ab0a42ad6a88b6af41e1e35e89b5965d0d638db896609c05ba8c8c1b01de9720ce7b92e28b348c58ed0fe2c46d154566d3167fee9a9164b9a81a0f97146f63dd41ad3cee2a1152c12f35079012b6b587808f36ca3db59ed292f9e9be633764f235ac79cceeee9b81e082e9eb0a51a897de966ff0b05e2c072406dc9280f22da2221589b3e624e4ef52c5ce220f7bac52e5d521ffce8bbb55d39fca01b8381e848368bd8cd7f8b26c4529b3ae61684643baadfef63ee3b53f3afc30c0250846","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1480e6645cd9b3f9e80d0bd57dc9503c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
