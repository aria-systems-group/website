<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3276c32b162b576741a2b61a725c6758958f51d3fa0bad4fe2ce424ef53143bda2387971c960fcf5bb7874ee28a40b9919062b44899df9cadcc1a66f2cdca43bab087704f0f405a1039cd5d612624694a504ecb54c8c865368a24bdc5c491953d5972473df74d9586dd0289ea6e95e4c546be3eb897b4ae071c28ab99b43f80d6c57f4a48e11826500bb47278c25fd4c39999aa98da2f0b69309f7201747168ca9535da8b7d0d36c6ddce9c5217f5d0c68c882e753a4f8e28f2adfff81abdd29a6ab7833d07e2e34b036f38a253aaed9999fb8cf951bce27cc8dd30da32836470ff5b499e0f4705ec5769a08e5348b76a7c8a51da982a76718011b10a56bce52b984522353e3cbcbf39bd17f0fe0d35b5993d9451358b120c57d2df3283618aba1d6194e7c62f8a2408021592c5d97e8d22103c50a5b6443aad300c2e6216c5b069ea8f579d25eca8d2117c77d6a303997b2b51516648c55837f638656bf22009b2946f766adeadcb683206494b26d48baaa2a7997b5d3b7b314b6f969fbaaf917255afba37d3647cb489d6d2fa0a2c7a04733e57f2e2220bc41cce9957ac3538a6bbb9cd00d062e8f9e9386ccbd1e68156db3e23b31c69ef878265b5ff3edf715b64649f0fd4bb464fb3b1f4fb19cbba37c9402b9014630b2670d2fd33cd2ad871d3e9544ddbe9da75144617d4b4908ac6f08ed140f83e925f5e2d1cb3ea0e5ce3f8e3ffbe034b59b1433b4d94a0d01b9ae806fc501235bca84e4321ce2d32800fc212f27ce33d44dc04bf1c39f137b31e6bd50f10aef3417e6bd6fb3fbea01425fab471c1a00101aa8c1805afcd36b47281fe0c12ad463d9fa04c978f8d9119f707973bbc95c9709a438fc13adb656ee82e6fd56227de0b96c9ff47f90ca2593a9774f3c6d6dcc3582d7c883cf05ef7b7d413901b7ec3d2b66d6ffb7a8bd504470a815b04b92ed50cf25fbbd77be432472933918f61241b5116874b8b63625550b81f41c6e043377083c6959c5b9fb45778e9d546c309edf2f8b341e6227299de30c5db638f471ef83bd3385155d7198d1239af458490547040116f09ebcaa407302be1c44e281aeb7a21248bd2adeda3b9a51167c1be4679f1fe00adbaf2545910cc05bb86ca446cbeb111043d451ce4e98c0985a5eb97ca3698d5b7f07883a307a21abac3fe77530a3ac576b59f9955925f9a580755068334022c50eaab4ba3ce59314dc63d6b0013b3a436bd5dd60c860071cfdd859437febaf2b34579c8ec5e0f6bfff073af3741082c4055b840655a4c5a583acc83fa0aa9c13a55b1562d0ab3756c7780bd926714066f2e2cc0d909265a523dfa1870b9315e804862d48d32f62b348694c8f2f2d21245ff4416dbde5ec751840faccfdfdefa25c64d38ab9e7e048676d18aa7b4d08c7320ee93ffcc251cc7597def948f04df7da38e92fab3a356347a86259e5bb21d5a5802c02d0da79c915e19e9b3175d40bbf5d3e6c06704e0dbf2286d522f49d80e2371fc1ded3e7fd07519139d48eed5616ace0e4bcc4e09652b010549173af21d1ffdcc0f6eeade6ebf09879b1f9a3c0a6ab91c1535eca0ed8cfdff08d28cae2bc80272fafc866bebabf6ec296d8e21b6c430ebf941452374c9aee2b4266f8e402906bc092c46347fdaf942e47e64c8906d38d151adba75eacd6215afebad05bada01eba3989d990b73cde03043b07c2d7790ea16db550bfb8a460f6c6f59f81d3d4065a2cb066bfe52f6edd401e3b2e165806fbd853fb236b83ee0250d2ebebf4121ce2ac358efc0eb3bd952f7f23a16765ddaecc1c87b4b7ab5e849fc82e1ef006215b3aea2d74132379861dfaf981b911caf09caae720e44d4be9cab3a9094d2a946e5758af6902e5aef243c49797c95c1ce9cc6fb6c3bf494d8bdbe8b3384451dc41425b064c03cd9056df59ac2a09bfc6ad9b96b42197f022709ce862f0e6fbd57b78dc36c26021e1625f4e6312edab4ef2880d1ef7ed34e311e49db0a0c28d23bd5fe3693d7f4df567d3a2b65a1a075ee0ec6e7409d3f69ceca4a810702711d1abcd6ef0b60a63b4ce7474bdfb60368147e412760bbad06869d3c880cabe1c490422af570ee00bb37d05b5d44326753b29e660dd2313e2ec0bcee28cfcae3f96f6cba8eed0826f7f7c47d8cb796b1f360758a4ccae8e30fc33d8d13a65fc09b147479dcf74b6650a2ba3e28c142945051fc9d7157f84a759eb1ba3e84f826fc9d85a89e8603c247b37730cdbd76795dd1e90b43954ca31d4814a60131a30f35b857cbf197709c68fe486d68de1c50876f335120e70890ba4a1228c648dd454af12be4920b7cdabcd9fc5791d96ba2d3de6773b0eccf6f19b3150e03f19dc3c08d46bd41b2af863b9374445b7a75b7be1c4105042fc59bdee294f69be41d63aedb4d071dec7a1e831466d8c2043f3c408d058c012c9f08491128321c787593776efd1bd654540810ce94cd81c0bff85eb1667903210dc9dd270513ff42de48ecf195f1cecfd43d671d3f27e1e7b1a6fdf8cdb74c3cec8b69904e448e3bfe7b0727533531570b6b72cd561e46f316ee5382726f3d0e9f550f5ae7f2adba1d739adb0404c5d308a29ae5b65ab489351f2c636fa50e2cc444a5138c5d8b0789cfc0d860b5da26afbfabaf467cc12f2fae143370a25661d4c216c16ebadf16a1fad55264e08b30ba4167bd94eef5c54e5e5d62f26e951ce6cfaea02a8a0f2288025ebc6e840ba8b66107414ef79c952dd95fa6089762e8b682bbbfee656e07c03f0e93efe4f0b75f7ac88a0a28638bc09b663dc1780a4a5aebd60289899ca226a4097dd527925baf08721576959d29e32ba5e44c5432e0f81d516a313471792752b2a5d7a9fb67f858287577691f8651213c9a9ee85b050b856267d0d6fbbb05e4765899c3fdbfc6690a7b2de1e49cf34dd7407e32d3f39cb8187540d451e0991c8eb65e5fcc3fd202de2a282726637f7bbac63970c858b3e86cde0ee6c3471191afa064469c3673345847ae47a06bc3a739da543024604e5e562316ad7203b561f24cf5934b15eb4eaf7cfd956e867ceb34a6bfa8b8c52dac148771384fcfb0cde07a67a7eb36fad5a0a02131d1132872acca9f8d610e5305a53526b1d1266f051e672219be1ff8bd55f075c33d966060e42c882136a648fb087ab055f2f432ce4c499d6df08a90f1d6e49f3b7878238758722d3791d0f5dec34464db608442a8828ab9ddb32a58117b278ab1d373b4237b05a5569511cdbd52c533067c1b035b57a9fd31a7f2368fb865e988fe8c5cf58a55122350595fb51eb3e66bb7b9f80f70696f6d9f13fa674839608f0f67a0e0e1ff62de24e269c5eeea20d63733440c06214ce94a6016ed2510982dd31440302bb454693143cfabfbf0b0c468f0652ea88c632bfe896daed15d006f6cdf427310c79e5c9d24430ede81aed7f9fa5971ae3012d9b730138f3c7b98c0ec31fe16caf754d1712a56515a1a57df85b448e1b2f96c42637aff04d16342169cdce19c9c2e383f8582a55f174f19ba929e047561dce2b68a0105daa7e264713260d3b4164d03de47701ce9664d1376c0395dd8e2f3c9cf721f4f48fc91d3e2db1b1814147a65fb1fe8fb59f77dab5c329df95e69bda905f24b9df1c3ba617ca0e60d0f6cc6504596c8fa3f056f8fd3fbcf7d9da0cac61782a11ca9a0ec12365e28009f9838023f0552dd19f52a338afe133c71e63ae764457d12d1b523657aa504ac4d909669e2a7b91d8411839fe320ffda5f656f691c0851e93ce1aaf05808ef550b841de2b58b2608c970b89d084f7c4b3ab0a1bd7d13d92798df4e161caf1c623e7a00784c2f571ada0873898724fc5ba79858fc1f34e611de18fc74dc3a20398da9115679346f1112039562c53496640bc9d5b64ecfb54978a5494e550b74eadf92cf8f0d5c1463bd36fc70b6d96f9e75b88f9f62d946cb78f88cb20fc97356d11ccbb1b2094b4ba4f2caffc0dbb1007b01348d6fdf830e8ccc3d4d35a4e6a0fa3da86f13996753ecd9e343a7f3faf9eccc1819450a82088187e09e5ec5d9991f72d77060bebc732395f1729d2a3be3078d9ab280827fcb653d22e2b4fd4fe266c58094173ed79f9c4f8ae469b592e88093cfa223861605702d7774c1fcba20980221083ba6c1b78f655acceffd3cd5e6292396621e6b55187025fbb0005dc4366bb05d91047ab8552728d2f0bcb1030f63704fb63e073b4ee12363e24385e1755990afa71b952d1bd6b77eb3090697dac41faf04df20e6dedb21ec42bd36c466a4bcb626a5025ad750737ab215a420923fce7a2030f609d238302f638465a62388096514660d533d81b2bc89fa67a423e9e0ebf892da977761a1cde2c87ac4113b9f454e7ce1fdc7269dae474488f0088a981829223d83a7200b860c10615fd9f19b45dc9c298cc71d17e529c7084627acf242d567c5426121dfc70b2a6ffaad9178151020ef316405d41b027d2ddb805c167e9c217171ca0017385233a4c9405881a98f2caa3759ad1b2a42f119589401e7881eee8fe6a52a271628049856ec86e8143eb87e08966e46d668ac226a880814d29c722abb1584fffff6ffc7e09935a2e4c62463e1601b6b0b8b8331b5e5c579ccaedcc62f1eb5b00ec70396f69516862aaaeb81353949914fd749483829b9cf01d3364a588a69454e7da4fe5c82134bd23c2c918837fd24eb404d4cad5f7f5781c2342d1fc469d5a35d299e7cc5ffb8827d941741c3b0663780678694cf1838fd6a3214061afa59a5bde3d082ffe34fac2870e5636a3af7087ae640e091b7893acdbf3892b7ad8b0e1cbbe7ef16f37c84946e689703773fd6b82357e2e3320737e8d21be29182afb1d8c93ad136c426fa161c5070930a62f859c1e12e671c97d81ae185296d3d48262187551fc2319050f29f3a52791bd63ba4af62e93965ae3ef665a9a59a58aa13b2d4cd1dafdb92ad4bcc0fe4dc8623202118f495708d4f4e7ff75043575f7aa52f206e274cb24b8d296c8e5023b4a45fc516bdb7ddb2fd8895b0386f34275843cb1855d857a980c071a0da4292ef8dd84ac72bf60f12baa9d1d522372fac6728960402d8eb6b4924afc899bfd03f98a4c45340309a907b651395635ad2045d421415f9137d187c58633a8b3b5653d737d408622df1272d40a15b9102fa1150a6c430d08f913eed4c5d4fb51bb0605dfa26037855f10965f891f0e68ce39d0e6120741df02dea44c254006f641b363065aa9090a1a250531da199a76a25baced78f3851746f41f6d7d72e5b70312e050c3712af96b33cc02155cb19c3e2d60b7db48e839b3a8f2d9fb9d6020ed213630dbe0943eaf3f20375f6dc4d0d30a0f66a7a87ca8a60f71ee29ac5f92c16814ed18e35ad7e4ecc2cfdb34248e1d723fe86cd159af0510cdf5739dc03536e54abada639af955ed0c5d6750d888e78b4e2a2cf3cc56de4e981cb0c3b8a8bcc810a369a869c29ee23f4bb5701943623929ca1be19f90c70bd0f5b7dc00216c44645597047096006d8a02ca27c1f15d15fc3d7b0c0def5527e17a0015a5646a1ce77fd06b5ea73120996e53bc4798bd11e985410b92441d84f4cb6b79f2b719c3b844d2b4d6bed473f6588a23e35df0173a7e3a31315f10e4d2965f295a6450579a9543ca91ee82d2d074c1fe68afa2099e13a0bb99c7e6b2ad0d1c380bfe0f5821aeff8617f72bda58540c626fe3dcad74b70cb0aa3f311a55b17c542b94e653f9897d10eea46d489db07ca5927a8f205e02593fb7c5c384233689926046c70a239ef1385c48665f243d8134a573bf311abc97de2d22fb020d1acab8b4ce41cc1eba406c90fa314fac8ca9251c1c0fabdfa4a38dbf6ebf12d74dd3550275bb7fa966ed8d7d2c05f02157812c670a33ee69326587649541213ad340883c495f9720428eeac968b413b937342e333ede5f4f4692a42dba47f3c6d2ae37dd0523f8cdbaffce6a6ab96bf5c2df4c98b9ddd55b73a2fd3a5d500b24d21ac8a37056c3ca6e0eca735d78763cb12e7719c7cfe80bf67511b20552ef830412d504ab33598b323e209678ba343fd2f04e3bc72a3778de04868974a8f6727a32588bf831ccab151ab8c134db4ea858bea4ddc09f7135c43fc657b9a9c66a23c9085070ca3469a17acc4587174f8bace716468ab79f7ad555eb2b996d6bd08b103453783b3ee5f397177f99599274abb5137d7322bebfc59d42e42b4099bc311e3fafb56536c48b2781567f0a09c7a7ea6ee1054de3fa7bb713215f01fff2327a4b7b256072096379715ba8870b25843dbe07159c9dfb59f9a729b39d17a3a4088bdcf891b85d05aee3e24bd8d71fe7e3201c3cb510fba604af235fa3a31ffc94d6c59eb94839d75a7aef741d5eacca8e1d3d543d1486070a6dae079f4a8a8e676a03adcf03d4feec0764eb2546a5745ea53e32daa0f13e773421238ce328b67c8578c03d128c66a03652a80b606dc2aa16ebd24349dd76269331c5ef02c633d9934a5fcfedb04b959e273034bcc104dd5b3fbdb537d23ce430fb36b5b7aab98802681b5d9f63dd62cf70e2e16348aab0aa21abc534d5a5731694ffd493e0bbc880c6de3d053a96a2dbc039e7e8b5d47abd18b0cb52e85d98ca2f69822df083e0b1d6e0b6e7d19407b72c34795280fae7b1ed9e3dc3b84c7c2c565efc07e1e4ea9f479fb19519669ca1d5a2e0fd0c2dadb1ba4c3d4f58e1859cab1bc74b13e9ee64b18396543949ebf2975a173731e4e1199b60e1fa901f2d781a0b80fb6c7c50e52d421111864f367f56f2da550d702906c3314bfcf518b6ee23c3477cca0f975c7b8c36bd0bb8266de995fa13c844139614b02ed8a6c5f50065b11dccc0a7e0eee2b528a23bb13b3586f088e65373fe1a207da09ee4df2e47e6f7741f5af16b68080cdfe7e50261e6f1d2b7935d5fdf6b3846274d68c837c7499cc625fea5cfb2df712934092386333c37f370cceab933b7352226a71248785b3f05010dcc160cc1018887fcaa666a0f34f0f99b430a1086c392b08a2d742b08657efd360b8ab4029ef1f3c70737704a268270de6f024aba5107d4631f24887533aa2bc0e2b43063aac89fc44d0f9807a308b5099a4a3153633b6266b08a708ff93a032f69580070d7c618be093ac2f8514cab34b4882ecb7a6bfe32946add7f4087a4e57a5b5b283ecb3149cb08a07d1ee0b03273ae6f021ef5a9c92d7a2fb794101b499bc69b90dc2e27043fe0f790a6a35e35865c71155a480f04e9329734a56d1d02821f41c9dbc75c40638a968d0bbb48a70e56cf433ab27e176abeeec2b28405dea9ed0cc268dac5646986b7e7e7b864a3c4539a881b38a38da615b2e8ac286bbc8730c1b3bfdaeb4c403eb594c4bf3b8b80fa412f7a505d1702bcaab57c82faa8115f80ff6d82307f44a02cb82679a568058d270989f8e606444009f592026ebcf35e21ca358cd0299466d8402cfc2893c1a4e91817421c0927e0ca3500386b2d6bb3d8def4a43a6a0ccbbd698ca2a6f69fdca792020fcb83398b7608ebf60e34682528d037847f131a9a27bbf02689e84006fae824673423c3d28b23bd683c0666eae17f0a9a79113749198d84813610a6226bf39cc68af86080ddadf32e6241060d7973a38513276b5fc143d8873eb65cb86a79a863a43330bab8dc724cad2cf938164f747e53ccbc4ce9f09219992c9c6889cd5c5021701249e3f33cb8d346ea556f8ba161f3b243e539850983f0c04a6f87b2eef0f55208496d0c097b546bc04ee2a54ea4219b77a3f250a8a84780c3af8bbc2ae714eec4ea11cc8c82c595a4fd9ccebaed0f7536c339ea26bd68675e66e14d05d85195d11ebe1d7fbec3ee94df8b150b6a042a869a661c9db3fd3cc3cc948194ad5e7cf9306524f05f4b974c054d1d1aa264bb3cd09a69788a1dff3c04b18c99870ef784247ee4e2f9bc44e08d6452b550d28740a69b3b98058b0fe7a19840639d063771b114b2d9356391c1b4abd375544601bc0bf0455e9820d7d7df23c8d13423392dbb1ec2770c06489d4141dee08e67dbabe0d32daf7b111f43766cec3b6291604bdac6e0445111c09d44a422639548b4b37f6465ba025d84c4f0b9745380bdbe4a215d13a0ac472bc97e68cd1fd84ced2c123c49fc9e8e036816d7dc048fd985782e44893743b6ef358a3dfa1f7b0a3714ae6d048a7afe13ee354d07c2fda2d4a7fc257e8012c229edda7854e32ff0ec52a86afd6d8d94deef44ebdf29ab2762f10353edabbbb32a6afd769c0f23c6d799538cd65908dcd23f964fe583e7553789b700260adf7d1034dde40a8f83b6961eeda1530b4f7bee374769564fe74d9c7cb57581abeff229872f16ec2fa2d4baa6eb64a6c13c8c89baa9b7046df00638e3527fe7734e6660a718c590421991053580ef56c8e4b42d744862efd9432e2801ed2389736e0ef043221ce1819ac5efe7c01d3a9102770beaf91b9838ce1729573d4bb68e7d6b8033b0f780aa8c4446fcca5c55ef899bfee9920f9cb3555863f30fdedb42bfd7a02c326ecd08e9bc32f6bc78b7c16dcb3b4c8327d582d92e0175813084c75cc295c7af05e311c863ffa92e82298b6696aedc7f196a00ff2f25e504010a5b0e93a00a639e1b2c473417275e9cae749fe7f1cb51e41b1cb26f6ae68b4a81c4a0c741971aba392933a033226d5f0bededcc7756d30d2e2611f6b5f1511dc7dda9a8b31390392a89faaf3296bd92229746634c17e75356d4b645bb39fb41f6cf514453ad299bb673161bdb3de698c4ae12b596f0b8ded033dd9504b7721d33253dab3543d974a7a754e6614b17e07e1dee95e3cecdbb541c5dc8b5de90cd37f75e6b9dd0134c65a9e5f890bbce9ef1159020687384c6a3648ba177c2e4c8516f59094d285e3ae2f96783770a5cf8683639a126b27654d8413893660deced8d6e72416aa668f2f7985508de5cfdc180ca72711226452e7ae10653f35b8fe5b70760ad0b782ba5634160ea4c2930fa405a299af29165e4a66a8647ba06e5005bd6b77c6e4796918b64245da76965e5276aa47e39d6f757664a0c557563db7569b0d36f0991090bd36715e3bb371af8649ae3980792455fa08994617d057a9f8d372e1afedc80c1854684939fa179043bad47807f8b3ed8b5b1e4ab531f1a363bcdd93294771ba3262e96fc37d5019c5cf004556944f01bd2c15d65c38e3088591f897dfd9498b74d77d29b16d79dbbfb0b00514163c1ac15cc641f28c53efe93fb4a880779d74c787cf4f8f9d805e75b333c4111c8f8c947ba620edf115d995f847f9701dccf07456f1aa609ecf9257534b9b1b959d84dfd561bcf2d237a3385617336ebaf9616e0c642233b75d3c1a5cb0d14093d2c833c7b9357ccb55eeb2fa85ff7226f4dfec76a210a8c7f81a1aa448b4e3b40577bef2c467637d335e0e3dea581dab43cb8e8d3a450bde7911d16b52274f85f17c736e7b6cf6c64b3294d3a8095c84e1d9c3dda7c97b3e79031baf7e15c2b9c7a001ea5c27e29c819e9c522a09a2bd78fdcedb25dc8fe38cb794340a960cea7e27577cbb1d81a1ab2a1823de8e2acf52651d8ea6889c95b34865176d9978594aba7232c272de94299d1024a05dad9514aad210882c6168c1e5feb444dcfd0d102dfdf24608f1f0d86aa1b66a1eba5ac85ead2dd22c3c2d714568f4ead8ce17c718a33ce1fa13399076fd615d1f7ae537ae1a4b508e359edb65da08affdf75ebddc048d405dcff87323a5d2efeada15d9f790fb2fe447ce5a40a2e50557954207da62e4d38676f24beed641e8869cc5315253b5342342d82245b8f6fdfc3ad762a0bbc760a39a27d6919793f8201cc5feda06c7ddc35121c862738cd8c8475efd39efd2b4499c4fc50c0f1baa3da4a8aca47894b23ea1accfccaf8d9f3cf4f5225484df09ed0436d78fc5736fd0dfdfb66ef112cc79b593d0f7907bca85d1da046238dabf6c4e45698200c67859960ccdbef598e0c8eabdb2e5b7e475be030d49f110fc6e22c98f62bc3bf23dcdf620f4228f2b31e6158423c2f55e26c9b02050d335d154aabc85762b0c9518f697d072558ce42f50166dca857e3254982031cebf721364119621b03cdd88ead563c450b369eba46ef6b9e2493878153fa9ad1c226f655bc0ea068834ee7f4b36f20793062606b6dc538ccbed4918225071a5b3ad2bc25593d133067de41fd568c60dd0bfa2de29e5a313ccb94fdee106bfc028a31dd13590836cfa28b7cf395106ed720ff0df259035ae353fb3da575290fa11cb63087454ead268ebc71b4f9778f82947c8b6d46acf417302419fb94c31377bcd5cdc852ea007febde1ca8e403d41e57834ef1099ab55cb74ca4865f55aef57e4e11567422a58b2c9bf05bd3ee9daa018360605e0f43860126566e79652dafec5f0603197e579275cedf5ab38b97e88f325b1aa927dec93ff52348974a47db1b218eec463250b23646afc021d4512055479573b90641ae1848a5e6d9e3a30d5a3e3865fdcb8f46428b1b24607051825792416f45058a75080130ea397e9540c42422c1131446a2e033aecd9baac46087e2d29f4d3a1cdfd92517ad1e455c01d2af8cdaa4c68b4000d15a8f283e18570ef1eea7f23ae0c5bd6a693d23e25899020667872d4acbaf209620134d5f85e66cc0599982c24a7c2fc1f22658619e5add8dbb2efe54ece81294640c7558562786339e62ca309201fbb7aede6b5d57fa38b650aeda0c9395ebba2118b5206754e8e61d321948532ceb41c889fe8fa8a763013b938c928cee51a02a47cb40912ffe19dff6f7dac189ea8094cb02029b453c71516940e238fb773c32fafe6b96712bb131ec175faaab7c9451ec9f8fc77a591f91dbb7ffb4b304a8881a601383151f0e8a85a5f29ad50cedaea72a2029bc507755b7642a2c2b997bc50a54d6413f9b7f8ef6924505bea919b5e31060fbce169ad22917120679a63c9827be69d62d7f7872d279e9d4681248d4bc8ba0db6bbd23db25bc07cea74ef8165a6d0b71acef61931b716ed390b671db81b00f4a5061b0e7f3d09cf4c1ebf133d285972e0f6027895013b3620f2c4b17a8f5ca51d1891cfc21b8b54570d1681953329817a364f19c7c3a00e6a785b0dd5c06132e4df9d920e53ebdfff4ec9f2af344928d12246470e533aa9df47b2e5975627cdf0086ee04dbad9706dfbc10244d325dae36386b84fb674f4839f619858ed582cec26690926078b7e9b2ab33c21253c8702dbcdf93bb8047e1b7854c6201fd40c6c32a4162914feeee68a947d055c316180b59ce5376a9860ebf325cd94c81594b42c541fb1b7a9a62795e9cdf39c60f8bab74d944f40b4927cbb7cd5199136ce6f1ff5cb52f72c821050dd10149dd71e35240e415d55bdfdb43d3f26f0fa3e87a5c25b5d77d24af6f7bcd7159a6792f605595d1c8c7a29d5c82d6d1a2a4fa4fb6b5e39ef0bfb863c5cbb6bcd31b8c854f7c8c3abe7f6f9e1fd56f840225254164714f83ef59bc39423d51be221ea77540cffa88615c02dc1599a02e57ea851b2b710abcfd4bba41956d0b92c11729d8fa814a0906441d0b92f6b632e8396242e96c0634ce1f9ac1d2bf0f1c23c08b7e8705e65079d1eed25868fea4c541983242f7ec8033fc9f09d88404dfe8009ae78671b9497c188a1e13c3139645aa011577c1016100e5c06a945b7016f8ba1186c01bce1a2a2f321c33dc4be335f8f921ede90230b4c3bd4b8093c9d845ea10181b0c6649ceed15e0a015f2f4cd563223bf01b42f6c0d3d258076b7d1b3eb7cde3d78747958d5a79bb177249d21191e1f24524f4891cd2b971c1dcd3999f44b104453ed0d112b5fd883f1dc0c34dcabd37a51e6fa6eac86bfb720f21f86cd996eaec626bb380df8504990473f3e7abb9e23543f227dc9e7065d8dff8e49426064bf58de532cec74d5bddf30df0c6b6e2140a6ae96e8f88f5aecf7c95103ff07be0491f0054533e565fa02cbe6168cb436f3d8d06a9740012125ed04accf9f36090ea89e4df35477337930fd6eb0bf7428a6d4e804072da844b156af81ff807ec6d3028eeefef29d78d6a502452efbc7cf7c143b65344e6231347a84c410f9b4c4609ff7b833e20229bcebf33031ec958e7931408695c062fba6ecca680d1f735aeeb7d7d95076222baed4d31f01ef7d11e039b7ad5828cd98705dda8a2aabc4ddd426846724cde2d2e3b26c2e8973d5a79bd782769e8374d195d5d2d4cbdc4744ba106374a0d69334d1a2caabfe30015c68bf596a31f7852084199848bc8c5ab641349a5c9ad02f36410ce4c2a758ca47e36804ee86a87558f5d5767c6638ff744666884104199eccbe46d36e0769364353627102b8e4b17634adb605ea3aa091191a006aa0dfec5ab354ab8fa6b9149034204beb913a84be0e8adc8164034f2edc7a8b116c3119a855918cc1a35a6894196489a6fa9d790912ca04e0a238834cea873601378eb3996d93e3cb9d2668caca1ebdcb273018208a54132868d2853be675258cf28de8220cdcd1444cba7840d554b5959e5075d6d21f951d22966a6c0d0caffdddeeec7767721fc902dacb04fac60e9d1a8ecd0c8dbf8bd88dc19c7134dd516722ad85bf6c598c65848feca2b8344b7318a574ee1feafacf4acd8a47358cbaf7dd6eb153bc2b04499b1ebd6f83b9170878d5d8eeeb81b10105483c6ebd6460906410b245352d7061777a7e90a9fb9609288d87f244bdfcdcf4485fb8a05794f65b581a6e508d9fa8556fd1c749d2cf181fa521e83b94b136be7dbba0909bd34baf47b2132ec198751596362e9618f9c980fc6c4080d4620929aef4dd6dc3e00ff8a6de1ea1fb198f4f6003dedd6f5df0566fa402e2f04e46c1e8d8fbe539d3d3488993b0c2337dd50cbb173b5219693ab0d9fb72ce707616251c075b7190a30c03f31bcbae845565594b3896ff47793584fc7e39203a0e13264207d068bf6f9d1cc5b55b3ad783d728f3e7ae60496d00337eb055db73d7d57934a51479f5e3f7aa83c7b630b94b110e5a09b649cb2dcaeefcc3cba5482192aece4e5b5e64873f55b3c990288bc964abbe9fe65bd2be6ed99bcba0a79d1df1f1ec5a543c81cbffa85cee488f122bd0ee6d2f95cb9bfcf7f58c14d8d0f9b74aee8d95a57e5fd1bad1ae41bfd1e4c6a4da08c1b2ccb14f694f508daae16043ea74f57748d73d7da5338352718302463900cb61579e3caf9dc83061af5a6e19df66ac9ebcb272368ff0bd3fa6fcc2f1b60816997195e944100f4fa6bf57ea869480445cde589a720e85bb03a1d9fe9547c4b7f23edb74017364b92789c09f9bd84a46e8a4808d9cab140597c4590ccb9cabf02ca866b6aeb86d9806b655a23bbe57e9bca42c17e88011d537d1e3663ba5264deed18b024814601daa8dc7bd1ddfbf6f14367700e93f5bd9ed36a1c459d6b55e7b9ad0f16f1765bd50088b08416c4b604ee7b0f128f69511c0dfc023dcd77970868e5e9c019e1f91862991bb92794b9f9b80d944ab1af3ac25ab0fd0273eeaabcef63d328b11be9a4e047dcd91ae2e8a8ac16dec0911192a43f08fa859f5ef31900709d13aac27c34685e3b92a7da3f5483961ff18ff5b60396e15793a63c6d93574cb5629c46d294edbc4a7ccd16a0f3fde8c9d13b3a4155fe516229a0e1c7d7f5f2e2dba7a55f8fcb6a458c8297433cf488d8aa82edfe62f9b75b9001e4ecda927560c277ed25631b4867e09e3b996aa1353a34242f31a518bb4fcf62d881f1470191e3e5f8f1b3505830c0fb77ecc0396815aacd04b9c561eb0c4b23e861d48a1b8b0a71414f6633ad95644b9d04469ce897eca3bdd27937312e45b8a0584a835ea3d4c15d9ab51eb329bfe8cb9d6e1b9ced697414ca8fc4444db759a521bcaf6895eafaf10406b61ae1e54d7c2f9f317fe3f0e2b694d72b0a4787f0fbf3cce5fde8ae4e72f44081179c0c5b72fbb6dc86bfc53bf3a73bf9e9184ee689b87e908341032afe53a3ba02b10f3a2af9b8e1963a64cff99cbb6502e565d162e0db94f0b92641167dca9c165c34d9f118fb0af3096ed88d0bdea5a858e1cfb91bd5e33d4745431432e84f5338e3b559d4ae054f80dc5ae904a9e7ae12f6a793646a70a2ecb76ff6061f2fd01798520ec9673109d3f3a9137a17821a9df7af656ef9213926b6e1db52954ac5eaa4943068cc2d98212c606f2e9e9381ad1add421e22806b41df3d18f44285cb28165fed06d40651631569369e5b70da898438cc303406abff69cf0f9de91728cf88aed25aff0647b10d1c0cb5a74705fb7005bbc89f132f71a71167902df1d175c775a3ba635f6e6e59064a11431b4d953589c6b5b561cb09f00eea14df8f9720e2a5f33ed53f89e9a700e02beb78e4be6f9d1897d70cf1b08e88a7758ca38be2cf062de5aa7917744f611176616f36d0802d37e601bcff0ffec2333450717cf203f2b8653d69ac2675c7424faef07bc2c24a85a4b52d4ba4ad905bbbdf887772cadaa4f5cca102d4065b042e8188520b371b2abee844fa086e65bdcfe4620407ac7d2cbbb3ac1f1e24aa7299d8b46a75d70b5ab922ecd226ebcfd0e235767a1fad86865336bfc577162b603c5751eb1198657aaf482b16f0812006fbac286b3db23296bd29c18bc2be49cfa236041be36d841a481bca94f2e447914200d689e4a64aae10d4dcbdcb5e1d367bb4a01066bd888c8a4c049b6f10dfb55bbdef3f9ab1ee5d58e9ad7272a4b4845dda4146c2b7df5264a307760ab0fac453f7e39874d8efed826882f658c3c59217700a6e891e0fecbb47437fc44d85e888a6415e056725ec0ad0c4e37257627a2844014eb6f650491921d6f921d09e4b5b1c49e123696f47bec80b18e6d962699fc99820a186ea5485488af7ef8f4b400a034f43ec2dd0b3264e257fa59245b47664277abafe21c18f3513347f279e43056c38e66e43feaa3495fafffbb51927fed65a2ede0c98f8777344d1672f0a9357ae709d59e3ac8df054301c6026f07b3e9a6b16921d73bc6d714b7ba0ca10eff376384dae040e7d43fee3bf8e0ccb7fc04afdf9991769c8b255b195b1c372c6bba3dc9fae321fab475fd17ddc13ce61bc3d2004d0395167e314c39336f4b5a2ede5f918b6d248c43a273aa76769abae462e7fbb6a4a9035a582d979f59076b788dcb2b8ee2b8852bed94eff381a09f30d3fd2453eb5bfa49c3056d91715048e3239cccebe1e9fc610167faa36ea3fe7bd6673a51a9414c6318235fc60115c44f4f558726318d8d8a28221b159180ac4bb36bcf01ccfb92293e1016ac676f4ecde0685b46413169302e24c3deda954d9def1ad3585c919063b9cd4c7d766388ce9023d6ae4fcfb139a54b78efbe5611065236d898999d9e47473adad13df38cba5b07f5bfa8ac8f1612cef7d8f6c9a81bb702b2e16ea9f4958353ca5e5a1a0167efab6f69bf4714cbab264f52f14b4b7c3be39ac4bfece6491cca2523a1a28439f11362906a2cfb4de4fd3ad5f922914f637e2096d91ef76f91300f65b5d45d1d471fbbe061316a895e44085746bcc7bf9ae23d24524ef9fea54256b3f6602659044ff70a8243fd63703992c671511281cb39c44f204bc571bc7b73054a40127c5676818ce685c37d5f996a3b0e1c8a35529af9a12debf4e808eb63ad56cef31b3aa1077007cddb18e58021641ba1de69448317090a04fc0bc23588b35439818c19bd573bd7bd4c7b2465e69c1a8908bfd1f5508d2035eb528f2d4da4c865b500110744ff74bef85bd7e6324960f42bab23d4ad1f951db8e66e9f3f578c14b24a6ad397ec54dc6ccd4c88d9c5a6e7e2ce84640909dbd8250c5922a7ead5f725edf297e375943703a984a76c6dcac81fc89dc4b5d661411a0a70cb2dd3b2d0f99221678cdc15c9d5653946296bfd1c4e1f518c98b9d5b27953b8bd9f3e7ae449a806f018ec03af298d09318508db6364221347e53f0b01836198a227c1aa6e48af72d2870dfdeca28f4d57c32588195339ec5abb52838daf7cb482784df05f68c9221ef96e0f512e976f51b038c01bf076982effdafea0574cb312dfedfc17688bedfd48c07766e632c34a9d74292c39b603b18528d3eecfe4489da1daf009693593db9eeb2ed63da3aad975ce2d8f3078229271efde044da4707d5fd0795be24279aea7dd0e62be3dd49842eb74a20399d2a2d93ba8cde763c591d8313d61aef5043aebde6de647002936550c11b0be01a4066e450bfed9ebb366be5a5bd11bf915b3b205c1bfa453f42c3c547dc42cf68582a26862e6839e54e853d8ef594db6ab02a4bbd3975b99a603167ef100ecc95e0b9e951626e4567c20a22a8566ae812c5d09c7fce942e05b497d1a0390163c90e43c2b4bb0ff785c53a9122b805a32c4affbf609b052a8bf6ae8e0f9c64c9345b4c55f75b36e21fb502d5e9e13a14cdffce0d2e33c35673b0d2f1b07742fd431bfd0216bd6bb14170e483cedb4bf786b1fd84fd3c893eb7da999375de59b549d82200a98c1201250c6a62c492e395f96a4ce5175c58cf8c6444150fef0572abf1db010f661241a8fde280bb0b3967e2638ce55e5c95c04d79a3386a4190062ed53acf400db0db698487cf5f4602c1e9103745e93c22270e58ac21784d79297a68c9a48118b10475d130ff6e7bda0299e421ec7b00336271a51695fcdb02c04a3ef5ad90f85f346e6474466905322b828ff41df7004fbf0a133b475e3af3659b4ca77e16a863bc69b8b49c05daffc61f0cf47a406714a96f41124acf15ed8ea11a2c94d156c63c3a516516d1a4dd2ed99e5b64cc176607e7a19f71f8a16d1d2effa62e7aacbd719e101f2eb4babba282ce9638abe749fea30159e17be9a6e6507bd06d4948f2e9b830ce459db53ebc6cc209bde6cbf9977002d275746df6cc9ce9b37c8d194c990dbd1cda553664c76ecdcc78ab770b459089c84c92a7bc0c10e57453e12dce43b3357366247f327269acd4dd2052126c4c310829e8abd9993b7680cd433e071644100219a954a5c23342ef58ff9baa8b83950e3d97fdd5679ef41e995eb3b173969e18c305719611452de1bb3738d17db7a2080abf9a0b6312facbf02b5f0e68432b6c6ee3142dd21475d7160b148ca5b8f37ccb2ad3fcf9a21dd1305bf6e55004a84ea3db2dfed286f3579de482040b14cbdf611039c0c20cb1f82e14524ab975093cafc851b2d20af8833bb3bda6606669fd5e50c0a2e97e3e88867f61d11d457970267084ef1fd9e12466940d87cf1936a29b9ae040f29a24acb28e5f82f05f4bf9d960b142efb97ed054c974e9af359c18ae0638cfd6f2a850feea0660b77114effe029776ce19761464ae442ca1b7b5a57fdf4b29f994ae7ea72bc28c65f399ca493dda2d8bfdd2ffed5433cb882354dec1e40d97a0434b6bb2b3691ce7a294ff59d803817c8e930c6d2cee1d2d3f24947dc3ccc8299f96d8dc1a1c729b449b251d5f2762d09f70ce6480f41af04c7e13f57dbc8ff1e82c45355527db13a320c0e618bc46a08407f48ddb60c83a9b06762ed61f609cc622d33c9f5beac00161451901579ee3b6171f5fc898ceaf80acb85a722ebb32a25c09536ef43cabfc92689cbc42ae370c8a1a5612bcd623db39acdb98ca3095e026fc5983c0acb7cf6d9d352105a916b56920fee8d1b365b89b6f362ad3037698f6ed4a650eec275c443a721d4f149c7e485620fbeefa261081cbf25f0984ea245320953a6e97ad70d719d3952c560600916bc324d4bcb7b03390ad2851f283b2846feb566b19f6be3809e0115fdcd4511dc82594f6b4a1d5e289c2e4c2a3a6ecd8d65bbc792b013ba9647fe070cf95f902ee75d76b9f3ebc82ab2a782eb6d23619393c6a850acbe4a3e84dd387e7dfc32637fc2940c4aa11e59aa3f4af0d45f60b51ecf005aea78720696cf48dbc49dbbc258dfb073696abe5bcccf78818070af2f09c6cf60dd7c2dece2b2002e44bdeebedc629c35d180525c4bec882f292bf01a3c12a41429457dde12ab9872ccbd83633a50a2f6414429eebdfec00c980fde5083bbb5fe794e50101d1f709210f7c582ba4df15590e4dffc8a84b14561902683c3031a29f1e2794e92cb6aff8877d7d083f007040345a36a1f40c5cadc166e1432f0550fd74e062bb63255ca088d922f5e18bc556bdbbcfd3dccbfd082b22a573b0804d4485e0eaaa54f29c895eb1c30c7da5faad59107266db65f15d9b593ee8636f7753f41916666ef8ff1395fa42ad9eef9149fa4d4abaf8d5f95e3defc31d91357c07c1979bac5452751ec66b8003e8f5948b58776dea99e69394579b26e1132a8b8fa55b552404858ae9d47e1f8c67472e88458e2ef80622b764886403cd503ec1c72d03ddf249a9f59fa1df2642be09f9456451832fddeca4d7d38e0b4963c95eff27ac4b128f323444ce2439e8b2bea793c90b3b78e2ffc2d5d5a31e8f42cf2182bb654ec38463a8d85c324efd625d71a349a23d7ec9f0394627e268e2e5f572926a0ba796cf3e1249b5e1960347855ec21de27c920c51d89c5edc8eefe5918b4fc794e207a722dd88861caaf195da9c4cea7097ff4406815e752ac0cea73238e86e8e2e3d2990ead916845aa29f87785e88b11b8f42ea3c0bee7fe5469969a61890db4a3457e6debcead74e0e8c1a2d278f890a73aaf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"39bf190bdf695e71f4ceba32876bb79e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
