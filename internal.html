<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c479a2f3c5b7cd14a3f4a245557b21540d03294361e67816a36c6ba05020cb2cdf572f712b65cdddda037d6dde6e2b8f91c6a48a7ee743d184f73b6d7681cfe4781bb5df34f9179afce2a24fd6aef06a17ae05314a4fad868532754c510a71f9c8e1debc087fcc34b76c986ea2bfe054e91049e4cfb7cde218fc09a1252e73bc266503a399e176e75339eae26337f4e587b0658b8fe9bf9f06e8598c08e5f5d4e05f3ab3f1ce24c27dad0bd6981b07997a6982194dee2d3396d7df7acc9b718d5bbab531c2280ab59275f627a7771dabb59c112c959188892218ceb61626ce27c4ad679da4ee42376cb0ac87c3e9d85778b9bf50d20c42908f1129c45b5db779a79fd2a19af061471faaee5e1e99f387dc47729ef2828b303790f437cd4dfa8f30d5a626b7532814a64bf9180108026d8eb9ce5775d8e288e3f138feb1a16f13aa583eedd883d8c97e09df1f5ab150c28994ec945f8cda4c4430e84e678c8f55ddf92916c2298363595bbc7fce93be362b39fda30be0756bc9abfa49ae47bda8ec6b18101e2fa30e7f738611fe74acbd9dfbd1e0bac77cb2baf9e515f3c04058c4e816e3bca6ffb556485cbabea303e81857cfa59b08cbc65be8d646a9a92c481f4ee51f21188aacf7011f03291790df18eb868ef590b0a3375cf31a697fe5f7e2944e214785aa9f81c7b04b2fdc81f00e7dbf80b4f608058b41d2c73dab532bfbfa8653ddb6d4ce91e9996b878fd226e3b736c3098af730d93ec7fb7732b7ebdf1243bc560bcd6798fdefd3abcfeae6a5bb52ef3ee2d91a8cffa4c07cd2f39993c797f795573079777b7f63af77b7b586cc0aa2fe823634dffae0ab139a016635e31c22b0d84bab4c68f0b0343cf496413b956ff45fe2dfbecdb2c29353e2c58b14fa87d40c344ccb2e89eb58eddb9e4fd53c92c70058c17646c9d24281c6c3b6b77b3742903e355ea7e016c8948a38c0ca937b7c083193d77bad1382d06d778e2625731701b42e48fe494ea62d9534d56efcc7f1818c1f013f0e2df8adb368a25bc34c5e0c6457da83358911f257dbdb2d8fc48d42b65280a359fb822cd42bf9f05a81c2477f633b009cd28eac9b24d6167a60da23a598e7989f50b35e9980f0eb073bf4e2c02bf6a17441c5c65224217321870e374a168ef5ed9b3243303003082de7cf78c5c48dce41afdc8c7cdb774c33085a047a2c0a6d41cc79797b626b10ad2e136ff1bab732729d40698ef7857e6c2ce8c961925ec9327b66d004e3015854cbc8ab7e357544569528f388992d59f06ce3156ae23a15680325013a1417f698f2fd2033dbaf16dd24897920d9528e2ccd921ffdce990f72f6716d3cdd12650532ea4289f02e5b208e627adbd3c370ef428bd3198f660517cc2e0aabccb851f57e5bb4a1a287eda2558f309ba0dbdc37257cbe07a71ffc8e36850de2638ec570027accf8f861f18cd6bbc3067b9a7d928ad9ca4d00727af0277be675dbaf2aa73af31f633ce2227fbca764649804b8fb6bebe0b8db713b71315db556877c87ef4e78307015ba22a3c89da58ed5407347117cadb13fe5cda4bb511326d5fe196797d5bb7290941dfb92f4f527b4e5375e01d2a274c57b14dd41b56a99f2a47c71355861cbda0161f05ec9aa8ad44449d771d67dbcecf8936974eab1defb889fe0efd1f9015fc1a315cc951274009cd2c249fd39e9b6eb3d7efe79c426cb3ff58d47ef3e0e3fc82bf1556bbf36c84aeb1b2865864c7136369aed597fd83ab5aee4a9ab5a615a72b0ea9387df59c7efe75117c3543ff434637e3abcbce5d0b519621523e5b75bd2dc28dc296069148ca7664544bb7279ef4dc760d3e22dbb716532df4dc4da6ca73fa6dd928a4dfdb1379bf3feabdb45c3b84eb81e2409c5129e1437106ed61f1c77d7d0ea6d642a47954d6709739882b8ea2aca6276045b8a02be305c4697ff27c550d2578425c36205ee7a9ac03af089fe8fdb00c1a56147fba0e0cfbc5447cad1717a6888a368cd84ef82f662b3bb433ca1123a7d97fc6a938f560a708e75fe3251e37ec89e551f1239cd1e955c8b93ec7d3bc862dcc6dcd880d019ce2898e6bece19384c849bea8bcd992a49acff5041ef0a709d9d9fc8a3e220f1446c5f59e753c7450042302b6b905568192af7d90a2b90b565db1cca818b98e8fbce535f7ffca2a72253faa0cf3214c903cef34a200322b5389821227a73f5d014f827107d0fca5a3302e90c53030a43dfa3675bc5f84f6dc69fbc45b28d9806500ad6965e320a13c1ff6f36d1bf52ede244b7956d1c6c9341299311e7a3fafd64bd9c970e3cf1ce05cf339e3f781f1f04ff74470514285bec1fdecaa40a4a93789a7de705a75f285c380f5bc5f208e59d3bbdef68744aa7cfa8276e1c53c2681a93c11a6902a7712d53b52c595fd611fb7db3b74c3fc94ef55cd15804d10c227a4f09d600ed0fd1f15f1b4d6da65c43dfbea7c9534c9571d81b1330c14ec6667cff25bd8f176e296a2adac62e3a546ab1ecdeaeb78b5c9b25bd88a3e56a3a1000082d2b1c23b6db8cb9a83d04110af3582a635962f2fb0d138450cd6a6295fbdb7864e5892722e9ba2658db62622aa874df201a1d3f02f09341e86d6d09518d331bcd5c5703842febb63cca7b3f0d07fe1e3fc5d35e0383ee0635008669dcd003dfa0f045bc88b9396f79cd761e213507e61668f2bea336ae95e4764a0534fcb6a25293c68b70275706a46aa449c2967363c4ce6ba6b8b2c05c5a96470103e923c0090c3bfc37e84f8eb0d19fdb834e6da760ae6713a359c5bb194a61d4cbd8cc7a2a2f5c2da9fcdd04f6da8acaaac34c28660548c6921811915b7facc5152cb91271e4a269d6063f47bc42c307243ced252f527837121597b61a39ec59cdead3a77cadb9d861d9d7c98bc08365a67583586206327184d340dc9eb5ce96ba41ea600f7c318e0f86485f6be4ac83bf9df25773c2a3fa9ce8455a61e686ab05808a0e1033fd68a0d07a04e6e7b7e960f97494dd432a989771f61494ef454ccdc28b565db38103299c44821f0faf4ef1843f0b3d08c14651ff4b781a3fc4db12ceb20a61e3864d576a6f3cd4226d7a80321bf1cb672704a3995d81ce4871152cd3936d877ce097afb0b8823d3f6e2b1bfa2675ef197dbcc48874ac7baf6cde6463d388c841497c5adccb9e0d4ae69172dbc1614bf6984c5d3612c286f3976207a48a5ea1452b63f7e14de5a7b68983cf721f0425029721a7d532b43f815de048df09001af32b2db546b37b0c5b33994146c5e98aa93ca0403338d6adfce895b88d8c24b315dfe34a91fbadfc90f2af411f141032010fa84b9d9296234522d7feb7b89da5950faf740810d12dec4d1af41ccbb5080f206562ad58a4f19c13bb84841712849dc08983ee7629953cf489ce94bcee0bb41874a3e9413b9785eab5b837c92a9ef8f1e065ac00b059cc615f00a4e0119ef0169b0c4cd9a725bed07ff7f0ffc296aaba35404bd4190a98adc25c48c597f59a8605ad570057692d46de2909ae7eeda5bc873cdd0f6f828d783b293f59fe0e20b4b390edbc20e0326808ef5a945f12e87d8b5011e280b6b224ef823376ef8bfc2901cc33b898d77219e27e94102710d5da92bf2672b9970d9a6e9ce3110c0e875016331f953e3fa0e7bc4ec45b30a9d45f99006db3d9e1b85b491d5a6027bd817b8c201bbd2d809c44c81b351b7dbc99bd36c4b9bea41674fc91567d7ebdfbcc4614d992f76cda746d90708bb4a2a7fed4a392aaa346d5177d68bb754de2d1dbcce0c855f67ef63861793d6deb823c9e97ee0de2a51f33bf0d535bc8aeedeac9c2aca11ed13ef877ca13ea60917b6905b4b2ef52708de29c21a82d3f743cd94ed0373fe73fdfcb95e0756491eedb84172a62b9f886da03c4e802b05673162724cc0e2374f63c6839986edd3ee7f4041c95afe9e8f5e65b338210af972effeccf13401bbcf1fa133798c587d61d5b0cce19f138d4eb427acb8dd107525e7eea8c33ca5a9db6f3aca59e895d8aa589bf7e3f71554f4aaad3d60211ce0b0915190886eba65d4dcadea745938986997e49eed3b01f03578f8afe1f1d37472c51943e834124c6a46b9e6f8a7f904b85ff6d9603a390844081f9468502eacf8932f9f7abad715c04a522dc74638f68b4571bb43a2ce0e18659ef985fbf78c0ef437aaa2bc94eeaa3039df3320cd4ace8f7e6c8fad4099de79a06a25de5252474860c454f44ccd2bd1c252c3b367b99534858141cbb29d347e50ac20090a126b691fb6195d3ad0d48d1d2e2f8f85bfe7c45576a286d9145526125d6ba21a459ae601c68a8b9706a1d087ba7ed4b7e02a322ce35aea6b4ff2302a5e495b0a2a16cfcd1dfb3c6e4ae45b667a3a015bc09d2228f7769dadbd245ded26c834639db87ad542c91e40d0b70e31a49162b2df9d8c25a80076a976aa511f0ea65fc88717be6e9240ce497e03add770fa8b24f42c20367941d1b374986646cc0da8c97f90e0dec550f0192d84add543ae1b47c65a8b688a92b0eb845d6e18ca503df51fd69df21266bda8e0a99e60a3957e057be766d122f696a19f0f182032f5b4e039e56dcb82499273140da67ada3a968619919ca6e0834778ce5b81483e148e078040443d9d65eb6b1657423019ae7552e45b95a277fe47a4cf2ab201e3d4f408d039c56d8f473a27f83608337da94874931182b929412c51712e41de09cd010bfd3eda997311113f1b06f8fe74fdc16909b20ef55e8d66acce255dc9ba6bb9d44bb538722bc7c2c1d60a8c7bbee8a3c9d9d40b8123e6c36f8e2340d74b709f3a7ebc0dad37c48609f2d64f19aa91eceb79263ba4de5ff24bdda6779066aba6a7877b2f3622edce6b69344618c9815fab6a1fcab3538f31579c59a99fa1e23280335836365b6696a91da45d983db354d01e9ba3c10b7dd58110c2ae84f346e275444fb5b13c2adb343702483e45dcf4d94084cbc8d98e97fe9a16e7a5104a901f5635800c46f6d488d1b480417524d6999cb3fc03e51426eb56df63746c951f616d2ebf89c20da6f89559c41cc80aa7b82082f4d3e9259d75dbdd38b4a4b1836b440180789f7ccb247e942f64b20a70e626d515467487d7870dd28877d1ee80d2cd6b8d165de2296008aac78e8000b207187d13aefe6f26d80a754a366bb9b05af9a049e7a765b313b82ec9f568a98cd9490fa136a1464dc8ff895490afb1033aebc0b5f9edbef5c1da8a24c0f29f034a054023a0ba30316d38cdde03a4f3ee90ee0ded2636f018d4f8a4ccc573f570539cb1222e3e064016c265ab6bb9cc4d182b90566b54b481b9cc5bf2162eae997acaf3f547fd77f521bb2fee9f7339916e3311c78dbf2de7a7a7f18c14cf705e13ef35e0a57f01055adee186f5b8418de15d7cf99550766f6640df6f86429f29992d98067e41eec734eee55b55819172820499cd8b97d451029a4b18190a36731fe68a1306118a80529ba93ce372f6bf33425233ee1940e33f206018f072119be3760cae2103174b46131e96a60fac828da52cf97c5873125d01fbc54cb2546d7acd6439565fa2d2a0f6947455b3101a9fdf83a4ebdfb6d3390f876b50e11e582628b600cc3aa78dad1c58c598422fe980f5cca69197d08e426e7cbed5a84ddb803044cf3e398eb1f0e82e3cd77ccf0f4fc481f040ee24ba5f55b971a7c8dc7f71dcedf74847b187c3befb9cdfd0bb3a9d3f76f78f4f0f078028ea5f764865885fdd134385efda4866876aef618142f30e2e764ef7f43e1ced23a123c9d2f80efb083d8222023a2a217374d0ccde74a79487ea231891ba3128d2885534c3b6316e6080ab443d6aaf47b4e13a7f41cbb16fa9d0b1374c5af3664051719fd05283281096169a224a61f28db9c143e5b72a8a20d97ae188c4927cafb185c9e7511c7aa9f0c4e4da9ec24f91f933db7f4dcbad99099882464fb4bfce99440d117675fd2d5c9f4719d5aa574a4d72fc9170e69c224adfeea90dd697bab69b4bf15185bdfcc9eb7dc1d9e1a8ddd0934c12d609e83824ba700c991ca063d75d1110b3d55661ef275f72850e9dd10c1b210f9c405b6445a18d82af607dd8a25af236ab2440bf818b14c9eb5ef3c65e8fb7c32e4386a046b032cc86def27a7a46a39335724159870d0887f35146c427cf9fee7569e1e6b7bc8a86d4df32680711b4c3226ab940b0c225ad72c46b1eed0c46b6e6c3dbacbc83bb84f6e24633ad80d7c20bb2f6a242ce3ffb8acf669977e7ce950ac175fcf2e9e609e643a1d21b40b659240d8e789278e8c2d8a4faeda382fe597f89ab8ea023e04e837b300f3a9dbe5a40eb3e0a2d2367756603d58527a6f903aef35bc184c762698af24c44ec06cfa186a0691f7ee32e1587c274df1501f3b0894ebd67f818f5b1c7bc0936b4f465e2d0ed5b83321e5ebd15d869222c9bb716f5651e62600f6f25076db7af8cec6514a692977c2e6f6df3dabbead4d165c1db70f3f615e5811ae964854c2d6c231e601c1bf025e68c7f5d87d82d0d5ec75b2f16db6b59dfe0f68f0ea4f445e6ae9e828b50ee22d7db23d5f9260a5e182aa4ed9664effc8383fbdf90df99b80efd4764bf3b2022d722219582d5be660f4fd6f48d40db2c2f785d158a4894e6016c0b29ab4b9a6ed749208914d6aaf2195eafa007d61afb3cd69767190cd88e6615a573b89c636acf10b81157b5cf0856886ce279bb7bc0c1ec2bcecc0b926ca79f2aaa36934a6f42d08e06a1b7a780edb6d435a0f904f8feaf81e81322541c2a2602466ba14814b826b5f3b36e0cbc796c77b69c34a2c318e9a2f5f43a737f76111fdb983d6038db235ced03365a66e1afcd2fe59ded2b6016ff765f6de6cda5eba3ab4337e2d998fbe6aff6f9f178e50ceb4d4a00b6d7fb895050be9bd424f7d0ef0017f9bd6fc7c1aa7a84ddd14a3a24fde30724de7535e21d29dd072afc81b73c43fe0d34c02a51320059af3e61e49a61ef65643c753c6587992228d7d7944ebc09537e0c8d22955ad36b4f235d959cd4b34ee3fb6f4f326ff808e9774cd2eec9467e06fd3e7a90928ee1b0bdae3d3b208c81dc41a78b28dcd89d99c8a42b0086533208111d4f9d9a7f94f71fcf9dddb33e8bd19bea1d0723b1be5abe62426cf5c7a04a7ee7bd78a2e4027c0dcace18c3d0a463bf059e2f5f7bba914cfb9886615d9c3c847465fb904a8e239f4ff791cbab81ffce8de771a0aedca507972220fba9ac97501ab31438930691caf146de277045d205ec048a92aa749bafec312b7a4f086f1662f791c3cc622884aa643acf20a331676a1bef6c7f1e32df024f076724087ed157089e177c55ab1625f7738797fb064993ca36e06a7f9c8fef94b8d22866eb9ebeb437521916eee85277fb92f752da53932555d398f31562ba9637dacb8d693c4530e4fb8de2e92e9b0c7444b197fa0dc34be6046cd2e4cfa8a6851b6be20a7c1bae9965555de41b84f39e8932675111e9409e991d9e24ddd1cae16f57aa8d584a3cd318284f67a7828f9b8ac23e29d65dff241d941d88c790d211348533c7ac2a7998e4f47d60f7fee8de907bac1f2b48cd9ac7db4f7bd9bc37f6c51b376f3ac8e3c8ff34f0328173f41a7731815041ef159c9c9c7a221e11635b8bc9ff3382f96657863ed0e531f76e1e249885967d23926e55c0c9efb66f882042ba74175f965cfaaa82ca26c03110aa2c51c6fac095e8a787083b527c067f83701cfbc6a0b1e1366e3a73cb048b83817b57046c6533ce92a740b094605d673f8fbc759ed91189b53eecf518cc471581c5548b0cff6c7efe22d5d5e4ea50a2dc151b1df673002fc22bb8971fdf005ad40b340d2c761e6cfc2b6ea1f95d3b8e22cae9dace6c8c2a6a731aa1e0acf519371b34b35aca1cc1fe9fd8482b02792ed45bef8709ddc4b6f10fba583ced74909f11e1ee75bea778ed278c7080aae723e4a27ec3289832a7d1465789f7b559923a9fd227e5afdafff70feacc6014a58379c4b5edc5ee6afc15f4f80a2feee5c665d70992ef0bec51700fd0715b7785c7cb38aae9106cd552455f69204d092285c11fde613a881797e6f44b4d4f56c71cc6509ebdbddd79fc71de9509cfef052a42249f171336be560fd7f5f630c4ee85131ac8ddd383a8c8e7728889bebcf2a193e913a498fd7ad73f6be070a34cbb8194837933502f92fd53569b9001f858ec624a51425ece1a8cea4bcdca7ab9de81b7e5072b64a821629960304c8ea6c741d5e969cafa039305277780e4e2003e276ed8e720304a17e6765452f218772a39708c176aac333f43ef4239b43ef4deb3abbc9ea12a361fed6a1c7758f34a98517951d8e4a4cab9ca6f44f890b6baf58605dd4f5e3100fd591a75c56bf3ab8691856a6c58317a49a81d18ce1e1a04435f637f28c9ce335f2d9803080643050d8f24d267c4ce7d77b7ddaec37580d1ca2452d0534efb6aa3ec18d1de96fd8df0bacc2247048970173edf5db95f68128f4469501fc36f844da0d0ceb7744095ca065b7c40002f4308de32f66f44013e3984d2ff6ac5b4d9d18ba2b61e3e8adcc1ffcf97c2e9eb283eb3aa5d039576f51bc6fb18e5616d945d1c20a7e665c65cdb787365eac0942f9aac01c613a1c6e34c8241e470e3b278efc1db063aff9f3a86176c576eeb5ee9d2879e80bd3cdc952fdc3b859a1d3d40ce380784504c63eb78d8b9398c71e66a4c2e4745ec2750cd469d990a4a8f6a4d725ec220d6374634bc7d77f723b98d39c4cdcfdcfbc05f31671c23c152189e17125a11fce1378f34c5f544d77ef88cc0de827b61cd0a8ed23010d4720c14a8b47b5c20cd36b6e05b791b51f79a032e10184c15d23641ed821ca603f966cb581db67c019fc2c2e71ba3fe3463ba5204409209ad29231e849d53c8011ae70e8160282f4be6a9ecb7ed4084457b4017f6e4b404b243fa17b4db0e9691b77b9275da91015c525dcd5313ff45b5ef9fafb0ef282f27fcc0e9c64c7a236cc5fd7832bf460054c1f0a337bcd3b5d9ebc4ca269e694f9984656f5371e2c200d97b1add3c43ddaca186f1f2f4b259e68ec025a9d148d79b4d380a7d786df145790fb371687b29ebd4439d8b71eb1c2419fc8c2aaca85e0d6cf370842ef2c0b33b3b32b1d5eb6011abd065e436c68fa3f2d1d64d3cf4c6ae6e25bc21e1699b9ad157eda7faa28d46d87d5b96e4c6c66424e02124b052e138fb14795f3b45e0057f1b427298ba0fb31884938e0cc5804ac48dfd25009bd03ad1b6b442450f2aeaa4f5653a6902a994360d5691c23fa83402fa5ab9d95af09edd5ada6bbf3e819c1c1c925ed705e20c3dbbdc575cb6e1a4bd491fce56aeaebb7196408254bc6590037ff06f48b60e2fcd496be8927726104232e038b47f46c11f3fbd10f674985cd0f7df1c4966d89afc3e23905f655d89469195fd054fc21ddf9117f0a656b04e41900c256ddae52eded4581b9dc5b6e7a40183339feb88ff88f3c3173c1da3fa187a93f7da7b971cfb04ff38bde6495744ee45e67fe5a3c846018c7ae0474f14ce4f07eb585c11d2658792102a9ff2858630a35733973c27dc1289bc1bd912ae40bc3e4f86d48804cca74203407f07ccd3aa75cfdf13261711ceef72cddc2be27bd94fbfe644faaf5bef29b66ab8bf5add1b21f360c45d26cae0748415af557bd76360806e79f9e89b8c432b984e620c5cd2924212cae345aa698e6b03d7aff83eebad48c2caf9c542a2b0e73e233fcd12d8b4226fd474d7853e71df7de88d6ca18e41a7ee5dd8b7fb655af4de496592d3ce4a41340c1fb9a7029211e6ce1eda46864a4387838068c3c879a0c49a12ede38113bc4a462ed3acb408aaba6a4a6c956835250b5602f14531dc7aac5836e1b94521820d521984d6dbf706848552ffc78eb92b0fc0801b4b596f052da40e11a19261d86e74b6beeeab0736fd8c2dadb33a561af38f3252c226924566ded05326afc1362662c8bc6f2766ffc1e342308fbb214523b1ef257162649805337acbd3b55d1c546965537f2290493ab7044c054d49499dbe3bfe5a212fb8c29a49a919cbcb7179e1f058effeb3474942feda5c9f8d16180610987fc0c16c2b488856d8214a1efb291eb2bf878867a3ba1ce447836db386e4b2010458f720f30dfaef51798250c459d5ef625455032ba9c51c44ed824d5b6d3cdf936005512d5282c9fcb75505e7e24e98985a44bcd1e02f4a43c1f0a9b9cb258ee275e65fb5e9e25c53e60e182780117ecad12fc83d32df61f42e3e7843b8c3ca63ac3c4082def675647a33b01217fa0159597986ddcc90760c9345fed522b7eff128b2f6785089b9bed894cd341a8d6ebff8a21a68443faaa8c8d898bf1876a8bd5f31cb1422183b713adf6c9bd975f40605afca2d17c6d8112f4d60ce131834700b5a1848695035144647f5865957ad242d2f4d976961a57f82138a45ea2be63317cf0a152a58f30dcf95e290634630ec666c9074089ffa913dd2d5233b70758a5f9c8b5db75459f79b184040d73a533ed3b77e0cee200237e68ade0ee8a79cab1ec8c0259f785d84516a4b5e58f8d16efde8902a21a4e0f74b2a00f951e8ee743942578b045eaadd2bb54cd81f8cba5119a7784371e21fb496e924dc89567f782e74cac27f3fee1903ddc29de6e2c13c656bd10c465c46433474715d1c91e6df3a397b89dbc27c2e84203046534a561f559ec207949f866d2ca36c61e9cb0eaa7affd4856f812d495da01536fd58d80034b9b18d097eb81339c03ec894a5f3620860ee9a995fab48b7f5ca3f82ce917f74b7ba551247a84372b30b6c05c193fbacc61610f9f0a6dbb0488cd1656fb22eaef305cc715081f6b209647147be8a13341e2d9f40694b64564846922b754a037b88717bd94afe093f6ac8841b1ff95a88bf99e385986ea33c52db54b9fff29d7e79229a54cb3b1d5792d0cfd8d9ea11b63a5d7f0a3dc9ec14ae48e0200c8fa81b4a5e534151ca294d8d6286323ade2a8905ae5ab71a1af574808bc7f17db85dcc47e021f43298ddfbd8513b3a970128313fb2b7c73b4682128d446990f4c045f11cf98d4e3effd4a586826cfa3197887a7c115bade4fec821f8c9e3dbcc73275eecd14986f0fb84bd485162945a2862ebb6b97887d4a03724a0b36c59e2a40eeb6626a08c2c098e1add0dfaac830a05059c2f49f85cc2f75a1a680ecd671b61478a2b8f307d1cfcdff7dcaa5a3918d8e1e2b72d5685ff1c39f7c137027112d3fc7a71f63a0e1bd2a828c3e47591ee5728b3ac822793c68ea584ffcd6e2cd7b5503cf00b9c529eaed5422188baa258ebda4d4eff351b888cc675f2f43ad9e42fa0264dd18b2d5c1b61dfcb834a07fe6aeca4337ed06e38a16418db59158736e9b646a7fc4c94ff48cdb7b3d0e8e256e7b96771ef1277a28c52d77cbd2ee7268230133bae6c6b1ef2d7f621f732a7d5bf4d7b65a831e150fd141fe05158a5b45a2b6c633e77f33b6c3e3f227601870c064b1c7441ccdf51190c42101c299a19fec2b57c0b027b3326fd8d84c0f3dc3afa6f9d8f50d25bd816887fcc0994e0cb32c775d321ba00b9e91a426ab50e70422fc9645edfbb7d5a94ac4b16a5ae81eab5678fe9054d899d68c6de8a359250a4cf31b5ee904202b7b96a95cee0d37a3f7755a2d35bda58fb44d58d6c2d4dc8d6eff05db0953bffa5bff6332edba240647967f44f7d5f7e9372aafb021a83fce3b4abea1dd196d7758267830628382386c2cc3c14e6dc6034d5b22673c9c0e9f36fd8a934e6a89febe4d4682050a20362b04ca9bd624a4ef0cacdbec3554227b477c28b7da367711d2fc9c9b91bd31837f561e67f0126ba86e047ee7a87114e606e050dd25f28e5cd982801d91b6a0997049e263e50cef82dae332496cbdefe73ba0da7ef2de67104f45e17a2e90c08db294abca933e3c2bab5017d668c83800c00ef8f93c1e67a7e959528ae531a14e21329dfbda836bd86f4cbde8286e61267e97bac1e55cd877bcb78df7feed5e8eca4e77ca81a4a43ab22bc571851d441fbdf0e82ea14db57207032024ed03786ec80b44784ce5b1e26d52e2db7b1cc4f6fe441efcf345a54cc996bd1efb53194c454b181916b76f411cf6747852a9335afc4caa09684f9bafb42e52f625714a4d50f6700297e9ee89ba7a580a47426dafd29adaef0459ac57bdbb20f615c89f240226cfca5e76b07dbc20118949f3f5278583df9c2d4b24b8e0787be3cea4d98a14c274bc1b53568cad2466d6878c01f03dd75f290a1b09a151ac9df0f15ad041f35c80ebb72e390e5fcfd55fbbd63fe7a6014d7845d4784b77106d94d57afc03ab47dc9e30432c9471592694cc1f0c2ec9dcefa7ea322d40b1454c466249ef75f8da9ec87259b7cc8490932ac739ac1c63e3ddac45936004cb15242eea432925c605912d707896893927da811ab1e4400b61e41cb8a3a10f9a8df42058bba53e97a6359824d419e94c84483a2e8ca3028e6e9d93b3ccc2cfb2d6e48a57e2cd751b90c38d677cad8c79a472c5cada861f37d48b6131029148cd1689e773e12106aa751fdece4c12900a18c7d54d106b55347dc3118403401b0a8c35257c51897086a10dc3cecd7ad8114e2826e895d209a8e1117643832a8a14967f65b77438053d6adcc8e021411cfaa548ca1d9eb9dd496153304bd4dc9c3cceddcb55d001057efe1686f643a48ced2dcc3d6c3eb806002fe8495557829cc1025559a7432da8309561a9a5a3cc6a8be81f5e2b5fc23565c57a851ed090860c99303a08e9bf800014aa9c5d00b4900e26487d59af4fd90934994eebd1ed6d320b057bb87d2f5beaac7bc6ce62635106f7950284e4792cd453585dea0b04294bef5d8e309226700aa7ae71ac384a3c0653c8cd95a7d66bf349b442617d28530c4c2fe590c73ed672bb4460a9acd23476cfd215d560a26730d68d3c757fdad0f2e15445962e371bec97405ab2c500801e6c0803db92a188415f6c855e8f985875e4b602e8338e37968037f94e25213a37f8e8dc86f679fe01866463198a7e2a7ae1f08a0d87372c769698f38b659cb82ca2e1c54ac31bbd7b6f044eda086fd4ea802719a1231098c463bcec99115310eb22955aabd204a334bf450b599c234be35ce6ace066ca960d86576ac6482ebb64f99cd902e091c20863135d4df2362a708dba93634a046c07adf21abe88000a21fffea1aff0cf367621ecd5602e3d49e5660ea9823561744e7ba28bcfe48e1545584daf215085e11aa4de5bd5e9eab1d58cffe887817c4a3bfb96175e4ca22753f6ac0dacaea5daa4ef908386e4d2a7b67c66af446654999e7a34807cb52eb5e378fb916a8f7ea20558c764e87fe571026032f6f621c43ee15164ad8c433dae6b6f81a0f62b8fc86c4f5b2a138b9e7b09e541e51412f4c4c94c20540d7c3ca01d83a06df4b4f885b39ec702b54aee32a47759103fb27a25ed8a5b74b2363b59a520cc50bde897d3e6e5652357dd1554020c7b09df43adcb9ef8718eaf83c2a01f8bab40801f30845c669db7cc976156e6089a5e99b7237c6655d6226af318eccf117d2da252d349d29e81525caa83b0563327bb83aaddbb0d27bd615bff127c6d1cae60c418179379ef3ad1e1668eeb03ac5cb537f26ad1cfdfb5ef267781c3cfcf7e83e4cc8369bbb5f1723ea0b287eddbbe6baa676be32f8231d9d8103d59f1a00dfa9c66f6cefafa2c36fd179c631fa4ccd03287b4de11a62762b0e73df5d1aa62369176f9676428d9b5ccfc0dee567f9afefc93ce89337a8cbeafc112eda0fd5ba9ec6917a8f470b55558d09fd3637ba0ef19a8f7739c9aece4434ae3a6c3a107dd742ee5755922191ee5c27b477c6f82dcd36bcabf5d38e4a7b96b46e7622f0529e070200f9cde676396ffc0f4fda13833b026b29e65c237a2ae576c4290a52cadf18462aa4f41e95a2b6517986dc0e46f20bcbb964aef97ea8099541d6f23e81cffd3da63ad720413b91c313df14bc7338a629c991fce28dfe4a98ff724d0655e857750cf26424aa1e137596fb4d0b16a6fbba7053da5bcd1cab6909c051f0f0866a56571c2a72111deb20192fcb3a563736d61b7078dd8628ea92d614a3bc823d8e26ecab1b12528d220efea4ac0a1ab4f6f0a8ef22fab6d9e3e3506bc01db09f8a0cfc0e91a404e52fa3b75feb1a0a7dca831830f2572f4bc47dcb93e9e7f723f7bad18fed28fc86fd264f07e3758ed3065016cb16053f92e46fa217f550a822221befc6acb5ce2b9bc1c974b5cd8c9fe4b1584ef92ca616cb90efcd23eebb89b68be994f1f9dfb6f5b4672a23de356cd2a41d8af5a9ac0ad07df387ceed23754cacb9bed1ae9b1e83ca94aca19d8ff19197820de48621d1793268d54a9f05395e75933650850a57750d8abf37aa6fe1902479aaaa5b6968950c2f506efc894510f2eef96d218af5ee147363d76956667d2a83fcc163ecb74a19639291274c2dc1e79b2f629389ffdd32826e312b553d8aee491b9608b77e09c4c4a0450f152a50d86d1fac131041dfa397111fc711338ca1c12952bbe7f3d3aeb948fd2696df5cec8995fe6a24783f5d5aa09ef424cfab98b033b751ec128479f7376bf0b51a1f12dc50cf230d5fcf049acd39df2e0b24f64db6f1549e86c7588a882b45caa9bcd3e4f716b316d2556508425d83a8fd9691d3d3c5edf314c3369d36b5a76a94ec2e7de5b46732a3a3cf46773a86e8e6f6616060b48060bb3b02c673b1bb19ddccc38a752dd01867a15f8b753d3b4231e475d5e196b97167ba8152a842a117d5c3c2cc5a37448ffe89c13032b989be1e332cd5666d7e8a9347f066a24a73178173eb4b3a2590bdee537d77377d035b1ca94cfeb530ffe4e28e4449dfa27b39c9e380feb701fb505687b59639dcb2ca87dce8612328e1d9a0ffb4ff0676aed6e8f1a80355498d129ba4219ecf62f7be1ad87cc5ea1e83e696455f2bc383fd46aba9f6478d4322907d8e2a26522ed83e3e2bbdd744fceded26227ecb067987ff705fc335b9304dd3ec575daae4f67ea456e0ff9e0ba452b2418d97818378e376a8b84daa142565d35744626ed0f912d2df16cfac067bd8117fff414d1539ef07f9d8522bdcbdfcb5e950ae4f4d628283d7fd5fb1a60c5f6bc71da9440991eedd150e61c76a484fdbbee6d7a48c2694122e027de8577c06b02dc8e50abbb26f66ed789e2fc55bf5834fa446bc33ee8d0e4e2cfc6983b32a658f222dfad89b0ffaf9dfaf942976e51105635d48a9daeeabf55800e74b412febd5f720883b0936f0cf36350414015134134e46288ab7a68d50cf3cd063321471a91bf3eea147a3af95a33f9092643870a69cbd8fb711ec951eb317f812a49c714802b0a35174099cc8cf4c5cfcf4d8392f818aca42730703022cc718e5a122d807bcdab233712beb1d2921063aee2ad9c49419db381af26cdf850f26b219e378bc9b1be8269624a203521ff1cce404d7a7f4863ab9a8e7e35ca17f4bab613e5bcfa748315fdf52b34744f1d8a3cba75e920c5594543b0fc164d85e24ca41f41ac9295962bb39c87f46d4d13e9cf0793a0a45ef8402fb542c99c032e4d6d5362affbfa7f4ff6ca608b74bf6685b8afd471bf42d21335b83c2a5dbcf01a7094e15c003bcbdc03e1af91e7e4bc6fe9bf38cf7175854f1eef840d3393bee952781d9339f6dfa8d92a908a390deeace1ddabbd83aae9be42050ec829665ab26852303f05f7d00e780737a7caf077702ad5dbff95867c669c3ef0fd97a89a7ce8766fa5c9b7097c71faa2ead13503bbdacca723f8db3631f2c6f1878f66528a3bf1a2e14a2979851b81e53d227f3873fec3ac5d5cf5eee0b9af001b03d9bb25353d4f31c6fbfa4ba5e3eba215a748596573a06f167e1d6fd02ad9c2782ecd4126c406df0e12038e18c28c5576ab2ca16cbda890271a015a2b48a52a8036414ea653f9aa39d1c59ae21aa89b1bd3957606d3b78e47fc908258fe896de5448e0cad0aa67f3588e4c1c77a8f2601dae927f3f21cc1433ddc910473b7b758d2ec5a77ee44e7e39f82e40f0619bc6da7a4c1b6685e89ecb3abad44798050555dad108380287e6d0463916fdc7a78153920efbab9598022943fb5ea3459ff46be75266fedffd1b744fd79fc8291789141ec9bdc501839046785ed5bc37095327134c781f720086e301ce04a50f663ac0350cc57343d46efb3816cb2262940a0d3d288437af6af497076c968efe64d34277b07e5d58fe616275e29638d0fb43c961848fc6cb971e98e72c899ed6a59b6bd3322c17f02e1c362f56ff192955a62f5840c108358ff361f4df229a0c0de5abe5aa02734257fa34f9326ce584d3cb7a67fd3ce2bf3f60611e6493502304c13318ddb7aa948692f459240e1f4485add108a4c2ce4c24d9bcfffdb7d10108b05c7ef6bdf520731f0c1012d5b658446d0ec125455fa633716956419d6945e9d17f0873f7a0f55b9eae20a4c456e651b17bedc05a708b630d64e43b839787b04047cbc26ed21d0d828138d079b3d2099aa02fbbd2887a132e81163168a633c5acf520273fb1361b68fd027c2d269e4e65b5d19345e9e80c96dfb958520481b8c59738b1386149e03bd15656265af32509d440af441272c0c90a90f8513307c55d1dfbf423af8dfa093cc3dc33f81a2d5b08a4feddab1d8ad1978f4e0250f2f61c1a45950e770f93e04e40708a7fe66c5520808db12df47f4cfe615d1c75062f6d36752a67c0b592b5b16b5a59b2d380277e07af463c3b2254e39c060a6a1c66ea2ddb5ff73a27d0b08902fa375a30fcaa625046ada874984dc608f8d0cd5a1b98932c3354b968e647cf4a778ca17ff2ad24da511448fd233062af9b6b24747a0e395edcf8ff81f8b5a8fbe46794f746285371417149437f08fb82d80a4a0ace6050bf6562ed1d7e1d795eedfee06aad6b525329c7b789259971f93489e58e6b561b40caf22c42f2f96fdae3355cead87657d28c2d2ce6171b740960fa510d3d4c945c4dd078ca2a8a15855070241198f3b019a4f320cab3afc8ad5a8593991da3e83ad752a0591b4a533144332a8fd216c46a2680c76669f16645d0e8af597de03a903fd8121ea541dff0def93d2507888baadd47d4d9f14c55a224b9b81db7444fc8069e12950b755272215624405dcef3b625565635187896dadb0acd5618e00aa8f63bd3e6b539d02c722e09e0f3ab08d2f12ef94f5dbf5a11336b1e1fa0a8895fe965d14b9b102632982234443f1ab195f48aa967c6825f9313aeec640acc477725c2cfe4768935938928dc55122a76a5c1fa15343d7205b0c0db44e6dcf3451f6d5bf2beb8e505b075dceffeb09e267cd994ac4e7a6a1a5707c64ef2474f7699d42756b1bb3f1f9f81a1362dbc2f34749c8d1d65ea31e892d29db6af3c5a54fe98b770b5d194abd263064100006404f2425cb62acbba0b801b2ac6cea2a40757eeec6e0356decdd441e6d9c245619f549185d31bd160a5487cc67176a2f5f401494788094bedc82acf67f5778c9cdc4925fabe7254fbb8e52fb1a25580a06f33ec936e6f08da1e902916f240a73c30e7720ffd7423f1a70eb204f14ad277680f1c7cda86290ac391728e2227f2910c1538989dba698434cf8011b802d18a1a52f5c7804f3ee35b9bd4f89a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"25d52caa4891debfb97c43336af1c3cf"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
