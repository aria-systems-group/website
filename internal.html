<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0fc7895870c7fc65c335015a30f3e4a0cbe57bc1bdbe39f19d05c717d18234325709f666e400d9ab249dc69fd3837692fb23fc49513180f9280bf62c565afe50ed8636901828de67c326d3586aaa98e90c8c47845a74b21b926dc6acf1703a943a434e9c2a37d13aac6eaaf64a1854abd00d85f0007d533424abcf21123f71c822227a9ed4ad1f8de730db5c3e21173d15ac363a45cab8cc81b76fa66506976ef4b91f4c1f9a3fd1a7f44d2f03b69153f5904999145065bd22ec43b177e37da11f2c9c387e972d2de2c7cd5e09d056924610d98b4d2dad0bb46a528480d8d9e251d5fda455cdad62a41ba0d731657bc34d94a5cbe3f25c55240b3ae5d17122698f8bf2c021b34a3c9cecbddc2787bfea3b783321e747e86ff70f872e0e8fd6b293d75c97a2dfb4675086cfab2608ac1d30766f3551fb992507e37c1a29b2debbefd2e0a2b2dff11c1333dacd07a2540fd9ed97d96fc13db65508c5921a8a875f9fc7e3e7c8089515e1272d06468e9de52c6bed7a7f0a665d371981277e8e498b279717af22f5145028e8d79fef5dd8e3d52247c40c525699a7f7de8176de1e706b2a86d7f2f06f57c4156469958d64e5f4dc72551862adceaedf31f0a702946ec83a4927d474a8ca352b997ca40da73769d2cebf42c62ad5b256fa7df438a755f84977f46c93aea4693982fc66076d5c383021d5f86d1f50fe6a615996f754e3f1effd6a310f78cf031335f88d99bd98337d95ac31bca71f5794e5681fd428a8d039679baefb2770a3dff0c12bbf4cfd2e71d65f10d5d2ef812fea26928961393d7f1d9c9062b9b9aa566d3ebfcc952f34a0f9369bd563facf26948cd6b5cddb0e9e3aed454a9fa794b78c6d68f3a8f2531eb456b90084106913cb5d5b446118543170c61375a39c3cfcd948568bdd49c8b1b5396d5b6550faa8206cb50a098b91a9a5946a3a256121c793ad0bb51d1237b69d6984e0b85ccbd81913b2e6bf738783bacea3ce6040b817c3149bfc7d0f79707bcda9f55b5b616517512cc7663c62c0186e6ec9db58c1de002742b5d14b142ee51c14158eb0f2cb021ff3c2cacde46d6592f18c077211cf9e928d1630bb8376b7381165cb7cdb9ea1d6cceec8f0bcab20bbc63282eaa48ca8aee2b0f7c1066a0229270b9933fac55ac45f69d35a2ba3228e1c941121bd48f11688c57f72d6e1b1609636e795cb10ff7fc55469d2e285852207e7726da5e301a4b8ece72274066001bed83eba7bbf16936a1648b1f8eed8cd14fb36cf7d98ae62ba367dd992de651ad665e1f3634fdd238f3df98413aaf1cc7c4fee743d89dfaf860580e07679c3c341155bb911b9d75a4ea1e9f0414b2e6ab04ffd4c27b6b109833edbe3b90106fadb1b9465aa3d3c76241fcd51e2f2191911c8a6b08126ceb9b8b04a8922e9f95efc2a99ad8ed89e85e7b7384f56aec6021f27e4d4005ae16c60c828bd18bf791c0020f87578db89cb2b1dfd589595f8a325507e2bece029c835e51e4e99cc3c7d7c79dc6613f59ed09ef93c4ad71cecb4762bb14a82fb281cc2b086560bd6aa919edb8e64a76f4d5b4a58b36b68ee4dee11beda8bd6fd9fc29668d8d24c986d1884f23b78e85bdabe8af5bba33bc6d40cc169267b82f51e1af770832f6c415d190e144c8f04dc114dee74378c4de70340c896b770f8028a703e3dfd9f511430830856676f35f4de4b501a13077b44d4758074472226805cec120caa4fad1eebf5e84828661c5ef06895a791c915c09b62412e07cbb3369e96d192f473508b5cfe28bf118c6671e019eeb6f483933cedf03da54aa30777a0df225bbbdfd07fd1828752a286bb3ea49cb022a256c7f092ae88cea257b9c5ffb28936a0c5ecb4819e43251ceede233e59a4534319760f81921cf8932ef6e81c18e58f852a3742b6380f6e880197c013c294a7fe69c2f47e6133b56dd9e5bf5ccb295e8254c5960080a9eec66a81e0c2a1d6d2910edced68d1610e9574a6c7fbf16a1c93e56611415230d1eb2bf95a2f8e0f236f31c8d3976efb70641a3d2ab12b3e4ebfd348365daa58ca8c2f1e02019563865c83dd5b0ad9165d283a12d730efa6fe7543817e2d72dbc575765085f6dd5fd0cadffd8069e6854596517c67c5624ec69aa7f65e27c87164d3cb3cd3936576a94280573de55d9b2be20208a84ed76665782ea3963f44318e51c9e63f3cac2adc933644e1fbcc44e005117312afb272520f118d18e396ca9feb1f2137444f9afaafc2d8b74b1319f838589f713f0b4dbe69d1889136e90a5e0eaa59c18327bae32f628d0e6e267c5a8ac00e32e1c1ed9310e060bbe9ebbde2f0dc33a7516bd14266cd43dac5f42fde5bf34596c5785dd865224a97ac2d4ccb24e4ded36d80293381d448ea34850d63181c076feb1df4b04f898c5d12eae7d43a83940a1ed9d23767da6327449a73aebf1e342dec419b3b69cf4778c9070810cf25da80cca96c8e7e1a7eaf94c995af38ad78f4bd904b48b22a31d47c9db83952369590a9b30d18eb70570a2368424b076cc3356af6f6250d07ff74d91f13c5861c88c1e745d65bc810836c5740a9b3513ae463e14eafeef1942613d80be537b910a2b22a278d3f6327f2e7879cda1e578e1783d24484a55a2da62d32b826a757661d9ae2ffb4f401ba34cd00e07b66e65f5de63ccd984eb84a6b5314d19a364914afb59816257fe8df39fb1e448d974ab929141810c11905aa7033a8ab4c8ac7ad919d58c7873cb914eec973bba32991602bf3b6a31a443a8b00c65057fedd7df68e90d8f55fdbbb63b04a2b30df8faad6b012b2e5d76f29ed5aafbcf271d9dda6e0c262e96d65708cfa7fe396a4a327b259fedc2fad5ebc25d2857ff831d7fc48abdd2817498e2cea50805b17e5f1ff1ca25064dc0d06b710ecce52f3ec05e5d1be4c154781724d80570cd0feaf4751063059e341976fc7cbf8b802025e2b3b361c1aec48494e8853dc05ce953c43eeff302f22508547f92170e09126078423023073f12d6210e0d4d2467aca1f3f44b3acee3f9513db1a80c006e33341242420610dd16ec88bd9e5c9d9ec9dfee12a70799cb395f52a85c814847c652182cb7adf1aede2a8709ffe9af6f1cd48a7ae58d59cb03ceb7d1baee1f1fb9212cd51865652c4051628bd8eafda388a71dccf88ffe06f3d54ce54fdc46d3744a58692013b257f37ee9008d3d49e3b30ae7e1382cfe827432268aab32b46d5aa9e8e316c00115544c106b443910d815bf0ba56965ded24af5237c3c7846b0c3124fe5298c5d0d1bf8e58a322e8889afc73019226f24b2d103deff8aa73223de4aa6ce869809e5fc6b8b3e3fdbdb8b4bb9f0411ffd78dfe2b3693f1efc1317e0f03a42b7cf1e32cba99f73c34e9c10bbef669711bee5a273b03a3c98f496cea4db207f0e4d587259ac2bc5ef08aa0150219e509507846de8f5895decdb5c3d7d57f000709a334ce767c74747aca3eba163b3dcd7adf18b1405863a7c60e168d5ed6a204c9b71011b1baab419929bea0fb0e37ff445839b113480a036aaf940a45170562a42b5e598c9b862b9d3d7a6b77b3bbd4198d8e35d54cb721e054f8ae8c9336ff601b9d3cd7f90c83dcb1c1074e4490a5eb4f1d9b3821e8a93e8d03c1301b49d3a97837723d1b263e600d8cf42145ccd2c63d662003e0d4619b3ad2e86b54549957d30270a8a152d74f2b81d517ecda8f9fcdad2b7fa30c561ea243d6ef3859fd4f5d12071b25ddfa925b6b34922a6f71357475a036826a92f3cae46178e2ae06712e587966dc741ea2b50da3310332b038c937650eefb13a10602d004ab1d8f5111e235523918dea6864f803c5d84a47898374de9d9d35c3138db4be5697bb8ead45c230a826d00401585c16370325638478cdd0d51ba6dd6aa0910f14bdfe0e35d3cce23bf97c0f5471b434675ff2e51f1a24d2943b1b564f44b0d50013e5322c553612864d098b58a1b2261005eb96986435c56ec7444e1489c72a8f5f5dcb3274922bd5f7a5ff47aad4edf83919bbd62487595789d4c9794c5d4c91e8310911d3e4d73df14553c088463d75b764e324195adab37509ab9ab78a8f2310c3c9623123baf14709d0a1869dccd3446a73faa5434a8dd9ee45d7a32925c71e5b916b1d47fb15aa6925512d3dc29513d04af737c0aaa1edd0e9e904566fac6c1b866fbb1b7f3e2c971f9f9455d058d1e2ca924a2758f395849e8771b85926bb3bd3febeb5b4b44308e7123523fe23ab6be82124574a2cce6d8a0f766175110996b39730774a4a5a0feff78de5f4ff3d2b29b927d7014605f97c826e013717b8691859794d3e30889a0674507fff831080f0d6a1f9e8d8e735c992af6d915ead988d5b30ee9fc5a6c5a706926cc7fb3ed5db5fdb1f846cb7f6b19cb9ea127c5dc5dee0476ced9fbcb117738ae89290b40df512d27551b3688ddd5eba310d897b07b89b274f458b5bfd863277fbaacb2d03637f4402916c4bb1088c1349af8106cb83d8620ade2c7fc091df446b938c05dbc1a7bff3359c70b21f4c04586e22060ad3876ec5072219170382b90def2f60e66bea176bc4288d92ffb9459f87d98ee8e0ec11056bc1af307e47e41adeba0c493315503c35641ff691531a67f50847d9feb354409fa0b6e24a3cbe9c81f6bdd7552e481de5a8bbd506c072f65df0e9e57e4ba6ae449907a6116dc59454e9a79c52cc066eb104d7621ef23790e2a1e20ad3f3a5efd043f0c8c76dbee6ce5c49f3c497b7deeebce315ae0382b87de1386c141f48eb07a73a949dbedd1b1a62d1f82a3133f0db638bcd24670f21f1928484e3db89a94b1c4f635239c7520e7c722356e5b39fc58af3fe3ccf8256d52aa217d5a6ca2598e742bff73bcebf876f3fe1883fa1e08a47d80a34cfeac69702eab7eb75b772e3997f1b73dab77a185053fa85b08b42b8386041c9684c2ee2a3d77baa436fb2065b222e8fbcccd3cf8bda5b5f05b07cb61993c4957f87f6ff80cc872c7afffd35359f7342acb87a0f04b76f0e18cb933923dd9c519d1aa4dd53a9f32cf3ea455fb49fcd543d7946c74b9cb8cb604849f3c4bafc3e9393d03a6b11cf50ec6a2f020fbf587ed69b015415457aa4a90f0a929154b4e0c614b2820e759ccc3288bedf5d3d3572d794fde50e10ac51b752ecc3328d0384b8e9d66229a7a2863d4d52c61fbf4430c925883e5eaf1115f32b1bdb40c98153ef7c9465883e9070604eb81804edae6f56f10a81409787fc35836b7ea0b740a6f70e405f6ddb3dcadd5a78a17bf474e96554eafda8357d41bb98ae8077e08409142d013798229d7564bbf28cd508474fd429610465ef458f6f9730bb34582f9780f88a0dbd000a4420875232bafcdd7975db640d9ee20800ae870a1ff6a207bb46deaeeb6c1d6cfe62b6b8c39bdab186a617be9dc5432174c98880e8f88c78e84319ed6ca0870e1bfb653fc62d7c8369d79520d14b2a83a5b18b54f31e5cc096f0043d7c5ad151bb5a82846f2d54d0cf1be25634a3bb9a03244a6f9b0dd558a2141362a44eda383b700e4a22877d21da7bd0d2921a3aa73914f30cc9a7738dbd4235c3f6fe689f31d15a2157a6a122e64524f4f630216443b8554d76bf8c0f5ba6321aa7f0e78bfd79bd183826a23f19d1e71fb2f3338b74e320aa8813b0e82faaa15021bb4da93e41d6c9197fe683a3d4f85177f1e3815767646a950f9358672b6980ce3cd086ffdaa7eacee97682b0c8b3c2d1e919a2a884e1ccd652340f8c3fe958d646dbaace9c582ca265befbf5d06ab6334ebd263cd207beee506e71311beeea2cc70587ed2e736a33209b29f775d09082dba9ca5aef54cd67ac22a6ba36f7ca36cc94cc2fd4fbed04d0c67285342a79a36caea5f91cc97c04522bc9e3458fbf91ccdfee91e4a88dbec18871fd33b3460a1c0a4422fe06b9b410e12fc0bbaaf419d61b4c98889b8631baab1b06b5fe83d5103beff73b67d95765d71bf2a77df4650c946954433ec38b8b3b4a8a294edc15e97908804b0e7482eb55e90ff906a5b082c72f47d7e63788af2f155c8b03e96343f8561ee42323a12e3ed3ee5c34683fb6f9c50d5d25a1495c3f75cf3af8e5649843b1d09a58bb38f8bea312404a6192280ed2f65028d226346c35e48e3d827d7b5d2742b0d200309f00a35d0c0441542cb692e764c0eec9e3eade8d76f1ed2fe28096bd19cc509be987c80eba4ee7bc505b5311eda189dda3eef8b78ba5f342c02297285d67c496f52712a51bc5b3e2e57f0a3cf5975c79cf95f971c0e50d5686b40d8c86b97a3b391f1d8fa87171a8f270e0a6e6854132e541226502e7354ee92a7347de6cef5b8f90e1aab9ca7232edbb9fc389b265ed8b98a39264efa3d17cf6d85fc1b5f283d384ce3f468c064da090d4452e9175fbee79bc851371e51bda30eddaa1fb168e8bcd1cf80ff4d16c252222fb16f4770b0c51241a7a5454a676265c9a6c15dd5fa045b1d28232bf1d2be62674cdcba33c30b6b0fba98effc6d9c418016cc6d64df9553471075129121ee7e597d1e632c49f7cfd975d18e8117937cc9cf6cbcd0ab9d295f274f8355eb4619bdbb3e058cf4ca974c603d4cf7e3d1f0ce7dc6b39fd7272486ad05f760e41e472c45cbf0130ba14f62b5387845e6ae70f5c8f585b9301c07f307ecd6ae3aef890695ab2174706c2a7755c9ba3e5c53d03de14c3ccc6255b332d08e230a559b660895f6c50966bafa2b369535d55b2ed7ed7d816508eb6db3ee6154a64c52639834d77d9ceab6f4d5ccc9e1766df696a71750469396649b958d8234b06619280498c1f09409a3f8af9d644fdf487a08a6a1a2147a6bd5456754d352012bd35b6f98b65f871ea9f59a10e5c5ff7c39c62df1ae43ed1eb8f8bd4e096d8ab0b484841b78dd35473f5aba3196629976cd39ef9d60b265134bd480e5d85f0770c62c3f6e023a93e5e6e5aab03eb1d47e2ecca9b3e5db5005a7fec47e266d96e654e0453107d3ee392bd3adcbf1d7a7c5e9949404add572d7b748d54d11c69c8a493d64c2f8520f2665174b8838d9bd86eccbaf3baee39c86d4fa4ef8ed934a017cc6b70217a497b10a4c6699b3869be917ff6517ca7cf257bace07308787a4691b2c01ee43b653f70983929cba0b0a997c7ae64f8226cb9f898d8c2b61ea33c7a3c20435766896d0e8de2f2d07af89bbea46133520411cb81ec009fd813eb7d8874935d419d87ee9a1c7dd28fcf80406cdf894926bb4229b93e20eb8ebf5f53fd71202ca4e4783cdcb43afbfa6c86daac27874b350b603240f60233ed84feacb1a2ecada282fff3cca4df54d36b9b6f338ac67e55c34e8d11fe1bab6566f654cb0550c7da7406ec70cff9cc83ab7e5dcc7396171df7615cc89a53a00b0a1edb842e6b6eb8845de5e1c9e80273ac5f2b629703746f1153fbc1c2d8180655ad59c537ebb1ae188379c2a2b4cd80b2196acfdae450fb40943551dd1a09c340e5770aa1d43c757749d13e1c76b0350b37a58627246dc31e3551ac7b628c0f1951d6452839c3c381572475d738f2e98a3b545fc25646eff79b029e92f020aba4a9b0d1f7b981dbeabcf4f30976a37bb025d9a944c7f07007f74f50645d898d0ae396d6ceda9ea24cd9fdf0ae4a08832fe72fefa899317c3a497f57c7a909bbf489a8a77bab433be861dafd88344e022950cf087e5444dc72ac558bae5d3452b4c313d395f1c4bb22716de64397d6da1f42715603449cc79f02b4e17cc38155559f5da08e6f31ddacb302d40a696fc3d009a8004923a94f698bfffc9fe3ec88378a9d425ae46d1e2d0716e78fd83b8c35478f1118a296e7d3d255c18f90704c9eb19becad06124f8c70988252dec6b7b15b66d9da87d6aeba2d75072de3d4b24f12d66483faa84222f7f8f728037da9fa0addc825612cca01e7cbffe1fd07ef9e697084f9a75c316cd98443a7c22ebdb89c2a7a7830e1f1a4dc4506b0930706157113195d88048bd62124e705241e28f1fa131540a4e0ef66f3bceb746afa9461545e0e6838b726233406e9d7e85c276de531d083da5e96ba24287a35a5ea5c261b540a7e33813b595d54ad980e8e7da9dd6e43c2b2e036c6c0346fc1c50f0624222d316352d4828a6f8321e3953ba6660cc4fe0c65bb6cbc365e1db923204b197b66e59e913d52ff8f29492a63530d83d858213018db001700fc6bb75d4eacdcd448c067859f250c8b8c1a1fe0d7b5079ddb6b21b3ada5e6e86c4cf725b18ae12c98c6871c147c5412143db0e702217499d03c7c424c568a009e8b12371b56ada559f5d39692c76f41df66189cd7148619748f67174fb0d54a1907216275eba904b258493d44b18cc54aed5b13c9ffaba796058da7bb5d00fd514750580e01e096a02b664862b1827f9f262fdb7dcbdf41c6a49f3729d8872ee33f78daa343c2cd57e1846240ad1cb742426561b9dc6d07cea7834a224a5474419c65284a6476a941a89e795a5c02052c921148eca41f893dc09abda2befaab212b3d606955579d835de22ec3d2d2f48c8a8ac9f7e750300bdb415a7619dac58c65eab5c020c0a598bd3a139b169de943cb0dfa6b60aab4ec14a01971759a47d862af14bb4522baaa7d4fb70cd68c83e3fde1de5dd578219c5b10d40b421c180e8991fa9c325593bc61df67c08bd87b873e1ab7d637bdda089b3bed48b184b0f8a1bd8a2db7e820148f07f44fbb732bbfb9ee41c069f0c9152b72a8b239ef90b580b383406074515944efcc766ebe22c100e6aa4335c089b436348febd3e4cc1a36c6dafe2600bbc186e8328917fb6a9203e6486590232f154d82f9d1d0fcab5773297c8c05af0680bdf590690c94aaf8b00d4f4511dfd4789e4bfd11847bd85b2e6285e8269a3897fd2cc1aaa233dc1d1f8b61cde2f414f571c5900e0e3fe247c54dfec89e81e38b015cb37a295f10e350b00644a78c1ad41bfb60a19e92d1f0e3e7778d3a40cea3233350dc0104a34a98dd40eb33e6a9f57edb0a021e563cafe99395f2f8ee533756ce5a73288d195e4bf87ffe466f8253002623df7b328c4e8b5e6c201ab4b2d5b06ca53ea1266010717e914ac1cfa25103861f51f98edfe3569c20a42f3f91c75db3560b5ac72738e050e4ea08bc775b51b2bf8d7b2b8d2b7d04a11b569eb935a0b6dd00da43027d467080b47e3a7a6be9fcb388eba4ce30650b7db2f6cef829a285427bb3e458aa4ac1588b163714e70584d2107e63d1767ba5a17fd3200f96cda9f7b820612db405a53182e524f5e8947fc7f9869c170b64c6a62153dac828d1bc7de965ddd7461f4b55f2bf8a8436742ef37a7d4af74a7b0d347fc4f67753e7537f9ed7f668035c9a0c90b90f1d1a4e115808e91ff70e17c97def9f55416075f43ad0cec038c4a3a38d732161e839354683440678a34bac0bcee594cbca430a82567bfaaa4d841acab03f98d4843fad8033e3994e4f4e1c4dcf8e4b9e43d91eb898c6f5b262f0cde36a76b4bcabb90f9c621206876af8cdf38393a132b539edf92391f1aacf916842eb7ec1eefcfba59ab5b455825d60c9a8732a85cee9d03850ed8423aa9a4c234af4a8252f9a89eac2eccc642f77bcd64ecbffcb4152c452140158acdead697ab1e57c0e8c6cb3a5eb79298b11de25f7a3eb39278f1d60911658bf0cb288b44981c28f538e4c8b87012221defa33d67f1aa5433cdb507f3425920f09412d6e06e9865a17b2544239d48abe979cd96f0ff26b7a34624c5da1ae717816518eb3fbe29a7442702fd7e9f47717e79272cbf95ea3982c2e4c529be25bb34e1e02809c9b7b2acbe8d028f817d92e0eb68562207a5535bc81d683ff665bfdb4e580caa6be73241db505cc934f24f1f36a992d7128947f7f0866b8a5a21978648656cc9f60929f6dc00d76e26d1c8066b8255d30a4ce9f08c08fb0316968990293d1d2ed3da88f6d4ed2a8dd704526ccfd8509db5e1c90d05d1d6e26ec8f6c0c8accae9e02fb39d7f407af324154a5af625472c71e8255ff5a374b240db421eeb461c07dd8e45871f22f80022a3f1d91b197e569c40982343b4135dbf4a3485b1243cbb9678db92feef2577c05f5d3814fc2fc2146b66272957e51397a89616690472b3f6c63599d8af89cf7d5f72d878069b365eb671bb241d309262780d47067f6b66c4669e0ef6163a38c56f82724eacee5b10c8857b57ddf3875244a244f1d042f1d06ef92a3fdbf535b36d2ef2ea553e96e8d381e421dd8d2df99b00338fc48af3561e563ea19d80f4f72b492f5914d04853f320109ec5bd97f7b85f4e79577ad78d3621a1dc136fc24b69581c5369921135fed3866a7e108669c17c1679d180e0fd8c88e7a319b4c211a16f42c8d759cb12ae19f6278b50ce436f142b007c7f575a54ac49f8458182eb3a20854a689ecbdb16493052c24b25eecf65848b5015c45d30a8ba6c44bb5294f83ac505487b444c1731c8c5c538eed3e04c3483107072967b8c893e9cd2b4d29117e784b33c5d709c8a5ffaf5179c742b76edcb63a0f56e81b3e8af5d62495251618ec186f2fb05fb0a40c4947b33214581a560f2c87736dcc3db4bbbbd2f422dd512766d31677c088b4ffd4f5bd42d4062bd4f70f41169d788b3a41d6317f3cb9f41e7e8e37abf480617098e4e3ad0e9e02b22211c1e51a429a9c694813ccce9a1350ae31802b096e470a731bcf4eb688cd9b05ed79506585b74727a64acafbcc789e0c26300bbab07ad050441642dc0a8fa27489d5c689f55adf2087a8e7d2f3eed507d12c546e75a61add750775d899d3d19831b8d08bcf83382972bb8d15037f7de1e3484ce79bbbbaaf0ea17ae1af42fbf58522c2ad0f34c520ee6ce71a2548306af1dd63f9f78f82b959bb018934a2c4f7128647dac6925869aa911831a1ce7e4ddd6549d155f2fc28537c7c2edf445cc450d05516a72e087b7b6756bf10cfcf4d0c607fd53bcde37958b43c9483c3ae2caec8f3558cadeabb24770275e6b7c67b4985ac378ce1bc4d496cc78ccb4205a75d189cc5b962df55360080e8278d9c193a9270bee1c33e7bca675720e05dc4f176a2ccbc49651b28ebb86d06b829d41f80bd76b685c4dbd6d7bf64491dc88925baab9c4b09ee2d39b97891f9852a01c579c39deb644ce295e0015dcc7b585c939cc5f37fa89f7a65bd8ccb23ec81c8fbe7b4c6c70557dc1ac041b60ab649c6e856a5005b26a8d881e4a6e7eaae327002bab879177aa3914d6e62af06cae0cd30bb0f89945b564d4619b700c9cc37f258e3159aaec3925f66da1a36022c1b7c196b7f87c44a4edc81c8cee849ec607111794cafa8505d4c6ba939cbf542e2c9aeffc1d386b2d8e5c51272f83fb6d372d14af4a46263a681c3505e6074536ebb6e4192fe50278e867d7a7cb0903e62ce9fc826eb14db77012edb2bd828f764f6d35da7d11b4673d1ef720fcef308f2ac2c32c12c66e806ead38c32b8ab3e6e336b42cd8c15a59416df38aee32bda75d5e4d9f3ce99609f221b8411bc0a2d4d59495fefe6b3ba5c2e8f4fbb19f270a6d99831b4e03dc5509091b3d30fe6474640056a0a8d5afee9153ac3323ba760870feae47d9128df74609077cced44924cd358c47125ed03e27863f8e115f2fb1459a5211fc14e4f61c860aa8accd81befadafb754614289a048432829d49a15a3e39d4dfda471729e9b647df91a303065c8260f1a0447a1e06557aa845c24dd86153db6b75f2c065ebc01502879850a32d19b6afa577fd85b00f4e437a4ff245a1fdd2cce0ca689c37c86b5457e5abcc5bc92cd0f72bd0d0cb81d0ea1c3f1ec6b66946f98e3a8cd944afd7d9bc23e79f27df23a105bd5df85cd75b68254f8cf66aee7b69b5e5e2ea70b11b3890deff49b18cc6c56ba7e13ef6f289a88ba0b5024b5eb93220f82034ce6c1734c34420baf3ea18229c181f6d6631986eae510ce22e76fe0e3d2361702426be0cac49d2eadd7378751957a9d437a0be1c68a6db14e61781663b6cc868149ac3862ebe34d830c02732d30050b39dc4145ea0c4a2ae1b6c3493f36e93a227cf2fa6fd9024b954c577a4f8f713614d1eb84603f7f00659dab3d174012d3c4e1235ba7d019d6c3ecfc420866cefa95c275a591e52f59801c302c241306119582c7db284fb638bed219a31b98e3cf94c09e819f317108e5ccd14d17a939f9d0b58857f2f51f24d7c058e6ff5847c761c16bd796aec62e8d3ee0e9411345f5bbe7fd78ea483947b92d641c54a111905e86d25ec7ac17b85bbff3f805e090cb1c04f6d3e4fab0a4f0147e607fb3d6c176841204946ee1f49b03f56fa175100ba78eb9435444b25f3951e4099a00f89fa05a763c10e40994c4c7a5b85fb46c617de1bb482f792f1ef9386a9beeb6c8572f09a5325a2c133663efe656e507b5376e74d07a757489388a5ed0ed62839e0486ae9d53040597303307272a31135186d79fd5a339f3c9bbf46639398a116a147e60504e6be16bd0bf3ed11bd8c9a38ea47460f1daa619ff51e55d75d0fa8fd4e5bd84ed16345ceabedb1f0dd312c5f4dc1bd21c8d153f310b800cf63611ba0eee899cb5c12cd64e0c07d407c9905c1e91e2a99a9e4454947718dfb1eaf08253e09affe0bb26bda7a0729a338be99df41cd2da3e64f2fdb19a716ac628afc6b2623b5109ee0cafe254fab5b828aad06a65a42a28675e95bac85776b9a8b6b60b120c7790e88c1a7d9275fb1fd58e873561832a891d46fb6643b59fe856dc308486c07e882816c1d41c48073530ee9398888373fa5f50241160aa181b6cd00e5b484f85461d7b26656073e062299cae5fc1e2b917e81f98dbeac2dde77cf118c2991735d09a83114c7ddace7f9d43c7d2ae245a3ff0a686ed8412087e5c38bd7af305d2e99316185321bffbc5d77653979c58b99b800ec58d07f7f23c60741fd298c0356717440abae82969d550949fd05b0f339b95c0c5f1aec527f793440b408d6e8681fcf090d9123acae683c79d5d62b35240d8a73334c33302c18ef5012739fbae6441f679601ccccca9c3ac32d3e768be015186f3de8601291b74384f690f2812897d3cd814bdf05bb6896f73aeb160c3a77603e4c14f58fa7a947917e02062c37f31718430e79c95021b064ec46b4e0fe774817d358fbb490cce81ee1b07571dcdbfd280ad37fda4d8795029c7b2fd0d5f76c139b4e51b8c8c73f7731efbca117a677e2d6efbd9d2c18304184c45968b2449c07136c1e93171d00e98b81c6baf667408d0cdf8e47d35e65e155fb46ff592caa84e85ec4c15fb3ae4de783ec355b48af7f1b109346124f4903751b0b312c9c44c1f7ff74f5bc5d5ea760bebf93594add7d6fb446cce8aa8488a153e28420fd77a53b64e6de8a4516f0a366d70a3bb77f114da5b11ed0346c9108525a044cea454f6f3f005251b515ea2ccf3cc788666b38cb6c32111ea4d4aaf93d55082762d9efd18cdbf51259a7d1aebf657cb5593809fa656b5e11b4e050ff4ef45d038cde2153d47e180f27864b5559afa1d51017b35e98d1ec710550d09123f19d4bad5749afdbe773ee8ea3c615ac3e59d0ac3188e532c2dea147bb0414ab60ed197e15cc16e3e139b8d7a9ff6c298c4f79fc526f7c5e8e382027085f400d0e438ae688724a4f41d0c1d0a554e666dd4f8a0ec81728fbb1a9730e39880f123a4cc7b384424c7d8b2da463a6cd19c3e91eefbbabe8d565210b78ebca0cd3659a131ed7592a8bb9391eb0c68dba5ddec1b40960a00634480ab8d6a9bac9bf656c2030c8ca6dc427bd7f6670ff11171f8bc4adbb4ce65c5e66cd8bc36961366e0e9ecf40cc2027c46f12c3e36a25452442dbc29c6e05cea4eb1f8e0bd13ba2c5284bde4541714000bd69ed493d7dc8d0259f267ed1c285a7dbe3cc6fe34af4d1e9e3de54d4c1e3ca48238d9dcb0ee7eee687110e331663fad1bfa4e02a3f6c5da5260e7acf5a15c53436d6798a90e2559de473ddfd92c55065f78c5e07268b6f5b8f7588257bd5bf3e997de57d1676488fcda16180015aee89eb8e7baf093d4dd287a707b11e691f8388a1b48fc06760db96050625b7e3d8a299965e347af7b8cde18d1f7f72d13bc83791b4d1c14a880b407a2942034e5e33fc6aee45f53321305459ef3e0c50e15908600d343f58165ac5ba3ee1c79a7d62fa2dbda7b748aa7c7dc53542d4174b99560ec8e0334f03b7b1b4a2527df1398aade145adaead170418ffb109b3d0a846fcd1e4269bec11c4848c9c837fb55158376652e9ef63648e6fe6734c1634adffe3704b41fafa7ebb773f1bda0e8354156192f4f42ebbec9eb3c0984c1c1039c032d5d34aa86094bd4fb283db155cb74a43cb880eb7bc02f2c5269b6dbfc5ac67dbca0a87cc8ff4fa0d7c8525096fe4dd31b84b18031796e49de555da5ed7078f88c3512ea86a060f4f877c5f4708c32f7b176e5647888c9f81a590d0f243b8c1251c50b1022a007c11e1a6cc888911e4fd8246c0dd26494ecea19a6818455965e50e98e9be606d00ab4a3639433f28271598d932985919dac094b64dd91c702fced9c9589a47ecfc790b0d08c220900d66ad1a12808d43fb5a37c673cf71043d9b36048f47ef6858e68542119695ca7160b0cc3c6f7f3866d533b007262f06723277415a8001a30c02140499089fde7b9f559bdd6ad21095204eb396b4c44f4f028d049d7d94b7090ccb8ba99dca7de47396b6be635c0aafe51c13797da0f4e8ce863112efa9f97339dba984d6a10b62aac9a4b007f028bb1c10f10ca28e822c1a78e831ba34bf2b4de2a0e77c79d77c15c61d209cedf19784220d23ed3e966bdcc7899e8ba0b84aeca2f7aeebc29d63f4b77e5233157a107d62da7d17c053b40362a7f76fcc96d576c5c9f63d9734052a32454f3a6ea3e771d29f095f8396a600e96faa0ddf5a22c8cdefd978fb1990cbbfbbe073d51ee928e6878463829695fb760c2aa265cc27ca8606ad3e0aed6880e3805009e01e8181aedc0b5ef3d5ce828e988077e8139f2f55273f6c441bd59690059d5d728f50d5b72d55ab65fe15040bd4d3d9c860fee6c091dea4c7fd27c65d8953ebe7737791b776149db8a3e09441b8b922ffa971abc0a8747d441674d7ec8a05a7a7b18d10195ec1276b2d0381c68d116a7f225f914a2071191df124967f4571281541cc5116d581756058ac0f763b2aab9fab5f24bb850b51e6a2852aa1029b7e97c9b91ce6995f90e36d45d592a0a888c4f2e5b1c2762111b965c8d2e038862250d81e5534b8b993cd6472b5df2310a0e814852684a9d31636891132318235494df472d94e5bb34f05941345e21e308623958ba748a9ce9765a2781627310405478a6816172bbfbdffddc495cd2e48decd4d84c6c38089e2f31bd760939c4d1f72445a88533e704d00459a5c422a79a16a4f8899bd975a0d4e3ac29a8065f738f230f43c08fb0593b5b58dd45c4527f0db6adef942e2ea2123659848f425cafa5a3345c895e443b90ebb8ee97b0068ad8ef6e102d2f07c082ed873b166469b146ed5e3dd31ec0ee816fca5b04e67dc025a327570d9a3de9aab124dbc0878539fd49dc093ededfd1c20102b5a5d59d8712ae88f98250232baed7ff3896bba048e05bbf7dff3f1d0be780649e4426ff12abdd41e4164a79b500159961150caf3db77d4141794d66c8d52b78d278b185cfb321ad3abd3891c04a6376cac5b0195be26061682fb809f8743ca795c995e8dc5a2eef167bc2be5707544b3bcc986552f254e59a9ee55aa21d76ced1cdbe67c789f2c2bb020401f65d2724a67230848d3a2f57bfad3c38e3290ca3e38b189d380c6f3bf674f8a7fac24d2762db96b1c2d864b16ff6ea0424bd217391fb477b2f090f1f597d0b7acd3b7976458cbfd558ec8f966813ea93e28520193b9f7b6a291b58f5187bb865f54ea78639b44c89fd8be88656f87886a5e17e2a4a4c611f9c6d761c29c0ed59396547340279689228e4abd1fcc5c62e88398c8598212b86e6302e25a7dd20fff4ba07fe52c1973b768fbc5575c27cc0e6aac40dd7ac81adf3d4ff919889475ec2eb3960236aac634039909f2ccf844cd6bff4552ce20405dcd92b5d778161ffc6074c1e408168a787b05d3d95f3c338aaf97c915df08be8693e8453d25d9d60d99839fd127e4400cd5e5fb85d88f47bce998e7d2018065b9614299d41c5d07d37d50d8861a11ac6ecd0d6ba74ace006f59efac6e9775d2c837f8fbda3f592603895830de6e82e1bb5134d62bd1ffda8395c9cebafd2befd5bc35099d8c834b246f2afc82c5cba3ed620f4065c17c5b3536260c30a59c50924607e6cbbfb2693eefa85cf1205531dc4301fb1cf47365d6c4de09d7e31934150c6fcec2bf526e925cde9c127288a8a6fa5f27ad15c9082d233bd29e6abadf6d1baeffb5a8ba9e34736b91836bb8fa0b22124c97a27790441c34b2af04eafab22a282822d59373356700330f6a149100ae6c03f2237c91f610a934b60ac6a6241cee67b3fa359f8a1f597dd6a91b7f83c76ab857b92408733376c228bbfbee1c4d5048eb01f3e50a2c3709e35e310b036f5c4e491d88dda5a33dd5e7ae8e183df75147175bdd394ac556194024c6598c0cb72fa223a9b012939ae7190bc9b29fa5118ada040bde91c7018ea3dbb15319ad27df7302e79333716fb85cb0a06ce44bbe0a283bb9b9d58c11748cf38e492def0014aa2e7648bce94a9654b1d199ce159769e901dbaa1b199766816fc2a462216263a758d2a66152dccda69a91dfc0e6d514f4e6af7946e292fa39b836f65c9e02829d348febcb8821846b095b8017115bb7b7073461ee986f714f5e81852c64c04babd322ea4e0e398be2fc28b1ebddbe7a696465391664d3c449322bebaabd41d122055658d30562f2fbda6d6fcba21420a62ed0095bc502f3b23c76982a527beac0028f2e422ab7f0479a1b82714820d2eb7f02d327ff383c6dfcc3254e264c9a2f346f6705dd9e1c8ba7d238d9122a5ed5049d4b7af1c8a1d82b838e4e15c66a19f13bd1c127e2ae50b3e048f5b0fe3751de441f1e5448f5168b0f99ccb257455bc740aede2809301678a19da812966958fc052adfc75d665492d7b0b22ff90748717d3c2fba5fac58d753bf6a941c13b64d507b1a1e2872d60889c69e21b6326b88bcdb608188bbfda3ebe6d774ef8ef689fce736b078d1b6098e9a7d3f25464034d62819f866f85097c265c07b2d2c981d9d3c053ec2783bc4a162e641078d8d736105ec37784e127d73595149d1c7f90c483a7b04e950578305b557eca3d15bc9c79771376c4708699d9471ec2be9b9e3887f99fd258e4eb0a5ab55183b45ee4ba9d1dfebd42e66b3a3dd7e31072aa887a8d284caef3e75a8897d7ede3497a7e3f840d8b0b6d8c5ab22e27ba2d792d20127c318bb779ddf6965dd0e7da2ce8827aecf7b7b9cd03ec0bd890b559dacf1fb6c7121042a4e4bef56490695ecdd412e578bab9181a4f9424c13208b751a65faf37a71ce267a80c264dd12d9fb603e2a7615685cfea152ce5095c96ca65f5efc72677225b92292311faa8f20a3cae2c1823b8995c1a87cff1d03948c0061bb2667d7fed42d079efeba97f1e00bb4757ec4b57ca57891b6e5074ad0b0753a3c3abde29f5e190d24153a5142b15b0142803","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2f3e2806824450a32a5a1c3f58ef3724"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
