<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83a7d44073bf03315a9c65e572d74960d0ee6c677005112ba8902340d92620f0e6ad0fb31f8b4ef7950ff8814d4423fa676f57c60eb83fa14f665cdfc32af26788eb262a0ae447d1857c218161d73111a2a48bdbfc830e71cf10518cda75b336d6f3bcd9caea04f5ae92a637144c9735934f36019137e5631bdb148b0f7e6386a082e80e2ab4c6bc406220253944ffe1beaff3ea0255c890dd843c55d68c73c41fa91a6f156b3e4ed47dc27836ad2bde45e4bae598ec2f086048260c5fc287d60f45e7e7a6a5280eb4f547af7b7ed19493017c1a5d5d5ec28c9da7ea8c86f8dfabbb7f12fe9fb9449851921ec7aaa654c7d644fb8a2d3069523d5cbc33b0c63a68ade38cb872c4aa7ea7fd42b14d0d2b0b0a427449f4c217e50a6adc56e6269995ff6983bdc7f453fa5c485ca9363e6aed981d672a4184b57ce01d09469feaf6da9ddbfee72c61b387b97a3c22004d1e0950e428ae8d1af60ccf942a0a8fe585f61535d33bd45c4d2f5d89b386d4c37187ada9f7f8fa3f9597d38a4a8a7091c706b72242fc4a2a05e881165a02b3b7b8da13fa6620e16e1da5d872377b5d14131467483902fbc00a53cbac47f9f5767b47833f8452cf933bd8051e8a35fdc8a55c6541ec716a99e1ea09496f5d491596ba4fd5ed757623790a74106e63789c691330abebc851cd7f8ff24c995d820866d66ff6db582a88cf744d7a16ff3d3d2b17fc04c15f9a6242b099c54ae775fce8a1ab2046c97c0d7baee36ba0f3dca2a3c246cfc65c19764ff4bb9982dcb84a042c3fa727645ac593b1177ce52b03d77eeceae064fd15fb6fd3fd31952f3e6030a852a0c4374fd0279dc3c9a1bf85767ea551227452636309012fe4b4e41af1fed45d879ca4062e1e43e908165ef3818cd8eea002e05abfb496c9ef7d47da14a5027fe02821dd6938985012a24115bfa4c91bf9d1d34c7ecdc376e180da3ba39c09e9c69d185b8c43af3bb77e1e093754a22966aa48602a82fdd5491861afcd424f4c235b89fddb66d8fc148966a30c64f624b9d18b0353c6fc63fa8d83f636c6a1b1d2bbbbf3589309c3cd026b98fda506e9181181a7ec785a7e1b76fc05668e15c5fca36f2281eb37a6b9a522c9acd217ac75d3af40ca4547f57ebb5fa3350f4caa67ed845f71474beb3d9297fc3bd44f0b21cc996f042df9ad555a2894580c12eb9f040479bec75babeb02a682216b48c195179aa3842a6d1f1699c3224e91dd9274867fe0601e92e7bae47f64db6f936ba5019f5d82508e28285bb7165560abfb1bfa3f19076b80d944fc75db14357db266eeab1432e246038959d3072ff92ca58e55678bf24cbbe67020affea9eeb94834d6f8ac7a92937c9155803fbb5e519163e37a31d31a2df5965de179b70344a1a9d32bae30394057c0d1b2f955f8a71e075004229d9d440ceae1c2bffa37640e9f80c4f21ef92af745dea2a9ae11c612a7d84d47d900923f381d4cc14f580f4dc4898ea91318f4327372486649d423f6d45d2ad2f0a7b12d431b22cd815ed657b94c3414c8c0a5e98db23da43c2794be39126d1db53cd40d54b0c814024dd82b5e59033b5acc5e788dc278490dfb05c075507ff6dbfbf5bde3e95e971f478997ff5554f764bceebde9ec0a02f27777d1f02c2cac8a108e6f79f7acaf4e04082dc5b65295f5d568fa64da617122fcfeea156ab60bb5ca81a1887a0eca4f3543155cc6f596adfda4577504ff7c781778ae8b49e110db53af9e5002bb5ec6dbfa5461e0ec23ee66e0f516f333f7f891e0ad8fe1194109583a98efe2aa24885530d69009c417ca19b734ba42c270cf65f8eccbd0d4351302cec742651364247f08497ef88ab9377cc24229196b2dff5f61fe2a217289596e7b2840b28c357dd80485658a6d234fbfae02738c1a38f75de5255a96e85117abc2f4a4e6565898fdd49772d1d54beccb1a57788669b1b682a2ef54a5ee6e20e48b461f7ad1df2742b7a840adbf46dbfc52afdce2ddb0c666582fbc3b4300b22665f49db5ce5bc602b9e47a1f314cde46e047d0c05786463cba7b6391a12622ab816bef7063fcb5aa95fb065cefb24ea1062988a6a2e1c28f3dfe75ac4aea9ad797590e4f14f5508e33b1c9335fab5b3bb035e3a153013bb2458dee7e966303de4146ec68af26b8fb36e3f0b353ca7cd6bfc938c2454de51b641dcad933ec3cd1b337102898150bb7c5612258fc581b8369214f6c17ead974e565d33cb0c871c2398af676e5abf27d2100d28c05483826f367850f7481b4638170c4ba1b614ce80c1338203edc1c3adfe5e9a6527471f293a31b81b1c4034dbfb736e8b58c6ba6fcbc30a71151ea4388dd2224ebf58d0ee113f0d5a709218578ff1984a4463e6efb81bd5d60fbe19703011f93a88e66e38095bef5184671be490e5d0b8877c059ba1129eacde1d7e118203759837cec7b04d48a4c324a5702622e97a0b792a7a060566b8eaae96314047a38fa1819b9fb4a8c938b6f99ff86c8ea0ee03eb50e17b11d22da4549c73e31c891ffeecf261003b39fdb62281a8228de20e83d024834c3e9d533543127d8a97492111388e5713288450964496eb3e8dd9396ddc56be18a8f9b33ce20a3a7fac2c8e7daea0935beb0580841cdb147da1406d20e9606e897a675ba2306dcfbba4c212c76579af644b895c78f4a83cbed210d61aabeecfa2c1c898e7ea5f12f53cccce5cd48d2e4fc1235adea80e53bb9bba24ec2db4280df604dc43f1d54fb5de5a3ad7fce0205df82367f29d44be36467a745cc4c24424ae9fc6b83b136bc747080bf59c2fecc66baecc321760b5c3bb4c89aab0a3ef6346a1f8e9ca32382f566da586dae0484f2901fa53d658c6a7c23ca1b61fda1632f88cd6549251cf92c6dc3d0f66a88c7c2658badc1ccd6b298318049430fdc9e38c50ff641159b7ed5bd5849ea10ceb21634edc04aa65ed1ff3eebc74e43687dc756aad56210f2bd676f5427afbf253784e2ef6d641ca86c85bd6f7efb11e91f4522d8903021f8d13fc5bdece44df3c0a1b1f048f11bdc0fd91592f405f0d27c2577e599ed5000bc6cba63f124ffb6193cfeba9e1a8bca2b70a51d4d1e74192b9299d0ef2e43ed9d199e982c08d6df1df630c637d19a8dc09e062612750ac4aba40ddce2d89f6254dbc1fa1383df91c468b299c44fc0f3a73bad759c4152d0134ead380fe8a291aeea9be9d06d65176c1fb89e1dc3749273ed125e68ae6ab91e94794b7aa586b62807502cc4daaa29d22e0f7348391586ac939c15a19ea6c6c9b7aff75bbd65511940d93211b00e8b1728196568da49c63c131116ff8859ed5eaf6594c3dbd07d575e847f9fc1055ccb85786a475eededf8b3c7fa908ba6e01696b6bd64d72f7d7e39936acb642f68c88facde89d3294697fe0980c40e44cc742eee1531d6443c581682b382fb3589ced7de74a421f0bdacfdc7ecb2838a34e745faf6097b439ed4333dba703920fb93dda1d5287f9d7b6b1e8888beb5f84e59419cb6434b36d6c972a6a161d93dff95ccfd95db084afeb620024a98352399bb5782c21abc8b0fa56db5ac82ea0c13028f8422e3397e3e0c6702424da084bb7604233773486595ab8086226e06c2a7f8531e1cb8996f72f12f70b8584d126c000683566aa01299be82921bcc31bb77f0546ddafe3d76cb9fc0cfaeb423a14d046b651eceacca26232885812170ddf87d1ec7a92385f84ad2985f43638310ed8174138078a68844d15a88bf4860f2534942539a6b888eeaec48102e337e43086a1dc1e717b508a28811c2ab2022ceb514ccd3041f33449af478cbfc5f5f0870c981b6800b3d43076e787057ec517ea2267a47cd30bd07385835f753143dbe5d1cf868eb3351950e9ed27bab3be52d88368936d30f3c8534c37495e7b36de9b64ee5b80dba4a9569122157ddcb2221d0fa1b5a0673c5a66f74f0275b658dcf1f0670224c2bd47e366c38419b6aeb2311578b9e3c1bd4b1a9c41551135999b8301b27e5acef44c64eb8bb7b926acda7a142b4a36e786dceaf17c0ad3bdec89d84841b6e051dfe6bbd464b3701310abcf772c58441533e8e45ef72ad5342727c8159df4ea8f3a1cc99766be9ce3d1f3662f9638408db9d6bfa1eb4b20020dd3489e89a5d754726b817dd8a98afa523414ab421790bc65f53907ee55777c817bfd3bb3637049fe72ea54efa11563e3b5354c7a3c12ea4958708f3cef7b59351f9f1c34719e9be18711d6ba03569dd88374d5b15cfb27b7fe0f88cb8444214a7c37dc9a917fd83a3d231eb3686ddf0ef019f0b4dab8b644d3e125354619173e173432ad8706ef1239eca9e47dabfff6a909268bd1269ac1f98f443e37406efe588bd739d29298165964df8ddef9a0aa6fd87e81d737de79e0714e6f682c026c6de3e8e4f0dbcc88cc1dcbbbb68b69bfec695d71efafaa7f5769898e3324b273db0444a600adeac35fd10bce077673d2fabb3f2d809ba26bf41926e1a07474006d877fa5c5ffe904e75abcef7756ab2bd40b0eeb7f1592ae00f98d6ee1efd75d1dc53b7a7fe541472ca46fde143f2ef01e886b1f13d35e2fa7159552395446163b14a3cc2007f0a0cb5a3bf6c691c68c8bbbf111ba1fb3b38a4880dad52acc7c53bb68bbcfbc054eef177576d1f2a9dc111fe48726cb36ff3e6f8c510323e62bbcd76d1d9d0c599f4569844f9287058d7eddb7350ba05ab4646ea327946c025432ebaed89a8784913a3b31c46349d8293cde3fec8e3a615b1a999ea77fb51cad1f7e85c9c509e75c5ead6a53ace1efb1a1a68e57cd618c2aef736eb9f098d6f314a750ec216a1999428ef39a879773f5cedfa059de6c5bffd91e0f52764c31f61c4c6f8c9e3c350150adb915ab57d02bb2b7eca612f280c4cdc4b6590cc5813b66ee92550b7d669da73f8652e02f272749646ebbd71b735c4800379fe202de6b79180e639511b19f336e79be8fa5e16f6b6c7c827e5e99df88ceafa1da3856ed41f5d6f51db47ae8ad60d2a0bd1eadce9decf200bc5dc2d107de528b4710b2adb6cb711a4dd5c986dd03871fab43d36d6327d8a2695b1ec2fcd9149d565dfa0351447b9854999fe22a86d6a6d924b22de153c1cd6bf1f13e2dc05b0d4179f95eabc51affbb417c45414c86bf124c502cfa53336e80fc3c5b078252a148badc445ccac6f6f1213bf1e12be71616e719e366d4313abece3029629f28e4a707b3fa6fdde8f0b449d5abe5d43a2173dab32909222a810fe36d00b748d750bf8fba57838ec95c0f7649d8ae958a5994c5cdd9864fe6e4e470130aa5f7af94846ed0574369fbc7b6114ff0bd31c16a3573cbcee72ab2f33183888bf3e595b4dd4c1cae56b6aba5715b4405e1149a5f0d917f23ec42169bc2bb579ee59e32ee668e71e52ad52d35ed51cc7d381a4742fcabab6ebc0f2705a8e28c4c35bb678a922ef5fa7f82de5f431a078bba1e46286d7bbecfd50d8d638768ce0bf3b0983444ec8c82ee3ec682cc3be7e09e56a63452d8e452c1f3ae7b60dc8b9e83083b08a018a4709d8292faa68101174999e1fcd110e3d78d3cc62c1b06eaa47ae97db89a4ed99624db0806e7d6d3c4607d1b28b53163b522a6a543de4dac6884361502a9f30c488939e86620d17b37f53737bbeb09a0bbf448c7f95db3eaeebbf92153ac292d1c75b97d867f7c7ac54e889376392f7c8ff56cdf532bfb8d547757013a966832bcdd865121eb9f2576a98e60f373afde51dfdfdd7858fb3f76a62dc24646fc52445a03ac68c7a466ff52a61b425a36e2530c7b72d4fd766ddf8f7dfddd5a89d1b06bcd7d1b2ac05ddd0c8c7aca9b62ea245743799204c607355f3773eb0f9517badf5752cd0e91d68672f47f94b27182102c00c9d0a0dd07bc6c5855671942cace39ab5ad220b61c8d4b7dd453fcf52bb38981945dfb6cdfe48767d53163b0809397d0dc2d113396d05dd535dd883805388f3f9145f4f445e35d1f697b16d13d61de09a5f3d675b492c7b075effc9ad7494e2226ca978eecce9ca96e2f0679e0ef7319af9c12dc78b866e1134590203a67edddc150a0f5d2e123229c826df9e712657d6fdc7e208b893f195cf6a44900f098688017c7fc958b80762ab490f520f4b0e1b61cea523dd793abbca969e4e229bf94529d4cbcd9b5f8b1fd50a567e3a44ed74b6e980a766dc3f30090740a7cb46a9c1659b6093fbf1330edf4313504cc2465b37953b4416ac33eeda6b34ca04f46ed26b4e9383c27adf06bcd22da6d84184c919f3a7feaff51eb4128ef2aecf3ff26f402bc259af8a99e6623e337eeb75d2e7760ad974dd950644ae78f1a18065d5499e6fec5bc30e99c0c95f1bc962bfaf1a8a3e540adb9cb37575a56226914bfade8d2ab80180c77a8788b0d401738df241566bcea6a972eceff7814de96e49b46404565d67fcb0d28903bb9a738b3979184aa3bae42b4c1f4655d089bdaa474b81d363b677c3df9e0ec66a5c7ec6a39373c569e42346027079d9ff209c2c071071b1d120dcc591055afed057faf65acdeba829bd45ecf06ee8d0d01f3854c7344ff8cffff14e8c41543c03167e472690cb2b80184af19bf4c39793a4a59a1ed0676bc82962f761bba9cd5981b49200411b3b1c51366f634159692a7b8d565237eb64ae9992ef482bbbfac08f1e44252ef802ed5e5c5bb0d9d0f6af7284cecbd84694631d5d0ed6e1d9c6a96bc3369cf11a1977d23c3c7e051b7fe396bf3fa1fb60e10e14e93e4768fdbb0b3567224a2725b439180a33d1fa9632992bedbe55e5b7158e5ad59a18763b518f9d91caba54a0fe8e8149ffcabc693967c8572aa2fb365cc12716fe874d1c8bea3078628199cc6f8b5ab7c912218d5ac44ffce75e173e055c659f8fe61d768029b65ef0994ccf134ea2a3068745ceb71d1a545ca91a1229d9e61535515c970b742e24fba9a0442086818c923dee9ab852ab1a4f998453e8a4639326eb0296a378175d6f001823459ff2fe715c688ad03027976716a5a984ff7c26f8189b51eb20f33030a7b4c4955493796dfb5e506072c160bcae1da2be32f9d1ff6209783b2d512e408d3772ef68b70b39dda9ec87f1c2ef3bf1c38a5df8d55127bc3d4c144bd7546f78af616e1a0cdf55a1bc2d51cd9d3e9e07b805fe32fe37e604832462954f70cf95f6d31684ef4b3276e60e1be56f1a652a036db5afe6e37e94661b79d4da5b227184bd1eaadc32752b52cdccf075632a6b9ac5d45e2c0607632e1699090d2e76cd1412ae7941e00afdcecc1f9a4712126b66fe138fb9ddd07f2cd65e2838810f2e1b11db41c0a24d1c91f9ab3f04ad7ccc819c1972ff551848e0b352bbb1c1ea728a2c0228d392a7199210a61ebf920fb3c6cc4314de32953a912ecf30b16522836b8a768d1b1f9364f16b15df2830962902e03f2939b9b246c49aa6d56d0365024f8694831aaef2e7ff2e4dbe7ba5ddd47c641465bea60fd544918a8c55c90c616db021e17624a73c6b2c3a5c4e6323e29cd0fbf6842bee5f29fe04ab8ebe488806a17918daa2b21854ef7bce8b6184bed85f5ad38906ba04a91f9bcd2cb9dbceb62eea5e2106edd1a929da5d5436bcc4b604481f5fb8927876dfd1cdfc6a8532d67ea895e9a4b68b1749b4c3f023d77b8264009ad439ac4c2b19ebce5e1e444dae15bbf2fa17b0c70e85129b5a3fa9735cd79f15d702ebca78b883098863a756b2b20b2d09f2768ec186de8e1904dfc7ed005b4611a6c74470739c78e33a10a1045e82cd6d38edfa8f446857c68e64ea0bb3f6b28b299e6e76650ac64cff1d4e4e2cfd22b349d2394bd2504696bfcb5f788d2fc16dfbca97aebfc7d1ff7453bf018f589cef6ed25af0985233baba68ccbc46fc5d01ac052ab196b2335a3647ce52fb6cfe3710dac171af4fb732d1b8580ac1c8bbf82f883d70c234103e698217b2997d0fc26bd24467ffa35647c3c73bb36bfc20b6031b044509ce559f7572fb07b986adb7f9e582996210a27f59d7901f4d78005e23d9fa7b35aacf183319cbff7bb369577e1330f61d94a1518d20085ab395f0576dcee1dbc3da30599e7d52b87a538dae65167879dc190cfa113605d83cb4166322cfdce4d7e5fa1ac6b47dbd1a75b28e7befc2e1480f00802c693cf51ce8227eb2f7672d94a3e57daf946305ac175798b040f016fc67708ffac26c8885b40e5a8fdd82236aa35b7def30cb7afa4f8c0284d9387661781ee6a8e327dc94208f1b95d75b012dca46a41a4ebc139f1c422ed93d47012f9d965a17865b1f2b2ef6bd757c20900b994710afc3ab98b02656d6f06690d9a63839907964ce8c4bc5552cfa0995206380b985b89cc7766ef7cab37bf8b45a3c3aeeead668cbb0edae3a5a96a6fbf420c6fc8db627f3eee1851a180937143a4ed27409f8915b68ee6a667fe47f9282301b3c03d18ff6cd8c7b964cd7095bddc062798b4d2461590059f34f6aebdefe320884de233025fa6a0392de54540a22bf4c53d9f2fafb78405ccdd2a5f3275e704f86c16e0cd66f7764e8cbd9479ebf7d5d86f55fc8c1f20ccf216bfc8ca8d776d9046f70f5d20b65dc722ddbe6ccdeb8e3851c5f93288660664d3e56807369a611a65e9e8e8b57e528f0784b1dde3ca0e2ecdbab06a69cc12451448f49a4e81e6f0d0b498340da213e5751234f0beba1308f4def86e301d26a30b74aa5c6ac6c3d8dc26c422387b7e33ee0988dbf20f0d576968053ae0e08f7f4d71a6eb12c927f77bb545a4d4248f1f8ccb3a90697e4396e37a98d334e65dee4d9638010a25080adfcfe456c4cc8114dd2bd5eaf3d3f04d00c7cc1b7a2ee539434df0a8ff853476aba21e8b4a42b5b62fff119d823f1046569a9b831c48d427fdaecf39b2d114836b3a85d5360b2e195117d89d0431031d9b6e88ad18ce889194678d8dcc6e0e486ab79e098be9e67b8066ad5e8d1612b15eb3a30b432441dfca03ba5321f4c32aa3e2b925595fe8a5bbc05c487b2f553023488311d08ee68e32141ec1d432a1cee75c270cd0ff96a10046b759d2e60672924baeedc728636b16e7fd2b808b9f30add8fd15c6f65d2bb16b1fa656d05b79a3244b42cf6c73269891f966f95ad1ea6ebf0201b6033919453bd928a4cf5df5850bd347262fec5a77ed5f9df1ccc5dabae9411feed20af8fed437637068a4872d0cec9bdc2c2fa59c34eaa58c9229852282422d7b5de985f016faad6322efc7977f8044c0bb5de0b197782c4deb631f2149a3fe556b78889596a64f04986f8f0b259e350774326e41e8802817d5ef969d76f44470d2c7df6133f5024309d188a11ac927671cd7df5a71d4fc003c564a90a772dbfd87bb389d0c47df1f729bae861fc38cf67d74fdb38a663aa87dc96caa0b4941567acbf628244ba2071182f8088e517da5059be99b0ced9293335a5634ff9219e9595dfbdcdcbfd587ff096b0d720ca664cf74e7b2220d30f76b1896ad0680c92e366d75fa647a6cb286293e9576879d1692e314be5f20cfd718efdb03011501abab60def4742dc2406bff455bc72e54292a3f04200822ad48ce3321db3db212bd184e3075bb8c1702c6879810a4c164d7ee869cd80f38ca75bd75ea9687b06f17f5903d6b9d65ecc678195c7ff9062a3560df981172930bb5178d7a555a3823622d4463afc01353e3d44ae221e3e24531b9b0310026280b7f823aebec7ddb3e57bab49f06d14d08f71480963dfcd0f723240d36dd9b3d77a1cf3370cbd3a9208f56f6e20a62ddda97d269603552b98f381f51105d93d17c266d4d2c9932f2bf21bc0fc9b29334bb86ba5959c88b5bb3804e3a5dee94213b687e4f40f7a9be856c1a0fafa9c1c5f8b8c619f120900fbd940565d76e01cba189b75fb4a112b04e4cdcfb4d4dbfa0d2f34069292219e153fef3becda6c924102ecb32ac68948a9e4a5c741b06348399f65fa128aca5bad67f0a35156460913d7e34fd7b8c2d0a1344e14d34aafa9133b1de514d5d633a8335132452b30725cfaeb1de583988cf875925054787a140ffcae9258901603d18b27d0c50447fadb4df340e37e883af03c76a7477972ddff721b814db09db2c75ae8ff658cc62b342822060664c60ee18f3aa430ddb7d5f4e1970b279063dd5c6f9bceb0b03079d249ee72eb3b4914f19a816cfa442a5397f9645f500eb929e3f3a1290cae03712e9dabc4c45c4b219c71ab140049655fab462986cc9023f4da407b0ae3d5b19588851ed0f73dc8a4b17b9861b6458b1bbda3792efce81311de3eefd4f6807fd1ef0f04bfd65b8df768fc507d991d013cbc8e0cd3a9a3526efc400b8e38dd6f46bf5fcd054223582a5f6e56f98a9346726b72d9f78bcccc5d47f25f78b34baebba3580f45b7220147184af547616473071bd4bac540b3653c6c8569a54702a176e5efd2ea94dabdc9569af1a2c4c6282974bd86975be3d6b0caf2f380b69fd23bedd24b3b9150d2b5e8cbae5434a0177c9ababc2c7e04f5a20b316c4da9394d8b4a2c518bbc792c9dd5c97063b66fe4d36159899de5788e74fdbcec042c82099cbe1c83ed4d6444ca28eace76b28c6eeb815beb9182469a30673c6d40b34ad4a5972fb60593b72d0270e3b196f9b72e0496551523510273e4d91dc4b67c980e1a7c545de04541aebe972cb720f5ff968c576c32ccb5c22c8e637e0627806abd4c98936556038508b8c5c6831999a26d5cbb2be2d6b3eccefe89b3dae0ca8579f96569ae29230ac118ca0d91addf499d730777776ba3ef9bcbd608cb70b24a42be7b3ba7a53cfcfc1256103eb6d275bc8946e352b7a0b9021a16be0c6c00f4445c696057c44aaa63649fc5c809603921d7060229466d722245b291c4f606f518b24cc3e87854786b073fc0be54f8421ea3e75882f7cf7deb402f7f816197b86baa25c7650d94f8bb689a6a60b4e6364dcbac7122e5c4c7d15a38237a6ba63e73cc28e191f3c3dfbcc2f311640a7f710c8d195ed0e1225c32940d4da179cdb1315a7630c54691efa81a6c902904decbf49ad51a3078cc9fa0236636fba83bdb6c3f9f83eb8cfc7ce917c69fd578d5253b7e8ffa65bc48b814922cb14badb6ad3085189919453771ee876339deeff52d9c8c6119bed29b0beb88e75a36b453279bebb1be57f41bb1f7e90bc9599bef0f522fb03c504c0e2cd4866241a294b87414381177b420987bfb67cfed0bba383699ea3000928024088f5ca429d998b161656d053899cb17ae61c0b383d0b9093b17093c32f168ae864afd3902ac363c563037c8ebafcc48190f121a7d589870dfc4b7de4ce4b2d1948aef3a29139201935e991417d9e323a328ab80905e69987370a2d5224b8813c886a7d275ce2d4d2d2a202e6779c362272d020c1fa8c0918b7a193cda4506f1ac1d77bfc369ef1d188c0fabaef8d2f08f6f4094deac5c5e9e22763cd6efdf2928ced4b1cbc5c8af2f387acc59e1168fbd6f0aa8b281e31f5f65373977534a629d53f3261251176518bd57efc2667a3fc05ac952a3dea15087da92702ed91f65a5cc467351f678e066613ca81d5a1784b432886d34efef4da7f628bda77be597b635096b1d3ec9997411b6aa865ae6edb00521cf7347157d4d24949fcf94c15d2df1c2f793517d8902aa300993691f5019ff881e124b380a57bb0dd9444ea8ce2ba604e8b9d24386dc50cad5a34a85d169483320b3b7ff7a5a577ce24fa4976190cfef02e7568c7923f496433511e125c565b3e4240b50a556e4fdc269b2f9b007ea6f32dd904fb31612ca4631c5b91eefcb00f91c55c389a527ada935749bf389b24c263e0b89cbb126a38d4d80b4a6189c545fabdecb75f582d9d07dd211f08f9d5ff8c9e32e8ab6faa2de8af881f83da3d6032c4e64d2499e5c2e444afe9b0296fb4d2003b7b34f85d3072738c311260a6d94f572dc917a95c83495f83e7ad8ca35dc48fe3fc8da770ded354b958f1a79dd0e30fb129a3e8e06fe3bb39554bf3dccc0db0969680a2c6ac184a6e448369d1f6c3a934d20faef3d9b41f05864ab723c8cdd25b5c0f447b9e0ed05573dfa384f6e4319153f2a24ef17fa2698bd92d45643f6d73d13d5fc7bf4db2a98e143b538aa7e25f94bbf99f5c301086687a36a8228a37d39ec3d1a6929539e23d1fa564450e70262732ee9debdbeb15a6aa8171947ba84f629304a69a3ca89610f2faae1b9020519f9f92b4953cb507e1bf6ef35023d609df389c2399bf6e6d21654e13b16a3d7849bda4c9b77a32b0f5f6dbfa9ffb53cb55ec330637a22ac668b8e284f54eacfdddcc926e7855c18a559165cb6ac2efa458e9b901d0d9f608a3ff38ee884bbaa66694bf08816038f15a46c16d6e1c05823e9f57da9a00f87c2b495f85caa3401e042425aeffd4ce3c79013427e7ee3f54bd4bec54a40404cdc8ebd71b433b93a6f1b831a77c08b08b0c6765d9fa82bd976ead3461c64af30037770fcef62237c9ab5a02a2de9cdb8016b27ea928f01884a25cdb3a373186113eafaa0ea0ce047572dcc55a28aef07a49d2172c9afca1d5c27fc08de66895fad370b6925d3918f76bde124d78cf3630b7406083f34f6a211ebf2083a795d4e1a235cfb3b46ab6adc3e726b73bdf22911f2135f72dddb3f98a8800140b5568bad72c3da812d169bac65d77916d01048958dbc065300bb6816004e67ce277c3fe365e3279ca0b00197d56e6dc3c3ee180aca66f565bcd7c41840e0972c0b5e0cb367c31807f6f64b07a22fbf7cc796da079fb469b6dcf72cf4aa4673dc937e943f001ceae976975f9f3db5d51c961153e0563bfabedcfdd65d3abec74c05ecc42a15b6e4373a3f9084b70126dea54b23b24304f1c4bdd946392de73289684c4fb81e3d174d9de014c3de767100f3d37d80a6599e1967303e4bb7a31921b6837c283022d3dcf6268f8c4d343841c04851ebd9c1490064ee0b392cab17d9f1d8a32d1256cad87ca65e6cf019f3c105ad94ad5246bb2f2170981673399adaacd52555e1ee7fbc4945932215743a277533338031217701b42156556677e1fc5377cd64c67140b5235235e7645d249d9050dc883ddc83e279c6dfa62d461246b0ffc8f98ca31a7e9fa0560fddff711b154a12fdce8b5256d700b73f4c12005d9121c6af1ec62a83972978a98bd8676f9900400e1ca998c0c4f1d50a6305589fd1b7b0f0f06e5289265ab53b5cf933b1a45c032aa0813617dedaa9363dfc4259b2f75f290196b38abbc42a4d785e139a324209efb782f5e269db75184ee2670e779bd4d5b8762c095f6d3f89ecf34fad0e2f3eac7e29ab279c857975280caf75a1242527e7d7f3c22f4cfb7a2e54fbd7d008fc85124ea47ffd61b5289f2186bffbc56cc7f042571a745043d24f30cd70d59ceaac827bce748736c5f61d39d9b696d553ccd29805ff17078f1a96c6ffa9c97571c2304e4ce70d59eaf5f43393c3c931a761af2016e9158631f77a9b62343f548087ff63fcfe91023e2d0341b17f3c7fed186e22c93dd010b0ec73ab0641778ea6d1640576531f6893966bad971bec413f1078e6c637453133c8021dc498e8ea59e03e4450093f4e7614155f3966273bdfd6b71397ca2d4f107068f02a9585d7653ef41996437ba2c1ec699d3730a5ad93f9a30f31bd80967fe49245d0a41c873874c01b8602f9f65b4e9ee5caf12a05a0c19035d3606aabe2e31870431607cbcf10d8233ff3141ec0388e0def0c1454df234fb6a96d5b0115bbfd4384f380a10c1bb1b3eb50f1b18237142161292902e7a28683992b4b1d9eee230c41d0b090a5c091cbca4a677f3f7ca8b9c0bb831345fa1e282088d559394eecd88d81f61a7f55f16aec507b9a9b79f0ead3e35071f46cc67455a0ac0bd11ee3ea418c65805952a04081e06db65d5374999ad1b0db1dec0bc9b83b09a521f229f71a16a3bdcf7ed74d884b08f942731b31300d06119a71f93651370658afa7796976ad91a41dcf7496700b35098dbaa3bf61225aec292db3ec07fa2624d6ad9b13fe607f55742c5d196d9017344f714188215551c812642cde3f22a86eeeb9812f4e55ff7e46f01076ac8b2fdae0bf28fbbea9bae5e7b90099b95b629ed39a84a8ac6a82cb07f00507031c965f29a488efe949bd15aae2fc870d0ccc8571cb5a2e04ec42b6d9a7ec730d57241c1b7ae4b568c94ba2cd18f227fc1911aca86177d9190acc6b012fe71423042e359ca801bccb55b0dd6c6e27df66190f8c9b2875afaed062755a313fb17b6275678af0c91eb51ac9bb4b5b94c8ffa0b22284c5ca049113a74de7ebe3633ca70df671635bb5948d411c8928ab449d3d5d6846545cda00d26b2d659fa32ccd4c1b2db92610427e0655f72d3d966f1b203e17fc1b37f011cdb754211f663aade0355087bacb25c806ccfbb04bb6eb2838949324191c8636cff53efcca07f68aeebcf405e4f3713b59051019b78547e7276c698c7ab05d8d32cd648ba2d7e8a59082e3976b0ceff08fa0317112415948fda58a8e7d379778beedad2e0b0232e3750bb4ec2b1e2d97bba19fa82c47d4d3913379815a93d05d58e2eabaf4dcbb29fa028290ad0512b0c71e9b5462d24f9ff1efccc8bfb7d547afa15901a82d0a3f7126eee2c143402c5a8f8b131961f4783a3d06c4565037246fc0d49491d24be8e5c29f36b55d1eead901691199e9f777e4837313f6dc67798d3bf491edce7ae4331e10aa50d08ff3caa004e3acd0ac120477c2675f7dd17da7c0b17b8977f78803ac81f2ec7866a4d1084eaf12c0293073afaecddd1b3a1369c60bb23500e654a61a98a246d227ee9eb64e8a61bd1eb77467e34e48dce930e7d55666ca22bdd7152824a28f0a6ecc8016930ae5bacac0d06f634fbe857869e6ef5599902318191ee33965859b4d05bb31b5e40c9e9da8db3325f5d01243bf6cb9e212707d0e482d8f4dc94f056c36702e7cdd8e320ce41bf802ce663a4707a80908376c2afd2d440a5ef292505c7ca887da0d473f25e869904d0a8709f09db076eaf26c3264b06dbd391f82f00a093f22949e85c301e34e62b46025995f2018d0ace7377d4c13a7d56b5a991da78e95015fa2bd6c4d407bd832bb42d962cb669cd0c7bcb1952362b4a88b441720b7f2453729256a7af3484664c4110b99dda36649f943fb79648182898c97a23d8f75e6f940be6d7bd01e7c7a7d62b2bc82ebeea6d8584f5d09a312f56ddf4f0820a99d8b68cac29b2602c80daa0ebc2efe25fe7db45cfd67409ab4afacaae1d1970796d2712b6867a4dd752456dc21053cc10aa8d78458f9cdf8db15116a25dacfb87d6ef6bbd02ed5e07288480b13169f91109fed756f1dbee551f398d1f4051e4f91a68b63f8be72f0be952b0bd180a71f2dae4c45cc7022aed4b77f7b0b8cebf366a868779d3dfb347c1d4d76353882c035a4af0355d31416864a4c997da846349d2319d298907462adeac6e19861cc214b56e2b65ba5f7ca89d76c2f0c38b6670d0808ef421eb7dd0cc0ef907b7511c7829b804c5731450fc8c4e653002f28706465a23a7d8407366e74a255b027ff3f3d874cb0348669377a4ddf2f024d984567605100466d2f271ea3306340c94328e0911510e1c9ba07feb645d92b04a8a5cfca9f3907863457bb4d78720d6afe7cd7fbbe820605f6b1faa11fa606e4e9033f610244dff33d57481d7d189bed7d466e8285ba3c567c97c30829760ca0c0e33a0e0e1b8e4f840df37a41da686618e413c210909660f1855bf0a90519347c4acf55f3e5f444fd5f682425ebc1de70bfa86d76779fef3d8d4f1f1ee961709542237a120797910ab2530a0c584236e22bcba8a6e1e6480d8ac2b2f32165994966e21496baa430948b567c0c4d1ef5e36e9c7932915677ffcc758e6acdc4b304cafb9ddafafcdda7ea786c2552668924482e420ee8455a411d871cd168d95650f43c41bc3836225165d053e41c4dcf33d92b0f419f5824b1cc5bd6ad3c904c1ae68a16eeba098b268b699982aa1545e3c6bcc06c2cbe1afb66a2f482a06fce2d806d7fab0b184e683971a5611383bddbdaa7847c81d329acf1b1425ab6cf54f7b4c22868cafc5c570bb6035834342565ed73607203623ef525c1373c850634f8a5f77b53b292931cbc1932511af75b987507cadacb67b0d809f36e9fb7915e58a7e0070c9a710fb84e09caa2098cc2047ebfae80ff69ccb28fa30500059be4086b4d61c57868f1ea95b894c2ae2b863be458c43077aed9a99e0713bbff95fcd212c870c283ba3f6ed764ab10d78342f5bb5cd27d3e094aa20fa9a25f799637edd57c8b7618d2ac1e36dfca215a4007c5b9226288660cffe6afa5ba14d7ed975fd91c4d0528749a704dfa28f218a54ca56498d583ee8fe9fa2cfd953e81e98024e0b06a696bbd138164313c87e32bfda2b5a1cce4093915af32f3ee7370cd131e8e30c982f54f42cc2ba71c7458429ae75d8f12289089306165372237ad449481b115c3ee011d30eb02d44073d220b092aae357d44cac6bfa19c838941220dca6e7e93ccacd230877f1cc88a190d738282edd43fff7773f93596e540129ef0f22cb559f8d73f40f08a44acca1dceb3d7e738436159463374fb3aeb1300462b8f6f68db2025de01232d12f76596b6c3a79684bd4ca219b3793b4bc92654bf17f307f347fd7d63c2757ba86ae22ec4e4fb5dd3eb91dfab4acf127c69805707a6666326bf232f6a240122c4ed9d07ae9882ad25794a536b02e4e8aa6c501ed686ff4a81bc020cbef72604cab954cdaefc844ed5d9e58c8dff4c68ec1a9683554452b77f2da3ba2e6ef3f84554a5330fe9cc43c62211d3dbb6f55b45d693a1877007fb1afe98780cb15fac01885877a48bdf1b1291d9c57be3a0e3326fd7b2d2ab370d4afef83093668a6594d8f0a7de227dbae22a6e0953f8241757205e72dc1bbe8cc065be4991bde8e0899a29bd9324dc2bc475ada3e35b85b6ea9b0a0e7ef6b72e6f8840685b04a1edece67f253563eaf6963802999e3de2372608bac65585843bed3d7f47dfdfbc00a3ecd188563405cca40a321be9c2615478c6477a09ebf20b81837a427388a971801b73d3c5c47eaa28d0087b487d90899c3b48d0bde77e34db2214e091532577eafb05eddd268e159bf7d5c204559010ab9d2aff42d63ec6309d2302d32a5c39691cf27d746e024fb4eff1667e0937c42b9c5b0c172c8ecef427ff7a7f05f961e54e587d76ee9e4736c19261be8868d42d17b78e960bc08e1cbcc2167aeb5f30ea19d44748014575f6bd52cf407495fef42ed63eeb05d8812e10b92872d31dbec3aa6da8172b6369e63fe73e484b85752ca82eca1586df9446bfef62b185c0673d6e6a6c36344f45b44b50c7960faf677150f2307ace76d7e86eb0883d7dc1493357832d4e5e785c7ecbe21ff1eaa425f8f46d43ded027ff8cc7cec8875c02211d1c9ee58977599733d87e5ae83a7c588ae24d643adfada3a21d2ad38885dd82f41abbd2bdaabcac279fd59368f9bf9d705fbd31d07ee68ce5bfac893695d45401ed62304d3e730b780b23a3e23649703c428b98b9ee097487f02828bee42992fa89c2211d095ab82f7cd763af960bda45197a424551f24c42ccdacaaae319d098e85f2a61c9c204e349808cd9f2e8ef4fefc6e023ae15fefc4dd3973b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2ef26ac5251b1271b19c144fe749c47f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
