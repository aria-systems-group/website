<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"86da55017a1c9ebe57e292abd2a3531364303e2d9a28fcefe5cc99a5d870a9d672bc6572c5417683f4d66cfbc8adaf450252115848a20329fd9feeeedeec68dfad926b16d40c69b7156f911e74fab034fd5f644366e2860fc1cdc94862e584a968bc4bba86e173fb03aacf0e1b1e0622ab60b2ca5247cecf5cd0675be4acc29edd22c9871c82e7c7241cac71359ee7c0cd4f94a8a6500c1b253aae7d37b4dbcd4c8c397cc480ff2e4803c5898fbbc7949655dae857c92ea81fbd7e12e9e3d96b3ab6627b8fbb478e4e562958891e591cffdfdfe706c017b287ca1173353901c59f09f41a75caeecda56e325ebe413d67b8dca0dbc8518f59ec37c8f23009a1398ddf5f962619684a8c845ebed345178ce37bdb087c46de7291e83ed7122437908ecdaac95ab66ecd0100751d7de059256be34a2ec614e908999e8a8e6391cfc746ca819645528d242c9e4671da36a46300d756b8905e356c866162bf60abde8f23f67e37e80bd21537849c8111ecb8bc02c5dc257b2b6c654537369096ede1241b0a7aef8aea41d0ae70bd433edb1d1ebc97d74b78996e61341775c09b6be4dd127f61cdc44dac23a38671175e652f9c36a7a3943df9018ee7e816eacd3efd52dd80eb8bd3735dd83a72855ee9c964e7457956cd098b9c6a5727f386efc0008ace923901de6214fc1182cd2c00851268cebb566fc29f1d3b545a0f5504b1500800a0cbc3f11229b8a30d2bd655efef188ee6491fe90b4456a65ebd8fa6fb30964fa3fb068c7a39139d857b9c045a82e76e91ae1da3580e6778dbe5dfae6fd12e57cb63ec85a0ddc3567803bfcc9483433acbcbcd9ca7975ecaf136139f15e78c5978d6e2fba5ee09d0b182dbb6abfecccec3406f8f8962ac5d03a78f06eb4690c4d05c6ebf835a62c0e2b3443dfb2a938f613a89ecdbf3af57415e47829debbfc4a364a24ceaa7b746e397e51dd80f7e2506fcc5780eb408c6fb94d807b17086e0d0a7b216225f1b7337bda41c3b6534d105ff7763697584f6724e9ad054380dea599fcdf9b7b3bfbb08c536ee18b111a34a5c4974bb6930404f2ec63c9ac9be28ec14ec2ff247ad2e5750934594b729435d42b019efe2af386c237b2fa9eb4f025fd2b0b104f7ebb498e912619f82de61708742becaf40ecb99c31ce7b668d9ad6de81bd693ca8b9a823aac2dc872ef7ea8bec2dd3919d58d1b64c3a1b2bfc37f23186568aaeca3e3fe8e11d5508d4eae90e36dba7cf23d6a560ddd7c8138ffe85c7d58199a4a5e03234b25f80a42b3b0d5713e4618e4390b55c55363e9704325d322f02c370f8623f149778dd4919b8176ea0c9d2c2c9212e184ab02e26530463fd51238df99d98330da3e281a8bfbd3ddd665431729be03fff32efd0cfb1b1aa4ae9ca8fb1f4e00d39e1efc6c8b496bf1a86d0be859dc5606bcbbb779686eeb382fe3170f021e265bccf46b6acd5d0e041c371a40d8302250bac2632d21ddd6e226637df2c322b1c802ca5d971213b713afa6e213fbafb693a616b1e0a4f9ebdc5cedc5fcb179269a794f39a831d0c161a4ffa98f2f52b9db10ea269bb1902bcdabcbfed96896025a8c92f4bd31662f5c770e3419c52e0ae3db9689282606520f3c94b56066e7f13a58e29f93323ba50a93aee0ac2de5d152309e8b4beb27cd3474d70f77715e4c0f919da27de37a7e576b98c2bb0a683cebf64f255ae980a2f28c66a6b64e937b50e0f76b1fdb2bd33e1d761839937625769de04691b700b3fa099ad535e344523e8bb60b7bc8a47f76d019dd4d7dc90463dc92aa092ecdf38e98e522ee774df2375cb62ee949a60f38b12adfa200e36f29513dc201aa05df9c050b3f39c53a598c5565b493b52d0a9f18ee69e0b82535f50b2b48b0220e82e526de038f366a6acea1511cdeacac413d6366e9533fd5420739f7ff1f9f94230c1277fd7796277fc9851221bc57a45aa6dd6951f28350fab7cd868131660a2ed0f80bb1a3a7fd81c4e52d86c9f212118df5f732fe78f6e0b059553e36ba1285544636c30c78f71accc4531ce9533a2b72929a8b2590efda3df43813555f809affc26653adf2e00eae20cbb49dc5739afe63e0f289bf95a18752d0a32a7af7fdf77968606fb60c222ade885dd36310970c0c9f1a222e49f126fc33421413bbde4cbc23479197c3a14b0211a9aad2fd0ad63eaebc36aca5b8334f5adc702ebb48bceb670d1bfa4d20b54b8f5a25d1035b97d87dacafceff1fba44a57f9e22f666cfb2a62c11729af22ba7c9949f0676ff110b3ace6ea1e701e39e00064ca2bdc6782d9b3ef752cc07f22fa946f70d5c86be8ed267f5593826ddc2de2b9b9f8e929173b2f99fcba79f86bca71a407b8e685b72735660bad070dd5ba822aea0e1cc31e361ec81a9311978410c336dba5c2f50a45717a8f39509f9667cbed4cc33bebb88f34439102e61de7141f6c81ee750ea2ce0123635350814d9fe8c61e1d410bca6e1f0f1f151f9c601b67742273561cf05ce3760f85afadb1ba6d9ecd2a9fa6bb40a8011d003f66d29ff2c6ddd1b544239982879f7e8f7adee158adf7ab55f91621a0a22f8ef181abf12ff464c7bfd6ae1295b07b756dad5ba407aedf420e0fd523baf05832ad98336bab8b76f39d823064be89ac86952b9d12463a040236fa3cad4ffe73f7b4b434463701d994ea6abbd2f3cbcfe10658186849b2f39cca114b61562d23c04cf1a217639249c3d9aee2daa0a78ab7bd5dd1ceb67a78107f0fbda0ab03ef2cec3db2cc41aa7fb0225d5c82dac88890d53bfd09c14784b72d38831b208a9a21510667a56cde9fb29caadbbe8aa1f56165bb4d7725cf698db4268c388fc41453798e8a5706d011f94298294fe8e43e58e9ee699c183e9f98754c76c7ec0d2164c3ab11a2424cffd3685bc1dafa307607de8296d04c420d0235883f8aa2062f64956ff3dc3dece73b71ccbb2c1dc09ed290abcef252c2f4f7eafcfa00aa56d47c97b3f11a6f501e029082404efbf7c302d4b46ded94ac31ab2b2290ffb5094edc9df9eab569463f763dbed5bbed3131e3e96ad97579e6d80e7c468860cd3b3d01945fff8ea2c0dc4fb287e670eb6dc600fc6093647ca8d52f5fd68865872000dbf68666b5a3564c0e70dd35cb32bf2fc47b7fda5c29aa7fc174e7bf48b3e769729e3f24e55021c1e3e283978a15e4419ef75957e32a46523d422b24aef5cebbdb64056f3efc4a748245827ca8cdde68fca347fe88943e00672795ecc80bd52aff0dabffa3cbb6de8c021ed9b9d1e85cecade5c653887792a15770ed7dfcfa726129b301eb9fb2da78114a491166489af3286b680dfd5ae077aaf9bb6387c0018e861aacd4be4b58f9c263ededf16fdac380f10408c2a3eb143197c69203e910e2754c247e1cf97713845e547d03060b5cd8b7340175c26a13c9082dd3f6b4e0d8370edbc3a25ec3b5457285ad28c5ea433c3922846943eebeefac5c0c7c0c597cd167308bd9d5fe2d02bd882b0c8169728708e44702b3fa4e2652f5a4f351037ec5fb4ad34d2a8ccd2e8c763822e7ce5a7b139b70a04fe658d5cffc2d81ae6dd380cdc432b52072d137f6e3a39e136124a12832d20e0747e76980f0c115b8cd6fd2bf8855b6d357de4e147b4156cf0c2b4f54df243a4f5046e7775b74ad58ecae327b8406f6177a2ce1a6b8bad1535d3bc322ee6850c769fa5708d978ac2fbd7ad79e1a466b9580d82a2a6c3ce335c40a37346485596504aa37ef35824d91d4e8f482296e6fb10192ae8380822206e3b28607a3ee7f9f58ef49dc1f94b7ce9b5552e092c8a929d506a332914188895f94988ba80ecb2d0546f324fbfcc9d71cbdb18203195ad6d86bcbe8884690c4c145c725da13c8f8c4135e70101bd3663d32da0c8002121a8bc2d3a99df9f8bcd0f11128340505bec6328aa97d52dfe4c6078f36176ea78abfe38deef0ddac5fa005383dd3c00b17dda96c1e35e190d859a0958c23a11dd24219acab8ab3f970b834edaf4a51109652d4db2f7c8864769b9b5702fc3e622300e66f45fe6a343560c8d46b613fc55620fb285384e2f932228aef456b269ca60fc3677e3247607a378867c0661f671af5775b75db9524a33746b0c879b0796b4b73a441eba3d571e237bfc83f654a317f054e0b43b9317cfa1309d30018f12ed78c131eae241dc0635c2f8f2b16b0225ca8d7f064048d64e32c0f80b7b23c3e81b90601a22344650aa0b1c8fc53f17a43045ecf0ca00986ac960a91dc9c00147489e5b9e975ccfb72be210c490f8a9a5042fbcf0774f6723c2e37642f3f2eddb4802d88065e1b827d21f5a998da7eed9049c2891c734a678805258c9579f84501c442e01b4383492de9a6fac53a6d448192ef7023da47a288049829e1a1b83061a82b018106beb4b1c81fad320136f6cbfeb6c4919ac9f5e0611f1ca78b5789d92b3605c4c0b2cd0118b774bc343127d31344989413e067bf52385c7a2795b4c3ecfc68e27ac91e8b2c755949abb1222f614a00f6a80a92d30cedb26107c18f5767cb476024f353b32ecdf0b25d885eb0c9a5d3e11f6e2461b832d9992bfd364583ec67358c91b8d420c1150af29fd309ed37583853e8d4b92a238146da324a84daf9a443408a4647e169ef01bbc1434a2a7054a9073d2f8dd678485c9321c1046feb156f0a856539be8365cee5ffaa4d18644eb6782d2fda078f64d4a513bb532f991e361096a92f801be73d91deb674845f8d00b24d7af4c7527893f503b28d06a2fa29110f8970a96734d7dece2b25a6fd01d5e48b4319f13fc3249ade726d09aacf597ed0f2a838aa0e7fc706c1ba6a24a0c895a0685b9fef2976be0994c5bd93e3a516dcb90c2180aaf0dcebb5f6f88189ffc8b69b05ca50c91e3ae9e01f0a1d7c713fc2d504f6ae3c90cd5e93baf7085f682f7a290b39a5ca6636d342bb81e9bd3c743ca5e48cfd726e366deb5b717849b18545482762708adc54c6d21809f1ca5f7edce1439824baf349c5a71b49c73391ffc3979ebdb6263b1a16a1487dc15db8d03225b5233c4600a180b6990a7682ea3f4b8e0c01312748ec3c3e17f9da07a99235259cd54b376a36bfe6b7c60a30588e81b2a6f34b044992ec758abd62cf813527a830e0cf90481562cf59a15aff4a71b4b412d798fb7120e67f6d5784ff4b749752c780205a57a3b330d624da5e21f470afd56f03255aec1d30959f9d3975262b02d119a892e7ec0261a2eac5d8d3ef99b58928b9f196b094452a65f50d4a095e0da16178461f7ca29fe0f32f4d2ae5f35a828187474d282b1908e5bdc66738d7587100239e7a447f5eee542d170fa81bf8587aad830b745bcc10e04ce8e1f0054a07df2ecd8be071eb008b9870f2afc38c748d57ffe65b1c3e449f1b5e7feb83ff7864c593bac70e66f3d1a717e1bc718d46e9aa66b47c5f3b92a4ce8e0fa23e6a6b342eaff0cdaebb296fd580e16f2ef410e868981755dcfd0a4ea343266a89f5283eea0ae110d7404f0fb5d11c32baeb2a121e2e6fd36b85bd3d1872f782bb29d89d18081e660786002dc04668b792052c2a199af8cef3420df53b196e7fe29c448c1781786b74355ba3ac3649fd1a4fd22b8fa8dcddfe07ca1101de9fd613ca6fca1a9e3ab6f9d12dc6969a9b9d5b98b9f9461179682e43e3fa12c169e0743ed4e6f2be13812fc7117e3bf548b401375080e78a26580f62c08a977108dfb36b4edf2edac9dd60a88aceb5566431a2e80a27f08cf2fa40cd85ac02c559a5218bc8a0559b1811d41518344e816482ae36f1ee2d6efbb6e457c18260be27f74f0ed18f1c5def0ea4b7ff4f92b3395fa621463bd465346d76c9cf4c5ceb11dd8cad68288d5b8f4031c767a6dda099637e3504e8ad6a77762e76f5dc49938afaf8c01fd6f7a9839f6ec10c2c1ce32c160d97229e251f2290589498689355144caddd784a7920012bf4aa4263933a51da75f3da5ebeb95fcb06e8db1125f009ed911cca2d74c4b63a91a81b643a097dfaae97b71dce88974901f3fa6f8753f2642bf043533437f0cda4cfd1f1f6b7dd7943b7035d8664fb69b51aa1d2a8e4b12c9b47fef987d086f6f392f058e9ceea88d2702a1c87ef7b04a414a7cc80c70e490e4a6352f182371365496183a2ee93aa9037b19bc29c9df384dca171f79365ec4c0cf0fdbcb126d31bbc3ef75ed1be562cb2573493f012f70bf588aa54609630eafbd319098b16099b38c87c2ea9fe5ba30c95ba5a9fb5f646329363504ffb9c5c41f2945b41677bc87ff3579f6381fcca7c610504d1151347cf4fe471bafc8101999b7bc3e965e341ad2847e7a2e1cfe8bc23a53fa7716d54f7fd4be699293406a829981d639f82e736cc6dbc3601c5c64741daa477ef76ab5a350651c193a802104ca784bd55bc97c19cfd61640f391fb5dadb72d8cbdca8b0a08fb6e44c4bcb551fb12e5274166ccc2c5a8c5eb7cf7c6ca398a0af8f3fe0e94e66ee143d7f51e455f9326f3e961def639f2cc8b8dcf064885b1da74a4fc1b08cafd2541585ca088707a45401b9aa733775828112c9e44ddbfcaa3eaafe88b948e1c106bec66ce82f2cec07d107973259780b2a785009215aefd245876fffbc0e8c508552d5dabf713d8231b138ab8c901e9051294da76880f361ea001292ca7c6c0f84cba354580bb7afce6d47aa0bd22c5167d56025395942f5a2f1958cfb7811c162a06197b415ffc93281f41f22269bc0bc8f8897c484adc97970b81b203d4880f3ba771a0d52bcb4e088949e94810aef0df8ddaab7a4d304cc78b88110dbd2ebc8ec223913765cb3d2ecf767c84ce8a52790ee320d82c8bd8059cb5cdd58dd1c0078e4c8202ceff455284b2468bd3ebd86197aec4393060d915f2d9c9af3a86378a288325198bec081d7ee2cd98e483fd31033c63decb6da3b55ade3ff2d5ba4e6c719d56b43f2e46ede7dc0b50a37305828288be63a2f9865025520ab60d2dc9c61306e2d0a9430a04d76ee5117f6773bc18b83b0267a58b82893b8e1612b67b2600e22039fb6eaad9f590eb196b70e86a5d35c46d8608ad6cde155afcd08e5d3de3d8700fbadd5416220399ed2c0c70b887411e78c45620d4d75b177ab56c9a61370bbf1b36d6762067b18a94060741ec35fe4a543cafa517516bb9e4ba8988f758c980e66c2ee28405422b99a60ea8768b5b5fe7fa5a2b1770f7e0d5a6cf1331a922ca7ce7ecb6f5230d8b1f38c2a5b35d430e89fe3998dc7794ba8721ae4abe2c7ba6df369946e3ea211bf6349f363f05b93e7f61f274c71d4bd6ac7bb97e99cc6df9adf8db511717b5561341cbc143721b872688cceb86b767e8eda14f1a8ec867ee67c46473d0d250a928dcb9f7576ffa92a68bab51fd6199729b5dd6b9eea0fdc190cfa2c0fa3675d23b279e806d47be0d0ed885d24c9fd02c67216d3bb3617e83141d17ebbd122f599f3af2dd8d1b06998c25dc285e25baaf4e1996762e39c8048572b6b5ab7f54dca6c0c3134855ebbf63dd9013405318046cfe3dc27f1f5f1a67d6a0841b4295cbd3b46efdc4a2cb0e699facb12c45af243d80bd9ba6de3690152b99a79c311c5ec260e11cf8a7ef401a35280b4a3b62f8629f7cef2739f1b75a9730363917133fc16fc9cea7a111a9672325045ec170ed240c1634a9aadf0b5021f3d4d615db5d09463809fd7b5d519437efa2b53048f6e68f2dae64803ccccb04f1534bc6a04e2b01fbd6754ef9958d9311c9fb8fdc528bbeb1a7b5bd874de32b8f1c47d894f54bcb38622b76752bc6c58f9e30252d2b9e8cddc2f3a98ada0f69a4424b5a6765e831177c8aeb0206be1c2f04ef598fae0dc73e24ead0683ec66038f3c24f54fd63471cebb1541b0c8ae1855bfd5223344b377bda17c3aad0cb25edc6a2daab1802069e15b2647d439809cff115afbf9f3cabbc37132ec39b7f75791e2844a2873884ff7d7799d98538e1871c34dda466db60dae735f20af166a79e8e50c240f9485f32dcff251b75d3075ed91e56dcd5591a6d043d37c752612933a648486635aa5722078b7bb3a2b5f722f146e97a2e30b6f89016041bacb382319bb97e4975697994b215e1f02c5bd7b1f21e24b7e788f807b254775357c9821305ddc1b99e98f5588d57d4f570031a61c77918a3bc7f67df5240e1876b230402bb4e1f39fc0c48d6a8069b137a64b64897a562d0abc9ba3637394d7b548332fe6d7de48de36978f49d0589a976857320892e4773aac5856913831a8761523bf97b348a94ac87ccd935e3032c8d584ba2c0ddaffffd70d2bfd8dd4042386968902a7ad5e7b68f4baf76fdbc085d9744769fd7a6b531f22497ed256cfc378c04dab6bed26f1cae574aad3ba479593e614e0109e6e78d807cfca6a0fa03d0c37817a0511950731776236a780ebd17676e87d0a9301dd77731bdaa68809ae0b5ddeec225000525877c2122b195c3b9887b256971cea829a9657506ef4f98d1da4420a69586844c868bd5ca0d8a15f182b61e25bc14a2dd5c9df9b42c04433d6192ea2d802eb3a4a9f31358943b6d334ceec47dd3bdb47a7a8fc7d28490001a0f862c06f297a066dea2d9a68eb771291b1c6aa9a081ac4841cc6655291492c361cc5b5ca3cb3fda69d9de836c57c56e0617cb27277925393d9e1d40f0754ddbb6840c1c67ee18fa2e3112fac41aa96baca70f9e6bc31a34c10a4d80d5ab5165e458af8eaccec2b51a9b9bdcb23239a7e00cd435c0a826ab68f67177db36e7086dfb3de2654447fb235cc4882ae7de32e3ab73566b1649a7b7d15c4187bd4472093fd607677c1f92a061aec9ff1ebd204572d8282304dd85f748f352390dc68f31bd27b28d53ae0cc7b65632aa3da255976a98ed2136fcd89dc4f003af0ec69c498562bab6ede8c168f69b7189359c62897aabcb655f9ebd5f376e834e2f952a9dfd4c2b2c47cef5f7163957feec8d85de2d53afb13f410158fa4a3611fbcfe5f742b585f8fbbffc62ee948a2d27a4eb1dafc7d9d159991b4fbe7e08e816365a9138e2c4e6253bc1164b8fdcfbef75b36a3cd97c5cbed1469f4f0bd1cfc760ef1d4e3cd340d67a9839bc06b42bce9a0634b88bee0def0be0c51cb2fbdccc22363bb30f9f96cdf5c0cc867c8ae657228b49bd768a1eb1d2bcfe10b159635692140db1229ae47b47848df2004849c74a265d84c2e6150cd49f0656e30fa00f6b8fe87305b88ca570787b57015030ddbf420588370ec84fa9689b3b347867d3667033a7ef18975075679062dd75103c2ee0305f8005f94ea7505e8667a979906d5029d724da329a5fced6c41b93fb0393b9132b59d75135ffe62c152d068d7c6e945d721d9398576ee471fc279a7fde8fe725de498509d0450c2b9217c8b29f0a9b8e5db52d96b45461cf907abad4640e0e2d34bb9c89bca36042ef2c7d4f0dc3b296dacfe6ee4d976e5a145353315f3a954e9996c8941468e3d689b603e614fab7335555d6200483b0304aaf42ddf5116acdba96c08600eb00410ed936d15dc78c1a662964ca6651416939360cc1b1b60218031a4cafeac23f7808e747ac38c56a9c7b94d226d00add11662f7c6fde1d4d90ab358c58560474888cb0a29a8085582906c3ba6b5ce1008a1344511dabfc28e9a88179c6d099e0a983baaee869689c94d3e888ec78ab93517fb12a24c8183cf25217038c041ff065b712e176dbcf2054c943c25359fba6a59e8a337efb5991ff540bc4ab49537f63c33bceffe8d8ec1993f56fcb8f7a35bac908d04e613272a69fa44d840df11ed1a69d4483d920519d07fbbd0a5ff3c55f5b730df59b74f28cbe9ef014e943a6f2a5e281942a491882488eb959ec963af4413f0f3d5684bb1377f510ed18c16aff611c48e47489d75907e5a2342c6a8e054a2a7f6c7f589a14553aa945764040b37b90092a7c3d04ee13f65a6422e34ea96b3dbb83c1f884e43f8f50ecf9f1f9c83f08a43bd491d1e37c357b79122dca740065c8b5ca53c84cfd3895ec5bf0ac87b9188a327bb9fab424db8ed8304d8004db44f5cba171a05eac73a89ecd4e7848c2714ae480260fafef6e4afb61cf59b6c87d6e95e28a317c5ffd12480667b3b3cd693959e466bc46fcbe6564d96de9d93daf63647b24019ad284f7e27c633e191084ce63b9115f158139a1cc6b5748b19786ca0f6a4dc014fba6175f62c9ef4ab04ed95585bc4b020c479c3c3b1b5e7ad0a10993228fca09c59113314a8321a4c348b62e24eaf1234ee01ea907e03355a73f882c9da63862ef440247c38193f69c0dbdfade0627f6102f87d4de7a377e2bdf7e348b55f1f1f3cec0f516201d4da6f4149420cc236fc81f77a66f46c48b3758d03647f52f150079df566ae10ab5c5fe288037c6127f0bac12a48f6b4427d50e6de3bfa69d93701dba31da3a14cf00ef6cc7bc73f7b9f1b19afb9592baefd20fd3662413bc5144432e403beabc6b439775e8d1170246691c68ddd8e498026a114a5791df4b57c6d704d61a60ccc377e7c6cbe9576233054ba11b5c5b9b5abce54d5836edacafe143acfbe06125b23529286a48bbb39155d29056495f11ea52e95fa21e6ac229cf547e7ddff0b1d489f57f25fd4308b6ab355061ad860a585da1e445b6f662ef823e29c2a2e5d64487ba519ea436403301a88e85760c75d5436cfb17e3d54a6fd45bae9f70fe78982520093809c8c6b97db5bbf9506ff18fbcdbcae61a6068efb450b3729ff9d36e37049eeee8cd72aa15c850c261fcc49b0a653806e64fac938160b33e6dcaad76b6f795af0026366d5820f6d8b15aeb9861a87f058b439fe4e169e83fd9f9e6b22732ff6b75f9733a79c25c98daf1be2497d3bd229752098e8cfe48a6d386aa4e8abd011c4b52315fd872afc4ec2c7b2898859ea8423526cdbb4b710170859a828cc80d765389c1a883d0cf195d61d78cbf90811d63f883c42e8b7896ba16e0a7e38c6e281489c8bf6cc6c6f7d6f77ce856218dd40379a5d71538c803a96a78c6d5300cc8c91a03b3799007f02220a4b31bd869956d80c7efbce88fcb96ba0ea03122ec8592959025c7069ac07e7beb88438ef9951de98b4b96fd85a193003af79e1278fab640d03f2bce58f99163ebd751ebad97a32cc6c0b00bc5bfc57d3b83f440689e467ac11a0fccfda677159728a178d053e7e608094ae8a8916a23476a391884da06999ddac09c9ac42b246c0fcd30f25a62c2d5a797f44fba447464d9c67fdc336802ee2e242dcd8029b88e54a0e525952c2fe5a8538ee7fdc7fd65a3fda868406ba8ab5402daeb33442f4bb2a2c065076f6cea860af3576460180accac762bb6094722e57febd9ae3ff1972799584984b8ed8fc7e0fbfad505f1fd0df9bca1c400a98c86fed8d9b71bd4e09b810946ba1e752868fda2d29c5496cf36ac418ed76fef9eba9e66125f20d130c5df7452c90c710446af1a4fc7e1c22de95002b129bff545e78d9a3ca71f758ba8a5e3f71ce247ebbc61cc93b2263a764cd44ae90f2bf9efa17c5851b37bc2dbdc03c86eef927d62261c844018724e7ae727e4fe42a59269a0b71c90e46350491472ab1ad294b690b455d6593922406e57258053e3fe303630ef6910a70ac4453912970a065b837bc311e499629bb8bf0b0cb0b8bb5ff2e42418e9db9465ceeb2d4a6671035ee2f9bbd108f9b21e19af51aa4b847627e5399c4d03e2d505763242ac730286255ba8f37f2fdadc232bfeccd93a03c04206410baa8fb1bb0e8b77a32149bdc9c8e79eef266b217ffce5186bdae3ae9ef64189d00b8cbe5671cc4e9d00767f77f444ff4bde85105c1ced232911233ea38cad35d32355391df2df82dc10bd22814b519e90384b27f57d53f57194361041b47ec0369461024329b58f1e2a89674c6f0af37468a597f0b67ab4134057f2c3ee7294c719baacb9862caeb3bd75190d876cb8212da91de963cc098350326dbcc5514e8a8b855d1c7a7c790e21fb4fc5d1934ee23b09dae87dedaf4c56b5f40b89c37de341e2990bf2a1b4d9af8ea8ed930146f748acdaffab39f3817701016f9beedbc506dbb42a12fc2728429536f854e77b6add23fbeb4fa3cb3e35a24d6433d0677631f943885e107a34bb3253784d0ce9528706efaa4dea7b395dd5fdb8b2ce5b863d9b7af5a549719f1a9227beb2bc222006e58f7585cfe755be37fff0058823c5cc2829cddc64d2f20335b2aac759e68cc22edb4e57156cfc247982c00faf2c6bbe3306fa24dd9a515aa7971d1271be5fcd063e44a05f5a55fa24a9668492525cbf6d3bc8207b3bd63200f17fa428f3947b70bec2b19eeac22d17b87238a708a52d8a94922e77d9bb0095bf3ba4f6a2ca7772b5848eb2e22cc61da75047ebd2bf513c66a0599eb23aba015cc787c153aa3087eb6740f5929b1af6e8bc5e8223a3dccb2184ca49b07f7a5bebfb4f2d5833fb9d200d9ab059b2a6ad158c47bb0beea144f7db599deb829b9e3c3ba14b997cb56acafd13eaf1ffd29eeda3099c3677ccebc1dcf95c7bf359000b0f4670f716e10468f01534bd10605216a64baff153a69c12146cd011cde388986569849f3fcdf15b2c43d34f5b441fc75354bd2155f3b245e608ec2e697436768f50046db495f8c6692d0e7da2d9849c54e2b1cb1be0378e7d582874bfcc939ac1e10643086c5583ec151bc94fe16f0f67dfba347c80b57b15802271c97a171c5bd9fa66157ba57c5877c331ed3da521ed51c33eb745e3a6de0611decfbd72bb87e665905d55275c17e93ecb0c616035536bfec1d846a8d7a667a01de03e9daa50956de64ea21bfd3c8aaa22299db5d6c5408a757225e961d1d07e79cd69940d69fc82d220bb847177fcbe176398a1a0f5222edebd411fdbdec6b87a37e1f2aef462ffb1364b83d4275bec9fe30da0987603d76b4455c2ba08c3a5375e2b85477e8505a7107fe6e47eabbf0b88c04bfb5f1b46f6742f4180cc7b87a8021b7249b0e621ca2d098c5d439566c4d56bdc03a495435ddf601ef0804334582d377cf498c78decfae3e86b4c432579ad957389b87e177a85334be517d7a1d03ffac9fcde79194fcae0ce84fc972640a94b13be0230e9ed2386764bfab0fb891da34b9491fd38a62e9fb4cfcf87c7153ccd4bef81a55065196662e2191f572c764ec4777c393473084a53fdf3831d9fb4aa69bb8d1a6ac218fa000e349b05e351abbd483deedce32a8e034c87e319e27f3712c214ad739c0f47fcf5ae4460ff28b73e59ad7b16ed0d7bc73c7e5a0d734cfd2c05e77cef5f81823e7af28997be72707c908eeb8763734ccf53f76154591c0f9a07ca3351402ee523a507d0e8f35c859ff2b59319ec63d38bcf2f64483f12fa9ee2dd4d1f95e2ba8f23f84e5c76a8d815577cea5e07f94ebeada86fcbaf8627a17cddb332d1468abdaf177057d1b578a5d6b441bf2f752293f725d8032f194219600fd5ee1286ac1090ce264ee395a7dcad160c03afac0903c1e95d259fd14f03ca81f91b00aead8f1563d15ee813f59a0103d9b5b1e0375b635e5cdc52ce147a8d540d7d5d0df9b79f62c6facf7da47b7e4e215a7c7f410d9178e0a406ab0e179dd94d49ec3987d6e329e9624d9a90638e0722fe59945bb4d1a40e7a7c420af7eb9056c6a872a918c57932f1824599dcecd2f799c31836d008f0028eed9470089f2b8af98e07ebbdb9affe20c1f4e99ef60a64f66824d7ed91cf6a7643f5f40e63ce59b5d7ec5bd66e6a3d6ab07e3b14b4f4ec9138c1c9ac8d506865927d0ad1fb0dbb842b609f95ffd6cfd0538333920b4fd880aaee6a5b85dda6e2f76f2ac162acb084dfb47f3aea7d00ed11680219a3ef57e3512bae31cac38de6c6a6332d0a43fc042e45ff9278849da3d555e41c76c625d3b0dfc283b2a5b19810991b70fa1fa974e66d6fcbfc9d720bb6918e1aadbf32739c7ccdab35163615a28643ae2fe75374b484ca61e40fc3e3edca38eadb72dcb3a86030a9d03109946ca3d78a4b672a4f2d9b64a68396ca49c188a0b1d1819fa8b868f116e71ba14281ef7fd00e63886fd48e6e01a42aaee88481b9c2014b57d66d547daf410bb404979ace6ee3a772a73939543a68c389533512700c5cd28375e620f6d91012af58096dacdb2cae39a85c7a5cf31daa969635609b99bd1d6f346f5009ecfa28f3ea2c25424b99fa0b40a39e25953ebd7514aad9cf29615351c87bfac20b416ef83d2818d99dd5416c69560293d343a9951516a39b725be08f19f2444b38a1e375e9631ee91e2844a2cd994af6365d1f062da4a91507a3c37c8c3f91c33811e37cb547676ccc8b6a3994974dab2304e2393c6c0956b996fd965bb358afa9b7f6749f2a41d5204e9542ba1b6987b43a2183d40f760a8a4e634b957082f12d93ab7b8c5a81f4825f5f6f8cd73299766a8645debc693733a9a1f4fedc06b5ff0dbbf5ced8b46435017447bd2ea6e1cc2a799cbde2fbb3185db77c4699832f3cbd5350164cd8586512154d3c9b6558f59642f67620728ff2376d56804d8952cc34a321a7f3d7d97809c581faefc2ea5c4e95c2e2953914196629e22c05c3e1f968aa4e5f693a5c1669d9545d910fef2d30ebcef20c30502d95aa845d04b1f32e3f5ef43e34afccad4af813fe8f9a90aed3a930c7797fa8307dac9963961f66c12ea4db18a4909cee15a9f35d04fc430f37d65585dd23e026755feba038f00c96f70ea063b107bd454324524e178cd1f50a9acc7f946ac9b5d2b45b2665593a46eca2f102795267e354468f74ad2274f16a739f4635b6f5f6bc01a8d667eb60d8fb8e9e2e6f4f4ef0440301aaa915f2531b86e64769fcc8e2ac4fe516186cc884dd402adf8bcb5f6bf3b25aa16f1e755c63af05dba418900eb6ca2dac431848b401fd65141977704ba1391aca5e207453bb4056b9c3d5e792f284ec861fb6c2a652ce777b8f0842a4242246ed5cedc3a4bedea6c24c762feae43c75b1707f74ca7ef67d2c26f7d1dbd498e65a39fa80fb46b867f9102d42430094ac8900970299524a76b04e5ac6781a50f9e2c63eca4ed66a84ee02eb00e0d7765ae570ca25f51bd041205caaeaa63ac9c3b9298edc1f12adbf32014c33cc8ef36f020c0dce7e7edee5e3609b09fd6814a4059d4dbc7f6deaeb6b3f32a59de764a55eff431b499f83f08c5b9abbee3a638a78584e728dbd02c3ac4901aa7c154a8ba583ad2acae20edc7d053a0308948d390ba23c13b5f882dfc15d62d32bc6e441ed57715213e69c0741a0dda8e09ac051667e69adb0ccd7a650451c3f6176c026a0f0df8d4e4403ccfefe2867aaae8bcaf2606d64a47a5618194365fc48b03a09a289323549adfef7006f597756a100fd07b4cb1ea6918f68cf4df36cce0e7bc3c73ad0c81480c80de12740aa5bc0ae1e66c2f43b618b1d3bd054bca39143f9ce5c0a87d4e0801eb8af665628a6e1b873975044313fbb7e5ee4be82ec57c35ebe8fdf50c33c272ea924810dd92e49254302c6b7b4795a021dccc99eae95f871d78ea580bd7c8ec4ff610fe3df43309f24476d3f42402ef8709b18459e5a8731c2d51e8bf204b9377c34a1aee18b0662a9480584e89ae55aea6eaab3c507ee8c9f260fb327f457f329a2ddad5a175a5b3f9ad71aa0e328f43a25d91f33f959bab87a522ea733430657503235a9acdbeabd8636c60adf7f468212941f4030f57fb9586e83a6089478987efe0454d55b8bb8e4ac04d3527c4e3970e37e016c3ac56c18418ce044375fcbbc5b94a9e07504d7988e9557f850281a4751d5b80d93fcb661d3e36aea7e065eed017508fb9145953a2deced708a33e3a570e3e495631343314f4f62228c05d7a8ab22474f553cacd468e45c7e4c8e3a29ab278f7bc94e2dc282439527236501ad8d440c2a6a4488c68095cff64e5fc4d574b29e005b72506b668199a773359fa45acad8d73ae9bf10362d50fa00449839e5d1c03d2be9bf392c4e3186373b5f4268f887cefdf15a6446e30427ae96fa07dce6f60ef1344c3cee05bf7888f7d56aaa407f4984ef58e6e56bdad7374ee0387c75c676f14b4f4007394d06ab3bd6bb2ae9a81df0ac920971a35e6d4a475601f8c9f02ab20f6e830d283bc7bfb24a200445d1e88c17803a15e0483118630f2747601526e51c1da8a1e141769f4f6e173834a5ced6f99591c1ebbea794131742de0e0fa95d5ec59a0261f22fec0e2ea7c602ca1f560377a374e88c4a48f1648501f27816dee1ba7c3340adaa70b7b5f8c59128014ecd86ec93da6fca7307d9bfe32521f98d0278ef833ce6dcd251b0c609349c4a84f07ce775ec4365e86d9f65c09c9adcbcd983a28f99dc1dd81830cc8e3c2775bb6aacaf44cae31b62a91d720558c06678ab9c9a7ff12237f7a7e9a44f0cf7d51d8e0aae63d7517f0f48093f02e0e250b90025bd113b518b91ac84b72b28953482aa63e6696040b31e792fab08989d09143bcda768a392bb011baf506225df5d4a136ac9142b76e7b05a42a8af86309da7ff13aea8e33ae1f2d0529ead17b8b0f44fcdc21ddb6b5e862a0082392f8283881eb82b62acb61142074ceea1701994a27e3c637f717909e95d7f939323d4523dc75adb7afe98b8671a2f8ee73b668ef26c4e7c8bfc84e1556f4bf32f96fa2c918c3a627306df236ea0e437e2bd5641e2c1fcf16b7658c7d7f4a89fbff9bf4d0a967da3ab360762ea50da02ede9e8c585834f79c66e0553f1abfb0e0b316d4a508d96590a4a83f6ccf14766eddd7deb036d5e6f597e19576294e9ea18d9a852860aadf55f46ab601d4866cdd40e9a5c3f4eb2ec519563c39fe9a47f4272e7dd8b65969cecb994a87f1fb3e4b35c6f6dd85cd982c02d87deaa5ec2ca779392d0a86bed2150d7497058682d473a082bc955416a768612a6e858433e03364b99db69f4503e72eeb37e7d1deaf219c79fc6d4020d6131a9accf560890553ad1edc89adf042b49119d9a71de4faf64e72e814e99a13741e6d6ea6d7d837c7bfb2c588d3b6ff55eba2663348c1296b64546aa345eee79c602f96f7cb1426d32292e9aaaa713616b7c9a0461cd46394b1178e99569d0dd9048bfabda0fef1f3755d55f321aa4aa188836cb20626c4133e816ad6a6eb22e5ef81c795114865a8462f4573145ca3ef31a021ca5854d345ea3219cd7ad166c1b5b263fae3b7d3f4d27c2af1b71e3316ee84f4d7571e72d8508d6c6f26679b64291de0a3b9b1daccebd0bd014348c5c51553ec54b52db6fa7f7caef71aa8dbd4a988cb7651d28e28beda3f4cd8b1f134b788a5eb1c7eb60ddb1cfa47356a870d5b829091d1dff56d15d916e2b9c9a89b931f8dd1a5ddb3d78def2b46094d61ec9e9b16b295af0638f10ef4aba6fe89b86597c7b774df33686ff52f36d29bbe5e15bff65c780a350dd5b8976e4444a491880c96d2dc030eea2995788ec79a358f7bec8dc5e7eeabe5b4f728802fbb764dc3e419a289d23b0f24194b0b81a2d43fc825973a06885f2b917a4a594f5158a6692a80b4c79f70618e7e8537791c1fb8a1334d85d3bbb01ab06563555add1f1dc5fa5b25bb23ab7739cc7306c3fe4da1b495f13fd1e4032015bb11fb6876ce057306879c120e53db1ad30777400798ebccc450904287ea8b1ad3d59093bd0b78ffb3e82ff433ceb5e8cbf46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"08c9d255f0b0da28b06a3be54f5d33cb"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
