<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72f6cc64b494871e6e3d1882fabe55e1c9eda867b0076746d92b82238e8105d38102fbb3df2eac640896c83263372e602561a039c230cc4230990107265b8523e92acdd61ae0d401d8f5da37e35df8f33c5628957f13c1c97f709e0a33c135846a198e37c46d323b3658c2c4dedfd678fc6f383e6f22f980da22fc32a75c94189fafb805c4119556aeb61a2ede2739850f08f16209b00dc90c634ea43efe3541253527056759e2eb0956aab9117c536f845e5633fc1d4012cb52e5985f14e9db30c8484a0d4020a42e45cbac9cea6125a3a488ad5850452d89007dad399eb1074b4f7b2c59b92c82fc481292b00dac737deb903893d1c16986c6a57276c78173ff79504017b79926c293d899eadc6398326c434234fb4e3e687c8ee52953d6a1749195da18453a920994007aecfad7460f2bec2b4ffa92c98bd08bc06b9d3a2c77371956fbd81b07495eec69def32cae3d1fd05c75607f3bd06a8f955cb27d49511afa8b2de59087e4bf35010f203af423025b58f1acff7717a6677fe82ca3f60d3e3dee4d15cff6760ebf8ab37b8b478a54df86f628a53dc461983c351f33d0e1985d06a1f0fff3a7d498ca21e1cecb5a64f296a8f9841748fa5610a6380f44760df15a43a6eb50151f3ffd0e8e1e7892061afe6c3836c2191a549194a0615dab7c111affaa06069e39583ba559a11b21b7c09a944e1636e3c8bd1d345d803b48212a9a016950aa5f92f3af56ba9e43ab22c7f7e8c8bd4acbf44ff69b92d094126136c724d738760e75b65caffad05701276d7d7e9cd240f8fab446469486e1bce33afde8839780c244f768d5a883ab8ec66a6c11a913c1397030e5bab44be4ab4b48942626e7671795db858e4b49a45ba480f438619bf5c222dd98e3bfae9b6acfd252aa99ede8fbf47354fe84f5de73bd8c859daa1ec9363b01c7494012b3f1282ac1e50ebb45758ffcfb1d1c536aca5fd9c6c11fb1a70e331577d3ce8d8dcf1c97af89a7817d62b0382e3274c615e4b147c07715344260085766ba91382b291b640425af766d149b8c8ea52c2f08bc1ee006848f23c97d323409aa7ef1cc7fdcafef6bcea277c2809ad8cc98fd40eceb31ad4cdc67f954a6af5e01ebf32037de3d60a383e1d906aa555b9800e85e6fa30dde184a1f8198d2797ff08ac94baedecdc75c58c148139e75a3aab1179b2f4f9c940d8b65ac7adcf4ccef4975a95067021c4ecd8051a68f15d133248ca16295ca7bb074b8f49c9cbf824c474617c7bb2e9e5bd393d77d78a3f5ef93c73f032aaf16428c5e9dcd6bc60e586f7c7e40c0cddfa7bac5869d96554625426fb00baa5626abaeb304a353cf618180eefeba966d5f5b82c04b850d982bbd6e56d937014b806b2b53537eb37eb2e705decb8edc74bef85581d64102e91236af6731c5896a551d75e444c1955afe0114bcc6c38659b6f37aa9b6bed84844ccfbdc236e20494a9e536371f9c2b38dfbf142c5cfb9c53f2ec094b7ae23df16aea312179ca0f7dea7d0b87b846c81bca953a2b128ca75fe756108213beb68e06788e6a627f5ba81ac5762963f3d5c50932fa4b974b9af19356d42999569c3af21346e90a91c299aea58ca02c1d1e5fc4d595c60700ff8a7e6f8f27b7b4cb0543634b1cba0ed7419597719b3c391f4d95b499865d157f250ea12a79a0aa6f9d76b61720f1caff51f5b294fbfc8b023706c3f57fe38822d9b88aa28c5bf7d69a4b62cbef0ef7cc1cd375ea9ad77bcba09a6cae18df87b356a248923ea7108c794a29d36339659741b1d4ff0a48c6c5a4d25bb161cbc88468c78b58e50bdb85c572ff5b3a5b26979edbb684be59d2e962d8779a347b31b68abba1be9a1b1e1f3c2c2b406b32a796c37669e265cc39ee50f0eb95b913289db561dc906addf89eecc13ef70d4728d7f3e28e2ec54da1f18b06b07608693dfa0694a79d562574d6eaa1dc8c48e62385e6039b90c6eb317c37132efd6d61a561cd52bd61c82bc4e46432f93a67f012920b26f4321cf3c8389c1cdc50e454e03b8083a05016c0f0bc4d0b56c74067ac2e6067907f058ef73b58120d2d0463a114350830ad3b476e4a3742d058d7b0fe97ce8665c2408a93c23d3a7af0a1713211f0a534bb8d28d2adf819d13bdb343250fb461a9632303d9898cfaa28428bd9d6270f3901e24a4cdbf5360a59f423f22d06898e5e36b72d328ff2ece9d4a628bf1700350890ec7d0a289a57e7673fd940aeb8d199c4d194860c0b5ea85c9b846f6347a20c59ae0fc5a17619006f5361a7ef21b98014b1ea04242f84f98a2340918b75795fe4853ea26c3fb0ed214b9a0d37fc57750f416aaa7f69cf91dd73caa7f574c43c6579c1eabe71eb66d143bdaf6db1728e2f261c6d279f8e0442b369a42ccc6d700ed562e727022a9a6a66687c35762dc5166dfa09b0c7a98d18ee2de5ab7f4a49e6e75747515476e1311bc1b2210822e8c8c71c9df53a6574d0913638480d82c19cc349615a2aed45c44ed4b39b1e0db9c4edb07e31f7f53f3080b057342fba0a834be26382162dd94b8f65f62d7cd4e854888d524423eb712504c46e90fbe974e0945e233ab21c357f9e6cec950930c273ba2572694d47edfc06017e0379d94f4eab5ace73ff18e77e8a844a6871d85afd66a15aa1f7c461a32d4dd8fd4e5fa2646e802f973f677c5af61ec0f49ec5abe4a320a4e9b5295db278019c18c8ecfc7d832537bcfc9a14eb202f3a610e23a014931c32e34503746d8551453b4e51f29ef710e26e82b2686ec677af746564dd6e82e63b4e769e98ccce036206a65053c9fd4857631d5505b35c4008c320c515fb28f7f1d72176e007ea5c5dc2d27301ba26401076733387524c0ff48f6366d2f0c1cf8e1732016b42d1ba353842adf883515e8e9c2afba2b1566362e82bfcad15ba9c0ec0d3dc04cda36183be5865566b1647a27d5b2509812dd1993006e20c1537058fbcfb2d6f2df1b3eac4104bffcb1438d3c3d347a8e37033425405a4f49afeeec3d98cd9ecefa3e24f1abce489ef265cff198588955cce89d16b604bc042f5287af47b39e1599ca515c69ceb8943d003d2de4b31b9c4ced9a35403fa8616e0e86e1085a3734aa63343a9c926f4e1aed5be76edd84d34ea295f0907431b596451c0296bb4822f8f77f7d31b817410178a8e340961774d7a79319d1b9344ea548463a331656a5762979ddffe12a821a26af71bbeceebd18abf69d3c41d1c1790b8d34021db4cbf1831b1d4e4194aabdf386c58a9c9898aa1a24697c8f4bbe5b0694bd899f067e6a3b164cd19d6a20f0c956f735640761d4f96213936dec00b6b572169b036a6c771acc70ea32e5834344b2fb9b7bbd8a573e289637ac03ccac049dc01b35b8fa675b1b733c6fbc3124c8d3ceede3a81c615c2fdbf00dbecb547ce87d14135ebe4b1e65a58be2e6ab38f796a50d81167279d66cf12513578ea9c5497eb1ddc8e3f3763b7d33d316c8c37341db6a6a7307bf14cf44764951ff2baf92d5527ec8ec4bb4493c5d5d1d090d83da69866f9b242f306f16113f67f8e61dc5a13be9b9bdf9a1d94d84f9285d96c9fbc695d0acaac3a6f5d5b0ddd557c1e6381b463ec640b87bb53fe81e4c8f44b69538379ad4b8d7ef0baff07321a8619361a70ce896f224e72d2c24ec9f6cb6141499a9d8eb523702be465a0d95b8b3a194117b7807195fb18ce7c46bd586232ebb486120172e33b1aaa772ca6f1e3ec3fafe64a66026a1765b5288e4d7e0b16e5b8615f9749bb1e967fd5e61368ee68d7f13586e339948e4a7e4166b9342d368fcfd1b78ee0501618da955525f0cc22e873a1ff3a15f79e8dcf21c657c05a3cab3c0198ff531b0d5ca99f245f103aa06b3d3278481b3da51e60b6e406de72ae0c58b9bbafa891b4f14178bc7d73bda84cddc95da9d1892b4aa20670754a1958adb1b4a7df3943bd2c2cf780758046f628330efb61607c5ecf84da254a6932cc8f65990fe67f4ee8f8e189fe49be17c49005f08cf1c9b2fd63dfc08b0d7924999c81d56635d8bce0888a8fcb757d8830dc23a7df95bd01ecc4b4504c1502c2b5fde083fceec90ef0b466b6cf8e5b4853457678bddeb6fc7b6078ead2594c5463ac50d2bc66600c640aedbbb0643ddfce79e291268f651c38c000716433617bd9626d4e4870571da755f83b1aa688b30308001b02bfb4450e175dfd41fcc6e6c3dfd5c9896e74405a1ab3684e287f36b21f641b36253fd3b400860310a3235a78716320b7bb03edf2bf2fc49dfcc47d89e11d50fc1d2a641357e977983ec7927f58dcaac531477c7a4513fa8a78d9dbbdc39dfd0d8e92c1299f314040fe0794fc467fc7d2c53296e965f6829ecb6af163dbac83a292583531dd094304abbfeb2c044d65a293806cd8f11f59ff74f556e417208bd4836b650ab69d0eb64e604ab57f213d9b965fac3f318742ad091c0c49a8f253afd5da6c8987b9fbade0263d09040a5f8d53f732f7ec77f7975c15c8695d3552ea1a7ef2a6d35ac5cba870869b29cfde39ef4d6fdd5f7100993be5dd28fae14fadd2bda15f840b51a8916a580439a4d7fb971c4ded919c223c15d8a20fcf93acb982e64b04eaa30c3020a793ec0a93bd331f5cabf327a4a14f2fef1369bdc7e76f61f99fbed8c571323b6ddaa89404bda910c45460c5b341406c97090a1da936ca222b84537421424690079ed7dbce78a4a00e5e43af9ead624aa9abd6eb1b49462201359af373ebbf01b5f22814e681ad4d5524d2b28933d9a6df13e7d0fbefdf90a65a0cd20cf4b96262afe1151a90fa8a148c33c8692501f57ec6d74d31912449b468f45d2e856b0f3c139cea8dd1d3a18cb4f4b3a0979efc3ae7492623c1a743dcd2df360a1712b90b9685f744af74f872a9f05dae36b0877850a7cf741355f0fc5b473380ba4e03f6e4ed6f7c1b2029d9db3f946fc3d9c70948886b47e8286a76c51438a6b3e0b6dd11f221d38516139a869c2820bb0c5e95e1837966a681e9d954e34646e196c7c8848df893f1e4f93dfafd381fa67e167052fb98989ae20d71b3e3b4befb5d590ade873a57876bd4d431f8ea49b04e5bfea009acb48f791a82f0b82f9909819e3263637a522d308da6c479439f2c2efdfb8750c5034709deb11966530a76d8f9b8de669df8eaff03ce7458dcf211980018f5848e03f888c1d00097557caf650c41abe48e7d9a7542a813cea24385bebd390fdaeebf6c7da51d1cfdfb0e3c2ee0cf60ee0b921ce468cbc8df0f0fde93dc9f0bccc8917064b4799d53357ebcdf5b910ffe942516eb8032912f827eb7a223d3c38c1a9a641cce96ed881815db1579b282e84d15a48255aa1fc86d079ef9d58b051d0d891aa2b83fcd259106cd6955c54a4edbd79609b991437e0d6f31f733aff2e76fbf8d5eebc9e77d52b6561c7617c46256b671647bd4c9eb81d69e51433478ca443e7e82dd3ff5ac1acd0736e1ed40cf18f2de7b3efbefc94e9e9d6e6e3f992f069462db7df5c086fc3d715c8730aed4ca75056c66656daf2c25f956786d87612236401eb77ac4e8347ea58bde25f2c5267507ec2687f21ca1ebadff3485f4c29551cbbe5e666b72f3a7010df332dbb5d004847bf43262406db8898104ca8e702843a5b7b541f096e390750d687248d34a71dc725fccddc1e3deae9cc5806a508f28c318077c2d25eec2ea7fad23fc8e5ad5a5cf3b6109d1a09e3ae8b76e820b8734fa39aea7a3e8b3d81bd41c8d6531a2923cfde2e69a95cec4947f6afd844e6916f6b28e8091c63c200155f644c113b87d818c18a48b99548bd6ceb58cbb2ff9957880da34d72e5601a3418f251935e8e52842c92512cd527cb9059604d3db2f72a649e69b571366aa16ce8b38df4faa1e64f9cf3b19c33918715551ec30c17a92e57978d8b27c91a118f039b268e4553bdf28ef63caa6b80a57e8187fb301f74099e95e179d1999068d74e1a1447da7997adc869d2876fa602ae334c0fe744c24142136096a8c0835bef5844b683b686d00f2446049b5cd22076b212a0e65aa3ea2fce2c8e7fdbc1d03eb1a755700f57e9d1efcb988548a6adcf08ca38283a17b7252ad1c944afab9e21ba01b8a81432f80483baebc12bbcd92311cb34359398d7fae73afbf393602c9c2aa328a7c5a5eea73399b760cd516d56ccec938fc4841334e8db7f1556e959aece15e43fb80fd5ee81f36745b0d5791675b444e967e69110ea06ffffb8199c1e4db2ad6afe1518588d7bcd82a8d4c0287eb6f1904f70c77a0babac09c6ba6ee3809650548ffa75d59990f7fb1c00d52eaf871365b358f9a56ca5e15f4ded40202f5a6a6fe084572912867fe050d115cd63df723854cfcdbd959364bb1aba8e67bc376d24d54fe9af4c8c080c2fec697c4bdc302abc577ffd08620fb992b040643c10acf785b48c2dd8446f9f77ab4daee4d828097ce42c37fdc6ae93d128869cee7b05ed11672e802a53045aa0f1017dc5095238dd31065c00c84f2c85b39ea342186ae524358e016aed6b548609dea33190022de2ad4e99a1fd75de25e967454fa12da25203726f5a8287539bb357ed0857f7fd66a7a747d5f27db9c904b89283abcd10e8d4326eaddbff4da7db77fd49c3ce3efb63b74db91a7f50e8f390e2dfbe7687bf7ad63a31264ec9e9f56181c97f5e3b89dbe3cff8dcf36bf9bd654230f40f1f76a5a7845d3086022b905f015375840b8989ef99a6a9aa14bb44c540a1f934f5dda1817c164a0f33818c81b7edf3415f8d35de6e823cea0dbedaf3511c9f85b15aebecfb0c2d62e521b742f5aa927d9d1b44d540258bfb5db0818ba0675cb55a70bf1398649dfbc06394136240511435e70c5e747ebe8c9bb0066c8650af41b27ff13670d63a6ff22239a3ca2810be198662346c597be32d5f4301153e5fa862da93a6dc7d7629c54ff1a0c3b623d635a520f72c975afec1261d5406fa8cbc2c6289cce1c803962d9cb0e16e1990dcedfab3ca67a820ed79e7b7e1b6217f61eef4f2da657ea6a9b2aca59848b3e50f2b0cc92b05bfd63db8e2374b08ede96f8f5323720192b0b2b842ff7c6653d592dea0b7a9ecf9b5bc4ff72e157d360298b65f247bc6f9f486d9a68edf9787768479343d40e1fcf4f2d04bc5a1530602e10ef105533c3b5012037d6631d6ab402f31cb02cbba11063d5434fd58669b8a5c7ca40895b26dd3d0a7d2de6ed945cf2425836cd10ea9800b8a80ea5c40ecb69f285ca0b2ae46d48e67ca22fafe174a248894126b2e3544cf01a303c46f237adc684a5acdd795daa7e1d2526fe66d79c81bd3997c4d7e3f1452b0bb0116878049839d78a3b5912ddc995e390b288bca0a39ebde1397903597fa11cd7165138112a51563bb5e37d2719a29453ee7beba11da07d220db910ad7dd8101810ec1a6c6b51a5995e33338ab665ca0e0a85b02c3e9fc03e194744f094f440ffdff75eef41b12bcdfa81c43e89fdbf3304ee693f801e7ae39f49e726f62cdfbaeae9925ddd9092515a689d8826633b535bc587b98acccc2f9a04216af9f5625cb2b587794c9ee4ecc0524bc7ec41545f460ff22be64f677fa930410cd8cb18fdc8c5d5f144d7cdc658b2ade6446ae2c409c3f4eaf08dd8e57450b40aa2dc4973a66dde921327c8caac05a4766f9d9ec07f6e2e59bc85e79d9034c7032c48f56ab8e8b2c40d9e3133b0efda067156f998e7ae8ffb4ff042c877e56294ec47554613011cd4dfd64b9487bb781551a37471445cd4a82ab0a0a8fd8eec90c93304d3faea1276ba4ecf76941279aeb2aca8dcf4692b3393b6f7d081d2974c0bf6e869d2dfce43b892e495ed7c0b3999bb0e1593c5decc33ce23ffb11eafc399d202d4991dc9a16f185f47d06d84e5bf69057d106241d0a8684c69803c04dfeba1856303dbf5a77afa443d3ce3d64a404cb0d51fcd0636cbad11fa365d59f571bd05f4c7a7e44eeca4351ae9fbecdc2de217882e935af64e64c0b4e82f9075894e23d2c93529c8ba526c3b01fd92404c9abb03a9f717da68d672e7269129fdff1816d6edf5064a63dc6c63e5587830ec306c0b102197620de11a7fdcb99b515db34860564271036d25c5d1b193cea456a764e4372d4a69f6781ca0d4effa44642b237981cfdfcb30af1196af42b03b12e8f90e7dd21d6f406f81a34ee16598e5ea437b80adba0daf9bc566de6687943f5dee5620db63095c3185d2dbc2c22189a405f057df1e3ce371c3d8e6dec912a32437045de86a08b37445767fc91a5d0e8f754d2895743101ecb0db34901d16bd03dd4bf464f522963259501b435342f5102c5f140cf9a8166279998b620d3edbe1a2026e3b0ee5bec268c5b66bb469e656e981f96f28890a7e9b068338317fc4745ec53409f4f4d096b9d926aaafdf21c36c3f77fb3b8de9ab099b5be8acdeddc6fb528eb4265e83ba8c137e6c9d9a6d9d281a9b6a102f13eb8930fe37b1a39708de2daf595fa741e07bc1509abcd925e3bebfca5c0fb27565e2131833044ffc21214d72aad85b97180a0b380f2ee6b653ede5567495e53b5da92f88dd0f6dce63bbe35e2df1b6159b0eda13d2a9c0196ab3a6505e99a0ef0b0d3bb4f552ffbb687884be896b21c9bb9d73a66e95a44d8981b1eade5b95732774d8990ad5661e3832cf17b6542c8ad369a0f83cb3caf244c4c84ea4a0443450b9602dc7699164be7be151a6765236dfbb65526a15c8b36d0dfcc6db57015b245897b6b4187780cb5167ec410f2c7770ebaf63c28ce5a31260b3d80bc4fa8003860ab476be464dd8d446637ff91cce778d6565ef9918daa691bf3eccde4454912df3a770efa5ba5ee4778d23271e5a698e8e89d3f3fff912a849b273d86f0e50c7edd1dbfc97e2ef72bbf318c0c206f7d2dd1acc1574e3f5b1e47097c2fe3efda1bbe96ba9910f63d2592cd0b9c6a8cbbe130db2bf431388b2a3afb1b7c9de86ae7d08f3d7d8f2101ab9b1ede3019ecd6a40a09afa002c3414f6a4bf6c8c4a352840dd90ae1de27a7428807a41184f1a9c8adcb9b999237a5c71f64ab94a341c35d8925f1d30c1f4d352abe97cda8c1fd9cc148806fadbecb6bc9eeb9bdf67ab9de2ca18b90b83af94162d52b73de9b6d7deccbecfe5677623631c7f3693dd8fdefa4e6f644e09d2c58455c6342ec20923c1027986964db7349eff66f3a520a84f6e66eec98c9706695759df81d3c77a7cfdcb9c69b06e2572c9b6250caea43011747c3bb08833aed6aa48baedee79a15c7943a9ff6512895218e2c8d004fb539167e45c6e15cd1b96870292edd034dfbf883ae3912be7acfa6641477cc634856b9f19edba7184bd9812728443a1c77e476a43cd7550c6fe1fe56de3d196fe8167662255654bc1c6d4db9ec59d255aa2baa95e92173eda798291b1b3b78631dad72ab4dac659b434440fdfe30a39903c15d86ebe3f6224ceab41d3326d192493956e46ac036f708108e09bf6ac291cfd5d2db56b1467ac644baaee56b70c36c19aa26e7a5181511b19af1e6d957fa3d3b799f07666d03f956673f27a5a55ba7f92a42d0e6a5381cbeb5add2068667741b155627137878d9a893a0dae72d707173278b6402621f73a011412f78bdcac3d868ce6d502bf17995d0194cd93ceb3c6d014e85a5992df4643068fb0981d87babdf588bb6f5131a863ab84e771a1bf1b178f91ee2b51ce2fe181985da414db6137dd68a8d06018bf33886c690356f39ba485c3aaa6629746f6ec06b6d62f6f88a2be3503a1bad90658225abe0f5f9973880d98986140cca251058a342edebc3940568f9551f136ac5606d0c1b910dcceaef2ef583a5f1a54dc30e614a26c411b3b09ee0359efd00a74bf44efe86e3fb800c9004fb93b44448533e55cf2186cd65b927e39b0ed9d60faa1563a3124b7fee01239ecb5c40264113a0db24250b64a1db509f4ce09db2d643fc8abcf2b2a8b25e3a00cffecc1e6e448467e2a02574ee66a5c4c938a1c4f2e03d00803b07f30143427cfacd74512db574b782048c25582c9f0702de3c568a3c0b97ff9673d86c5326b27c311c9a7ea76baad3ec1392b488b42d6ce16721ed9747e8fe6889351430ef8a6f97b0c07293327a702def72ee71fe7af215f2c5ed10848cf83a02c8a96ffb1e826ca9e10b5ff3cc3eeacbafe5e7f0544fec9d67362cf5528e10df690b8c37040c39183081e41bedeb9589a79099c2ef4ba39aa83d4ffd7ab8c41b72bf9d37599286567253cda743d9a362958ea84c25e8b2d8263b498354873ef25cd9f92b9484ba6abd821bf611112ee0b8eb305e175c416798c66b290454f82a024f75c8a645a43dfbb5734bd77c48ad057115cf0f8cc9d4ee75c93a8581fc807c0950fa332dab34136f49a642b29397247b5bc5656b27df63844fda5cc30152f458855b44ed181aed06aafd84e4e4a9ce93fdb44bc8eaa93e40fe653718a62e5e3e4f22340e705dba3338fb1aa78590ae0a999292f3611c4a99567f2e8461be6c4256563851e79b17400ed12060a32ced4bb3cc04a7e3405d630faef469d36c914307c3b957ba994e054dcce44772fd4a19ea3dbbd903c7f797d20c848c4bab10720ebcf1eae0f62373384d85c4dd17db6171d2e954627bc5983660c521d4f2f8622d1fc943cb5b7d943812c04f1fd02aebb5419c4d500f5a5ebd31bdb38ac310f28782a1e6a9d6016faf0b70244a03a323a69a0ee9fff05e7c3e4575abac0ee00163ee88832fc7a8cabbea073a8bbc9a8d0340590f1bb5003e1d500855971d9be6dd451ec284290dab49aac6c2f09c8faf9dab2e764e6605064a9ad4adf72233979892a69d6a768151fdd2976aa226750a1c4f4718244871c0f3fea8d131f53865004cee8e601ce82c6b634464faf36a440a3e8765c446d22e0bb381585df6982a836a367541f75e7209d946b8bce0d76feb4ae9a09a5eabea84b62b78fc87caec5c61df1e16962c8da8311552c60109717187e35c6aecb3e393f5661e8f041f1b441e3332e7670a4dbb88d353558bcce77aed06a47b0ef0055ed92d4afdc47b547703a94f14e34ae5d7332727acc81747234024f2051e713352573bcd2ea6356a2ef0e2d7ac98daafc3b370f10a5fe8895afa684e66f0d14cb94f7d4f4a59d0f8ec2f16d7598c3a0336cb6cb941931e8daaa5c4de486422e30f3b1ad6a1474ba27b4c425478ac2e3302adb4bf119d7d431bb62468ef9d66edd3db97991455e0ef9637d8354bb7f1f9ab3d9392ccda25f7077b680cc2e76d0d88f83fba905e992cfe7939ca99892444bed6078d82acc0d5221b6b26ff2c9575fbeb2b662e485ddebb68d048904bb3a164ef029df8b01a9089c3d914149ba4372ceef3a4ede466d993c286c6a20012abfdb3382e3e0ec44f351c3d8e586da033c448f3e2cb339bc9ecddc96e3f05ee6087390c0f6f80162bfdcc1d0bef0bbce18d5af1d0f784c0cfa276d827595b44a46313183f5573b329c452cc6b3ce342a7f8a208668838692211e8c3d77c409975c7aa5d4f4eac1a5495dbc161a0d2d7a90c791607d4c5f8368cc76e38d8ed573dbeb55a81eeb13d28d09ba945af258e2be089d7857be48e51447b9895999faead859ade615bafae065f8d25476a2d754079be8ae2b6ef2928aa9375bde83becd4257db672a5e78fea551abf9a6c52d93c522f9fcd113e1eeeddcdc07332d30a07964d0dae2e59c609353485bc5217650f3bd6804bbaf3d713baf80c879ac078a196e0af97fabd8144c4fb433cb2c61a7b54c5dfe8edcbc89b06c5a22cd841bf06c7e4dd1a78b83e7f2177d03b2afe2cb76422968ac955de26ee3893e729dfd01b049e9cf770d6a2ca232d73e98010973fa2fc1d58304a19f55a65fb814caa33658439e06272b4f2f489ba9ddf6206ddd0d430248639cf1da6fdfe1998766e8256b9c7b34cc83058faf3cdaf8bbf2fe3ac421389c25c5cdd942693612396296ac6ba41dcdb7eed7f9e9d806f56c7666b490e045c7603c663aff8e2a661491ff0eda0bb56bcd00057a5260dd5aab4cc3bc56a156bbb8415ee0297a136222384f961b2d42f0bf1fd8092f4b5f2b50250ede6c19bad7d6dea763e2ea01b9e59e7e9fc859ccf97f0ac7ba028c976aa7094783c935574faa55fe5777bed92dfa1daf310340bc5d8932a3be510694d2264f033a8aac5ccf0d37dca1d186a18186f27cbac8a2b01b4b21488d75775beead3cc968495cfda08914fbc52ef38bada77b3b499bf4f60bbdf52219782c28fee2fbbe30a1f9a44692e73af4188d360b23e2726896fcd4e0ed908dce217ea7e0ba8d4aa1c191fa5d958baf646843bfd15bb29dfbc5f11c80248f5beb435c2719a235d1947bb432a7fdf64bd49bc95cfe7916db3fd8d7d36840deb4f5e2161392564d0d469357691ec38534b63caf4d0584db07cb9659bc615014c8375f5e591826f3bf820d15deef01a9ac60d8786be75f8ca34b51ddf1d95f6f77f2838d2c6e3baf806fdacddd5bdde693061584429d4e34263c0d3925df8613807650812402c2177c787efacbb5365aae954495a451181c8f85bfd1ea1fb3c5278a3e3545f6078d280d6cfd2f174dbd1e643014ef0993d41d8203d815315f73228981791a73759491af29242762172463e426b1c0df59ed185f92966c75be0be57a9dcc86feb4facdc7534fb174ef88e904e2a66179647673077a1157fa27140c25050123e4f1a65a2f43e8603bcd3c678094648413220fa16f8c8268cea8a81be8ee781ead24f258f48bdea2c95cc226dc7af7385da3ed73af7230fae626c6c72ed7bff60874081389d7b0d63fce2205b07e939fb7117ae4e6d76729c68d3d4d67673e89b5545e8b95498f2a6d1da38c7ecfe60af5d861ff0d94acf6bd3fc18aca31109f6063a9d258b9030c6c32283500edb08914c75792795fb022633758388686502ab3e7c0cf321b3f45c76677b4f1c4266c4ac3b2e34b968397f9e40f12e6a6619fd15767bcda5c345527dd4a4cfd73e1a49ec6794ade54f4005288d2dd3dc7985501beaa649f9aa42e048aff0f3f8fcbbcb1dc134217a31410b36b3dfd318ecb02a54d2b2e5e86cc996abc07d35017b5a527e2267d71258999868b926ae8f159e3b0ac3de5b3cdc80a1621da1083bdd6d9e79279a820c893a8cfea0cbaeabd5adaa9ab992fc977f1e809d3cad5eddd843384719e2113905ac9dac25a0d316ba676ece23d1e91695c73d75ad0fa24358627009d1b6f9109045f6e9db6704ecc3da8d72c8bab26e0d75c087da2d4f52c45c15a49492ae39cff1f8b2138769b44c8369dafaaa4153a80267dfba8edab5f06dc66a08c4f72403389646ddedd9502b62edca2147f943c0c94d57e02b8c1794039142374028f97c692d29aa782b313b55489ca9bbb42e6d0c6b4ddbce10813313a42b1ee7831ea97c07d5e481314eda31cd959f8cb4e21c24f04cc63c4edf628dd7ea3b205d413a52d5bece3fcc92384d8b9173ef1f85ed5c0c443e50b250cd9ae3ca280fa7f39524b18c10c3ab3672d6edeacc8cc3c96b2c8517a8bbc9195fb7a96244f1278b008580670595ba109d581f1a6be18ccfa160a740687381c17618843fa515aa51bfd9b684f47fa5315e68b3276c207630141c2a65718daf8736bda446321968c1c5ddd4e170c28905b826a3d3187cf914e6e47bbb9131bfbfc09e8c03e70ad54f6d607d42759d27db9ff54ac2464c857c1519e6376c0981c27a2efdaa702b1c2378bd3d67d13c5e657fd3e13b9cc9a5c586746dd69967fb930752ea992897e7fb51402d0a2a899f53f20d7fa17680045bc7ac13a5f386c8a6908e75645056afe52a9159143cc143711d2fb04922876530f7d5f9226956701651fa1bd3d05734cd7f397dec4b39392cedf774588f41e8eee781b47cebbb7cd7eff0a527ed9d722ab790a4ce2e4d0abc6a9c4085e4e07884d6a71b33a3a8c833423537119f93e9c4546d11cf6bce0e80b9f617195248c951d79836021f8a4e7d15e7284a2c111189452a8c652cfc6b3ab70c8ceb6b490b31ee41730b678d2dbea19b41820c306b398ff2301d5645d069522fa3f8e4542cc137bb8151c6be0e98fc3384fcdf64988ee2e13afcc4a6c8903c903f885f768831284375c58e9fc25c6cd890040b0cabc153bd91f41dbfac986da15fda1efdcea8e04caaef56d6da55a988666549133f6a13b5bf6c92d184e48f4481f9115fe56d3a379be057adb1cb9bb5ca0c1bc951d1e14f12ec72f6dcfdd0cf963ad4d0365b2958701a402bb5e439d1daa7570ce687eeee365421cefc093b37376e3d138bcc666af10ba5b6736455bbff70b0f71d12290b1a12f31acd0f46a57a38fd7d43a98566808dd747b2faacb0d9447c7e74e61fa4a01355feb620255b35bc2aa23786f59a24d9c4144b692c161600c3a211b665015756182219d137fb31a200265e4b7243097a0db2987cb9fbd2349265297888cbfa7b58d9dcbf3cee4df1934da9f27d092660c56dca443bd28589c7c9cc3910a3a446207484f28730c1a0aea008949742870958520f02aa96012b89c36784a6bd08bee9638a3e5311d57815133d03289cc8583fb80c82b7cb4c6af4358eff373ebe46c4b0cec175e7f136b6772df3c7e7bd74b7fef65053b992b93bd2f8e0ccc75227458730fa1f80432f711a7d4d585930691987f1e9d5b2269c6a99f1339f54e049ffe6862db1971e5605bb93ce18655d89fc79f71dbbf2c12fa0e62327d3c59b1690213e8025b029e67323457afecada175a58a3f0aa1219dce2f44cae2b701e3a0f53a3fed0e1142df272f2916e7a2c7860311eaf333f5c8bb3573276862a1b78cfc02dadcaaee954e1ae8e1245d37890f5e71cf9d106f2637cb6716e9a10cf55c5a63492b753d39f87b804cf04d4e5298e43a7d8593877dfa6ee0f958d01e09d61abb48f41354f5c56e8168a643d86e4d40de966cdd4f40ed87408c613d82cc7d548bd71c3336500108dbca91bab672093c72d9a798415328cbb5a87559d59cf598c1f8f3b8eb414776e342fbb300e8ad2d0fa26dd25b5bcc2dcfb190e498348bc717c3056492b171484fcc77383304cec1c1ab3abb74816848e0550804064a2ef9b2700abdf590c0e1939f1a606abe38ac3d915cb1741397ffea23ad1dfae27e72345c9f1428b550ecff64e87ea3266ddf2a2fac3da86e3a27c19f2843affe1f4d573c9f9b9a27f9af358cf64421b530a8c2f2c1ec0447e7eb031b37f2b63cc6efc397e747683474507f6c563b2d63019a98002f2c467cdd858c081826610bf466b16c9c3f92e89c0e767fe53d20094cb76a243c0ea63b0aa3e09f45edb90806fa12645d1dc13ea9f11762f44bfaeb41f2476df4c7eda886143d425453bdc30e9fb0692ae2f33af11e3975ae53cdcf4a3b8193a5e5d7b7c4c34f93f249ea675ea6c6b4d02c264caa24b56d762297b8fcd453fda9f84b44aec2b19ac3ba0d7d36d6aeeafa2004f98438293a08835a3ab35eac5e50cec325098b17b0b47a53f6708badac9b764dc0693e07e602552c5a850cd044cae0a2c8b804ef211f8b4d06963c47b68ac939864945f862c98438ef6c6dff91e8505a3379bdcdc76ddd600431043296450fe8638f7aba639417dd598bf9c6fc925ad1b230b8d14bb11fd6a70a5bee646897c06da51adcbb023d0cd46dc530b86cb6540c519c0fcc192f6bde1fe79b113aea194901009ba246e8f72b696e82ca4bb0360b9cb9e84186056028debd978d1f8d9f9175ac16d45f4d74ac2c3f7a399e3efcc717e1c8bfedb0fef015c6dcfb15e75afb63145a634e34068dfb7d0e7a63525981d20d762065e9824737197a8022c7055442bdb9c58b6b1a5d270c25572ca8d4a20d2fb9fc87fd9ea6de6692e99e879653caff0c9ed0b6e22165bb2ccd9ddc98117f7a5f9018c089f3586bccdd5556c40f39caf09dff1fc7a531f402076b2d3366532dc62a31a45e056ff7726c27eee2f647fde8cf7f5f69b065ad8cde2b67de4f311ffe68cfa7b3fea3ba6e5454381c4be7ec353c55563f040ef38b6f74f127bdb7f388955e019357eb5dd03d742379c81a9ffccd809514e3cc9d5f9f5369e99bb2ff87121ff10a11fefc57a6da409e832310f3046b9b138752bee16bd17d29efdeb2303a4ff59c24a91b424c031c5025450ff94ec54fbba5b018a9f7f840071695065efaf3ca0c7cddb4db195e9a04979a472c4a6d64e13d9f0468f44a1dca8fe8f8cdfc297c0979f48355f8672b881930f979346011af874701b7296774261742ad072f1c9c386812af4547d3fcfec75ee9eb44fc867cdb860bd0c28db62b1a06ea6265a091aab33aa9f6283bb69961c88802772617d442c5cee86e9ff3da474b4cfb07308f142264fc8c57797ef595f47ffe34365118ea63aa47e32f179b879fb53d491c7849f8cf5e9dd6f222ea6248d01818512a985bab8331f4a74449136fafc0be36f085b5ff8247f12b3c450a1cddefcf71481a89b1194fe5462074a94509e006a53ee1f854ac5b65ebfe53f9c955b0b0f040b972ac4b360e3d726426b962c96eed13f7ed77e7b1ada50de48e4e9eab3b03b13815002f42cace954aac1e45c574ca92daba07bac74489263c68a1e0bd8d2c29b139626089b8626cf5d83b3e40cae47cb3019225ef1e726c654caaf7bc911a77e12effb92f1ff8a5792b90094f86602e3ef74850f4571746de9a86c3fc3b6c01809a1ac052b1fa6e70940b6950fa1b92e111f2bfa696ebc13a99969d4652502acac6a469fc5a87b650ed178c7f68f62661e2e722037db0e08e2bd5973ed8a0caef29c24983477bab66e1ead6fc551f27f01a0d1b4ef46a0a53f32909f1df6d1b31e0df1a60a3f32a05fb2904afd1969b453ad341cebc0bac178acb1ebf53d9b73aa4c4e70094c17909f9bf48a1c21c9d151eb1083c25f040a92d03d994b8648c0a6ae2d0a4a5cf3309cd6abf5b8dd098630f0983c08eed1c4973e0d7e0303044f06901efb5ee6b2adc6b1943bb111956e91d5dcc6e3ee8660f330296b756e4f62de24c792ad60344bad1e54ff51a83431500240a2d3713f5cb7dcfa92e54d6d9ac74fd42f711a67cd955f2192853dba6b40f68433259917538bda921624a7e66b25abd3f2c759faaa30f6fb1977d9025e594997dd29328eceb29101078f4a835047d0b5b521a6fa8357cbf0f1c499d3cda727122286d4f69f1981c2fa20ee26be726751d7cb4f54a7f5407bc3678daf7318d6b2e0cb449727326f42c12208bef69e6d20256d666f89ba6b36b8e8002b6a99a4a2ec6d5cfa32f5bf4da004c20c493c741d3359702988847255be4de494a112a4bf52196990f1e3d229d7d7fe66fdd993de59894a8730c3cd9504b399fd79e8482d8cb853979518921894dd749e17c332ebc9c743c59e9e4fbd645c3a53b19cb570c07fdebf926ed43a5625a46f5731bfb3fdb7e07989e09cdfde433f12bee3e36c5fea85cf9832fe8f8ae5685eacb61a333c922c27fce7bb85e03e30d17ae33136f6c6e5bf09f95c5e4ee669537872cbe898e592072b61768be6b6bd260ecc14d50c7f58632012bc7ed214a991e9aeb272b0da5c15de13212ef092cd7af59233460e61372833b0b15a978191a28acf86aae495760f7426d978b0c5275e3c9041a0c151c927751c70866150a64401e0d7747dd044922181ddc9e829","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"0eb26d40505f1db7dc056299cb476a32"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
