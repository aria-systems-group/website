<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cbf440f17fc0565b44596ec7bd2d07320dbf9bfc5665f08a85b569024d6c57e38d64aa3ebf9ddde5f5bd0f35158c9754322b599635d051fe1371316beb11c26154e985cabd7361eed5aa5d971952601f7d2e8114a1be67d676ee6b080d1b548e4b9a8c7ccfa391fdd870668885a26c567d2c1920345640e77d6edb1fccf57216db5cc15e101e91bd9ef4535b6ca9f0ef3f298666f64f53ecb608d5261808cf06991151545ce84effd425c23d683653493591b73f76b915665b887a0ebe8e93bf07b88b46b257d1488c4e0215e013518cb8300bafe2e6b2a219235380954f24309d036c3beab4ca6211fdc03acd55d892cd109a7769de3248e113e0758d21fe31439996d6f7b3bd466c3a420bfff51f3b51ad41ee3a7e3db753d15abde763f5c23ad3a36d16bcdb9e6e8ed320b6105648824e5e463446f0832bd0c99c550360c82b938f1bdc057adfc98bdba26f78dbcf24e3e3ef13cbffd4ee26c3eb6fb94f0553e8731598c59196ebdfa597ae6485c7f796166d0f538ca7ea72097140ec50f489eecd6d6dfe77453d845977b2672ba7f4fc1ed97644824e4b2c1f1dcfae68be0f73095dae68431dc7c6caa931c94f61fb837ac17e1ef22cf6dc3fc7689995b3452f9856e3e31758866fa28161d44987e25ff98f6b059881763a95e90407c11974a8d907879ea310ad6420e8152c3db2bb9d8126f461a7c2921f5f7282b0d5ed6ef1469db5fed1897a6a1064b7c1b949b802651498247d7b45efd88da8c7e3a2e99d6ce88ddecff5d668fc716257158e46dc29c7d28773919dc97c3833ac9e4becb1fe3fa5e58f70506b722ca32f1ec48aad53289a283e6231e650e3e3a1bdad2e9a51861c6c0fcedcdc57d6c83ab81bf9831bc7f5c9b4ab90cbb92e6b83049276a95213943d56c38d1bad84da685c2245a5e97999483b9193f9d3d96996fdac7753cfb516bbb5e1c35edabb6459264e569e8822c148d28dfdba6f0528f2937dd016784e2d703ea02a4d035ff9b019df43af4c77780bcb7b0bb04146692c9ca05bbfc1afa8a49e2c06a75522c8e92a41e35056258bdee6108b49ea2c86e28f0a4dfd9dfaed866ddaed2b0ab694eeab29502a1b3545ef788c09f2f99f04181ce8d91f14029cef31c5b0a5b97d4c72ce1ac86fc54ffd00b34c32758561d37158894ba13c188dd03994564bb1bdcd87b3174f5e0f8d885189cf4a1cdc7191914c28776b26388f818546d504223eb2b76c335f234878b27ef4df17688331ae23d9e347cfa7b83377e5564efd4b5c4791de6a599557c627196a67cd7ba61e692351e4a98c4dbd165d597482186b3e88aad035a399c42d04356870b72afaf956e1396e2ba083f69df2c46e6f083f354312a7b5e1cda4a19940286670f20ba4c21968343bddb7a0042e53d021949219729b1515c798718e9902de0ed271d7fe0dd3de8a1c7d2d35324c1aaadebda51e3ccc851587ed63d82b89c742d410752681c29a7c2951251c29e09cca7c5f8839ecbf9da8d3a3e85d5d15c78e15e5875d242925cdcc462605498ad501518b2d4876eaf4bb5a8fd4c834c7723ae66ddf961d1425a29617c5120eae78586a82b8e8d1ab428438b3c53e28472b5af05e2608774443d39d920b5601c27bdf343348a6a237714f3b60718aff7571b43ce4555f95c70e9b0d39a707c53ed27f877c0033ff0e02d112f23a2e120c3345f6cce9a2b1975135e0b561b35daf2aaa33e6857d83692abf380834132267794d71311614251e4b7f9589d1a687c1c0932e299f39e0a2dbc683b5d393247cfb5a41d0a698612fcd93ebf0fdfd3c3c1a00a83891ba510b457fab9bd388a992fae662d9ee2c43a39371fd556a779e3efb6d5c23d5b43b789c3169b7778499f13d7745fcd579b3b1bde601bf1bed7e1f57854ec2c701c578fbbaec003362d88c0ef6fff7c6cc80c0331074112c6f52a9111ce77aefa6837513e3f28a2800f29a0833429900460042a59838332a1b84b9929c9649a839aea596599fe6b011e8a41ddac3a498310f91c160e7ea36074dc4a41a829c9656c18f1db84736f808afafcb8ad23e380f6e0c67caa6fda47ca2626157409bba549e2e7d1c43cbc2151e84ca101912dc6b4378c579178ad44c1c03ecf589e93c11c3b44262b79cddd4794b9013069ad4c9a64c52c1ec2b67fdc0057e54ea67c70e1d86beb7be41697bae1aed5230aecd40af88184c667ac4099ade1cb07bd64cf7baae22526589ff19c65abad1b37217ab976a4d3cc2c2e84bda22c6e6a2238cb50ba2e7858e040ea065c8214ee07942520c844419d9e04b914e71c9cda5ed19de2248270f252d19fa0ad6fad7d3359605bec7fa6a893b58a9eb60198d3a37d27d85c3648090698067d1056d8d9456c9d8684f78bdaf522cb93e4f3c3d2d9c3872ca943dc76174e7183a2155119c73b5cf22d4f06ec3c90d7f621087655a6b1a6d7695078bdf9973a174891e785b22dd5a4fe45ebdc6bf5b2cd4edc1c97f9e993745844f5527eb9aa0bc0baf469299051dbe8d2250ae06753c4c7401a5246e0a473f39006818fe9b98f88221922d70593cb3e06f83dbd967976a7e7d62abc740374b577841354727b3d0e7b2fef7be9e7106143364c1a37fc228baf37ea50a0fd1596da8627cd290ca5673db42cc064097c2b2dac8460fb88a9f987b2916ff2fe93c6e4c5b58b45cd31d938f421f4ba3cba935490c82007a0040f1548f2aced3a64bbfe298df54903ea46d489a8ee2631cde41a90130266d8967c4d3b13c3400b5bce50550b7725ae2486b803b70d5b32875f675e5b6b674e04550b48f366e92ed045e79ec14a08d0d55af1dc60ae4b30ef68fe9ceb02f873397a99ffff6ada96860773202c9d615ed3e24ecef3bef2725f32082f6160bd86610cc2c6c79b406c1458eefe71973c81cfd8ad717d1b610fa8a74823795fca2ce02b17ba3b04d7f5d871253936ad5385937b69412b19d52a0f2119bdae71584f60b34a573210b2867ef1827de551eeca7168fc929f4c6612444454ae9c1a0b4d12f2123c5ec495e17e2e591ecf0cec90cebc90afdfff6b556adde0dc9f42f2ba08d973566e479d3f5f110ceb5d93839820af909ae6ae35662d24309fc104f7089f26bdded97502ef72b2db3aae093dad9ceac14fa4c41482b6f6f0177f710ab5f341171d5075fa015bb893eb17db8118d0068a7e7cc6a094b44357ed2afb27a3de718575075fee1b6c264f48dc356f9e698a416713b894d01ef295c2f661efa76280a653285555eb6dfbc88617b78e22d7a990a48bf241d719f0f4a67ec202499b43cf62afba0fee93dd3a90c96b5ae35f32f01831cac4567059465920a6f06956734d7b68b8c1746eff018e37ee7920f3b50d87863db8887fa2a4820bb571501b23fa36c7bcde4f5e50f14f23c96ac897594a3a99cee46c6a590ba96049067756eaff2d1a3ff6f27fa831574c688e0ee0fe8681129efe3d6e1345a2492c5b8368932180245da11021e62c1156228d9a0a2dbbfdfba681ead254d48b28d7c48ef4250022cf04febd2c9e99dffa337f0f5f021d15cce522e00be157d47d305cd0d46b21f0de61421aa714992c2509436fdfa5e44fa8613bedaf18d9e8fce264aa2c7364103425c1416ba5757ca0ede9cd09245ffc1f425198a365e56edf6b53e6063dccc9b0a2596723034d57ec508efe59f0cd281cfe9a4f6f1f47259292fb398f76e42a4cf0f63108c9661ce94e50109fcbc028515e25b9fb5d84d1467c5c24be111556508039b0bb13c58bd0f6157dc886d4adbe581a8e54a64a6d9be13e01a0072019c7bd4a10a1faa73d73d8b1afba6ee7d705ab70a2eba03d1aee246386b0dada77dc590c5c00b399d9a90f2d4ffacf38f6e32bd86755d763eb7c5fc55f06393b40623dfb2f3fb49d48a5aa9d028ac03f9ae2009e135ad36cf3347bbb019cacf861ce6bb993614259247caa2effb0e50aa348f01c5551b44723b00ab98632d2a34c9663e6de9a6d840ac7fa58fede6710f6b8823ecb88a2388355f10d30f4503d0c174f4207a7399591760b69f45e1a605ceaa915175794afbb7e4cac66e9e4424fd7d7d85cf82ae27d0e65ecd6846af18ab9bef8f5c0be283f9ac2b66194e7dcdb70c967869393b65a15a1def6b6dec01ba86441ab5daa0cf198170dabe41016976420dc7266c943f9ca9da723df96a458536e0e81f14a245c323f0c479188b130c956ca2e32062a6cc3a76b1fbaadcf12d02a4116b8a405d40baeaf2808b2026b33447a95503f7ad309a7411ee637f2573e9266b3a3882ffaa8d263725eac63b78ab035910e9b1bf575e555659347961567ce5604f626096a7088ce6c94f7956a21099e653bcffded80b63eea0cf8ea1a862c222b536d6a10975760ecb98f412a7124cb91f718e9a8757a513a5411fcd99728ef763451e4f9bab817172e41eb01ed65017a7ea1343689e05c75d392d0f04c1a4c2c96855f996136916bbecf686e0b89df063a21f05bff564678f4defbf37f8da63376185add34dffcd1b9feababf588c51843a3b0d0d89e46b2d372711a422b28617341cc406039a26ab1d799b1c9afe719d106985f9d32f3e92160ac5df1db4c90affc41c2a1f3ddeffc2d48bcd4ecf770a6de3ad53e085e7ee53e122253a5cbfd50fcf6f0e17a52ed870ed1019a64121091c8dc88f34f1f922d0f50d5bc1aa9566c09765376b24a42c7cdafc93607fd69301e198acd76784df5afb949f2a5f7afcdabb8d380a702f26785d58f5957b7dc0a1bf7b25d9bdf00d6c6376afd1f5e80459b9b3b573d0f02fb5b6f113d0e484e28d29dbf07e1695b7e024b298f36610c79495211d3a7e037a2056fe22decfa4176fc7dadcf9e0ce9de4eb3bf6950396aa5a8fec8ac2435f488ad7238d3db2aaff85be97027042c16b928f6d0b7f6ccef958ace88211992a53cd9080688c3615f8cc1027da9d28e39b07972d8cafbdaa3eb895deb7e04aa3e9c8f3664d66ba57f1bfe94daaea73ec069ba023e4b0d47d3efe3835ec742a7f8d4c14ccc79d6574d7bd68fc63f3897efe6c91aa9f12a4d43baa935f29a85b0c4ae2dc92d2a5b187a66b6362cc4affa3cf612599de2a4f5315d101f34b52793c59504c48e664ed939cbc183abbcb972c0db2f08568f02fd06cdc6fa4694fa29e273cf29f8ad177786681b9e101d5cebd96e34ec629d00f257a1d26cc6d09a4f3cda6c4bff85716f86246a4736fdf851f26fc242cf5977fbf8da4972206873a53901b058985b336691882210ac620758e03e671548b50c613e3f57688dcaadc4210e092eb3032368c3a97dc2a684616e67fdf204ab225a294575df890d2de16d39879322c3eca1922cedac5c3ca3fa46a3da74001b685210350762263692542f744ff8d1f0152c9213f53295c837eb9ba2d0e41cc334764a4836ab7d4a28f49054f3430a671a2201788cd82333c1f56af677aac667479ec97910bf33cf17fb91d5f9edfdc131c495fa6e6ddc3a8e926b19d3d1aa98d221f3b2ba97cd8f0d374864a3cc0eb81f167c49be76e8fd7680ba7db561508b56276be6008ff68e631a5d1e3032b8f7e276835df98ddd39a54e0e65bdf673e3d89b9f032797f2a6b75d74a07e058f8005a60694629a9b5931f271ce2e7d072f75427e47e2fe06a7e8f5cfca5497d2fc5be5620653f9d9445627fd2b955d8ed25150b8e2a034186d6521c6287487f5391f79b37946f5798c2208c2e8922c25a45e43db9a7a9ef42892fa277683191e4356b97acc4f056c3d67750d029e265a921a3c90229472da3c83d03e408aca2a9eb6ddcdccd3ba10963037b37c994f00d4e1eb75e93b1837db60b533bda1069ef67fc9086e2333ea65b13347c360f73af6f90703c78424501d61f123f94e994b2dae5a402849bc59b321b7f7722deb69c6589e21d7d8fb41a76f1fba62214c124f40698ed65eb24d6ec5113e2c0578980288395d7406507e7f48c63bc780fff665572ce84269c6509fe1bf72f00e09efe088e6b1be601f352d6739be4e1bf520c208594a20bd76e2756da16300536758ffe90036718bcd557bc70966bef93fe97b1367c4853e08cf0d30502420b85f207fdbb750f32ebcc3ab215096aacf4306ffd40c1cdac0d31251269d404b78a7085d7d830eedf437667d2676a73abb28f73233c805c7e99ea9ad6628e2a540cbb63b4098748d0c1f817ec0b78cc2ec2b77ef004919b56558b296069528097ec7a26e3e533fb0dca66d107c6adc41abad84d229e02358ae257d1e6fdf17161d25c5c70a21bc21fb832a1cd947c92a481a93e0d8bcf68f0be2bb3e4d3b91d9befbd7c2016f07f3cb8095c7704b1dba25ffd37405afa3c64d3dea5522671151b796c8a9a476a9ba2d6c98071c7b4e8c5dbb95dbbcad6c92a5f1fb30c5c9cf82f22d225ca2c29e5a86d23cbab43543666e84de5cb8bb11dadfdf87ed8459dd3adceb5e7bbdaf530b5cf753203699c10f3c46b3a4f06d63445fdbb18379d42e91d31322d0670d963cfe142eeb55e7924fcfd45aa69e7e3b5ba437feb02eac19383650de3b0d8e84ea94a47cd47cd3182148cec04ed9733ccc4cd782c3e1921536e1a9aef83531cd92bdaa6409965bff0d1b63660d73708c18c7c1b90321caa683514e9abb352f2f280cb480d05d766ab69e99c5252db86f861a962184fb05d41b8b01ae46484ab4ec2936f6aa14b7bdb8156366d0df5e2d948fcdfd4f8cc0c684024bca757aec36b87e02aae99889cfd1d3c2b9eb55d24b512566685e94ef7f3d08851308a341a6782d190123ff21bbe5f5106b47c939bfe148fbce6c6471c1845cf4cc09e0529701d4fcd97db130305ed3338b7615f3dab5a17a09dd0e16fb7dae12fce45062f1d94d986f47fec7ddc9d383b54b4c2bd99230ed7c3cbfbdfa03be15acb925980a74de122c57aff1a3b2acadb47ffc9af1686bc924e00f5676b694371c7499e9732c07a62530754b6002a5490091a83185ec30ecd6865bddc19f93fa09f23d0df9d8abe6f681cc9eba46ed514e9a8742c63539f2550dca1c0f8b4ee45f62c29aa399461c7379d464215106965ce309239d9b588137544f0d6856c5bd7d6556d5ae4237b27b710c3c208405ea5c8181a4cb9677d92e5e09e37cf1efd54b7c6c3bc78c01e1940a4be1f2010efe048fbe01e58eaedda8a051b327b135c1ea557762fd703c5f7c95ac82ef3adeeff6e6f31be9dd20317667662f23c6283c765cb28021df14c689c93a3ca8a056180d33e097c188a0026262ea28f40a7a36ed3bcd66a718cc2def98ce5b42ec2a27bd42fa38ad61e4ab2b3491f4c1618eef870b6085ef87f101172fef69e1377c04b72890c96083f29fbb84131e8facf99fc9d45ed1e7e667944c16636f9531c1386f6952631fd7c8f83fac89960bbbb17b140ce5b16b7399e06b0411fd9e92ad66a26427b1a378ede1a227ec19d51598db0b5c8f50cbb49bb8f0f75c487f18a95fc7ff94c7e08b744b355b19a67c87f55c7066a0290e7b9e2c8a114fc126d40f649307c78f39532e7f3af61e66a5923be91c28c02419ca046830897d950a7f5aaad2c7f92b24e83f2289f7827be7536cc39cbdf61e1bae245e332fa50342c351aba4654cdd3e2e247560a43297b521181bcdbf621af607380fd8cabfd3d28bf40e13b9de589f5b463a559d20df47781a5ceec2d8e57bc51ef200d4fa2265e5a9826883eacfd35903fa67b28cf53456f53bfd96b754e8b3fda79bf24a1eb2080f91657dca06135fefebbb1c6e5e0b186609966b6a6d0a2874bae673b0548cc27c557b13ffccd9c40f83f5fa6ef123c2c9baa696f9f934867876d02afacf35fca6daa130aa36ce387a206f2b6ffaffeb93453e9b8a258bdfccc737c037c0b7424fb326052e9d547061168c7a25940df10dbadfe47654a181215da22664376fddc315b95240d1c267486901506cd8d88299484c1ef7d1bd292567a534ca358149643ce35aa4cff8a0791cfaebb9ef116aa9a5a4d5733af036f26f31523a0ef4436814e8c68b1c6d69b3274585a8aea0e88641b6611606f76bb23127f55a48f9f9f375588bbc236ae8218b484b3b74c42a33a5c3f8aad67b0ac956b0494afa85399bd654808d095f58187f14d94b91279f9a7c8bf299344fde9c93135984046b6bc5a8e1b3e862d719b0809149f9f692b9f9d8bee8b80574bae6fd4af30dd3d32bb76fdac8d6931515e249052e363291a38148480719591b10066f98e586d740d622777da3a99b5b3e02e4a8380a94e2ececffeb8fd1f7fc293f15088bc6276f581059f15f485c3e85635ede1b1eb53073957cd3023332f88a459fd3448202e95fc70afd846f4e30dabbeae3dd286a9b50e4b9dfff5bc642de0ec378f862b5dc59f1992ef9160e0de9e8b49f3ed4eed7b6462a787cfff55decb8cef7f896f810ad8e311b6422dc912980b9d029f3d127e32e11eb3bb6e93afcc95dcd1b77d32834d2e04289a6bc07969f314b6e326bccd56ef961ff9ab24daf46e69da407bb065539301f290251e0dcce74a53cd814bb19ce0e2a926b20a15aa568bd51b2e685ce0ba922f2e17e7d40cfa77bafd26cfdcd7cb3fc5e372879a901499d28a56716c6f96c1ae16b74be257248ae51139c827cd7228ee87a2d530b1750f447c9c300becd86a3d9647d80c3db827c77897f7794c9fd9ab3e3b65dee7db787f71a4be00f5708d469e8e97f9814fd94e617c8c01b8f54b69b94de3319776a1ab7889db514f0b6fe7004681d28b58949dd0ac3df2026326ba066008ffe02147b4818c63ab98d5a4e993df5cc561a96b137dcb35f99341721167877c15e45152a7cc5fa4569252bf1ad5be7c5a4301e9362a0a7b3b74a54133190d8a14a9adac7550a3ae6e5d979c32287460988da206cd172c531578a8ab263cf1821a108e45dd5bc44bfba89150bc36e72058e2bf60ebdf2e48b85b19d3ae8382b48d4f45245d176a681cb3021bb8e2bfa3783d2228ce1cc962e4eb7875a7681c874d03219235cb15d1f64a5ba2abf189ea36059852cc6f50f054c17b649eea3f65ad596837a9a5515fa534cc7c10e9b6d55ccb2605deff613dc55cf80b38d10a96b269344ee5e6c82fb3a7d99ded04e378cd8ca72e32f74885bd8f7833af662621ae47568d5ac6137948cb23c78a354508811b26fa423d00f6aeeee4295425162ba252f982c7df896acf00bd9daf8ecb8ff6185a396c76290c656562d96e2a94b18bc126ed0328613abdd4b740e25bd37dce14099c347a05be32ef46da422fc0347ff47c04c109a2052083b04c4d03a4417197d2becc7f2f017e788cfbad14c03231a9c07e94a6156196b45c1a7dd927d9f131e0c91bf8c993bc1fe65c5d5e0a83abd45ad480dd40391722232d016518de475532d9a5fd718dd8c886fd36a468993faa3269058f5de203193e54c8a5cbb1864552f12ab9e332594fb92b8859d3e35ced4e06e1fbd49849351002ebe5a5e6d30a5fa30be7377d81c399cc3a394e5b7a52024502406a5d88e8a6f41e34ec5c6ab53256512b111dfafd3df5bea0fe701da24136a1c3365e50b31dc0d6d8127d2a69c71e398c8a0a4afde00a327ffaec8e6adb6a34c52e1a200ee0633fd8ad60a4e6ab67c50518f1b5add4b5bfd49eabcd21068f2c5b4054e321de9d0416a44b83f0786790cad4a0fe9d85c3cf083e209f2ef2a59bf6f66e03ab934bbbdd3a38e55587519c306dc8ba314d7e277102f18e3ed467345a8dc4575f62e61ff039260218bd8fb1a43980ae68f9df73eef8d39aabe0c7da4ae086d63004cac97ec342791a3b9d2350ad7962a5dcc9d975623fa3e97176a31aa421949fb6043f4091d72d12c551c8ef5002bcd6c5f1d201e56b698c98a137d09ec7d002de8a4b047934e140add62a03bcbf6063f9305ec0a36542f133e24ce3432849f3a7bd28d4c3c44e8d02ecc1e6b11bdb4a10f6acf0a6b6bb9425342709126eb2aa1991849a0f87fc838b5836ea75dedbab1430930fcf888d13bc698197d4564eb8b4b7bb5d5634af4c83d6b25dfda51addac22fb585fb75cc169d46b9434c43b49ea3a7545d2845468c1b3855ae7aecd23b5897b6c5a52ab0b94aade356195d7bf19cd7ccae0955207802389dad4dea40e4a68158f9bfaab6fa9fe5c33c811b70448357ff9cd30048aa2738b87ae96c7532965dd27dfcf2d5b4956daccde68a9b1aee52cd2f77387ab9e0027bfa19a5d1399d85cf211630fb37f2cf9830eeeddd9b5fb0aec6c52c78744e4ebcb16d186295574c4d3de7e0df761c474af054de7b0b15a5303a7195aa259e89cce3f40fa84d686ffffe08171f1ee26bc39e7f0aa51df99f62681c4dc592be0002ff09a840000595ba38a2c6a43eceef2ce69e0333deddd29fe6ab50330ce3814b8ed9073665cb092da41af4cba4f0849dcafeb8285ec6de281a93cf73713146f1cf2c4593240347697dbf73eece50cb38541510fe965333b14c5ec97420c33c5b150a7f7962c70e373c9a073bb2dd2896c332432636901b779e2c26ed9a0e02706da125502cb358635dde4983d5e02fbcf856642f96b631ae3cee2412036d1dfa3da0caabff6610d9514cba96d8bca13f1539ecce28be8d2c2ef279d49d4b61ea4bfae1e2fba02f37546b46acecc49c58f91fae2e4930686f5c8ca398e6b31f6d5698b8e6a4860977786f6af40e2101e0c29e9c19626cb52138e375429e6f9cea887884c66d0b5a31d05f8da4b86da9c31a5be8684c249c27e05b8b81872de7b777273862a30f90e107236a06f08c93869cf342bc3291e16c025c19ec47996865b245c9aa6b52b7a493ed358d347976d9b668fa5d42566cad84b847d557b1697fc7327485f42f0abf53f3f0e2c25c003ccfb3767c58ea7d2950e66225547df3dbfa4b5c535dce0aecb814eb540ef184e29be492e53a29989d92992afdbd8f3ff5b478cee39c2952cb255bb6e4e3abc86b41224d944fe2cb2a96b7b3b9172ef3dcea612e8f09494faaeb119b054be33558dcd194098b639426fdd6c62d33e60efa46a9d4898325243676d07b66112f9968101193772dcaefb6ebfae49a52de32dcca11732d008e154b3d7938192f96cbb22b8a84fd811d03e519738e90031b63c5f081a5e71258b29a340ea2cfa92ec07d470eb6e456960e1c4e042458d6f0c8d9cbf3acf2561ef92a81961b52c0a9b6bc3172dbc287c9bc452c609ddeaf56dc10099a8e220a9dfd11aa2ac56459a412aa536f3590adad7752effce72ccbf153ef6efaefd031c4751e4b78aef93ca9fd275cb523fa83c7f47b8e50e7cb654e93dcee70fe07bb170cca475aa254396c16059ba96e513f8fa41853cabe827f30704ee02f01d347332f4e5b54512b3332af005133da4fe3995ac7d59d167ee48d5714a31ef010623fbbc322e2ef7e7604506e6a5698c7283ad473566a6c87d35eb43c39a02e3d3a018dcf6590cb2ec1a874a6c7a517aab2f4a206ef24ce68525bb6bf6d3a3540f354dc25af154164d822ecc9311c549ee4c164382f1647a70494c2c402cfd618390f3c7f441f14fe18646628b28c18a4f66580a1077b828b4f28b2b74a405d120b2d576b70ce09458edf7d1833c6d983cbec35b9df68c504cef3db260ce027122b62b336ab7fd151122036a426628d61af7e5668171ca64df3e6968dca5b03f881d715512172b20ac246c87b68657772967d5e84791fd9b04188893377f50c36e2460588db77aedeeda725ee56ba614c2dff5091b37839dcc0aca788f9459a4d1a7778aad4506d6520e780381c5edc5071c5083d1cbc51867caa94fcc1a69dfa24e91e07a4bf05b60735be215eb0573c6063b85725fea7dcb022117085446286ccd63cf82e9384998a795a415d746b2e92dbb0baf5307154acfbeca871f2f6a8303e08d603a3fd55cccc2953265325114967ca6104f06c48fe117e6f24472ea5de9d413ea26d8f5f06ca846c49a5311f2383c0f97066b7b8f652200d956c237340d2ab5c2c7d7a4e6b059d03d7ab8200f76340c10a864a2ba65f1895ef424186eacf012f4848d524ba289c43af44656ecec4f65de5e59d02b8e8c986ec787c6cedc200ec9205622570aa6422fcc8616d6ad61b163505092add8154f43af5813dd0b482fd12c3bb8b2c41078100ed1c31802793215d60c2cd5d279e03ac850c65d4586f752fd84c36201564bf8e06afffa21bf99b0d8d44b88195a176d627ed6b0c68dddb49395c2e77ce7c588bedbc9479434dc793de0418deb11f9bb1b608500cbd137613e53fd2e533547fdb54608a484ae4361697a0cd5571a129065b2f1b12b6d30a261b38bfa097aff5f28354b4d932194a06877ed63d2bea3c7cc7a956e92ea38a1e8d0c4857de0ac7e93c6c840aab5c98dfbdd9a6a3e45c930ee3cd39db0d713577a8feb347ff4ec52cb10f8eca88216855c4111420bdf448ac7e2c15616e537043a8f7fc1eba081c2950185cfe5e3eadd18d00a5477c87cb0f6b9874dcc27b8abfd368b653d737f3eaa76ef23d0b9eaccba0f7b4ddba5e4ec97d4e8702aca6d3448af81104f36178cb186b9450490b3402f0bb4f359e3ad622e8dcf306da6cd0366a4328d6e630c7f0e6298909038b90942da94ef8e62c64403db5a35a307ac242fbc85a55b6d417493a317743b4f53f0273a78ca019cf0c5e985711cfbead9380c2ef6494ba32da8e1dcddc71766484a29fb8b5911a5b68b4c46e93dbff5d4f9717709dbd41ef5a5832c68fb5628d64b637b287c9be6517c336dd51651d7df0f9a2d778cf3c6ab843322ae329df226aa3b0fbc447abb915b92e5ac35d4e516052527e07e922875b58e70c1423b6f9fcd6a9f73bd0708ee2b0165a7b02a66a6d7c68bb8808e47e093f15949c583eb6a346f7443a63b34ff5725c183664efaee684c1a7e4fe8eba4260644368c08e3bbfc651019f83ac7a03c9e39eb82367e7249259e81529d0c626865ef4ef190a03c0a6b2d8a705b0112cb34947fb24c05847eae61a5f2f32ef51495303748cfa527f72ad0d4d5e428d75b5af0fc720daae3a1608338e7631b220e0e87620cb62341ac3b75913412606c964b6bec80d270da4edd3b93b8e89003a2d449d5f47913fb5761ae03e76c352a38917cae3fbbb20fc7b101ed672389870951685c3af3c16dec923af314759456470ab87457e0db669b08de735f1f5e1054f1045d0ff522e85205465806b29e3e7bd5dd84ce57947df610a27d8c8c0d199a807b6d96c744ec9c032390b3ac9056189354608e45197bf186e5707e3414c2bab634664042142dfae934c109e22b29ab1f22271bc1a6ff92adfc5d880dac3faa2be5b996e28bb3daf9234dd8f1303c40b82e779c54c9aec3ab037cbdd42dda3dd2fe8df8865cfd7fda8b6b67076988d999936232946bda0e89fed8d3e5eb35e3fd218913e7ff6b37d6802f0b0f881af8e8dece395dfa2db4758f844fcb610025b9c1b9fcd2ec0583ae1b970fe5ade538388ea4943c4dddab73f6c4751cdd02ea5781babd3a2092d466b0b7cef599120b2c8d03a918a092cf0bd9e49a0f98afc8fd02c08bf0e16553ea469cd8a90ff4132d0c40d51503d6676d516b39c26f3c6db00bcc63a759277bea3359bf7f6f6b19ffae1062c48f7aebae9f6ebb12be09a30870ab4e46687581fe313cd40acaa615d2008600be67e36a83f7b63bda76e29b8e70613aa3183e4243f479f8279dae809ac6ea7543af0dd0fcf6d055ee78798621626e2439772b037d7f5208a1889bb81ed677f566c03bb4da6b7b3bf7808e1209f5c0d38fdd2babcb819af001b006f7799298c494aae9747a50ad50f3c4cd6ed3429bfd7bbd014d43ea2d6350a06cadf18cfd05c9ffc3dc7a7d2855b3f3fa678ccc27dd440d6e0d393c219bdb229e220a1f21e622c81289a71c44309e1fe8cae7a601d6eab8102bf409c316ef16deb2e7d60326c6f10a1ce6bc7e1653c1f8e72627a0ce1f3124497b89f620c915cb938c354fbca84bf5ed0c5b8c002605904f59343ec86e590126276b4075e75bcb264448e548b87cd76868335e20db91ad81ba0c565515f13305965c9151535176de933459c29e2eae0f05d2e68ec0c007ba00be33c77b432d3adbc6056552afbf54d12595bdb67ce271ad5a22e15ce22d9b9418cab7a548ed3e45e6ae1f48ac4ed1a610f0ffdde22f0dfa87e8d8536fcc1a09522db3f6507b8bb80647bde48dd7382bd96076b94461bd358b4f85a707fa96398d7cd7efe793a37c1f092794a4c78f0a78167e36ec3db5f89a34e7e46000709af1bf9b5844043304dc21257a96e76126c356b411d88713bccca766dfe7cd5b84108d6e6b5b769c571bd27e0a11bfe58f1ec716888954ff0ad5690fdd6a8cda1ce490fc273b0df25185c6c9382cf42f2bcfc557fc7acfa74f2138ebd94e1bd7d044eaebdeda69c7764aea59af4db3ffb88c934a524a9a6ca452a19936bb1b9b07a5cf8b3dd769144bd47ba7a7acf8444ddd9e05b45af77681584f063a3399b24d998f69fbd0c8ada4ea50066e695d00f1baaae973781543a3d076ded23dd1b4c8a0b5671a9987779aae26efb07778b7677f72a64113fc51903aa3d1a0ca9e01a4c9853a074400b624a22b8e0fe933fcafbde6b9fbf285525df5c167f90731a6cca16cb5977e29989383884f57c75fbd05ef711f1222a29245d0e00d0cd4995af9a0a3689864f19d965686060575a53a4a2dc5cd84690d45cf2382dd36a5de04c6ab4d3668cb2b6a7c221b5204e296690aa9d541f79b4f2b1892740026a719666e9ddfccb6af8591f970b23cf09258712ae7083316adaa556df374ed1a569a602d2fede1c00ce0c667b072c089ad5aca3d65858383afe17b2bb8c7e36ac5732008350bc635bceeba3acef646d548723aea24bb3eae5e9928d8657baeac1d27b279b60fee939f4f5ad5751346d2fd698b60569915bb4fbe78502fb0a6dd9dcb6aa923e347c304ae7b3d3748e02ad0ffb41148147970e8bcb63e865f9b769ca90307499db2871f8f732a4dc834658d62c111157e5a68c8cec9bddf2ab434fe1ab6818732b2a8da7f47cadf562bb3d022ea676dce1e5a5f5f7e642301f2eee9060b5b7cce67d5139f1162970ca605357ae90dec7f55ba6e50c1fa1760c789a45306862880a5095a2ed9ffe9617a5d41b948e75fd1dd66116a5cf13f63e06befd6c1b01d95b479c95727b90a2c53390e299b8712131397f1affd72257aff2d3e983dacba7589b9d43ea1828db006c64ec237458491755b210b7ce3d91e9775cf7892ddc24fe248f6d55aa9da82947844b1897da4b5c2b4584e219e84aae8938337414a409ed01c965c78d6e805073fb162eb157f1b878f19cb42e27f27fe284ad0fd1a3369ee3ab583518bd551e1d3796d6a01066e976d22dc39ba5001af6fe340b021f0eea00b0b465947a5798122514dd1ea3e495bbc2b892ecde233ecb08e1ad78d5ca588d11f2fcfaae5ee1d51ceac0116b8a7a65eddcb84754ce3b0385ae6e915da7533c39d026681bf6024134c6090faa33181f274f9abe8e5d7f7b5f10f0158bb248abf8898e509e88ddc152406d228b91b19beee483ae1a58298caeff9f305fdc76780c3b278d51956c01422bebb02707556eb9295cdda7092c47a7bb0924f8c8b1146a046307874b3922a5dc0b82e5b70a948e0b0386841d8393c00926ac217b250ed8f636a46323b05b826d8d8024257b38df1cbb74e27e06c27cf32bd0f51c01f48602e58e54e6d69361a11ff808fcbe58f51eefc3c8af89a14f5fb9c7e67998544607511491eea7c5d371dd7975c1324b7d59828d4767fef9881402152176f991471a5c1b4efb28c9a89c1dc541ec2a93e5e62c50ea3fd37f7d0d29adba5e4c238eb6cdb9df62a24b3c446412d7bb6f4778493ca03a0256e2a10366aedac08efe4f245926e288d5a2efdb93a45872f411c902acfc41c5080909b46c7489302d7bb446000e10e25a5d9b446036402ca4db4395b75d800ff8572540a1c3c4fe061626f3aa869e386d850086bf5e1141c37b2c583d2bd133b6266522ff380e8e86ac003e729e934d8f7b263c0e56810e15c46378caf9a44cd55242187025c9878c6bbbb2c4103c3493cce0fb8ce86735526f35efdf21f05140dd8709e4f050908fb7695a7f11be9b02f4d409542cca71826a4d2adee000a9e7cdf3c305601636fd8d0a8241660937ed70c7555469576effb7a2752c6c959b508196ee03ca5423d7673d180f1baa04d4af7f98849cb8872ae960e1eb7483e6a619c98b7747d6818fc1ec7907f6fad67c8917492fa610c7bb133ea975b9e0c77fb96ef20f3563c4fcfa8a5d0ee1503305853bba44fa37aa72491676f056cad0c73c30911de22b571b98ff7315a3a5c003c9968f69470ca5d9b7f108f2359f97fc2ed51579f3f1a45e719e411c5cf7372d456eee1f19ed6313fbd27b79ed94362012ec0aa55b4fcbd97545fc39cbb41d402843865a093a9882a5a470e4b8490d2167dcda5c57776f65e4665527a2ababb870864f37dd78ed977b51828304c5aa85f24fefc94c7d08d019db16aa820a822921b87c2b0bcc9dca964e2bb029857770d29f67001856c6d9ca62a2d4e8e3fbccf2a6f49591566ab19c9d496b4109c3679e8ca676ee99d4e374b58157ad2a58ba477066880584c68abe9c3aa73bdb353dd83e862ba2d3628ab1144da66b7a7edeef7a0d35107d29fec52fc1219c007a1ea78caee3368c5878ec862c9b04a5802b2120604184c6b906d1bb4799f1ac0d92cf05d9f60520fa1e3f96d67f2852eb19de31d2aa0c2c0cb3ce0d8cdbf27d7cd7a3c39c17c679fb801f8016e130d4ebabb64922237a946a5f2eeb3203dccd0b1c9cb48db4c9216b021701537f128495d3c6db79af92e4245a0110dceab292e73d392865ea76ccbea86d922d553e930dd352949bc326fe3b5411ff673ecbad36063c873b1ef1548c6f8dd46bfbe5ccd59b37888c7682756cd0915b3f0fc5737d4f2a50a39d36ecb183a7b6facf1271405f92fcd70d943adacce57a0014676db5f75dad1f6ac010b61dbf3ce4daf3c94f118e7b5b126bdb95fbeda6b25959de2d710f0d2be64ea05715a321bbfb7d3f83741e7d367186dd46f9c262ff1e822dd2ec14b5fc38bf0866a2c7ff3d08b32007ee69ea550f82cb8eda6afaf56b308025dd19a7936c7ee51fa2f38abe209ba95473a6498a1d444b5de296b17da7549e501ef2cbca6f9d76e10c794d52b8026c3ebc9ba40ca143c3909cb001e56e8151f4ded75676bb4342cd6fec47635ff3f2d1c6670af04fa3f1716e94fcae012e95f5d2da33c2506ce2d68dbbea2e3913ee9c935983eb432019ef5d594536313b7aaab107410f9051134e045843c9082f9478a59b1bc0f1b1ea880ef3335ca5247fdeef5cae45b378ecdf48e2e852efae89ec31b2eb314bdb07a5cdc14a11d2c513e158a346679806afa75a1bd9a2387f684d609a30cf71e6cf4ee1e9f9eee9b67d5ed33889d47573efc012e04ae07d5938c9bcc292f364f34d452a326e2fd4add0c24ad2de2d6f997593d65a786794e3c8581664192adb9f17b7dc8d193bdd6e03591605bd080639680f4c293351fef839ca966f3a640eefc6dd55e39431203fea413d812754d2aedfb6589490fab6610fa1576260412408808c81090e3248c87ad768fdb8702716172855b0b986c30cb58386c7a25c740","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"47ae2b8b81019cabf39953becd232c93"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
