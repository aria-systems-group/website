<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63074574d0ab80859d89fe12b74b62a55baa9c9f08ce34b2b7842bc8aefc0d2691769371afdfcfc0f273e7dcb91346ed12bb187d57746c583a8bc78328a9d561f14eb463f86f94fdf989e2169c7627f872546848099aa5047b2d1343e7f6cb8aba0aa3c7ce2e199ff968bfcade98004d799d1f0fcb1d25d1a0d1f2176bbd3aa1a3e74111b328b2dd3722e2b2f41111d42421e3815e9f2b46f18c2cc00887a712eba1a0d33d2b87986a4fd2138dcc9b2a124b30c0acd21885b477e38e5c1c8c01e9965a6fa794c85811a343919d64b7bc39726e1d84072fde43e1410978c8a62e85e5857069d0bfb3eef0b1b96e1b6bb92334fb88d83cab1f74197ad869860c00a9955625da632e5717a36c7c9bda1b5e0eeb5a7aaa6ac4524321a0732546f19db270b4d6582fb9fff227ed9e7ee802fc7916d44af44c93e626f640018f47fa88742eb6d0488b3dad681b64d037ef46cd435a7c2afc20cfdfabaccacea21508b137b13815609d128e265374f0347afc345271ec1d3cfd885fa6e222562d397f56555a92c6d6ab0d0ca05a7ddee44ba8d8996088f68d675a844867d642e5cfe8fa6c895bcc6c58945b7c0abed10b73b4b31bef21e41d163bc543f7f1ec6b5496e7581389617d81c3e7481aa48c79e9cf97ad268be16d50c50b7882f0fd0bd56682ad9e782b17646ffa0d7b00921995275be6714a25e7b24099e3ecb26bbfa43edb45e47b7b89310c97f220887ebf6e8562ff2af769ed3f04e3b477a7848dc9c013a16609de3f9f63558eaa7aa0680b7b6470d817b1afb11919a014a6d7e21ed83df8ed00ab0ec8ef28b57540adaef209c8399134a0c16a0d41105c2a225560926e1fd16efd8e2fee6c5e815b29c6e087683a2c4f4b0b2b252dc53ff653307ded879fe755ef7560d73cb2c14b09e61d6dc88482e619952f98a2dd79fceae8e66ce9aa842dd2aa6862d963d204658f6602088bf5cd21c022241b1ad9f89d3b5bb0fa648fe6bd8582221d8f51a8a3fa17b14c03f11d5505d16f2de4c7d37142e9e1d1190efd5376932a216ca611c4036d7781ca506d8ee28551bb805b9453e8af4b5ff55e585a21160818378b1cd6b7cb12954636b1c2fdfbad8156f5de316c30df5e29af65b08c67124f334c27ddaaa0e47a9b643af7441d4bfbbf48497463d33ff5b3951643a58d7fee5d3f42d0964e0bae5e8bbb52819ba8696409ac3a0c7450defcb108b6aecaa1f39f9ed1b6d42df5217b6129872bacdd683e08f7de7075024a7b29521050959bcd2c9e06885348ad4573f7b6f6ab41cbdd7aa09e3f5b5f561cf3ba72f5feae117974b802b306d7eee2d8b6f15e431550d2e1311f4d7139704ccee4ae89f8f1eb935113efe5924a8f3d84e4a370003b137f47ed8de07d9fca46a28284677a4d97369372d2a0fd0e1d9f2d8604d82716040a8a30cda9b7759a443f2d14be1c590e74fcc189fe685c351b71af4ebef8d98fff169deab32aa985a8875485afe926d45b7ebd727c182fc8ce067114428f6737cad2a893c7b07ac2a786e8bb8160e7feeaaf02e2a5fc4d012f1109de1210c231c0ea5e90c1225232396ecabc61e10230f918864bb897932b9e6334a72c3accc5103b7f845ab50f1218f683dada99cebbd97518ad428b261ba95861cfee7ff28ce1db04a43de60920383e67ef34876dfc2dead0b08adddbfeb6a6769aa0db620991bbc59d888eba9c645776c809c51dd15f89d30c42b1474957fd4a86353b1ad7d947298827d60f8e2501dd52bdf01aad84befd622bf247b81fd805258d11a7f43adc2dc67649bee6a67d64a6aeb7d92b3837b017ed18b90c455efd0c607523bd9158271f9afce6fcfa2daab33f1435171ae0c69af68eb1ff53a573f26268435636ac68baaadff7fb5fc2f14717ab004fe63cfc745d093d81fbdc60b2e3e336e815ec4c6cc2783badcfd38a37d611128a948bb9c3df6f4f3d58ef17f305e7856d7fe10c9f5f072240e617c1cbaa1805221fff16a8f449a9de65b505165779d2448beb9127c6a526970e1ed2e4dac6fdd2aaaa4e8c918386989fd4cd98858a593810d962ba2741b8724e6510f05809720f5cdc3d9fd79b2d74362b5bdae38e3276b841c027f1f764243e4fe202feb5542ee00da43dd481a45185330854b279b1f99d132e83d984383dd183452d443abfe9402b8f676e885b6fe7d7d6472f9978c87ccd4a3330957a47a44c26326821ea147804881c3c393eb072ff62517e076f841b3d1bd82a1258726407b76093382ac3774ffd6e9597476e48e42b571405cb94393609f184ff73741e6b2ff3836be38f4acf4234f5d060d8223357a035b9fd13f4af764e7384d9c2776ae37ccbfa208ea7327e9824da3460173983aa63b366f9a578b7e7c8a036fcdfbbf54529bc29c4c40141ad525b3b401873ac856746e857f2560ecc7ed27026ec1c7f6a5889bd11c5076acb5c78f0750d73eb947172492c79d3421ebaf8e81fab54cf7e970b0f977341320ee7183e1d82199a4a9eb7245cc38c576690db796f745d979c0dbb932165a1d0329fe3829a9eeb3097ceb59a2a7bdf8d8df8dacf9e6a95c325780db95de0da5179a6bbb7081abbb998129499d19c7a6067123b13aa2b6446370fdfdf4edef794582d7b150326c27c496c1d89b4a822b63884e43793ae669a851138e92553271064969aa0e41a402ec40f578badde07b51c92d3eff81fc6cb53e597d9aaa2a3f7db0f9dc724cf07a834b16cbb751b2e30b3d421be8e19835aac36b35cc89ae9e426c228e51d4bd8d529d64b447e5757ba6962ef636e1eea0475e68a690311b7bb8e35eed44fde95a9edd6c40d737616cb45a77ac95fa1f5fd9760595b6821268932c5bc5707014dde6441f52a9cc78d760207f56ecac18997d2872ac1d82bfe81e90364bc26b720da3bfcf2fafa4bdda5c02d40ff60e6c511f3955aec3a2930493380ca1562aa1b9e53473f6a5ee494efe7d592a2ce04beaf61f5d9e2db9784b66a89f90d7b925159a7df19b1cd8d7881545d1a88db6002518d911936c0ccd1bca14b9b96b366742cdfcb1f028844ed91d6f60048019958c4cfb2bb331ffc20d0c721e65deb70ecfe1a267ce9cb2aa406b8cca437d41a61d37b7c9b9a4718b8e5a9050d5751be11300e6012be0dac0ce2f60d6f2b642465040dd62ddfdc84cd696bbf9152da2162c642f43132c552044698ed7a27bd2ee3db62cb68c8171d4714d3601e2f6e4406dadaf71112bed292aed4b5b456af3771b559fc456f07e28ca518490d262c080eef16b8d94fb4cc46e37532ec802777bc3b0b10013eb320600443f392401dec578203560efc7186a9dceb466f566674291f05709d0375ff8e4baa34bd2fd2307bd3e56f8b0f2bfc4d1760ca3a09ea3b5ee822fd6782655c7e2dccb411e24e1454233b2197908db0997257648a85386d0188e0d97ad852f06f0ceefa277013ceb938ffa3d3f9d3938ca0879dd77de079b985c0c1e11d10dd32d4fe6280540086e5b73a678dea3c832c672f2ae9520e18e689a438f971e1af6e0b80f202d2ed4cdbe22b4e4da595e776c208542b993a09b2e660309e3720448fa793ae16a916f65eeb354e51d3733345c63e856196140464461b53261661157b4de15c5d66ff308b5e5874bcda4d9fa953cd3f40eae48fb708565a64a332d31f022611d7c9a36ff8a8e048ddccc0229019f99dae1dc5e952a7486545b09e67e244ea54efe33477e89048156d7bce3e942430f367f097da55401c3a8fa639da35dcfc5985ccaf5401ffabca25eb29f432ce8e405830056c9f3813ce768cb405f82e94e0cc994a54abb0b2d907d9a5688b8933359c96b33434313fa0e228796496b90546213b59e3247287a5e45f91891b64559aee9a5926284e2917963d373326fda743aecdc2b9015fc123a31c3c388075d5675f04ef5edd0d52c5354a0978381238e010ce03188c4626c504cdebdfca3528082ce9c828dfb4f3f1825d40bb18fbb06b42a96c4ee95e8c9d46839885e2ae6dfa482850d751ba494cb026ddcfe6162e79814d8b4568adf9abfab07b1a73052708bd6adbd343e673f52eedb80f310644ff88a12431d661a10ba6f8b0066c8774bd7854012d11639a98d5c6a27042acb72e52d9f819726f2d1053afe4a1eaca8261e04c05389e4bd5ef574326f36411e8324168df7d80c8117e726e8319d0945569cf20d60938c6e2c880508f7f9188fcf37fc2605ed468d347800be6ef7bb1fdc89988330c86645c71d03da4b62c9feb54e7c9eec4519a3f13aec95e2afc287a0cf222d142c6c4431d91b8ec035612bf7ea47e4f1e0812d44274ad8bb17a54cb0b0b4db2963a696a85bca389fdd8b81bc7c7eed63b7d19abbd1668b5bcff3097a5700c5082cb54ddfa7b6010a93c8c2b871e387e03c20faeed3ad4f90c1a1186d9c47268aae05e6ddfaa30fa314512d38274c880d6067a2fa9e2873c27aa9298ffe1eed96059e8b19c70b1fcbd91db49dc2a92fc4ee39ff437cdde4b40d4e918ac7240d48127e92b0d0494b7c4426a7381309b8e9d005d29687206880238f2d2437ada17c91344d0a0605882d78c90586589d4de61b17bfcfa2f44c3d1adb4019c45ea969d9c006eb95e8638789ee990da151aa4b67ff8851501ccaef965021079cb8b773ff52d02d510552fdc0a1d8c431da95b0f24e0ba7a9c030139d9f132fa00927a07564172d07c3c7488b2feab56123091c2363e4c7a4b9e2714b135742d388c8698bd1c4d96e76f90df9232641f78a5a0450cae08be03206ea01170a8ec70828f89fed0cae74e69d7b9af97d3f56c113fab986816698bad839141106f129a858d4613f4823e33357c744ee4028a9fd83a1a5b778e4ad23dba457227042512d1a15b452cbd4034d7db4683caebe0b9017a1c629263973ce7261d961f093c5317df8efa5c8ea3a48576034ff66aa6fe272647c3dd6a6a2380ec390f7b151c4e81cad9e8185460640b5842b2fedd754e5fd30f1fc3a28516e4e8851a9eef65152f2e4cefc18f912a238f883c9add73470d9f947024863e318692eacb59cfb5898033f45b3ce587a41970dee227e9e92f62593b4167a4ce096b9fbc3664bb75adc7b9f1cf20a3c4132997c9274c05f7baf672d3bc18af01ffa8636c11fbe7814e91ce9292f3b545fbdd38892e33f11e779a3d614061dee76c89273bf19789bab71ad00a5ba5d92a81891735bbcd762b061c154b332eaf2c5edddbdd3a93f51b3053a15719447eec4ba3cdca2fa9adc92ce7b60a9330c57e99d3cb34472a0b449ae6f937988dc4b87dfcff95396d029cb50dad6b996bfd0f2379bf5d4104383e2c2f6a297a3fb6de4cc359a9580d3fcf0faad70a508e5b59ab5484025ad92924373b81d183a78a1d3f5891aa9d8c845139033fa3dd2365d25674b99bfdc33fdb41a281f66ec98c962153765634f5e19be97a5aaed57faf4e7e7d343934db276125c252ca1349727e8898954aad7537691ed7d96d4ba4d6b6b75d512bed5c5957370d196c3cd15a6dd8d81ae32f3aed4a0b5b4459b760c04c2261a0305edf5dc97491e54e09accfd8f2425be43e43cddee6d6f8d1e5587033f7f8479a8176723a45592760a76669e2bd63ea8ba3b23917c53a9ed127c4a12337b7d919a31fe76b61e80b20c040981b0bcc07f8f515af9eb830708f16b2873a03cfbc4718464b6c171bc6f82c85bb93e6aa9c47760f31215aa8bcf9c6a536f5799799a53c121baeb86c103d52389c6cc05fade9460953996bf0ab1b7fe4fd861aea2874b8013f5ed4d2f3505ee8fdaea01a702b01c27b204c3f61df022ccc51c73870dcb28b2fb09e6620bceead407b782f53399e00f7e3a5f6c7dfbd714c6150ad4b16a0430160cc763827377fa7a8de928999766294e453c356a66c2288cc0532092b927aea038c57f81daebae285b38d1758ec12a0efc6aa5248f3cd8aeee67622671a3b759979f461420423d1351e98f94ef09f35721c4a63eb8d7f8cef2f9ad547c8f0b2ce2c603e4e00b4cc49069099d8781d4dd09af3872c1075b3fe0f9950d1963048b08caf4ac7eef6717d25e785841c32ed3bd3d81238a140747b1d809537d849fab0d2828820e0095a82cadcac0f90e5cdd1080d6322d0085e869836d488e215ff1a4c3b081721213a57d15ac0afc7fe9b0e5cbf1c2b5eab99e8dba6fd0c90e63f4dc8b0b853f69b27e56c5283640597e1e8cec76f8decf5d9df9cf32d176652d5b7342b9280be9163aa714d3f3e055867c42a9a79f4df38e58bf66d734652bb3fcd7f17137e89db1d1770be3c2d6f4c874bd5f3259f1265a707fa29af823b29ba4954b6ec19a0c2689e812b2eefda1d8a9712aa7455d899e2557044fa28d7abdea9551627b6538efbb81d4419f2e99c0c9200859354b6869df8afd399550c184eab1c65f45a97ef9d057f2aa0b81686f4d5f62f5d9d7f84159f16d676ba422206d9dd096077297b9999beb58d34b0e77aa6a139aa2d3ee4f1e10bfd8e33a575205d8e9ca2178e0e1b7827de69aa8b525eb09e1521bf6816bc28ae432c64332eb14271f00fae8828e23b0f4487e8e31f0a91eeb937344f3f662bf45c4f09e8ea27469ea2f67de59989196f3ecb21f8c44c13d5838d10c66b697b4194092027bf6527f268e77f696ead1bf128c733c8dfb2aa63b7ac48a74b2a8c4f5287a9cbfbd63eb81f4f21bf62db886d7dd93492796a9de0796bda04659abaf7a2d2874b89f7dad1c84a74e515fdb316680dd99c10bfbd4cbb3788b5f5cb95f399a1b064fa1aa6e0f777ceda5cd2edc9b4505d58e0b82018a0ea7f149e41bbadec4b19b87634fab7885f31be1b72c7194941dddd1c6836a0e12b160e28a8be43d75e25d5ec62dd1ff7442013cd1d85e743a26124e2445c0b140457467f90f35c631fdd69e4e248fc4e667e9a6b38646c2876a90dbad3883989587881cd07a5f6e5eb77b2fd8266d04c28697ee78d20bd30d90d7d9bc89c2fb3f3470dd133c61a1b4da36fa820a3f2fe547ab84879a4b091dba38ee5bcf9ca3f08d672508e6941d79abd7d9864ff621fdf1760cbf793f306f4f2aee19732d67bbf80a57696ea7e9b8848e1f27116dba355cd4817d9af6a580204d70e7e6ba10b548988293a835f2532d16f5b8cc5ea86ca253dc57e270df066f48e45f68c2a379ff90b52b772e9424f0e97454de1eece44e753b434aa633d6b8e72f370a40f8d005f4c95addd54adb78200cf6b19b266d6e1ed9de4042c5c29ccc505a9f6b3d9f0af23714ca749482508c90f1ddc8d04c23ae6e870f45e9c015e74e542b9c031c3a5f08549f60ae5af7ee6b0dcd5dd1f513a2dc28843e2c6f320fb6519c5c697eded3f1e76d5a610911d1bd6c6f37be0d1c7f1e8293b047b60d667d8a24abed43f26bfac397e6f83977fc923e3dde4d46e1940a399dcd6e4406bb1ab416c1dfa6d0e81717941e5f482ed1aaf29efd7a371776595cd807b8f0b0a08fe7e8fe7f113ca60f71f953953e6e4032b507992a00215fcf22b4f3bf8c123013f9f70e9c1658c7baca1be9a2c97dc81e63cd6dfbaabe4322489912ac3c3324cfcb9fc04afc0ce58e523bb08bc8f0fbc5fdc6c2c4aac4f1ddc62c8e07c4e7306a46b6847024349b6e57a14d9896f591e69cb43b1782fa01bb1be924d9be1e24321d3a932803c112b3f953461427f699f200ec64e4cd033bc78f1a14dd85ed7d6a22030490716af33a71867753bd50d57099f4341377268a06288837278684526e2512a51f8ec4455f0c5e2f79ba182f1eae148a345b9520dff76da16876db75a42af28b9883ef834295aa4b11e18e0831e6922a503b9163b5952e8c24d8cbcc819a6810a5b9718df026fd60fab5cab287e3f3b0ba5e762ddde602ac4f82ba05f1befde7d87953745858cf7caf0de01c49815030a6a73c680f1c11f1d93b83679d996a218be2ea1eafbe9f3518ec26116f913b1d5b06b8c62d22c8b0c56218ebd3a7d2b5d427bcba26e203e654775e8545cfffbe8acaaf390dab2eab6a97b747eb3f2f1693b7e13317c6c1c75a3830bdbf86d99b379de4ac1009f62a4176e6e7478d46ab0e8f44d9f9c3292e7f44c1a98a7816b9a321918c729b5fd37073d92fd7286689aa33d287c69662410a5fe8f4e77dd571275f018574528246cb9e26841ee0009266ad7ce108c49e1a676a61bb0d0963a111626f7bc74b26fef67019079c537da0268e73f337d89c9aa1399e9f308c46f0948da0167c6dd40734f76a95ec1a5cd130319adf7e789f7f3ac7c84e4c7be6f2211f570d7d0ee24986b61682049dff5ea58d4a6494ab1ec50d6baa4985e03b88c07510a1317b96b257883ccdfa78ecb7f6962d3013a4c4586d4d77a1f26222b2a104db0dd282888383e3a4b0bcd0159529b9d87f6a012f72e1069e730c30fbbe3677c6f401357ebf3649b00d4f4e4702ec80a2819bf699ccb798d78b5c3eeb256780572ab662e1c4da1ec613c089eb42d194466690a3d40fdee1bef7c162c78b3394e81e10171a077bc6bdb09d3c5fda88ef4353c20470a0eb38d32eb777852d46e6581fd1a3f4f96b4eee14ca5e34ea028ebc870242dfeefe2e306e6efe02149d70079b26e2748213dd67120bffd6e2b7db51d455ad420874af35d7452fcd920485ad4cf8892153d6f7c9b6114547600c2f607d2fc19e3a36d2759202a567bee2d61b332749a8e9375c47572054362b6061f524d8ac229c173505a4f0e20af95279b2b4c95dd0860446d718cfad32df9f1711f25b6eca98e018084c6ee818419bbd98b716a7f7e7ec796885fb0437b54887f412587f19e636ff5036b2f4e97e2bb3db24aedeaf03a53fb7ae5b6429431afaa930f8bfd6cc81b4948e0146fccca2545fe00307a6f7f2e313cc807d3825a08ca3eca6e1aae254402e47138250bb9e8b55585c0170f112fc70f0521433b95eaf8b71d2e53a089d135d0a2e0444f8046f222ae0e8b18675e5c28416fa672a816ac17842e96c8ecbbf4fa6e03b70acf69b9afb51f84142bbceeb7602185500990171924763c07fea5de30b9ffa42c0590a32978855533500aaf167faa367a0dae54767b29a0c3be7a9b56ac560a0b909000905153bb6a8ada4f4355f8a6bf9a0fb973cf90c549b85ad521983de6ee63d83a2994175add108a5b792f7d5c25a024c5195c601fed516eb11fc2f8ffb49d0f73be4d6b860d40c7cc8f04a1935ddacc3aa6e5e809c90614f8af5c99901ca98b574c62e0d773f01adc4cd3f913a96f5929e9b842b7c13da80ff663f1b8a2e7f6b51d2bf05a9e59a9426f68ea8630bdbafb9932172912016d61bb2be726fa7263d68141fadaa66a5d43e452042bbcd2c61491f2683c712856733a2231d08151a6a4bc94cdce605de622fc5f670eb58c842169bd0f7b52617833da3cc8886528eeb2905a1e5ce97942a8867457258bc67f3f2db32b68b5864ba3746c86e91de0b1d1236ad7cd943ee0078f66cf71ad6d4736571cce0d59a3f6ce8290739484384d65353325b053c2a3412ddf93ae3fef9e040f731ccbcc38bfa5b9079f38424f82e9deb629ae6de3041721b15b2cf6d8ccce4860f5bc37e69066116477a790df49ef5cb8e42151c8bacb9bdfd249f49ceee97c15a5b13decdea8503dcd3b38dcefe1e195b9887f6ed195122d08e35396c6afb97180e929eb5001db48fc868ab8c92ef5152c2c6fa7eed5bfff9f891b9f62be40e63874f30b73c0e28a7ba1222e5689457b59215fa18a88a26be9369ccd49649cd77ac536662a5f31bc49ec8a97169399ccde8848ba77ed186be1098f160357f1b503ab41d4fa770c88e5c8b9877b6bce45caeb365547972e39dbb1ef9aca0735c32b4330adaa2973d1f38bf3f224fbcc52d49d9037856024f1d72250a97ffa45941c57edcae1d127fd5c66670de2f8497d5de408548ad45fd38b506b6898791f63b089112ea3bd289b8299577813b375aa45706f2e75be631b27db7b16780bd2b89ec8f40ae58aca347f78c44cb5b349781d1d304d7029910ac674e6a8bdbde8e5c07227911f9bcaa7a33ea11613c0cb514760417efbb6efbe04883d91d33ba52302bff9c66caca9c1ccf0aff1e81b3a51838b8db2d2bf117973b55c45ed056051a02fa77e1fe690b1b5422eca646d813946dee268b5e6615521317bf25f32e75bb94fda28aefdc6a5c2c718a5140f7268d4f3e5ccc269d6970f398e04737a7a5b0ae8f8d30d62422bff4620fc3b269c13376afeaf915ed4269b88121aad171bb1d6a7fb9af5a06911369be9a56efeb34a1d29935fa0408f6fa77c29dc14dfc2acc2d933c0702b011663194ef32f7a7fab369faf842d40bd2146313ac809914a6add3400e962e838949498a21d3c65fb4b85ac91a0509599c5bb28a9ac8461000c81e1f86d0804b2f6f185467662c8ab0068d5b29a610a17803ecec3d7f73b97955ac9bf06b97af2f4c3e1e46d8e74921675599836eeadc42dfa1c0eb39cb2d09b6914bacd03d746720fe06a313b2def1710b6fd8feb8c114f7027e386e2762b4797f8da9bdf9469454664e1dec1ba594db2927c22b6ce24854f7a31cfcdfdcefd35799314427860ec59db660aaa1cdb0e2639377f4ae784d2c6fdf847b546e8418635cb2c70432dd0f320cf6d8db3f863ccecebd17a147f924a2a3d7920906ff0e3be451f01906da9598b23960fe3a6bd8c04931a34ee76bf3748a25c0671cf546551a426680577160322531bbd0cf4bb7610bc938cf7ce0907c169e9863755215cf42cacfcb47f7397722ec99ef98878e2432d5df91c1eb9941b0540b0269ca08ff444fcf38ba8487ff6b68640726dbbdf2a9be0aac84c3818ac1571b55ceab6bae670ecd609c937918d259739793fb21c032c46446d644dc7c9a2c143dad3eb0438915af98acd3864b0b80dcb06ef1c0e740b58c2f8d461b94cd61a37ac700e89c7a898b7636dd57d67d718bdb0a4d8ff92be78530372553fd6f702b9fff40e966917c9b515926cdb211104913b67a4eb3254fca5cb7435caf690110948b8992841931ad50021367e05878615d9c337e8f820b68e1d88c2b6afbb275a2c2a01e395ab40c385fe2bbe68141fa730e597a53be1522fb4cb265497c3183ef696a9b6978c9a8538bcef3c649e1cc27f4525902cffdffb35a940d16afee3e8d85acc918e47ae249c4dcc746a0e93485a31f142e709d86d7ffec72431e20fb79c1b0f251513d47b558902151d430480508ce5e41c3bedd036ce5be5d347d7824ab593755f06d0838206e3e74e6ab5a4515c2e1c625cd8d515932755d05bae168e58ba2f276349e2506c9a5e9ff7910767f8b212e429c045326dc6baaf06aec2276bc3b862240710d7217d83dc2a6b4b6a21261129d142a8e937307f402581b53b3dbdfcfcfc1e1c580bfdafae6141050f6ded5ffb4bf1de01dd0e58ee545d9e2193fabc18eedf6bf5f8ba195b7ad9f3fca16c3ceb138ab487b3c1be8328671d26908d8f14648765948b3f9f4c5264c6d2e448082e609193f360e20d5e0d65ce58ab702c66cdee701c07b2d08870ccf47d16780852a1b0044fa901c77df16f13d9e4d294b2d2c11d585a804703a6fddebf2ade7fd76bde02ee6a9db2582d819b3d86924e1411a04b5fd9d9b92bfb0e0192a1129b306c9641c6323dac9a86ae6475e8278391a8d6ab29a907137a06c86a595a5fa7d2f9e97c5d016ad89ce1d3c044f03d85a30a2c4ba366f6d6983f3663fcea0e615a326536f51ac1447e85870a9c69203936bd219f5cbafd7009545ef32ff3439636484fe0b5f807820805d067312b0ec3bdd3ac3f660227ca95ac1c60d86f56bbdd2ff18136db079511dcad59219aa2269f65211d874da181d91843a28f2156e58cd385c96c48d94eab0ca660ab454a8f72caf1151b91404d7fed5f41883c1e0f4b237ddb58ff8b0153b0297473a12b4e425967a37d0b1a54efe1ba81df1782527d91635b68e850b937bd6ce5b9e4fb0cde23888f1f8365384bac57a0aa0360316c24959d65ba55adc827b62add16d8759c760c1f3c16db5562427e6a507077e98140321cb164b27d15a829e2058ecdb098eea06eeb8a6e1fbb55f620dfa5f220bc31dad796b1ce63df8f6b0c2af0419c7076580c9ca94ddd869b4655b8b383cf02f6f48b67c742340ee911040ead73a384da0c90959a8995dadd940eee3b730a782a881b0ae4527d2f962ad9ad4be5ea7f73a8beb6fed070d6a7d20ef8222961de616e6eac32679ed11884073f5aaad8945301cd79720467e1582860c852612a647dd3deea6bb1dd8ea9c17e0bdc884812bf4aee883c69049e39dbc7080269a2e142cc979cfe31e627fc72286f303709c6429906daa849f84344aaef6d87b33c45a2bc94dc48019410fa5c60a4142b412b2b5430de33ef7264870ddccb98129bb4952e8b0a7087d44e3253353aa74fa97aa5d087970e2323ab06605dcd3fbf7d5e5fba3210dc190cbaf9942eec65e4fda8e5ab1119b7be17ab089f77a8a328db7bc2f83e7bdbf40057e8131daccdf547e9cceea4f9b3b4e6fa0cde02f0356273d6b73b5d8a5f883e1577598aa47e2fba4c5329b07513b20ba5b6d012453d9a38d2b968551b2f62ac897224da1398d56e38d2481a7efc57322ec9bc3e0c502c278f582eff7069dda47c829b0cb845cdc06d523d85ba835c1903150ae871fa25a463bd45b18321d4b9f39c3fe93bcecffb84ad6e927d49bc1634d056546bf89db14930fa9bbb750c0b498eb16ef0ad539c6635a267a6780294a5ba1bd1a87ea115b87e9c2e070b16196498cf1a72fde7f4662004b6b650fddda16c6b95972340c543ad2a63c0e7c397d20f9247378164e39e3ff8990d8be219cc4fdcdc2f03a3e4a2298741aedf405550add5c2c9088c14499204e38e0752299a647a1e5c99d1b749189ff9827b7092b5e470f99b412b5aabd8218b563c2dec7efa8cde636a612f7eadd1eacd83f5d9481b58b92729fe78154480aba0e0fc90ebb9357467e2bda2eef744c77631bc112c5e56b36fa1b37d5597e7924dde647c5f720203c0d0ab2887d3f51138b290451697c8c0a38e4450ee79b690b6cba2602957c78b7f8206eadce95521b1ab59ba3f666a77c7488d6d73170ca8f71ab0de96f3be366f3fb3552604346239824efb4b88a0615b4dd3de88f03440e31736bff935d2ae9a4ed962b963142570fcbd58978fdc9759b7abdfb3cec8b6ef9dba9dac8ca501ae89459d8536849b43546ffb01b4c23f1a3f7c52412edbce0fe315d7d4e9472703e4ea595ea1c7ecc963fb31e6e6eb0a29e67abd76956cda6f85c170566b3a7fca610d9bf61a6f3d31888ffbb908fadb836ade349498fdf0de41efa86a526e76bd3e93dbcb7ab433c9186c0f60fe0d120514a3c37bb9ff0e822563686233a5f791a5e888fefb8a920c9027133ce5d631ace1c38dd3b0d0cebee14747475caa2b5654b8bf7a7fd20ebb97a37b11021091af3f7c1dd2415b863e4c143364bc262f42e4e514d36749dcafc2b808a296525957e093b8a839c33882ab5b85f27a2a491d905a5c01664282028de09237874b35d1a1fbedac6392dacfef8a768229b918f565ee3118a3fcece6ba68d5d63327813889acd20e8bf78315daa9653cd52387fadbb38782e6648ad8988fd2a0226a1575cd21a76dd4dee5f806663d988e51278ce1b6e1e57b6a481badae34e04f01c9acc2f829deb17409777d921c53af5c6808499532c5b1442674d67c9c55205949544239456f4d8d2570612f31d5963be740b4cc7542c2265d1ed3f131680ff670b69a72d0964f0951ad40c30bea2078ff360156faf62bca1f898f3bb1262281a592449483ea47626d218512d4cb55581e17670c373504b38b9dd99713a5e6978c27b325728fe7f232bd80b17a33eac9e4c270a8cfb3d8ae1ac50f8b1075f14466d9793a3772489a41e33b32e1174b33a12655ca5c42abe1cff4da3bbbb3d1ddaa42df7546550170d757470bf563e3f40d81a724cbee1ea47e6ecc478320f46a093f30d585e44751c6d5250b4f03b0e76dea70bd625c1acfb6c8ea3c7ae227ca6d5ee45dafa2c41fe7114c9a194742741ca9a5dd4c9911a20410a52be6258a3bab0f22c1bcf74eb7802cf3da6bd1e1ad986b8ea4a70ddf0833f2f2499d2e1db72bc7cb7dad09d86ca8672d82a0be3062f113f96752bbd452c5a57d1f4c7514b701286dbcdd303b2b2130002813e739fc3d35519318acc2904dcd0cc98e1a2b464b3bad08a5f40bb132ac19f22085928f06762f3ae1acf3db196df34fe46ad384b00c52efbec19d986426810e14b7d7eeded2ac9cad06d7b82a4be1b39712bb1810607a3bd239ca1bba9d1ce9a99a1e917ac3b5dcbcd305a4c23d4c900bb32a40b2f20772a63aed3d4f0df89f2da12e7217f227ec4482fe035cea63441dbbc781522f967b37e887e6931f4b338fe9b8495f24434dd64d6c8f02bcb61c11ff79e127ad54028ae38a54c7cc4f2d074461503f08ec7288425555d75772298cd4e6b5ca0a515cfd7e666cea43f35e40d8c32d48ad4b1790a4281ea2f7bb4e15a2f472d12e83caca30851b0dd18cef70c2033c8f450ab9e9a70b56c076bb796ef0c833e557909f4921b335e08a6267b254dc9abd66a0b70bb14470a4de60b76d932b7bcadc8fd8ddf9af12a1322d1e826c6d2775bcb32661dc62e3e470fc9607e9c1e2ba0a953fd2dc42b1e39349acf3120ce62fb4a819406ad23b0ea1d9d5a31693923b0a2dbe74bbfd1d5765a61d7aadc514d79a8a0a91f664f92bdd5062adad0a6b3bfead3543d9c84e06e7dd8ef894d8a94eafb343f945ef26c422c6214896e194965ac5276b0394ab03c73ae6c5a1f5dc5dfd668591d3506a9ba54aebc8bc9e2f5c50518881279634b3874ea12c555360e098d29e6427ba2cf171368e4e584caf176762cf99493c228de678d36e86a94e2380d81a5bd732e13c6303401fcbcb18b16640f1ac41ccf5422ba0a4564dae9ea7cb3aa7bb8b9296f98f1364c87230e0ad728e0d2f6305b1f47df98159d337b4bab73fb4d865131feef90d63f13514988997af436b7455155b1e2d386cbf5c3cba113258ee15ff01ecf5b6de42f392b23b8b431510b072b2603d22794e909e82882430af02268f9e91b3b24500d97ab31d4ea299481e0a2c670fed5688c4b325110bba0c700846defe3ac7bf4b4ae14f99b586dd414b8b1a3e095f9b61c3011ce0a91896a350060f77cb4757c719e69fed44e95500ae1af03a1d131bdda00867b0726bb390e144ea585242e69760eab62b18cbaceccef1ae1f0b60bf073fb8570156f88218923552357721c26c181efe7e1c31515fd6e42d947b4eeb223b7d61d8c8337e2a427c4e2e53975b761f1bbd84f58690e0e5775168b69cc858faee543a659ef2baf40f3989843f726dfe3a40fbf7eb9373920cf0fffe059b7786515465f3ce8208d2efea2e5d1e9f5f0ba1e52b6e6280f5e20b15f096bcb1adabd39c83da6b25718ec2d51549cda3a3747597ef9b54354e1c79b0c8ab7af5f14ac098fcbd9b7653be311bfaa507d8b1c7ca30a4b9f41ccdc976ab429c7c962050f1e46f635b722c66efc9b61dec1e736f46ceee3d8b101f3a32d1eb27ccd5c8a74363b1cf8f3aa858ddde1367a1304f555012f4808d137fc751500cea5029c3c05302a95e68e6c20a133d05e84b34feb0f0619294236480d0ebb8f6b968b2930705458a4883d21362e88b641a3a4c39df4409425fba4faca84536dd99fd5ac45062c276a9b6da85d20bbe06aa553dfd5fd86477160e8fc93b5701a5aba0fefd3c9edf57407869f51da23ba1387acfa2362467f8464aa18690a2d10b4f69ae98b9950c85443fd3125142903b237f73f7b133c3dbfb2986b93efd6c04a0971772d83fc94a870d8712c5c1faba3169a0f0742d827bf834e087df47e0e029e9794dbd694f3e149498a115dcfac5aeb11ae652a10812d0b3d5fa483541ae9ec6bbc6ee0c05a3fa02f07217229a8a981cdb93271e4f8b564029c6ae62d865033a2a83c9a49a8b57fe16b9a462fec4f34421c603899150b96017c5b484c9629fe5445ce61900eb1e10b5e9ed7e53529df26e20a35c79fcdab1d0f6446c7fa464c01d93ee79791138bb6fa04674abef9998219fc9ba4f266ff72411fad1324ddf3861ff224b3e25feefecffd50cf6b21eeaf3b432542f8669e2f7618a0a6632c86d0f74d77daef99ff2ba3802799d3fb18a2638c9a630036433b675f01c9bdaab7991106019d73db9d54192e7229dc561115f168ce3f9f695cc2e0d6df05df83d3e6b9ff2b73e76c32f821f6820372b563e99ede6e56eb4b29635e1e944db2f874834d73852b1d603b173881cdb34d3f32dcda06be7e6549a22e74fdbfa6738d839d7537507340a00055c8738aeb35b2f4eac35157e11b0ecc6bcf63a7e4fb0a97c767d16f0e207dbda3e6044a67c85cf8d1d984e2fe35755ff0f86c63acebe6f066229c471630e8703a00f99cd77c0cd9eb209196d8346c611b332162ed8968caf3f916005df760d954244525b471c387ff141a94362f28b94208268abbf232edbd364d79ea9f92f423172e2c7f62b6976450bf889cbf9ebf0adfeb26e29a90127ed76467541cfef1b73051989f318714d191bc8ff66908cc02b33eab854bed03cc92e6a0ce465bc9c974a8f0609aaae7bd7b61a61b59ae91c43aa4e2ec1fdebc73e63eab22388f907882781b57c5b9230e3a953050beb8e57ab54ef40ec0bb2bb7aeafef8b361b71f508125839c7e24dda901d90447a3493a9b3ab5f0fed08d2acc33b490d9d935243a93a2c72b1190dc5f275ad2da0332072ce70d7c68fdc64b438172ce298399422fb3bd427e0cd8baff39323ac8aeefa6c0676c2da60edbe90c3aefd77460f3f1dda8b44072200289d5c31bc9bb21b2cec35cc2549144afea2a5818756bbbaafd00b45b054fdc89d68a3fbf869d9da6d232ddd8a907d3023fe1ceaf3bd859297f1d70e0dfee94c50f6fca8838fee8e15babaf1808f85dd4cd829a1b8dffd8212fbd077d5f338255e421530f2c8e1d2e60c7c3631ab6faf75066602f879629a535c0046874abfefd31c552258fbad55d6b1caae6c9cb7271ddd1e6a648ef24b329a470d87bd464ae32e1863811857242473ac4769cb773cbf02bfe4a94d0b4d7287f5554ec2c38953e55b1e7f2c8ea609a77777a77adcb47580cc2dc318b367ca2cd1cc26ee223eb009a4ff9972b6b93b6e3c1ee0d9ba19fcbb111ed23002152af331ce217d9e3978bbf676c2c304b7a6767a444dc0874103b5c35e56456fdd2b4ce66fe816025ce2cded2c5fce82bdd98d9d5ee7b8df97feb4e65414ef95574356844ff8bce2360ea1b62a7757c9559fd26f5b73b1bff146dc0575fca1cf55de127d213750f2cd11bcbe88b04c07e1ad2c16f19fd54dff5f2f1dbabfa44d66a3277e44f1bd14d6a4a7f0fe7e6667a984065be38439ae74fdc125c334773b6f4e96ebdf3199e87e75389164453e4cfc4eca3d6c0942b001ff82cab21f23c7d26b9a95a09ef48cb105e090a0e659d293379dde69741bba9781f1a6a45fdb8689fa4699b5aa30ee2fe058f237272b3898fd8f8f420bb1aeb8cca02f11a4cb558cc3905e804a1dae057f128bea1f3932d24a1173754f3a6eaf3d35dc494fba1994f0ee6d2fc1a0f82d6c7e7dc8a594f456079","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5de1585f62e5f5e97b1a247cfd17cd41"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
