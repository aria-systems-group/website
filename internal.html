<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0afbbb152193cd69d22e12a00de33cb3049a70834d35ff78ff3e4d51f282748be84cfb0bc7d1e7cce56f4542fa62e353ce4fb393f834c4b3eadf61e180934eecd5e88da87f99fc7269b43d95219a232ccff8523da53e49af2b6b2335a216a527762c02527e20dc5205f67ec3923864a1a70c83bc10841e70aced6f6a4e8cfbbd1f0022ac32e22af4957bccf5270f592e7bedee9c2f1ab4fb0a859ba6ae5919c5260e09f6a03803ad624a024e3551ae1064e561994a1ad374cd2743341f1808980c7b70276a0917d00f116375e89f086b987d9c8d055058661fdd9a0d5cf48c3fbec31a0491efe6d22aad61dad755b6ec518426745dc947401d15ac03b218069f34be117f9f69d4b29f715a746fb21252e2f487cf7c547341d98b39ca00ce02072f1e36f51de87ae68532f0ad0130b4670e89378a08a696d203b77a067870246d5461a4302a3f2cc2626d5caed513d6f256f85cef8fa0aa743e1775d79ab4041a44e252bfdf1a9cea5551aa62389ee86f5c77055de96d5be8337b6b96af395c09f7183a517d6859460cfe6514cefda7ab01cc2434e47cca1ad00fa871e7fdc56f21e74c4902cccac9e2995fd245868196009d9adcc8925e4a26905e95dcb42599126904958f443aee883c92b54deab14fe7fac57c5478699cb659a10989d2a0f3bb60da1ae501c18bc2f57277c1ef0929a27cc71f4e3378d5e153fdece0f162b8cbda5710ba77717ac542a0c0b28cc64aeb20c7721e0892608229922d644eabfd8969e51f130ed773201eac35c9f037163798ca83017e5444a331b9b08f6dde704f2f646a86712c805ba2d20a7700fffc1826e4f6887194313ba0c6ee7bc1acd39918762ff3633868a54fbb70ea8d66452a4c8f9b1aa7880603d188649236415efe5f68a99745efd73eef6259a91f130343f64c4ab6ae729e2ee22c747d5edf18d362123c6e687f1ce09b758383446fb7e9072412f84e1f275717799fadd2d153e9a3544284d53cec8706833bcc2a7d42f5a29866662d220d0cd059dc7e9e156147a7d98ad838db9caafa41b3b943cefce4e2af728bd1d3e6340ac6a5f5bc1dc4b9d9ae6e0503028e24e4c44e1a7898aecbf070fce117169b1b06b4886a22a040b32f243b8607d53bb2aca4f6ed47c2936b7634834d48ad9f2a7b21f7314d196614eb1ce984fcf54f096162b80d48bdd323d785182f30fdad829b6049133eb1006a63ce524ab41c80b4965c4aaf11789c6d4aeded98e1917a7c80a4a397a00a45ab6831655a4b205db7251e04766eb4a9154805a8461283de6175b64a86b7946fa8a0c54b8ffb2e1f19fc9400a850f065ccd1de796ff881b3dd77a33578af469a1759587f344b2d0f4372bbe1ede7873dae703debd670e68799eb84d582cb96537deb1e8b337de30607b374e6af59f220c097282dd28bbe9233b86aef418b651c8e11af2e3b7bb75aae0ad01d650536a5ce1ef813733099b54b056b1a9573fa1a6f5008343e131a4b0e71c3fbbdaf18fb64815c8be1df232d8ae7bd7e3b7b5c9eabd521b9d7b20b4fde497e16c5d014a2242c065f27d655c40f509e2c4d0c5e1dfd8dfd2b7d5ee0956abaa5bbf5dd6609b6bcb72577b43ba29e0576bcc419308c4c842c4d1bdcbcebac50d156028d0caff28f32b86a28d707042fd24c9a63afe4e50112a462438f5bc6167d392b9a18b9f5fe4ec27c035f6113175ce81572d70153d7f499219cd1f2ba48a11420b47d16864144642cf6aa69043d5e7f2f01e7a46fa2efabd3a7ecc07f44c5ae04e636d98f7b75a803bcd2d537392a25996d80b4e4f81f12d9944fbe46ab66fbe826b8c87a1e5b27b48f7559c91b7116d04a94400045dd6f7d8cee5174a50096e8bd788ebeead2ee22139efadd5eca262ab8be86507aed975ba6e482b054584878c92f01a53248895b715d16387ad66286718646395af41996e69c94372b597eba728ccf01aea781fb8501b5178ded57db9750853a1baeb6d59b3bdc2f3502c97a8d5869ba34be329d392cadb2d0594f5bc161197ca6d6c5b516a6639dd603a75cbe296ccfb2598cf20549d57a249aff3a6521f39c0dcf2db6145e4fbf34062d0083583629ceadb459c6b226509fb74c4e29d59b193fa0081f2caa5534a6fe32afc8c1e57ee2c2dc2d527bfd390eee45f2681980922e9c9f54d3429858604daf97ed69a6260369992308c2074decbff5e6d9ab484b1f398d1a3a5c18fa5ad881773258ed44177fb8c7a7d1f9e141c9509d5af2d8b7ff07e6890557a5b836a55fb3f6bcd3bb61c3d7be763a02b4af5a9b40b055a2f5dee0c8087629885314e4db6168efedd5a38bd4e46bf8faf004501415ad0a42d46961fd325854a572beff9e069d742191b86e8c4e028f6e88eae64acbfe20bcc7bda8bbc12b25b2323185276b31d2596c8333576447c7658fa2a7dc75f28578e61923598967cfb83271241c34147d0e1122c800e6202eb815d402d89641b2d60bcd181188c27cdc5673b1bd6da1d02ba121a34ca8fe675ae770905a45f6c54c7e2d60304606865036913e1ebe7e2c19d97bbb0fedbf0b8e089acb54d105d335cab8cbd3379066d0279c64e4844b3509bf34058a9ec552e80bcf103c8b4cd8f286bd3c9c506fcb3dbbf5136039146ae08a73a6bc1f46b5addec1a9b84fc9f8cd634fa501af21a87559decbc3c235cb2fb521ade710e7755620e96851d35acb2bdd763b7bc89b5bbe2756ad1a7e9847b4a1f80409348db162a19cfbbeabba4e8d35df19bf4fb619f81ab4d67bffbe6c3bd73c5c025878baed843ea3cf91c0e5b4484355f278fbfcfdd024adb3f490a4200de002eea2724b732f31c296318ed3966c040b499bc930ff96746b3d76f075fdf8573fea64aa3bc88a69d1f86500438b1814d07b04820242bfd5207b13ae19a93b7d7b8c5782f4c297aae8033c6765dd480505f007e9326cb906e1d28c0c84114a49070d376da8a4b2991a1087086d8c7a0607ec4fa76c405d560c2ea5dcedd9f0bbcdc9fa388a68a1b09f1006c810f004a8526974b3c2040034fe369b297e990f37fadaa6a9967c5f767b614353e02212e4dd6cf9f9e1b71a619a6cd4311cbce2acf99d79b784d9bcc21d1d578fa0682e7e55cc3562fdbbc7ca022394bba0f7311c70dd5471c04f3ac76a78853190f38ac6664521954c9367ef4bea6939d05a7e87ad0cfe5c713ece70e0cfa6db2f3f57bd4605aa6f796fb3a327ecb98665205472d58673906253f316ca20cb4698885eb18f73cb2d1d31e89b0c075a9f36cb9d66d21c9e4bf567130c8da9b80f6fbbbc1f978a7b437512365b7cfc861bd97c3a6a974fa53186e1529725a5bff5b268d2ec7a4f50922bafac0e44cb1c36f1e854446f6ca46f171e1b8e0f7a7544913f418c98d8b167b78114864ada9bba72402b03b3a7ddc726154cb5a4c7d58ef757347e7d7555c775371c58c92bade129b8d729cc96e9e73b734f419e1991346aaae09af7114b4c65e0c5a123621b9f8464077c5ee757032115f060653cfe6f0da82ef7c13030f375d58cc4715a51d327490f10b300ff163c668dfd9cec3b27f6e01b3dd210375577d59240b662379e358f51d0706882081da0155aba4506edc3e1be697bd97484908d450989d543feab410776923172692a5fcc970d395854ffc06458f65294cf7c76133884690246ba84d924741e729d10796efebf2dae9f3a7b25907cec1251533acbea03528d1cddb1374491fd6a6cc5cf17a648e8ebdefca9aadef53515bdf6d6bcd3df1e56bf25f7caebdfaeaeac8ece1d060828f830dea84357f52d0a8232111372084242405d87d93e8e40b7c98741153575f31a6674b99423e74f754cb8655bec49b6f72d1ab7f771a8de37d6ed29e195697127c3cdcd9b19bb9e5e619b673aa864ea54005ade76c495b9e0f3a80e0023af723f1f9ac3cdeb2645a9cb22a4d4cfb208940efc5833facda9456df40ff7070ae9c0074427f3d3dc4b268f11fbfbb130403e0906b5167ef8175e8345189658a891ebe537cffab89fbafe1da55cee2c524d10150d0c672612f1857123a0218dedefc060a141195081dc40973e08a6932818517a24e01c01b265151002a91d70e96f70d5a2a5ab43f5e90d23dafbda678db633a3e927a4f3322b99c35c9162942508e10c54655a88baf59e5ecb88183a2a6e79ce4530b946428755191c6a893a8741fd00c3fca52466a8157910b87309d5477bd5739ba515b3a70bdd1c8ba1db9deb92a993ab85193d9eb913ee1809d4ba19a24682f11a8d96fccdb161f62a98307b51cd1061b925bf64fc7611600a4b0f9b976298e409fac92d3459d882da6f5933b57724565b3fb5f200282317a434c46d12802d9526d692ed348a4f812ec7caf319b5fea7eadbbab3528ee6f880a8d0f6132f23648b97d55615f485f2a685a871a96d86f712d9fc5dd61f2de005b7d2ebea8d54b1bd0dac6c8f010f2d95d1145f2b878fd00c8ba6eb83242ee1ada090ae5f78d378513683d7f1620834af7c14c41426a0b15003d3229ca0e129033bc5e735d36a823757cbcfdbcc40682e152af2c92b216d09f993a946197c9391d9937a0b66f6d19a6158cb533fb3b9ca3f5b8cdbd99bcdd0b25a3b58e43ae9b015ff24c9e31d55991ed0b63989b66369eca0ea29e4a82579366b554d30572c660712ef70bf8873393ed7dad7613b1fdb3557a147f39601ddb1daf6f1a218460360f1ff4ce8bf451aa0016c0108a851b7dcd370f2be97650ff3ef773041445ef54dc7a99eaf9daecb67ba6926d106b8ab944395f73a94b8320ba70de91c117f90fee8766e0f6e27e4e115274f0d0bd2c1ba7c7d37638be7b128291b1f8cad5aa048e5f7958a78e1bd93d4dfac28e17248a82e58898a8134ec0f9efbe70775696df9934c9df883b30527156fd6674b89ab2e947a488081079b800bece9ae31d7922cda379a9cc03407d0245d80b3777a4d9ecd2b479acb70ed6267d9c4d8e7e198f3c85f774d9099a586428cfedc4a31214f2f2496490e9d03576f13f53ed5ea89925329302f50682d7161cc0cf474d45d2819700299cd0edc70b1b3aa525a2354f0f485815420455daa117b73239edc9a5ad91705253d6a424a3e0cdb89a3a1c59838feff8f16c91b0243b7984f8c73e7c0756e3cbc919e5807f09ec228fe6a708b8cce06d987775417968147d142dc66e2a18aff27f81b0f7bec52bd858506ee3f7ae621ef7a7d7d1e7a8beb3c430959602615f47df193e1198be5c861df6f9d70af365b4aa97c4e4f90581ec8b97a64c1e11adf1f874b80cb23211e6c1b25feb979d1f6a4f4be4335f981cba01659275ad0551af7e64f07771346af4def7c64c72aff37ce0a0962bd54bb1b6a45fff2c6e201751961283da4cffb85631719fd233730307b8ccf99c7cfb70af089f923298c57867af22fe371a7688054313ff68b202cde829c57761c2e9a950906cbb594e89ef9a782d9aecba98cb03d4070b2605fea419ca007c465ba628f4148bc88533337931253e8041e9ec9901d9305761388b8ff5a96fdb9de4d6789e1c99fe0bd209bfb579a7d1da8c36605e7e7a057ab84988c400c682ee1a4640d58c53b4c1837a2c54d3ef6de1d9aae19dc72f0f4b71fe12bbc0baad59d384f01c9f9fd44078c7ea55c9c7e2349330cace2b95f0c6fabac73714beadbeb82343e9e840f3e261cb32fab76c40efcbfd32d9d1a575af9f6eef73108949afe484bd9b49e14759644a8454f81ee4762d92de7b144b76a3d14741b22ba7827d06ea6e44562384bff54b5de392bdf5797c0097ce4aa96a159cffe4936b99eac29239d9b8899b2bc03f7102dd1685f7a39ecd91f956365ee2f3c4de628753f1960d4ecf25bd6dd9f6a69a92b7cddb7ae9ade64a3efd83919e2ffe5f61b3a55fa6d675438092a94b73e3ecdf34df3f65af7add999eaed89f95bc854bcec7d45cfcd7eeaa9998e28cbf4800c042ccd9c2fb23ee088d85bd657a9597480db74b890eee107c19ee2616409173a42a87a94e32e0741122a5f6cef9db77dc5130f2643e73cb7f2f4110845dcc7f7dad97e370d4c18e37468d0aa713e5d6780aff02b56eb880e27be99758ad6d82de46ef57ad0b7c8fe6cec3cd8ed5e89ddccd1f96888555f97977dd7dab81f3fff9312f94d79da0dfdb1192b8d23ec3fdc1aae53f5f0413bc5f996f92f91056da2c82b5bdcb169104d0c42479ddf06f90ddbf1616e7943d2c2c1e04644f6eab0954ec02feb8e6acb8c022f1628fac9cd17ec0a253b546332ee30c4eb9fcf40651a9bd859cafb4f676478f473071783404ada1c26b47839cf1dfe79ed408ac2e3fba328f6a67d30b6d73a6858a3f146de168f0372e666da9bbc2b3ce6dbd881b0f200de21573e14b08af4d0da9509f9a523d05dbab276849364377c25091c7ee6c3ca341efb2f10fa40902ac46af6e5a8ac26fc4bd5df1f522eb2b123f359bbe1b35f21e6897a5914e2958f2fe9dcf7d30a3dfeebe96628e69e61e804409b02b16d4a8c8b0a92f2234b0f55d213bf48a4c323e6eb949a331603dd4afc9da39d46916f3a52aa54c7a22218aa6356672e3469a040315c3be7bd6435763edd0e1587e59d73058f19c49c0f95a2e1850b06dde2e55c8dca1ca7e5f3f4cc98c4be3627ca7e84ebc0d22914399cf3ac83c42d79adb972a820bec1a4f2a193c9e82ae1efb3266e0ec86e57004ae1b74533f103960853185f559692092996a718f2c8cd5578e2a97f11d1e8689dcd2ed756ceddd39d83713b519d3df017fd1e0d424957475a641bce83b7d8895b4e4e28fbd9a3225079e1a61232da014c2907eff5a4d1ff2987378bdaee6811a8a72be2252ad9a3a9a257e535f176f270d3bc5f822966e42f32817cc8fd105d34000b0e644a67ab808899c1c67836bb60bb623ba256470303bb2cdcaeb7f3177ef642d90438dc4bfd9b1616f59f724f33e70d1bd73ae8df6dcfdd3e13c0291046febf05850f248fcc6f56ea6e78f21fa41e534bfd9be3f77df1e59fffccff36db080f871b4bc3f45d13148e4402aef515a07504a7496a9b508763ba70c9dacbbeab4449465a0db478205c200aae265429c162e50cf745e156a6d8852978592319afec283505f273775864548a87f93532213b30c881d30b05180339e0999026a865888313c4649111f11a7f935835cbeebfe0238062e425fb971eacaa7f37f5d0093ba84980d99f4d13db60a9e0d650b0e07277d746190627541def593c3a8f1ca88f2e4f49bad3b160bf916dce22146f04b20915c5dd80a18e35761b8f958cced8fb9c11be3e30722f77ed906396117b8e1a16bd87f88f93badec70a4a3b81d815338d4e00ae0073974cca1cf52352c2977744f5b7d5da379cbd443499541933a910cc60577ec01e4eed5c111973635f8a4f04406b4b6a3f40ef0020166df192de1cb85df31bac3ff821c8864d4c3cada744aad52d0e366d18b65b6dfd51e4afbf5e857006c19aef5023de22ebd84d263f2214b53e7877816a1ce4d7495d65f16e616d20b306740da394db29201a4cb3707811485365a5c10d9c481a0a02cde9defd8e380c5d57e3b602e2c69adb7c53f025f81a5ac45fd210f620cfa7a7758fdf2cbf34528d48e8d53add6bf082ce75976332f29b6134cc4d04a50b3c4e8219342952671a2ad9ee511758c9410a5771774d65638da55a449a47475b33156dc90006fafa4479a843b2533a6715fbc77b7924b530345ef134f69e726d990715b321380221799a995fc613c530d45b7abb91b9615c8a180774e064bc7ef0649bfe6443fa84a2ec68f836d8e0fbc9342ff32bee2f90e4c52b28ef85d5228613324320f2fa3bc11edaea228face88cca62de4b0f6986c89dfd2b6e086318bd50a57bdd5c6e572ea88887eb8f804e99bd9f88306d4df1433993d306023f598f7921b548b66bc9a2694b58256781558dd931cbe48cc94c9a641c605519be78007f69e4f03fc7c763ea82a0cf3e251790f2a66e02d3a5dafdfec16d4a4ef64b671cc846dcf46a388af307fb2e529358a030f48ab2e148ddbf2be33dac74067d4ea4c860726b672f3f6cf7252a063c889ae9ec7caa416f99fa2763d45427439b14e7462310e72d9a2cca7dddd00bb4c56e91bacb9e80f32cfe47701757e702dcd42ff4b868312d7e07606504dd746405040b4c5f366190189c2a5f772f2520410c8661c692a3543c34003443a698e4cd90ff9d44b55dfe31d52fb00ce4367f6e674239f45cd1dcbdbfd66a156773d90a94b50209bee0a774c6548daba2667bd33a18a9396b40a55e040b71e55618749d6eb5e28e44f32c413e27cab05e338bc1436a2ecc41ed7b643bcec8d38f5af44cb1a95d15d5516ebf90c072c6d7a28bff2b8b3d43e47def6de68e95be9d0afca7c30b4189da71f4d1d42138075159e6cdb28756cf2404a9a9b9afd07221afe924dce222608829ade3c34a03d5a4eb5f44343392c59a2da3c038ce33a2a97a1cdf2690068f6a8cd781b52c6e524d2ea35a99ac7def3f205d992a1f39f258d9c4cac4f70f2a04109047b1e1824dc34275b21ebc99df0366ff91b99ab7036e8dda626553119a615b4a38d124c40bdeb7aa4fc1c53f424fa654e3f2338b4980adb7b39fe77841bda7e35380bd5bbe8ac94d1782e4707f71cee0e06e6346d2d702690bd89db39223d672018feb81a71afc6c19fd483340beba4a483e990229f5775ae891785c111f7411b172a99644bc9c5da75b12eb65870c1dd3dc35eb48d5d931639d323a7aee8fbf3985b232c90454dc4e3f5cf95d56fd9f8a33a5c8053612bdfcd342d562c975dd1e2067b8281dc26eaa37651eb180ba5a504c79417ca4ee57550019fce0e6f59ae963b4407c39e96a7c617d229090e1a619fd6ed0172cf9d1f39ad19a04af155adf9c42e6c5ff03afe946bd2c2da06fe4f6d01121f4293f71bd605c62f5b4f2c9dcacc0dc508bdc5d3703cca530c9e1064e79cc9491b003b3b2a5a820fc0142b0516a74ee7cf3673fdf6fd9d1f482c653817abb6c0ce2d3dbfac10a366742e407d74ffe1ae16f52f7edbad90fd343650ae76b044fad4e231f8ee56ffc4fabc1d2e8bd9c557cb312f907a044683bc14fa8cf62271de71e6d85bab1bbbf770b7dd881f1aa848ede6e2be8afc49708d360203d3cb6e3d7e9dc245039240c1dbdf7b424b2cf781d6eff439bf96d3ac65b80c820cb90812f78a01fcde39ef0b96c589f63a897e56907e185dd81e127564b7108c78906712235e1da5e2af857b675d089f4ee77f19c0ea32e7f47e69544f9200668627092fadd92a0b9b7a3c2d6a9f2dd083555e2941e26def61dc6ad1b7275df1c7e3cee349cd1e93841bfba6be179f1039c1b723abc3d8ffdb7313db0377c0e5b98f6ea68326655fcebfa4ebee3df992e18ff2dd7a0a7f3754f7a879a456a77b3647a7955d3257bf944ebcf8c35c6672ee51e626bd93c79c55bd611d899f9b88fe7029c51d5c929705cbd62e0ce7acc18e30c0e51f9c93b1e9df8a12fd48160d80e8c3bb0d2a9edb2ac0a166f13fb90c8783884a27ff783233a1583f9e5c66e47663c8941318bc5fddde859d1250759b583105933bde9c04975d4cadca9c47d3d5b5d26ec47dd8d8c10d839befc849c69268b09780183aaa1ad43019ac006f2668d0adadc3cbc3b2b3af09f696dc708c8e00c61b2d9d50e0db642cd9d6f9b0316f0bb9b57793d7b557a970b8df03730b8f83cc95d0806643aacbd127598f8987005ca3bb516cbd52f45371f2c9789ace2afe28d7ee7b5f9466ff4ef4e720c88485f6cc5be5da84cd3523b3dc6e00a3fb3003edbfb7331199f8aad71763e58b23cf40290473a099ef9c5a9f582a8b9e4fbcb7ae2ca360c695c1a4478b5803f19cc304db00eb6b69491dafe14a5e0b092f96775394b12ec60745328cdd923b48850e4db90e30fc8ac93b50e6e59a61e7317dc7476d4d1a20c48dfd61c88d3d851e51b42f4490c1760ed91c47a7070043ce2dfadd5bc4be87856a2b83da76e523adbe67a9077778f775a6363a26fdc140fb7c5784e7ca9a42e2d2bd62a2aaf205be3bab19f0b64231a713ee8db52a25ad967f9e84b069d3679b2540b96c67cbd62458e1ad62204def64357405fd68acbf3cf936236d205d3ff325db2f133bb55112d64f3e11db815ca81eb7a1260549158c8f899599cebe8f4fc8494a2759f5fa1a5e7c4f7464d4ca1f54720b80b1d4e6666cd20d2268b58a7ef99e626139e2b22557ceae9c0c58f026dc2d130082fb0092525dd4776c2d7beb26ceb3ebf1b36264d7a8b37fe539a9ef12f13a6080db0816cc371bcb6b310bda484fed2bb8896a928660edd9d738ab628ab9c1497337c2599cf10a1bf0985702505cb9610d2f18eeebfec42f493b31819001fe4ead0c4a003a2f026766276fd51aafa6288ad5579a5a5d29bff285f7d302d90e9ca94f78fb3cb7ff64689a896c15d784dc36ff0212aa055b56a6103f0f226685720db647c6fe71c979dfc5d89631c21dd85f540c8c7ed59098b1e296a7d9da54d13b3e135231645331e63622a96d7e4dd3b6a15ce7f2c02dcf302cbf81fe6a8d3bf7829184f27b30ea8567e1599b3be53769c3dfc106806a419c2ba34877e02da4119279a54e08a4f5ba33a0e975c168786608570d7984307a0c4c38eec74fd5c9d71be78ee5284619a402319b7e882c342cc79f3799cd5180b7124a3fe2bc9d6d4cb759499731978be0c9c8dd779e78e67c295fff389c18162597e74ed35fab41ef89c35849f1a4bf4228752ce1e7c0255960fee624ca70901a42373e9ca475f9acb8c13fb3fac77cff1ffa8deaf15599c3c598ffb4919e271699618aa7fe308d19e72918216d548ea91c04162d3e0a418a012ef0dbe6a4097e45e86cf7bbe07027b7512978d94780bd3e120756dca7af2d4c4e2c4ac613493a94c1268a031aaefc1e874e08a186ae82894b1f5e1b849fee9010726ec8b36fd60d5b1809ac24091c71bb814093d3ff417d793acf0eb41af6a667905c2fbafaaba103ff5cef48d91cd6759fc70e2455f894048d5d1fb2b5c4ea2890acc32c0d1907aa92ff35dad190553e448d0a1cfd3329ce7b206d35434787431cfe96ab61d93fcf027f32ccc30f134642581d61f453b9937cdc9fdf524ae227de019852ddcd3eed0357ea0a4c84442b49a71885124c523657c8132d62d5afbffd6a0025154a32c046b760ef43ae680cb9c969b27f57f405c17ed88e762617fb82a361290078d74e4b8f91fecd0179f7d1067dc0d86d8155fbdc729128c305d5f3ccc3f6c8b7f65465c1e1172581d70daebf86f72ac89dbdee38b5263ce1a028aea6588b2bd10ca452c6bdeca9a0a16abb1a7d87af2a869b45c400cc6d8b39efeaac34f517de12ffde8134a17dd135ff8842b0e6bf3140f3cae84ca27154592adbc85a842ee1ee40545c6eeeb9619d47a7632e41d81c0f72ab3b62e7cd6d811947869e4fc9c88bdfa471df24b14921293e8cee10c5ad3bae3ed1f74367d6ac964d6541d7e4cc190daa64789212ceb3e2b00f1865a15e0519ba7f80b2a269a152c2ab4b35724378eca9c52de51941da0c8d8103d9608b2d545c7f3055167af9c781edab0227e2d116b30eb8cc6b08f63e43789c125a9d95830f8d8e02c325636e5a27f99dc8195bbd469983bdfd916676914cf262b7ae9cf0057051dab992a70b9f42ad7ffbbd8d87f51eaf1185fb7f81610accb050a8b8aa76b3667d6515829232b47ffe4df770533605a0e479c51f39df259a097442114d1a385bf8c3f2ddc0e1f85713c46741387fb6814a9db677d68c3862f6289118f18d427b5744ca303361a5e572de24e4de24718007e2847afb0fbea03b09d290fae4c09a31e83451b0092565d10141411828226890302e356e02b70f105319084f300a457cbab2db061f073da2c87a5484b2a02f6d8ef991426bd08515066e30a1c6275d5158d85ae64a558c3aaf8786dd0e939a77f50108b0e674157e83dd739ffad50a47597d654bacd0cfcf0497014ecc1f243f7ef91cf8c82c7c57a2ae0c57c709b0d27a0d445c33e01dae83479351fba86d0914f8d5b59351bdfe0d3b0c0d3179f4e065682727270e15222f959660ab813e5c864cf4ea24feedd99658fc7f839ee2af2b63aa0e7ee8ac729d4a119b8855b95b05b3c7fd4ddec8dcfa9c304303526f76011bf007ca19a5291297ff7cc237e5877bf66f9d8ee5e408cc1c62a42f3bff511966bb0f1251f3dcfd67c32b4025d24dacb2fdbd89ecd8657a3512bd7b0523a2a5dc50f6fd28132e98030cb8a363ae59563d19b1f65c9a24945c86af1fa0f97a6be6442282ada6e77d8815574bc2f805fd5db879f8c4287f2de606b55e56a1404b828293933408d3071e15fe26a50a0ebe55541cbb95a0e741fde5955c7830211b037e17920fff189c08cbff8e555d2a3e81e6b7b86bf7d09f97028e2b63a50fc6f20221532ee56a4547aa1842c85427db740ac175092ae923708874a79e0b8baa3b68a5b4f3281aa08ac1a9f4c53a11231fd74025333c6d753f0023a5dc9738cb624f68c835cf3c013c8819aa40e65064e4e2cb506ded0a91803eab984ecf01865d6a8f7e5d48ed54cd841a7bdb3af4ab036cdbacc60f09545b5778d9b7c85beb68a207c9240f287127545fe513ced72650f16a50835dc8c48b836b7b1f0e1471a505d8baa89757c9ea1c741a92a0f3b1e1408ab1ffa75ccd955d1e94317a223bd6c9731a14493545f91f227f56455b23faec38f9c760baa6e70483d929965a8d75dd45ca581a4991c1596a77c21137353b85f9e208a09d57765de8236a71d49aa6e9fab9d7ee767c1339e69075cbea18c099aecd4f9af1605ef362c13513892dbaf9d6acf84275c5c042d627dfb4f998e3b80691e939e9f4ed41d4121b88ca6213fae78b69df5a295e3b7cb40901a83de8d72e762be3e3db76be0d11c3bb430408a6780750b9cf0decec32df93dc7a83fc1f5a57dbc844183e734f1dcc35132b13c1ae83f5ab013402306bef04a231f76abd355fa4089331e8fb6a6e6ff56815a0dbb6e1044556e2ba9c18fbc5c700cbb6bde3a3b8cb2ad8f6b44e57e3cee3c9f45aee05949b408d8fdee3341a794912facf07835d7d420072fa435ed25b095c76d61ce5a90a43d6d93b9c0c9653328352ee873f3c49a77ca9f6d99fc493e18a68d2c1c3a1ef207825d71f43bf41d27ffc584c262563207f4dc38784db9caaf1c3212c589f7e0debaf03ada553151fcbd0a8ed938ed40eb289ef05e855fb50ba96eb02479e262ea663ba8739b99031b016abe1663ed7f659aba8442278b8cb1700518bb247f5f036a29a2665ac62d2ff7c4f369ddcf70fa4f661a7c978374e57ee249b0a6808739e574bd0cbf3af8c8ecd0f5854847a95bbf7f951d496f57d57ac5f2c606efbf25ae3287c8ea71b9ebb9a9d86897a272ebb537f9789d56a28afe828ca9d0344c0b0ede6bf1d5a2c83fd0ef29398867285eaea31aac8011c66e192c77477dccf51b3f6c89ef574474eafcb92f908baaa14eb604952afd0e2b4d66930a00550eaad45b312152c5c8bba81e44ad0a844f8ea1852a85f4417e642715fdfe8f3a7739922a88cb0c949e86bcfa8f846fd2d49de0066070b680e045cec87378111571e5f99f77b0bde3213bf06ab5a020d8e3f6e80ea3d21cc7ca78874e1d23cc8cc2c68eae645925069b3d2803dc143f08a2524c827027316bfdf90e31ca715089f30099b1bcfe90f2e81b25d6f1fc3a0e8a5075f363c744d746e9b53fb2772302ee73bb9d36df9bf78851945188d340abaf67046dfa8b536b01184f8d38d7b2d967add57a8f281678a2d8c6d6a14baf1d1442c2e38684e02778ad1967f3d8dcc643b24600d0a20a4b83556310d02c5cb1b9ab1d3fbacdc64e8d10e8617101440e0e0a3da1591b678238196f711df3a2014d27790415859646bee7695e34f1ea3f9bddedd53f6151f49f6417347f3174d0343e94acdca06eca07c519e7c95f48bcadba271ec17211192c50573c1aa9ee0a8c571f4e7eacf67f63eeb33f8a6346a29b45ee899fccfe694de76d610459e0380a374256a117b71d7ae503d1b7a1082894e7ce1b48db66276b42bb0ab653c7f1b90e3f2edc3ddb52cf8a940872ebbd40c46fed90b6d627efe7521143b48197a201c7c5ecf6d0e152221298c173764534f2f70076b110c8a0923bf0889e6be06d3ba21448c327f8e2d60ecd6b8470d3f26be3e5221769487fa2c69e7c89f5db9675fdf94f229ef896ec7b35bea7440ec1ceb3f3374462ca6fa15da94f5781525659feacc12f170b7e22c27bbbefe2bfa407d2fd0eee58361d7753f12f5266a7bcf2a9e02a646795e6a09277969c03e731a3ad0897be1b5556db3d68454d6b3e8cbf80edd909fc39c4714e299e571bc48b7234edd64a441f90fbd9e6cd244e826c82ec3ef3d2666e5b8a67c94f8099de7e281aba3e55d9cdce1776d2c4462b4d0a37fc007b5b658380c45e833b286e049a589dc231e2b240131b2f2e10471c5a45ec89376941acf196166a3134ca74d5f016023081b994c5dd2e3176efccd2bdff42880518358bfbf14536f92e9596eb4cb714894d5474c349d8009bc8fb361d6088252471866cd89df7b443f633c6d067415db15f036f6392f9889e50c70ae7d8ab7e80d82fbea880cc755c501d00bf094655924b3509493a80377e446bcbb833c4c7b6405eb0c64e319a92851817660ec6ea959b87e54fd2371bba5f2a9c51cd5bf1cf268a69e4b9f8401830c134cb7882727b96e35223cdd1556f93d449e0b5d6e8d78597bb10c8641f163d86383b335e802d143654d9137d3ccae23f2d1765712e4ad594594805538ee253ce4f76792dfa3e4c0ee95d1fa8ea2ee68321f414d29bb5a3dad9dcd490eebafbbfe96fd69516e330165f8635794f136a139de493ceb1ea1bc088d4fedfa2b15c1e7e66ff331d3f1a18ec7bde3315c9d6e027e29d6eb86e0f4ef61c23afecaa8685caf80dea9743f315d548613a596aabd1347424ac58c64e063a45101cd19289eec793ef62a96936d3014da199c5cca3d45264b9061d3cd38d59b916f7981386ee42a0f7736a53eee0305650e29eac005aa47c0dc51a1cfcfdf36be87658e8d5bd6f6ccd445a170ebdd5b65925ed457981b7bbc4bf504f3b3ecf4ade85530153accd2b9d9dd1cc7a9b302962080bd1b9c02715912e9275769d38ab09fbb624c93e0504fcf54b9bf104a41bc486e06237d73e4740c34956fe68ac23f6754ddfc2bc31b672262b1b98a3b0e4c94b560df2bc6aad47e618b3253fc4f43569426873b183aff376f9e6ccfe6431453b0806ee03e8dab7c895f3b7ecc1eb58fa18a4df07356e25dc786a403592038378a1691d453450794ff3316c8ad68dba20f3e416f658966ecb2938774b158818f5b31d6937ae866f3960c7d54ace3d69ffcdc42d75293579d4ae1f70f46a5ceb922556cc82b636939800ac39a4a1bf211c1c1046671f69b665e44ce04048990cde30a2bdae32a28c0c2d7c4a6c747b6c3b605541c9216a4695ef52106345aa4ae141c03d8cbb9d5c92f20de368b823e24c556d1d13c65285209b89a6143c918eebafddaf6c19a79bfb747a3d82862ce589119424a0da042425f389c5b92188f07fcc104f14d9b98705502e258df312d966b287d212c667377c18e72e7655c5c50d7a8eb34fe4404bc374a12d022122d3f5736d355c696b909f84421001e95564efdf49b6a794ff0e7c6db921f2078e7bc1322d2645947812bfaaeb7649c6ff901e357154b878dc987d2e95196d4d263260bfc2b339158ed01f6c8bc8d6e35d57018b9d074f8c1ed4dd7536d8ef9ea5550d6638fb51e72423ba1f4d3d45e357c96fd89653e6dfaa8b8f147c4e96b0b5446215d5c2e4b40a621b8161f55e4e25061db4b6772859f737d2cffbfc89726ca1656d3682ee07789908dec78b02b595f3cb6b7f7bf63dc515aa8ead2e658068d3919e261de69ca0bf8920f367b451d1e394368bbf2e1fcf62190a5d92951bef5efae87e23a5be8394a15defbfd0d359293759e195911555c4557d29eca9363c9ac0704f0ec69c937498730d662f9ccb1d5c319a736d2bfbe2eb2d9701d2b64072d3180df05d9c68112acc3f2bc500afb041056f3b643d3d38222220d53dbaed1ec0e5e1e26bcd00ebc6a2cbe9adec6e9e27529a7a1433c530e9772774daf6d9b3fba6ddc62a17edd7e37eb278f200f06935638dffe4e7beb6f401befff8c6b575f2d1a727a0840b249bcfac5003d8b293ab544cbe3d553258f5ebb6ebce57114371e2e5f71303d545a71550790025bdf778d1147cb0a5055ee1fc4d374680156d5f87b6644790813403320380ce144a04e670cc7f3a80a34a06676661c4c6f4b308d022b098c5067901a9ecf946c6388df0c647fe151f4d5dada2191da6fdb5db9bb380de13d3827ab4e1e020adaf1920266a40457411d044ffe92ec1760da8f3e49d1555b5ddef72c18c0215cb272a481bdac0c9e1aed30c294c6197f561b7e6368ed949b2087f6c0620f3a25e3e1beb141e9c4ffc277f8c5526369f9d4593bd6cdac57887252a88cf7b7a0f6ea3c1e6aa5b38887f7e4790bad92ce591f6c7339175d4e903fcfd6472006a2188ffcde96780ff7acfbed7bb8410b73253fc3e6ad5b86e3224492ade36138bc28e91f614b979982da1b6b96143528a2365a8b8f0b51b6444ad7a8a889a32b250231499990e07f510f44adbbd87cfa39bd20f010add4d920f56dd0b196df1ed8da829189834c73109ed2199e7275ed8436915eef7d5e47c8ccdaa2d46743d33bfe943e3337baaea42f588c5284e3021287989906f79b38a9fe582f1cc6908768e68076a697b2393d56f671211a05c6b750d6f18d5f1731ae79beddb49628508f3a8aca1c0c06982c4b0431e41b1db72a2188b3f052190a9a7ca05251d42d58984511de448e3fbcafb68407ae7e5d92d604c90a5e00cd6dc408e00107618b6e1e706cbd17c845a8ad1f6903640df9023032e8dfb476637ad363fe13b26aca0aa4138ee06d78520d05b0229bf679b9e694952129091c63d82a028caf32b5ec57691c26359e4a065562c722cea329707f54c76db7c78c3775867bab54300389add0248c9ff10d57909585a176734f425aae1b8e54ebe5e9710e39828a82fae52586962b9a67c42d19960ef290dd40893aadd66840014bb5aeabdb44e9043422e19eb05f274d6608cf7d98b66dbbb362fd9d89c58cbcdc1eac21ea25ca35a17aae08f6c83a9044f93dce43acdcd9fceff3f858e1d88d859150df0049266b167d14ba64a80fbe551c1db5141f4cbb6d766ee12ba246500b09c111940d8fd646b02b2b8a7a7f3b72eff80006afa715814a79319d38931c068162b5b095c67b583bbe27a2ffac35397cdf5c31501e87af67153c4b2e5d24c0e5713387964d9b6956a51c5cae0bce2b2496abe39289f3eb9557ac3f355000cbf4681467373e65415f4930c23adcc43cfc6222c732093443c24f0084bb77cd0425edcaf0b60c437fe655901db6652000a7820815f2c326a75c10c32ac9453958cd0a7180c7e3330c15b35bb2688a98a47bcc647ce86553c0c2c9615613fc1cd46e6d384abe8b42dc46e14a53c1cbcdf00a4a6086eeb58e7e1fe3c846ea81f7c05f2d82da1841077b812ab69de8dec48","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fc424bdf4dc12a423ce827fe8571d1ba"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
