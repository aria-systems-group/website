<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b981b2c240f3cc293417c9daea143758d18229a9780fad401e43c86837babba9768716fac45062070ae028fa55988554065358d8f18bdb8ed6e963168f480a0ea52cf454ecea0a88de84ad5b1fd299e5a1a104e010fafbca43de2a71e54f3e051267d9057e99beb6aee35dde2f4a61f9866909d02d9617dc6f59c4eff70c9206446e91ec30e51e4b8a08e1cdc8cae13717695e0023637678dc8cb8876a49aff36802007913ac79a443583c909565bc59cc2f1d97efb7bc4b966857f75ea0004c6ab446355b9209d19d276e936db8fcdb6d2c3dd91c579090bdb99f5f7d0c8d8194abc9fa79eceee3fb6f03f3a2fb0756d2b4bcddf6cc5484849ca5cd14bb606792bc68ffa08ca733d28d622e900bd5f19d5e600590cb74ee6301369c73e3caa196d1400fa8d97502b73f20f61fe939504c903b1fe3bebae1ef2d6a7ebe198b1174e710b30394a2dd3b87fb22cdf08e8abc239432a450973c8aaa8b06b0e8f6ba8e25242d179afd1b42def7b65305c41a349256a7c55018164f0c4a251d8537f08328ff3d5fc2d7300b9acaf1c588c8c48c22d088a38edfc8e9502cdee1c49ea918cafbdff4674213483395e5bb2d7c89629336af65faa399f02cda2b3300dec8b677ef62473eb5764e2f62a1d04ec817c13766bf3fa0346787a32417425b593ab468fae9e91881cefb5a21afa72a48fbfcbb28542aa726c62a99ca6e550f10d9735ea092cecea8ba9898bd1d4133930e71c26f65bfa813bc9440b699963dfa364f2ea26d3721d85c56408d46be4441ab8939b9a42474c8f81db6ce4c76dd503bc82edbbd92e8f18909b9f83e324e49f9e03e479e2684a3980481fb095a3943a71567fa7b412b0399d7d7497f6fef86a1c3bcc6bc2305750336a1197928b54f1d25ed9abc3f4fea470e1685cadc7dfa547dc3460aef640f7a31b094e5d926923f27cb573e200bf26e3e0594e429825bf2d7ebb0dd1f050f63e424a71efda4b7c4402df01fbc455df76e7f400c3a02693fd7c516215b27fabf74e998cfbdec7a2250a55434aea3e0e9a5741aff65a2ab8b81b84334d9121d856cfc85ccec590c302e4cacae3789b61cb07cbb0041c73f39739040ff5b0533983136b2cd3d33b753f96a79fd82e94dbb287b814c366f90a25dcee2a2644e8363b1a61918b0e1a81f49be18201a12d17312ad7c56aeeb2fdc5021f5ce64382eddeeb6bd3e50e879f205ff6e8b3eccb669a5a8c45ff2a1fd853e43897cf0c211f3b6e733fe8bd660036adc591b99c0bc637c61ccd403551195f9a02377a37801a3576f91168c3d0f807bf143d18830bd1cd3ffc68f3b00621ed9561d3c6b5f61c294232f8c695cfc5978581d665e3ad3a4e2b9bfcdf666ade1472e279b410eaf53bef4565dd6e8b377fe272ea0e78070e8472c9ea7bb1638e26187135cb9ca832135c369c98df3d303d8b1fc6bea72f2b35fd193fbe19f5c32cb3fa656cdd95aec8ac07e4f2b8412dcbb08e8290bab280fb4fd8d44d11df4187ec00f18a03ef73802e32d9a5a4f1eb5c88be56a1ff1ccbb7621b2153790061e99bf0e1ffb43b6e9e5a5fa5c7b71a5f2b7acccca4126321cad4333e8f13a245d7f6cd6fb5440f95099078bf6e5aac2a329fd84118feaa150b016774d5f964b175d928ae8dd9e9cb8801049331b28c5cf45993b6d0797987ff17760de5073ccfa03be9497e55a109574280ed017f9f959aca694ddd0cff28e380af3b0856a533e98dd9cc750545bc79bc8154fbad5b42f765c27738fd37f95b907820859a36f5a64a3e0cfd5344474aa65ee948cdde2c678aa4d829ffbbc6ca3b83fa995b774b8dd8f1c8963f3c68677ab74dfce238e4b829b5dbfc91191328b1ccb7ed8fbd7f502d591c646db47739d40992d3e648015b038a601977dfd1d92e1e1a6875358e975338cbf235d8e3c5081d20efca5a9d2c6e32c4ba125457b5863ba3194bcb47c794a737e64bd5c68d2e283e5873f38b906201c59b3590b69e7d8c96da1f267da73aa9c6a1a0adfcfa61d057e932f1c794bcf745330098b021bce06ba7a4368cf1b2d6afab1a7da62bb840fdbb0b6c51773bfde5b70cdced1ea45c65aa6a7f51dcb394000b04fd0299e63c77478f8d18726bb437fa3ba447f7bdd6b5f4db91d550e12c2da4488e33b76743663954a5deb536211c6b6272e55b8fc1dacbdd02da3c397f208142aa4f49f23a3e0f806399604e1d19e1ffeb2cd464545c3f2db9d210890a12707803f8e7a47592b882470b1ce9f8d5ccb86469e0a40e3593cd862fbab3b73643a245aadbd288407de5c660e1da84e37adda2e78a029cd59e02ca812e59ad996aad4597a5d6374eacb93bc21cdb569cce8d38932f5f4f6677cba07519fb5cf0c185a1fe34e12b33ae86cf766e8c4e8469756e00af48854c4496c25264bcf6781c9293b77e75c002e321dbaaba48facaf3a06beb09ab78cd433284170d64d694e2a0f0f065bebe677a6bc44280f30ca1c33cb2bb4105dae17d1ce23d95163035d2739fb1ccb6310fda0885e3ff77859e482847d0fbf25a343790c799fbb558c6f16293a00bb20242c46255ef981787f5e66a87b7d113eff4a71b6afdf60434cffa1230a73bfd5013568f22e4ca359f7750f805f4c83d7d3cd57b1b397f09af04932ff00b19731743607d2e8b168b44dee28b2b11404ba06d89e61ffac35d4ce20b5fbd11d56245ba62d0e8d5a9727959836a6dbf7c30d49cfaa7d3214e637ddf96ab15a07fdfd0415add55e8df17079f8c1a288540d2760e0091b0cf4455fadf7d98c9f88f5dfe493ab356ece2ac9f7b00b71ac49548a98daf296b9219acfe453a34da8eb0ba562389cd37125cb32d07bb35e718d90bb82fec1a0d38ac76cb4366ef96102d967f177242a67e3e6bf40a28ec4778c6c6b373a7194c54fcea70e6cb3396a30b8f7ac24407eea12637a454595bde2e6b65f25fd8f73c245200da5b38e60ad707a71a745a29b62c3ee305a18b9c13632f08ec49d0210a4e5195728cd1ff98f5b1e2d97eedd13e11a31f1c46a38ba510ab012e29e404fba7bfadd43579e313e6ac3ba3dff58faef8883b97b9c4cd32a735f37697b16756d1afe583d90207a160fc4597f457646d429673276bb4847060446ae56ec929f8db8f6c396f1a8bdf158ed60f660f259cca824e47d3441973164b643b548994fcc3cd418c6a69b2bf74643b0ddfbba5957fb043b3977e973b93fcd0d3a405e2521625007a60eb065520f01998f262c2d3303a03319d07c6ebd85b331cc6b43689532c276585937f6d54086676145daebf29b1922903f47742f2a4eec4186c5fb7b364a218cff839784b0dc52b0df15a44672f946106a14a2111ced057badabc40e98d8ef819bd4d23a7dad3d2310e3d510fbeb836b8dafe5ed1e04261bff78ced759a3d1a3111ad7efc675750d6c9717c11b093361a719d9fac4b35852766615b4cc9fe1a2339d3dffee10f09e709157a491f7e1bc98b715afef9adaad78961882b6de9e342da6ed0933893ac157278060047add6c2dc4c3493f82a6a09a3937d70f606186f0eef39df62758eed8d41683839b68a8eaba476a6be989a3808ff00a89872f1618abbeefbe24fe1a5a8a2b70dd722d7b78eece7cf47cad5d9160a16eca6b560827f2363f5f7020bf279f66a68edf6c690f13a8f17437b62ed06b5dba50904dacf9c6ea6ada9d355c6bf97c3298edf6ea93b661b9a4da531adf1921569e5e95dd273997302a7e1d5024189ef8a494b3a452fbf8f35c2ec168a65ac1ef8fc26b6ad85d6227f42fe3ac4a5a486b43e2535bdf7e1f74b3940062792947b16d37723c155101d1f42b4b821346527a68c8049261cd9d650f349de0516cba45f0fe74d53fbe4b822456ef8e310c474c1ec118472d232e731d474fcdea78912d6d89f1a09870473ac5f613a14f408d5671ec5314743b6b75faf66379772bd3cdc03590b7874bff1a1a6e112cd45c46d9550df66e5e294af19b4afe6c9d1928a905ae574649fe74783d2e1ccbdd9fc434abdc29714ed107a6b8aec2c15b8972482103c7fe15ffd8c72702d885a63c69efcfb6cffdc6ad0d0f3f79bdcd1aa8611dcf631fca559cffee348773e416eef3199712673b9ad16e41733b7a2969eed30a02d87f43601219ec5742eb831bd381bf094f697243444317c26326a888ee63556c8fe425636d8258ca5b55829bd7841700c23c51a24e841d055aa15912c4fe01e8fd2081013628c67e1b160c33a8c5cc307336085dfadf2ac4abed5545c6a1a2f5c6ff36a627139bb85c9aaeebdf8310493adc2f7e8308ad9fcca32a37e278ee9e55265af314a9e5994a3b15bc17e206da087ecae13709e61b55a57f2c62eaba4611a5018c00a567c1a829a2c2dd38f461bba75ca0f13415c4969d5fe5060f2d5a496da8ff3e77350e56430762dfa6405a1b68ba6d229b3ea4e5fe0c6dbcc2e6cd5b7314d7a2c4d49fa0a6cfd547688faa67755caf9f1e4772339a012d8df6ff4366ced35a6e3d7cf130ce43e1a199b0a325e4ce4b30e1be51daacfdbf98bbc8ea1f0f0ffc7e289e6077f938f4f2c318281e53bbcec04f890758e28b201ad176d0d8ba53130981899e97e48917a8dcbf9e80b54530c8b57887953262beb3d098380f05957995ab2c36333f68436673a79c8e3c7d597fe6fae95fda5e6d1cb5dc2bd52665efa733e829359dc979f7ccfb3032dc88dc72c48b2a9e373578c3e2b3ca41a4da75b1e10e82db41bde2af4df8d1104ea2bd166128eba9b56dabd28068000bced60b283245a50d4c2818ea1783b0db29369e8c7586b8dc48484ee25d5ecc4d4041dccc132c99a697274735b0a181c4b61ed10b222dbc1c43940daecf63374e58963473479024b0ba3a53219f9f5073fb719ade128563e85ad980bf2aba8e75e0e626c0e515f4c2d9eadf97bec7088af54ba80beaeee4a8d20d37fa680683a57ee7e04808ddedb18d629f0b409f8060cf1c9e4928a2963f786a4b938b6c1b5c2e67852a6bd0278bdf0b21de6aa92089561ade25665a2a4902876aadd01a59cc1a2117ab8afe39fe143b0e4cc6f9b26e4d3430e6a5c94f442f610d5c6ff89995ae4960c9c5009923015959d524170c9d5d8be839d0f3b8464c484bbe9d3c983da88239220b0dbeb688927a21b31e5e36e16f925d5deb366af02f942195d3b47f6b4abdd66a6f1ee6728c40bfa18e37603e65a96672b4a82a5c9abcd570be59367e88eccd9b34bf1b1cc7b91eb9b470a9b15d29ef724848ff9bbfa89b2f3f37c44295fb37d3a336cfe8059f36bf093cec06e40c80c308159e2b53731a4bc37ab6fc894479b9a81f617d4b0d4a6618a4731de8a92212e986182b14497ba32a95cc490fd0ac7ea54859616fd3f851cbe99f949412a5a3e8e46253ae6f873de246384727e5878c9d87491d48146587a3d1346e5dbed5c1ed3500ad4f9b435b74528b863088cc3d3e90729dd3c3aa274cbb7aa96d0c714d2ad406dc94e7ab9881cb012b2a6e81e088d9c667cb0434244769b23b1519651e2a56fa7fa35d0443fc810c25f2f792594d9a713a999e5f0013057d513e998f4a12782a588eb4ce23dcc4e788d37f990dfc1a2130bd41296585de846c39b1b078b8c718500f71edc890950683a0c7977b552af442331921e9ed78d1d4dc61324f472fc65ee69b643e10281ccaebb3d288c80539f835d4023adb37dffd4d618bc6cf608679f7498d191092f3ba0db713b39a4a6627a2820c26548aaffbb38072b4f931bcc6352d157c57382294ec81b6c807abdf6f81015df3e839ad0df48e434fcd8e8fd7a8616878465f426dc87ba3f25c343fef616a8d5f0318ea0a778e37920184e8f2e961554a16cb81d9000221e7cbca8f8b66a9024c5d346728ae5147e3a6224f89b71cc0199b38ca56b37b39a8d3c725c93f17b298563ecc5dac5df56a52347857cf3e37d100f4f8dbb005f1ef940404cdd0fcfa27c824bca2edeb5c19f8d61fd94eb799d1a56d7e23e9ff3165aa29284c3f1f01947287eeb398590ef613038061684ff8e2eb1d3f7c43a88e87a353d23f855db3458b50515176bcdf0fc88fcb8b4951af790548a45ddf652feba646a0229cf77b7e152d8b0b52313b3d7a6db9308d1d47a2313cf6b4af6a073d1fc2a364ecba03345b5d48a7b1621f2db25e1c84d40e49d225aea54aa23863fd7f0437fde1e43466bffc5eb1ec3c2c7cbaded99f75211f59bc1a61da263693932bcad2e066959e131a22bbdd04a801b129220ef36ff315529fabc3425476669b0f58d50ef45d6b940c74745681fb6fed725d64f984e992a9bc251ab889767aa4806f990c819764f9aa168fc67b8e320bc19a936d2540cae484558c0e049293ec3ccca7e61fc72a598bdf86e39c061654a49a3de3eb3e20a0203eee7bda4d7e299768a3af1aa85e7680131292f50b6cd04fcc063df95355d01e230b7e00828a6f0a3e116c2787680f989389a9a4c6ea9637b69e7bbfe5c0880071e2b0671ed65ddeef396dd534ca724b49cbeac9d19c883fd1789a1ea974b73dae4d73e824e118ffd68a17c2d72142676e89a3b7286595d2541aba23c241edcb0655f99ba39da8701986582e4a4cdd8392ac82f17b3237f7e8a4320b5fa0cbd4765118682816c050fdabcb7acb4dc32e87cbf9d2257abcb5223560958269379d36742a0875ab731f0a9703210ef64597dc754f1b9954d53ff12f4769b25673f6a1109fc89b0495c2e19e47005498fabb26ca0da9be7ba69cff13273d13b237fc296aa4427d8340b273a68fdb24cc8882f1240a50fa922d58da58d8813ba47745b40afae7c42d312876c57a2a684a97edb93cc8eb7cdb3eaf0f4e368e2ae211b5c3cb51d5a2063071f54375d4be43f364cc021e705f844e14aa362048f80e3a3599baf7604e6ddc4b0453d95f9b4d7738d8fcfb4b20ff368b9215383e658660a44d7b62ba30e738bd9d3a24ad6508f045bc37e06da61514b79ca9e459423c4cd414b1a02025f8e6822f1cfb59f499d040f0edcaa698272f1cf64edefb009b502516d477f0dc212ae2f988f299bd6cf11613172c991adcc146e83c135cf4e125e01d45de912c5d998402e03c63a730505da7e3fb2fe27898048deb93c9852ec11092788287b5358397cb49168edf1c83377f8c57f67f637e6c7e8213ac08df7a8550eeef8462b1194b763c655b5956521bf5c22db9fce247c20d5e307fb29d37de52282723a0e54bde35a6e3fe575be00eab804a5ef97a7be3f75e2a38a1bdf5105313e77fce43de5473b362bb814d29ed9065bda740283499121c686a4fdf28da8eeb2a981f740a6807cc3919fb0202d47a7458c2636781fc67105e70fa977e8bdb2238a73a3bf71eec174d9d0e8055572769e9b22be7444c640e20ea9368f7404818afc8049072795c6f78169acd48dc41786fcb9599654eb779e446db06a40601a106a94edd0b2401287c256faec7be555ae7e5e5c99b5a86e2f5d8297b905bd323879de294f56b73c371c6e1fcfaa628c7c9507ab11e41b125b14fcecf290db90e1fe4b4a9f24eff88f72b65c9bb496f599ae54f7925165f609f9cbc51340f4bdd48ed7b87f3e5c4c94b68c7a4289d2d5ebd3e8f510daa359f75ad5bca6272c7774b43ad7e2426b2b7b5db67e78c9cc5505d512946cca37dc20b6fd210ca51c65bfbdc83a9ca04f4c7c2ca6ae291ff49e65af571fee5f430d61fd8430cd731157ee7ff1dcf922c36c21b693b01d21fdc96032adc3c81659ef51fc8732db3c951b7bd60ee5fc1567617e3651127722fac7f6927b54225c98d20b1533d215cfc9bc8b6412fce5232eb7570928f5aff4ace2b5e94f362d49d7218933d03a942a6724e05a8120476cccbb4a8c312c5ba2f62a38f1b809f32e37f683c828a4d9001602f9204a10b112519a96e46d9632eeb9ea01c5f892740ef1dbf02e74c5e1b8d6b489609a36bf916bfc1257f3f18718e27dea1522fe60e81df760e3131c209e6ab61cee48f56fc9466b80fdd18d634cc8b6b0f857a896c9954a7e6eb253e0c73ae70796f0ac26ae46796272fe08d2f17bd70012967a4da1739b226fb637d5efafea347b0339ed4baea147bb2ba5ea83938b7f0ee1b42b14123c212261b0217e5f89cfeadbeb76dabfe42da9c05621278849a7396b5c571dd8c51aace1bbd3219801b7735b76aa7725ae08dfd02d70742da838d54865f0565db8f86b1fb726438858cdee74291d3909928efe7ed86eb21cebd89475645dbd25d025a18f3b114b7b7851db2e088c4c2eb681bd964e84709824c276eff1cd43d4bddee83301bfec7d4b792c04f3c2990924cfd45e8012b09e60fdc57763a980e2ce70d749698b89a3ef2bcec4e2c870c1c352f33316ebe87c2e5992b669483d374a856cc86b78e31530bd5ffbbdcecd2a9edbc22ffd5ba3faf4c3a1985f1e83e088662a6d1ef3ac09f6c2928bc1089b8bebb3f95bc5d981c44a09c06e6df8c84c6fb0143495b11996893495e4c5ddd66f94466a4e90e4e0f227d10465d7c459614526a15e2be7bfd45e1486c38f8d4b2d06fad2ec004e83de9776aa1b1e7e6f7757f345dd0a44c2c51e70964b3f7ccfc5fc206b1e5e98acd39a23d674807f78da56a95e92d85ab9b1cf0fa924973decc688d51ffd5fdb1750afe71ed4b164d1ae67de858a2eb20967fa22f3a421d555282b807320c6140f116998d8f52125b7277e56470d3fdcca7cf43a8e5c2ecf1008975e2d7a497b4a99d46ce74c92e4ba19e3cceb39b51b6a98ab7da75216de2fe697a69da396c6d87d9b370958d26f3d4360bed6f01583bd4b0b3ed72d8af09f8466c7748910bba5869e0f6abe815f738674d534d2e52dd36339cada132f71037811ea34cf450c733d199f65a6ee130a64f84ffaeaf4e35af260031459b1538adfd57f8e29f7573089fd3f1c7f3a380f603f88baf41545c13744e4cd44663081c973bd2898fd916f7aa291db178c0790ada74758f6dbdf60ce39f698b94a4f8ab6977e3621efb73e8b660116d56ab391de3aae3483ff5b35f5c88712940d75d7dc56836978012a81d3c5a506c952b4bef986b3c755b46da2558cb9871b386571811e88334a2da942f605d2c51cebf722747addfae668dd89cd2b34e2b1460d26058e16523aac286eb05659788690bb7dda1daadf0a44c1aec83e9be7ec68be647531ea16d4972b8d07c713a103fdc00b07e9154ef1ee04774f3aa32986e4bb9c43541f75d5bdd13b42c7a84d764d71a81ae971b2146bffcafb696dcdeadd2fd7dddc0f48ee71350f276f4c449b72b982f3c533f404f85345c6c7606493f48cb86a34182a197a4b52436348bf4c78f42453b493f7fec303cf91d896642d0d9a325b20f81860ea65369520b6cee84a4d1478779d17ad9f7a805f24d4ea41899729052911b5c4777980fb91cf812e4cc74e3862d908c56d3dbdd3fdcc6782be6f260e1551b2ab3092a40c5e586587951b5e420f0e9768ac44fda197850e743a0765b0f72459f14ff3bbdb8d24ac3d6556d3de22c332ba37cd3f0d6703cc916e037cdfcf1787dde1fd647ac734a2f2d464c8a9af439409b13772a92a2659dc5e0936c0e3a8c70a2ae80fd1bbc8557cd0ad3c36de4200a94383fefeb42f6fa39bd7d068ba8551354ed23afd38c6287a53e9748fc7d6ca4ed2828d537a3a644298491edf5ea55b538553c6b6db76395dfeb6afc95243636a84863d3e76d04974e8a7466c9bde2c267b7a8c68b56cd53ed229dd63e5cfd3443ca27b0e5e5ad91eb5116dcfc384451f795d906e9e8bf80599acec60eeef7fe6de0e5d8ae080ba84776db0963fa7c25d78e584f955fab62387eb9f8a7f367b3b5be1cb46124880fedd0687d6a02db75e81089d168bf016272d6dc31143ce86ea98fd2e8b0cf76ff5b216343a471322c8a60e1b739e5eeb6a63191947123f22de89ef1f8ef398d36a26b97fcf4b8fbc33d53400dbb08e897e38331613638a75374fca12ae1927987ed5553cc1833c55ee9d2da4a1f05e1629e5de0843ccf35e63f1fa0d1be9643aabeb758544ea2339b1718a68da169f81607114d888011ee3b9b9cefb7b5f4a4bc5cf5d6765ff218d58bacd3467e77b434bcd090e50f75ee603f21c0bc7cd702ec730b0395211eaf2aa50f233bd5587d79d6f799546deec78c643cd9953a63181df2e3f187da0e564e4b1eb2ad18b497f824814d518cc418b60b477a4517c3704b7530d541de467d63f48aa58763f9f0aefa3d9a36ad8aa4ced1187eff6652d32f700c2fc1729197d80407293a342cf8aed3e4e8b5b9c7c054ca3fce674ca1fa465a994ab96a5b996048786f8ae83fc9e2281f31ec515da1c9ff390dff068008c9352d3fb0272bfbde3b5fb432bba0c3c895967a51485c28d03ac9174face15c457825138fee0e7a6dad0d48751ca548a6419fa69fd1efa55f166f63fdf5dcd6bec6df9cffa440ab03a3b05c960251ffb74b30473ca5a2d68b0c62c64c6fa2b74a8dd919d4676edf6f6116db3dfebc6dac2a651c1e8a802f1469e96de9129397b27b51330c54caf37c9471e1132d8524d9366dc559afcf3998a7905c95060c305be821c26b041009fd805df28428dc5684fe313c00c6fd256751493142c39411e9b1c6c5c9dddb869bba6b27c4c0452ffd1318efa2ea4d2604c8463aa8e20db1f721402454d598ddb38a444960afd334ed1d49caab313986bbed5c48722c703d20002f662bdf59ee7f4ae11878f1a904baa96e494404c3aba852756f234a93424bad041376f2d6843048b2398241f0b54536aa664d2fe96cd2ed6e0382a66bb6f07002d14829aae2df6699f3451f0494750a77732f28fbfdefc9d92715105f52305181737e766bb9e755d7d41c00342d9c714473611b86df88d793cde6500a2efd0a8c98ad2f65c013dd5edeae2929b7e9ea8f34b7038e688c4ef8dabfad6b36368e4e8eedb234cff729a0f9b9b415193e54fa1e5acdd6aae2eb5370a8c200cdd1a2bacb306cf2546349ff73d63fba6f26290581938117a3bf3a83f776220178b0b51ef3f5a27471e88b67d1763c01ebb37a43b62903c5d602855adf0f14db988ce28e81001f336a7be6d279405f089eeb89fc9cc23b3f6fed718d7e75ce5e7550aab577da6d037e87f96f7da42effbe66f5225a6e3066193e9b5bad3a5b78f0290724c962d9e6cee80cb5b988b0d2f2c7037d66121b2b34d1d3c0d4465dfb17b18ed7dc52afd41c453688e15e80e1e9e4e1ed185c9e01659aabad08c60cf6f5afa70e501bf61988c41deffd1a33915e803f8c8d75102937d96a665187e5764cda383d855e6242c2597d3a9379ecf68c2f764c30e597afed8fe3de5df970efef3c4a7d11781d21275dc9bc9bcc119275cd6d54fbc1d573672273ce04cbc2dec310db21b0604479801e8f737df2dba3bfc13e02183c47c4cd02198418ef188938319a5233a22707ff330996779e4a8f5b2c7012ec98bf3ea56abf17a5ca5ae4e946aa2e83a32004753d23ba1d38c82a4faf80f5fe0b571f3e567f48f0b5a9e622fe9e911cc67c5f66e76b6e0bb72a04122dd9b5dd3bea5e93c57be9b8a46981fb7d7f4a07a1070a0fb3b37e52370303302c106e051ecdfc12af5cbb65d2ccee07592a1635f02ded264b7374e48dd97c81194a5ec69c417d0180db4a193b0cf1fda14cb6cfe7072e509b6b67b5b74b6eb18c9823a2935d72d6ffc8cefcec33cf8d0b000b09aab9b04ec44e160d807b96568db68a6676e0da603974fc6b611f1e411904f431c18ed972c3947d5925d0b460394c4861cea64e336c930c767e97a0ebe01bd76ae7091f7cb408a26e5163d212ed5884fff4699701b7c0c8d4c009f849fd7e53d4d3842bbd4745fc06756b2f904c4b173ac3fec615841827bcccd442c6e87561c3a5448fcd5cc3798a4f864988bcd190508d8cf108e54c946127f112307647c79936717bc7ba7937aa4b2d3b9e1dff8bb06901d21dc0265dcb2490fdd15223d28a9a96912bc77e12ae397499b5ef39605d96936218b10106e4bad622b41ab0751c351cfd178aedac87c672aa40531ce6ea825f87cdfc6e6b0e261cb4a90c48b031616ed11c7155253ff4ab73d96c52e6c0257d35114759c9d708bc7e9b189c246082c2326fdae913d50812a4e1e92b973a22ff3949932646503281974542a347847a2f834c2654d8ddd5898a951382ede8807c29c1d9cc87f78fb074f0ae0272b672edf3857fb3eeafde4642c5aa6f05ca3699dcd8904f7386b86642dc5b80567a023c5965a9bd067ebbad1d2666dc77f9f5a12630387f31da3829e52df44bd6cdafa48e143663f82fbf1a7ba18d20523933d955c2ce95b2abfb08d7c70fdc11117c335e48439c7e0017e829f1c149248ca6c2bcb12d33ced059409d0f16d1989cb63ea9b6fd20d3aa36bf06f38caeeb7e05e12b78af7e72d48f7cd1989dfad9d76fc515f6e2a6aa3b25593d0ffd1590d71edb73eba620e95a269be9cc32746dc4e224f817bf9a8ed95bf410b96ef11a93e9d8e37906889d91b3821d9fcb2dcf7b477715ea7dc42a48f49e51bc5064cd59860701f383ce5c00f99db001e69394fa92aa450d89be4693da9b2748cfe7efc829407aced986205a210a159b8b38ee235ca510270410a9a4ecfa6e16c21ce23406c386e7ce84fd963b52efe4768012ad34b5e21301c258ed4696955f434c6d6e566ebb18ca0020e50312b0faa4eac5df70cf3f381ebb9d4e06eac38893f68f1b1ca61642073c887b774bd6b1d63ea9c594a62f352df85ff6223b73b8cfd63e586aea11f841c22fd5119c85aea280b907ed56fc81da21a65e1d65fc38907f22768222cced8c3d8ce6d78e583a40101db592ece328d606af124269c0c2265a3f56e1459ad165355b2f2be6f15636370c94c354143725c41ff143376b8e95c18f0125cb1a31bc2df5978e8f6cac1639d8f1f0307f2f4dbf61324c1ba3101c38e61295fcb787c19b4ee2a2799750a4b1bccc7b1f082ef94b0e1b8d38ef709149176893d3985b0fb5304c65e18958b71bfa0fff28fac21b7ce63f093be4d3df8c66f7a4a3fb11987a7c63a649c4864e3528aaa82f6ceeb9c4698a17c1f9c42bc0ed2324c503e1268ff93a5121d26668106655276c01dad01271ffbb81596f7679eddc80c80bffe4fb936ad6145531ab9d4a682904b31379cdc8f31eaf49d8a6465c172f0d3534374d4504821f728f92bdaf851ef81ea2529d5e41ecc496cde4e90558f9ce2cb775a1efa3eb0a3a42519b8d384728f2cbba9a07273c34ff43843a94d456de576c3c47e882cba016db4598351eec9663a00554a742066d6e4bb65115872a8567e03489d65fbc890354b7904a40e9269e0d1bf6b98ea244a7e1436caed01fd10b88db6ebf7ebe8ddb4522a48862d8b914578bbd2030a7d0458f7a2cf2c598f5a300a3ccd2239d202cf7ba76605480fa1e11b46684672206840a923c8ce71daa2db5cefbfb59d5357eb83c0ed3843ff69146055289e8a37910273f54c6d7f89653fe34aeef588c74e8f5b5fc30b099729d63b85e7c45c4bfe75cd2c5a4cf9fbae7f2b30903fb2e92bb595c7a21ae5e7fda34939888d3191357d97dea9b914a1b7ab58e0952077309871b821ead9068848b54ebe52bd34cacfc142cececb896b401004b0b02cef092d824be27fcb0815ca63b8ead9c186195e23cb8fa4f0143b775879ef56006f7026acb78e4de3e517763f39497ab686ff34295e698145bf4f7e7d5b565e8c50d0b1c026ed38f16eea63e2b55b884b3e2943ac49f844ef3b25bcdd99bf116cd1392a5bbf09ff24e42f7cb21fa5cffe5fcd2eb18973f515ea094d627706e9f8dc6fe3ed2071f99b42f1189306ec9b7e350760abab933cbfa40c9ee860f20497a7b11769ac9a2d1e50ae7b9f09dc32e83ad283aa808672a793735b159b32e3e6b013b1d31a68b5e0ab73932cf778f4e3e0e1940f5d23b7ec09f2b97f67ee27d90e7d864c0581f63b3dce9e0d19f687809bc24789b200403908521ad6ac6df53ffe2781ea8c5671c4e9b8bd1f4239f3c43b607e714c835264c3c2baa4ee0d20d510d0cacf655ada5cb934ab337588286fafef5780349ab1ba4919f4b49735bde30a610a5dc146063ae1038645d52cb9ca4247d5ab7b1236f4b465b0b2617016863fb310550d5d2fa0145885c71751c71a6fdf152f70c32d144d1fe36e02514622a83dc0f05f4b1fa101ffa28724fb97e01eacbadc4f4f021c561f7dc61b9cbeeff2e372beb59183e7ed43c4a8584954c6c223fd9b19bd0911ec8dfd58765721dbd926cffa105f3bd5e10fba22f94d375fdb10b05e866885757851efb286cf927d78f24366440cf59e9298366e819b172dc1056b0676a98631bc6d097067ac0b8259847f90647276f45b10d7e2736eee4be8e050458757cac6cf421111fdcb32fd55f0fe664ea5f3475074c08fc0181507f74f57587ed2dcb07b77598c72c1446274bebbe06ecd04c4adb828072cff154149acd1bdab39be001b8f0fb089f70b4fc301480cfedc63cd75d24bc7c59cfd1cf6a36296be5d3c99b9662c9f6384e3a197238e28cf4fdc511b1dec6cadca3987faf2f56d3e01385d95a3063413124706de47f7d5fe0a3786b573016feee288a54648e34e3a30428df03015961291642c4c344b91ad44b13ba66652146e7f1342746db878eb93d3d5368a91fc2cf9e075c44aa71f96947c41d46bc1ea696a78158e02e194580506e5b004300d6c708d750a1c59fa1561cd32bca0cbb51d8e96478d92b6bd1900ca278c16b41ce9041829b863d6813d30dd4f609b4c051c4c61edb43646da0e1a4ced4c2361454fdcbaf9f93e57c681cdf93722870b984a7ddce6fd3842d2c0ee96a93eeb2d69934dcdbf9cac345eae36d94c78e6e90011e7b5a0f830e784065c0da4c596d21b08af99488023993bb87d0dfb88d151494de7da42c879d55c64a4882eaa5ba652613b9e9965edfed9cf45e95a9624cbe33ed204aeb85e47799a26a789c0fc276428696df9ffc4cd198ecd62615c645894fdda03d1e2be13553fbc1b7f0ede0925d2d0004e343d42bfccc8c3691fd5ddcba78265bdd24e4dfc9ead2cd0ea481ca63bd5651b3edd32ffca3b137f485743049f54279c59a870b2bc8b8fd8cb9ee6e08e8cc8620ef123f53fde41b18bfa8824180ceb01d7f8ad419e3dd3eb3438fe818d42c5efb66c2f91f92e2feadaca23648303a654a29d3037b04b1a81b596b56762adf432f7e414a7ead881a8bb2df39039bea4fcfecfc80d4ffa40e03da5645821803850ba7f9b96056d745767c63fdf009aa6c889a97eeac2ecc653727887890d6d7465099e0da6816eda6b2b7c96dfc3b544c530c0571d62753167bcdf3c892aedf1067dac16a870bf589a1b649a41a8f7ae70f33d751473f7e343e5e2960ddb2457b9bc06892246b315be63e6d9e930c7abf24546fa3d5b70b3cf496819d50c375b0edababd11362cb7664ad8ddef82f945d15872693653ba27337ba4344b3ac0e8e3e2067cc6e1a4405d2e532505a9bbea2da31e8c6955a1de8616586289d163a0274bc7724dedef91634e05e73f2ffc863071738aace89acccbfc2eca8acfc0942578d11a872cf7d1fb044ad090d68050b690cd5de5ac3cba5ddb818323b17ff3741ba8a5a2262ccbb05d8b6be392365ab530e0bd1e187619a0a2b6e543e9f30f60b7efd029d1cf181ed0a789bf8614699a5a329d20d5d438c594c35117b8f59849fcb61fd6d0d130c2a61d5adbf00f1dcd5d189b59bf178e2748884cb70d32aedc9e3452aad59d3399965677feab1bd5c0d86c4f4db7c40ce1d8e2938457d50b26a6fd7b3326f5d57183f70af9805b276d2b95e327593794f95fef26142fefcea66760db47df04958954aa24bdc8e4246cf1a698a866a49ec334d88025ec57f06f70a066fb164cf81418cba68eb07877e3f6c0f762628187a09cee1539d0e73cae772a163ba106f464adecdd7f9b87b26d2dce619e25edc4f8eb7a0df59c8b7052e6b66e5aa39f1635be5234c103d215d8f77d717daa8aed3e5f591bcede999deafe99de1e806ce2b1e4fe19dfe5e19b29c381e818a702069c4c0ca70e76ce086494720e322a631f5efde130385827ff37b7803dd381c2c987ef2c181c75a641a68f2bfe81e2f5657bc1c876c60d201255d31b7673613ec056db358faa55b69ef7c7ee4d4837b35e49dc0eb9801750a01b74351cc0d0d8fbc49b8275fa2ca5edf6507d60e105093272288058794c319cf4e200b3531fdfca74747fb72d744636db8586993cdd2ffd4c9026ba389363f98e1379234f1e38e6a3fd3877921b77e1c3d7c38c8c606a8f94738be3eee411b679bb68bbbd45d61379e29d510603b569075df230d2a35a1cb9f80272a624a1e6f609874d0470683d70d62ef1b3b66af685146c357dd5aafff8c4a2df7ca99a77bf993070dd150451594b8a43583f07005c9def78a0bea8cb2302d13ebd2eddeb0385763a849230d00ab22bee7ff09837ebf5f69851a92ec3ec456c582e30c47b0afab5b756fef33dabb6c6fde6ef956a0b4e7972748c9661c600d83b1133067436912e263045d9c392cbbcbc01a7e33a8fa878f1e4b4e17041fab9536b6b26d96af454def42606f0f90e0221fa4409df0fe2e9108b349a4c383b12f64088afbc8b96dff0d73e0a14663914fe98a23d367fa99a9ecf83a13aceaf85baeb1a0e56256df8f93acb7d5697993a5ff05e6af53344ee4b5d2a6190e8b5ecf206479269a75ff0d9af460a6b3b5df69eb72b1cf3a494554f108e2e9c9d17b56b3866182f97c6bd75b775625b7dcbebe9b11ec08422aaa14b966d41a93c037de366dddd12e2eb3c6e35233382af542ed559958a6f64cf2b1bba53fe98e2f62b8b97e29882f8cbc09996b590a2f35d377fb14393957f14c30d25b1a267bd359869da701485a3a49d360441e1409821e252c0832a77061c563a34e5df6f423e45b5adf8e709d8f6a07933a24f68918c4923cc778af6fff33d5ffde4cadfb0f69f188acbafd7436944f67464732af6101ec245990342ebf814d0d58133d99bf9bef64993d725b6efc7c771b61228e6c6a86fc00dc5447873c9e2f17a25ee05d8a980802410b2a8dec4b2e951871b2acfe60eb57f9a89dcb2170933a2b1d09bc759bd1a7acf7095a9499cd7629b0960ceadb82380f7b0e888aadc0ab0455b1410b9363e4e2fd6d06a45b64e8973e34576922712e08a2e4551a6aed17634af2ad52c4d1ccd0dc73544591c0b516f31a87acf564872a26f510e624019ece026b862f26d243e3f0354843d1b01471b02054b03060bcb76627a1e03f94cc6a1f6c615218c3620aee106aac258541c8f9275bf4b521ce60a6de553d06e986d6787a41807db8b0ffe9c8b109fe29852d9d2d9243cdadea3dde804497fb39fc6699142f421c5a199e0d48fe0e3c40f421833a5e5b09006ff479445f312d98ff3528062b217df1c3eb04b4c8bc30981f993c7b3f61b093ec2d159f9496f8dcf5d275e0ac8412a039e28c666164d8af67ab513439265aa3d24ef51e2c0f26f1e36982f2b7b697d5220962bd2a9c0628cd6d5c6e88e0b79cf0dabc3a2d45ad651013ad7c604ef88af874fc9f656d196731e0acee000626f765170e5ccaaba0b85555e4792f4d18aa5290d3e9b80bf4d56224e6ce1fa04393247066e928786","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"97764734878bf87096fea25a8b9a1124"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
