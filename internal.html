<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16b2754881ff86336ca09ab714e391113dee157f850a40751ba8bec98feb6cc82feea8bedeb5227fd4bf48c291c1053cef258eb1a692a8a304f4e846c8b2b72addc6c9aebe030b6038f29828faac0c7048b92972e9dcf318cd3b108b9f95dff55b550cc69a0078d651eaebefc74c90b97355024e1a3fccb281cfd2f878d7faef22c1d09f77172795538522ae724540e8ea0d7d796f70d3beb986f3165ac22d4d158a8273d3c2509a1de0e4977dafc9993177ebc826528de8ff19251df0dda221e6f4b29a47972aa5fccde6d61a330f30abd0df381b4d767bb2632b6f5750fb019f88f9aa910c9fa4f9a25108ab63328ef71913ee63873993af5a9eae61cc31e60b127850224ba12e0c5397b2d9676bf1908ad2e2c45b23ac88a21dc4661b02c94969636a881279953ea319fdf5cc8b2b3b21a1197a33541051431d4c33254723dc92b8eb9bf310859bfcf8d128d60ccd8bdc10bf3249bce3ec67eea7a83fe5b94398a8098103349e75fa5635ad8e121a82f0e7186d51809adc832f9d40ece92e36544f6fda2c5bbe45804e8f4507ce1e2b6dd90c5d02b8802293832449bdce9a9dafe909f525a99205aeeed955d9184aaa5cd2892a6e05dfeb47ca8a414cb911b1e0a45a7126397e045ff5a2267bef5dbd7435cf5aede7d44db5e09d3bf7c6932d2d238d57c81ded4a51ea182f2f29cd489e10704f5806b72aab2c91e602ff6da7d8cb734323a2c1b1c67eb99ed1d7632c529c4f28450eb31bd5c0ac1ecffc890fb655bb42efcb8cef9014da20a6d0fc23e74d324f2a6b5a6afc4441a65ab36b7aaf36a0132e8225562a1c214fec535b6f726169ec068c0bbb784569553f1d3c3d9cbd74fa8febdebeb15bc4d0be6696d971d187d694c15be38d06054d569f0d20cbe0dde90c7a74b6fbcfee7eea1f62b55182db1c308b0848fdf70afe1db8fae6a406b9f161a252c49c3a3f5e703f685128850e06d1641896d32a704d9646889283cf993530eb3125f3e026497572a8912d7b7709bfc1d39b668cf33db753e17e244b16a46eccbd183efdaa853b02929ce057524fde1577703c231bcce07a4f35fdc31113b66c95b40199efd78156b647d6db1d63ec702c0abd37e80253021c6b25a269cf60ea39c49f07dd00f6a62df6a8f76889871be742e21d3cb3582e4c3405af00e1b6f2005b935bb1df1212f441b15158ff2bfeee54e716a5f6e63b214b63b78cdbe4a630bae2b197da290d0b2fe8321b6edf4f50810fcbf84350f1e847b869bd8a64cc165479c90cb97cb9512b7816c97d38f864fde20a04aac16402926ea1b18eb28f68d12e2b8ab715674724fecb92cae51cd2361fc2a5b97f5263abe065668717e0ad9839f6703e94b164afcefee22aae84c2527a71981e3aa3b6636722771138a1f90c2409df1365811a9b8aba3960daec76c317994c1b7bd386c98900d0adfd85380c34cd6c86f697535bdbc96d70363da53a8251a0c05b8bf7c0fe3a18d5c58e4296194e3615c0371e54bf3ec7178e5c36b38ab10a73e24701215368a48776e8e13ab043dd58b6104891517eea5eac791a1c7715e3201c2f3dd51e39b67ccc9cd9cf902f1dee9a26d08398878acb0eaa71df56b9a268778d4ecde3acb418b930ae08f53a92b525d58db2983993a53284b7a5a1c8ec587176b7a660591868df280e7bc2ce0a0a5786ab921525061ac8705d5c1abf3b8e05284119b6e9a21b37fcefbdcddddda389192e962dcc3dcef633bfb114a2cacecac9926377fe7bc63e1b9d135748afbc8b278363fda39cb2b0b617aa69b58c1edf522f6696c111dd337db2743b38a74becb47671c857ebe82b1d20e3f6801863c63d3733fea0c6e0d8de29756bd225e5f0cbe997a02d2350df90a5721b9825c64c2efc1ebad8210c2ece5b16547639dc1d5a3fd8ab23047a5a0f423185aa7c91ad87133f9246a601b853d9ee93b143e91eb9164cabc92dd32e2229a6c0c93cd441db7bdb36a7c532ebac37703c4f67fef288ad0e5824133a5cdb35cf44bcdd0df62eea966ef644d7a2e195ee448cd45793d802824924b9e32911daa23b3c7e7c0e34d327db2a0fe360bedcee6f7eda7eed4bbc53a048b9c136ada4391050fef3c6f10004c92ca4376dcb2b6c3d5d8580a57d954ba5f82aa4436becb207221698a5aa8e4dee1505bfb375ee640746c1f2bf87ea5c97cfc90bcbc22245e395a89c562b37480736faa5ca4cb2c870a19e5b6a2980c11ded87bc8120045ad007157b7586fa1365000d4606d243fe1753237d72b194a8e3c9d0a629cb087f9d66127a31ccda92aa21e5f6b6cdd5f3b673704a2edae3c9ba172c50acef1d2c16e13a3ff71050ca86dcc86ca9b4598e1b9cea7ca74764ce1983c3cee0dd576ed8cb7bf6a347c9f4f9722cea7f7277f3eba13a26df0291f1677399c33b5acb0b6ab84d31986d38d622f11841d60aeba8694a20bd1a1d4a7b7443ba7adf312cc43432ea06802ccdf028768aaee6f3082ccef2e2406952b84e4b609d87db9492c4688763145feaafc9c694ed9612fb99ff9188bdf37124f26ba8d390f5d7fd47891ac247a4d0b995670a741e08d4a6c22dd2595335614f4268ab82ba9955fabc38c999b0fce305f2a976c81cc78611d7961e8353abd2252eefc9f7ac0a8b01d55a5333da2715201c515a5894e805de88830db7c9dd4d1093a664cd2a1a44d1916ef213334e941a3b7aa849c14715c960608de5c5a2d49d13a213985c38af92c03c9ec90e66bc9fe2709be7f86c57232388f594811c2346b47b4e6bb13df714f70969fe440099ac3e4f5e3844d2eaa1638c9b5e7b07eed51c0dc05ab22346ff07da2a4f7ecc7f2ae6a42a32043599ef9021accbecf3a6e8d13208d54bacb6eb5a2a8c489178005af673343a18c01a352a5a26bb1ec4c273760942259c76ffc8d97598d7bb1267cebe13fe3680946e94455b03a0ea7036aef51f0b9450cf92133f95b4808c4382c799bbab35e13961dfa7e90a4086bbac0c7fd5a161e59d8ca084e6eb984c7afdf014426cffbe1b87603700b209d28162a270dad09f528182ef9e03f1f004068aa6205e5e471379809bb512036d4851d5e47f0eb9af89edf10eea6398fcd4d98e9a72b1e7cdb6ad9c8da35c07386fdc0c756a5f035845d39188dca1e988fbba6d4438d40a5b4e1c0a0445331473091d39bee15fb6a69ee2664bee1fcdd353cf29d9bdaeb4c6175e070e4b232bb4acbaa6c94e900cff43f89608eb2e9f583b57b2fed70bdb9fb3cd8cea1c4e095ca4742bdf1d4e9357aac6f17743050781c53f4e3af620fca69b908e56cad55a580519549674336a091fad09e67720ce0057f6f4039ca72dbb7f5731cbf373a9184c0eb70f314865507b5791f165330ade7bc852ea9cea7decf1c41f111cf11bdf3c8330dc64193ba1223df8aeaf6f6059554144f1d0066cff631be3edc858b97a3209630a2dbc7400c6682c283c6d0987e3d403e39c0d451bebea4738eb18662fe614b90fcc103cd1fec38bb1799efc40e2ffa24faf89bb090da0fec259dc9dd52dd24c09e4ac01d868dba6525c8aa93bb30a21ac9c8f0f43f295657f5c02facf5f72d8961a7990d31397b71c95cb580051fb8d3a0725645eeef4b32e864716ab60fb8182b28e902d8a1f9935c419d2bc7ce8a02a1aa3d24409a3f01e26d715f28dd190838bbee3fa79ce5f0da9ba56f0bda4081327d5443e879c2a768f70a3142d94146fd7c65758da1f77e92a58b387fa18c6f50797e86405879bd3ea2fc468215debd9b8ad128a044ade7197d3175511201317118b21022523f80beb2cc31880385152e8b22d6866ff41765980e30023b1ed248cc2a99fc70f2e126b7c77c727fd447b6f60bf5583c90ad2b833e082ff9ea3c9af198b9bab1481e4da09a01b3cc8d42a2d4d13e425ee026b6d04a350008e651588fc86459c53254f7d25a909247dc80017e38bac020e291fb6cb88e697a668dcb9ef8f1ee6511c91ccde7ced803fe7fae53afbeb7c837bec32b4e2a26fdcb20948bcdb37d66033e9114e0d56e35acca8ebfd04829c6e8ce1be1144da2e551f00dac17178aa03ffa88726baf386894e216096d1a7ed21205d211e09463920c1000ebac819a6be7a240a084eeda6a6a4bee534727acc5b7fd53c21de6173cb3808831a505b10ade9216aa680ff729c2a26cab3cb2f66597b560f3877e25234e4acf470f30728806f2ce4ea997f2ee0ffc1fd0da8c9c26ffeb5c953d1a2bb1b4cca6c0519a5facdc0a168bb6c0e73d9c86c45f5911bdf810c46452ad10f3afe59b23406712fe02cdcd0296cf964bec5dcb44dbb886abf9da6532db7ac7f8c86b218d82d91dc531dbc49223b3cb316349d834a8400e04a2c49dc6a1f0464195bc2f0d60a48a0060c307d182e1ccf78785ad549f54911bcae9251eb11f9b25d995601605d469cd3f1874b622ebd052b8be5097fd2ea129dc27fca4a9e611ab9f355541b4c1ae2153be37e526e5b84c3b83ff5df284fe03d8f6fe74f8de06acdb490c2820f48357c28de8f116d6da90ed32bfb752d59862bbb0171087b2aac76e187b75445c255817324ccad2c269679fdaa7a3220fe2f1648016f8438d777ba357239f3ad2fc322184c62eee0850f7579a6801e3b46a8b1119349a8c2c124f154a5225a1785dc51bdafa8fd36aeff7ef76390eb740fc0f282592339bb74ed0e9d3dbcdeabd3d7db5c00d362b0735a1ebcb11db145e6b8361a717a4349962b4fc25c0389a486cc26edd9a4185deafc7d83346e5f98f7dec367192427724c7c6e50990f6cd1bc624f61079cf5123d7e68d8463a47d96ea697a273388c0e175d28ad89859b5f011434a7da536e3dbb1fe25869557b2a9d3a77bfd4d537ac053630f1e9becf10467ec466831fbd68da358594081a28b1b4b7901f97a703c4a4dd481d0aa32344769c16e03c8cfb26e9b23b89866609318030066d498ff273dca6a1eaa2ffbe3de24f485b79e80d51af08e1363dd5a5bcd6252a549568e7dd66d9b67b33cc4b808ab1eaf7c54c1a3a7fb87728847ce01831d65746e82eb02e72488f5b7dd3e62ef05bc866b7076c7295fe29620419df74f4e9e2d38c090eabd939ad5d2605093e936b5259232ce5bbded6dea0b23026c394dd09e72e79efd5a3ce5a994dee95e85ebecc23f16ffdebd1707ca52ba6d218062da8af16f0f5512696749a05612d827864f8887703ac024cfe36a0357e7556fc6f365a95d4918d2bda0c602ddc4fae15bdd2f0e521e935fabd730c0519e4e54c3ae6d853e4af77d4c51c7cbd8af842f8d77b11f82ef575da20f2b458ce2dc81c1f55b6239cc751030a48b0e38a37f1352a863b252324415e51fd2916ed89b8e17e2c09527f07f71a612726c09bd680bcf7f121b217a0db770829e0c334422605b684bcdba2c7b72b6753049bed537768b83d020cca346e84f97be9f9cff08c085d1afd623a72c7a05219a60236ad901e7651797f08985224351b405a294e115fbbcd4005fbb9a73efb724d3c95a2ebf49478493fd6a520b3381cc8ce98b3fa483840af7dd63adbaa223fcf6269764afd52e1b42bb26bd19dc2569a29455cd0a4184c447fc0fc4c19619e742781a6c1445a4e166a1eeea1da859e860c352d0afcc2839a7120c3fad2a895848fbad485efb3e9ac08539945a90cf1e18d1c17b6041d062b240ae25932b5ea6a9d9f2da56201209edf44da5672fd581353ce77f723d058ca10ec4d54c159852c28d335dd7f6c66c162b1b71c55b2f627961c557859d679ad62332dcf0c3d64bd64b98bc8166102bdec21c983564f660b80af52ee735b72b6afa66fdfec22e9bc54893502e7cf03bd9ce6c389add48f1e2b6824478088bf083c5812872d002e7cf4cbf46e2a407f11411b4314f60cd6417c9447c05ae4b1982f49a3c32f6a0b0fa70d791c26f3c60620ae5bbd1458a3d66e6353da8880c1a8e998e5a07aea5c35815357cbe6007196336b908c15cc64c6eadb7f6a2fedec0b98a7b07e6555e76fc389a9c2b8e0d0425f23e873d0a19e1ff8aa2b979f8cfd4da201151b8071f331f7987de5cd282cffce9f30d5e7ff9a8e68b4cfb5c2824ef2bdfbf1d00542871fe05e2fcd732c71c03c1405d2b79939661ccc3ca33a6f1097fb55b9b0adf202bba705c7fc69d297b1b108485752d8b6685b2237b216073494d21b7367fe11dc4c5108396468d77df5cac9ec5a394b08993f9b659fe6b5fa9f289d9023b43493c93a600119f5d58bc15ba59b9e6882f15ba7d8daa3f3ea73cb2752239929c956f7059a2081504fa578ee6afbae49efbb5795350757131d6ee8e31bb8b924e0b176b96fb0ad77bb6a2c20002e556d387143f904beec3e74f4ca0fe75cccaf0cdc0938a272d5b68833fb9807f262a97694dff61ae27fb6fff3ffa30ee0e38809de801c0e799ecff23142f83d7f0cda33de94bd4cda16dc4cd94917e14a4efa65e9f5175ee8f797902a0c3697ad3e716dc2004d7b4bf35fd8bbf24d07a8ff29e1a576fd4c2023f74ebe9b3ea82153e3d23f8120d96e666747bdb679601754e78b12ae7106078595f60afdb31b780406709e732d0af4f888e9d96a5de04d7ab0baa0149a1edd6ef4d8ba2f309138e497ba681aaf83ade62929619bcfef3387e990d804edb119d59115b58dc430ee8b7b4ea0b00e891d64a55257e7ea547a8d23d13b31d397a55bf007d2ebeb957a15ea73cd54d26a56a29b4f7c94f0c46116cb989e38d1b6fb37c5bcaa4bc3d6b8673f777925070afaa374b70741cd290f435774ed8dced9c8b55f4268c9a64ce02678ae226edfde88b4a771b2cce5a7f494669e4a98ee600df64742ad46366d2548624d6858d6b6a757d79d9d5e4e7d1aef1c73b6f09b2b91a446314d82a14ccd3935404114b3fa9dab00ae50eaf00660bd35e298787311e11fced2bcc460e2f0ded9cb5df59e7493ab7e012bd14b7e5a455f42b563950d59deeb06840409d01a3727ecc00a2138edb0806f7d793b6377041e10426b59995deaf3e89a9c3a02580d6c02d7afe3f5fce98b40cc2d521f687938a271449a33cd6a0a15226a23ce6bf65374383808eaff228ee5865878d3c98f7c3926d53d2bb21729a5a8f354787bbe119e1738a1aefb2f8de94390e1587e2467ddc304540381f8cf1a75813b08de21f61decabb935b637ae69e67b0cc6e65ec1a5d6ebf2437a50f315c84bc9b160b0aded0a7200d87e2312e2c8f72fa1af91fda24dbcef778c3dad2cb6a1aaaf6a24e30e6e97ea161cc66df0dfd35e0992d5a063537135bc377ce8c60745f87b3ad01dd70eedc8e3c6baa9332c26bbaae44e76ce85372e05bc33cf7559617b5321708923e43b04f2fdd6aa50439cf0e2fe2a960f73b10c687968c397aee24820109fc8d5253bd23031a342f16fb94d5c301e8f241e2a476fbea6d1e0097a3c485e38586f8bd0bd169c2c1c11ed4094bdddf60e3d511c2407ba87c1f31a964ac216cf3661c039bd0372beab93c39f7e296c444c4506592a6793b597d8df5dff17917033dd7dd4f75a979c6886f48d9098ab4946fd5288d41e56abba9f19c5cfbb3365d32ac939a98da2d6f44141ed49e31d9925eb912aefc989b9d40d0ef94059d900c4c9052d202542e9dfd3965fe69af5e90c39a9395ee11527c4413f56723a9b6a26fdce01fa8046cdaaffb93da3d6d7e2a004eb99da697808921b6f43d04a22a1434fcf1980d922f9220377fc65f78165334115ec8479582d7574655a89ef887d502b9d7d331e5816d5f520d6e73137072ed2de80f85ccb3c1f99e36a6555c0db364de08bc07e4c93feab66d2d6441ede33799467b2edfc5a83ab55bbbe0f1a8d62ab36ceceff2ff4632b889072504d482bce6600a0638635caee1d2d545f5b4f5751f19216946373c2c87aa57442c0179e5e4a34499ef1963737a0c7c75136a8fa611023a20cb44563ccf53960c4ca4e584cf58d95567a71966c2f011437f3e39fe30046ad9da255c96a62c5c2928ab8549357d34a22c631c7fa585783f2f78a9baafdcb83a5ac90a9209b0646386643925a75b11d6424c999dc3a1561a5857fb3004fccb4c5707039dd0e7422f4817177af11df208828f47c5c50ad0e2638bead630e0232e55bfff53d880b5dec424364eadea43f8fe728067fe5b637e06465ca23f49863280bab108908b7d977460404f5758ea2f28a5575d9ce4bbc523e62ca70b7b5fb7ac09351643893f6b16eecb4283e3d4d84e48987a6a4fe656b6b2087f01abdc027c33ccab0743bba19de66b5144c5339951193a46bd5c7cf8cab84eb1cc67915dc233382baaceb9d990e2489e8a2b09503e44b0786cce6bbdf545a68b59cecd0fea5f0d5a0e2b33735bcde3b18d78e4142b7c8956cea45b589d13207c7b8ac749aee8f384ce8f38410b5d45cda1a170baf945602cbc4e0020c33c12c424e74295bc9944f1de06db188cb72408440afbf0bd7457f505e106dbb8c40f89f55fb2ff5439625b36e77b2d2543979f84600f54f42684de0c14e220e87753bf52be2b7b2b0734624b7aa35d744066901c45b8cf2dc7a1550f16ea38c404f8deebe9c40f4943cc5cb26d591d18e4bee591084f491a120a4a03523cdca41ccb42066e34a7c377aded5eb4c3c8bd21683a6afb126b9418c6d189a832b166926aa1deb194f51a6f849d447ceab3603c1fd09521129f0f80cca6b6ed128f6136ce7e0770f88e3dc76244d09ce4813a153f449e46ec06aac5b1fff81b0159ba8be64a2cc3b4a3d29e242a98ab7cf601ad04738decd6d0a982c314ce62e98638684a9e1207428fd0de34779ad34df1a5ddeca0542e4e3439a52d0cff231ccd39c383c9a3cd2e666e043985bc2fe45314de38ecdc02a1440b73b7eb070e5a23031da4b43f978eea0dce0bc6ea62f21ac2bfe58d909a0bfadcff5dd65d5a92e426aa5bb8b24bf692acfac8aa177d5f145ad34faca6b2834b4cd8039cb8d6853df47e081cec475742bdca9729ca55f803ac707fb3c69cdb6c815278b6291440568c447a60fd70fab5346caca4dc66bd82b4737b085eb3c22043f77f5179f62769678dce80db167e80bad0d6008be0ba9995476e3d0d60c63661445ba557f37abe4b7ab2f31843a6fc231a5c36da4ed29ecb039177c1013f720b84a3f2f84f34a344c2a47c7294fd4bfd0d3a863576b09442fe07eac95053e8b4f771c91b6c5812ea4f1283bcba05094b3784b12d6874a6e42824df5f2470cc21c382682f89c1a06eb51d41053d7b4eba0a0beb377544f022f797e214495fd8f3f5f41ab9d22a9b0963b6170060f4b040f14c713f4df0932760bd61969a641a4e468108c539e92890dbb091329fe68f3dc4e9ad048da06d9c2c546f7232ac6923cb63c9e42b0e6a946b76979d3e777dec991826aa85a9dcb889a6da6ea2e9ac98184554909c3c340253ac2deb8dd2f4287de2ac10b4e455e2fdeb0cc00c06267a5bbb2ee3937b592fa851cd34905931e78e253fc160e933a8088d8350123f3f112eaa0dd109dc8ad816b16a86d29fd0fd6c07a3628873829e707f5800b7dc8fa71764e0bac655114d56ef28169776db01262478aab81a425d66073a85187ea44553c576c45e7d0f9622c43160ff75ae08ccbf831e5972a2f9537f4912e6a7dffbd33d393ae3ccf04ff40198d8f4242ec3203761fbaa8f10bcb4f753dc83bada12246020add146c49155bac8bce7461c7696b9d594001718c11765447980afeabc9d803ef0a084a96caaf95c7de2042eed7d3a9edcdf9278896a528cc04d17a0641224e46e542d298e8c5c5b7fda2ee53b08ff8802c1dd9c448922364bd932b47126f9e6cf9d3a154f27aecb3f12f42c448ec87899fa9c5da97ca2dcd45384fd59339449f390be54d012d4a8c267171645d2447d5613b5541ee7a805a676b83348274c333e2b784f7d991d62c67b5f5bec6ed00fca416ab329f9b624d7912533ce92b53f47ea5b11d64c045e2c6ec6ec00cd34e9cfb7d1a1ef4df546ae0d0e0fd116fb8b325fe90bd3b67b0bad5541c43abb6b3a879ca7432d86491ebd957b13d19162b4561cfda2b5d8ec409b61356228b7390a3b4a913971e47f0262b685930f8294802f1953468bf4aff2e72936829428e2b980a399c945e9cbad11369c4e01fe73573312e948edf1e3e36ff132f48efc114b16d476d3faa3c2de2c945b7016122e75747faa52b2b757e96872a9be4becb97ba9a79902861e937a24a94c21716cf34a726de1e6e93e1e8f5cfe4c1b659f6f1891901f223a3824d89bb9414e57ed69b69a0ce1217e530de4bf5da9498f522a1cfc4ac232f39308ab5119985a78b8f277b24e17d82ed924b7c9822a8b43da9c3dd89364a210801f90d32a0a66d4ea685aedfefa4752c5361f740a883b59205dd04c4510754b7f0b31c5697afdb4062fc3dd5e303acabcdaf631a36a89bfef011172d9ac2f17b24900b6a6a7c9519eb004bac9f81f46a2c5d3aae62000836a7c77a0f04fff556e3678528d5f9ce734019a3e98faf0d2941bf50c1e4ac0c49e2720daea828e8388b292b23b9bc780e237c5b780c9a693e4eb28753b911828d1581916ef9d2d479309b9445bb26aa5b0ba646396ccf60fa696bce27b8fe1bcc7bbe19e7c26f8d3982c737f5e7483e298f3dab282785063a14c0e3c3d2e1528e97eb88ed95b246c5ed35fc710611cb5ed7c820a46227b607287f63ecd9f730aaea3a6327986c2c518c5d5e2c3fbe2ac6d7dcc3cd53f96079d4c6388d9880acbdfb12cb47dab47d77fb7c02f3f7da34c610e7ad034f6cf138e3b57c8215880ba6d215c5cedc95007dc5c570869199db7e7dbc73545262bcdad863ef27fee5a11b688bfe0601fc59b40d8acc261451e5d12abf0c3b5dc65dbaa736c4ac449581724cc3fc1f63db675ea2dea39ce228ca45926f71a621ffe362e0d537b206e01a6d0a002dc330ba35d0c21fffc881550b2044ecdc5f48e5c5affe454732eb66ef8a60f46ba6c3ffb63ba9b208fdfa00a570a3db6f6e32b2847c3148d5ebfaf0baf462ac391bcd3b7a98ad7d067130e5ff2435984c7b415aa2d56c79fd2c9fda94dd09857c13b3cc86430b91b98772164e84b420304cec953309e761b75213d5ae0ddf94ee2f8a378553b10a457bc1e4c056f7051758407f0340449dedb5b73214a0f4329c9bb51f4d2265fb01fd6bf621485d1e7e8760d7f6b8183258f2439e925b31ade2b0bd2a09f63a426bb42a09c2ec8a446eb975c8715190cb4dd79d575007b479276fff870779960b0f3a7161f2630a340802cd0a22d4068261ff16a4b94aa8c6b181e75a2ecb79ee990131bc7990efd5771114840c0466bfc6dbcf08f6c82446e268d9e0c93bf8275fe6ad3a00d57359b5820242b5867f161a3658eb62fabf579fb289e75010c498487ec5400b7945b5dae5cc2e1d8c4549f188aad007be7b893dc81fc43d408a362cab43a5a8a527fd866aee558c5c679288064347b12dd2054fede65d0ee28139d5c3fe8962e58df43ff0b45a253322c0b68f30b94ee8967b86ec6a95749d474e7a4fa5c3dd69d186e55e91f35794847da10b9bd0debd72f35e9f93ca2e3fccd2e81969ce5a6ecf516fb6df0ae6b8239c748123b740cb1e19c3d37497ea9eca9eaa8ab7d4f199722be1e00e876c69fae3fad38aa0fc1b09f75435b9481236525ef14c757904469a5c249f9af4e3b26e6bba6e288fbf17004f538fa6eb9a2f03f6bebf11277d4530e1bf3091f5fa15b4408395a6ef823adddb60d4b0595e422e3034f6da024d96f529a387a6a8864b525ceb6777d5938694c687b86f47d094206915cc46110250e2f4b3f99ac36e068ed0dca679caa0305741397bac86db0aac69c3d62f116b8ecdf7f180de220e23bee1baceac7b0475d6d0eb4817ba06f3520a1f85d7e2eecf469657907156dc5c4858c7ce6bb933a3fe09213d7675ca9496020f5c962d2686b1ad6fce486b8b949b6d23cc6da4c6a729b5a43236969b24a7158a023bdb90941a6d894827d47d462575ddc33ffa5d0cbc3082cf1039205e857bc1f09a67eb5868885b2c63b6683987d06839f2ee3876f133a5c07be91f2120d35497f245ae51ac66583f9c7b4be5aec2654999efd7192b6604ed6f41857ab2410f8cf968cebdd0f464932ccc9f314cc3449efe972215de342e49bc090bff0aa375c802090e72fdb7fea22a974d4fe4f116188d2ff23aad8d55202c883ae15e3d9f5b7fa208c0e100b0aaa1aaa2eee4cdbb013c1bdcf041d709271e240791796a64f1ac6f14aea37f4390e315a691f94996bdcaecd3511bc945b675132c585b839e478eeefe46c162cef13f0f173517ecb34232200a7534fdbe12d9c986230b85d493474d4da2fed036ccc60c2c13556295983379c3ba980d6022d2725a90c214d9d38ca90096aeeb90d609a7f3953e00dadd5c1202c7547118d808f6e22c1a0259bc4f1e7b6eef0ed32ad50c97e0ba559b9ecdd8cf5b247d28a17d97fdb955b6a64837b508845cdb12a3843379a4f55f5c0a36fb4a965174ebdb9f8ccba49737492fd67206ab9e8eb2d1b3291636f1e80edc1ee4885b47b531ee562856aa9a0f0bf1e0a98edd2a2b30ed199b370ccd581bf1870747b06c4fb50a754dfd5d9aa63d2a5a69353b3847872b604cf5366da098691279ae114f35dd3671c653884a474748a9a34bec192ef035c50a7ce23d7659f330253c13be39b4084b921088572e0d941ac40101bfc99335ae33a88c211ae31a6c25e2d2ccc7d14227cfd6517076a030e782072d0091dc2ffa398a0fecc34602e6ed47d7552201317feea3a5dcf4deb2d0eaaa49f68249103d47d5e7c05dec2e5326adcf22214ff70bcf07f13c5b0b61320e8b43540998c15d2c8369e5d8ff937697d7d1fcd1b56509604fe62671881c49caa44a24f35200e35a303ef9b7d8f71710801fba1f2e1e395da402aa527183c6e4a8a4549f7eab0bbb5d3f63273f694d7040aca4b8a3673eb1092563cd222fda68216c1db705e3373ebfa6af55d422c7e8576841f51174c0e66479f27b69bf2deee839fbc38e06b6556eeb212ed4c6d97e31b467aeb7d58bf1b26770dc3c96abd3488249393a4a13b7a35f33d00bfcd58613c3c16fac7551ab28d63bf873c3fb0cdbfbf90391008c59e03da54799313737ab438f9d0383ee0af28ef59c62b140b4d2a0bde80610b9dbe61dd550cf8c941b7b996d1c3b8dfc603f064a6325bee6becd71088d64a2fbec526ae4edd83cba8944d449b7522de1ac1060c86804704a4ea1dbe011ee6e1401d27474711c515f79e484e5c03667f501b9d799d523147edd3677b75528a786a5e46dc27037afa409ec9b97d672b28bac93529445ff1042500ab5ca8fe85cfe241bb1f103f1a6ec29cac746d7db4a06a72c564682a9e22afb1d024eb023cee585bbad9ab8e2ac1c3e433e823eeb7dbb17b9356b883dc0708b15691122378e976546ab0aef0ded0b1e73d4a23423fa846b8c48d9fd527e11400aaf7149d481019f1eb2470b8343dd957af55d8a02822c0f95342b5cc31fdbfa89287c6d4fc08a67bdb646590d9540bc4828100cbdb1ad233deff2a8c634968634b7c04d5b62d6e51429f6a86f3c477ae073376429fe3cd45d673b6a886ec1d08367a46a4adfb47fa52d3b57c7850744263a8d1aaa86a2a13f28d2c3934b2b269a0acb64a9f8fc56bec133fc9236a057748b8262d8c079db93269960447d526afc6a531c5055707282dd0f26a8cc96e2b64366b4183832e39da164b9c57d2e72369e8a1ae7eae5b9328fc2c140312e78f08229b2d50643ead561f9db56822fe32cc625e1d394fe9e18e7d6a69250ff16c908578c55f9b2c9fbdee1feea341b8e9addf49361e3c7a7fbb77cd040e073f7575d57abd82364839e6a647987f86bbddbade864d8b54eab65233b625e8ed978f5fb5c79e411af9a9d946d42269e54e89b3d90dfc41965afb1b48b4994d44ccd10bb0ed42e88d5ddeedd7b155d9a8313cba170a9dd1238daf53f83eccf8e43bca153f9288131398c3db03bbd050592ebb1942f4a698c11465f17247432b62e730ab229dab3bbba17c20653b8e6e1a381612c8953cacbdb82631792639a8595fb1a6a38dcd6d756ac93f18f09049a44bdad81cc61ec773890e28db5b7b90c2114c28a14d2c83cdacad04b2db733f1275c3c5243a71c21f4998096b347f5e5603e01aa84fd80033fbfd75dc5d72cd608635d8ea11f629e094151f0649c70eef76ffc331948a01d2782befc24061125d38692e3b532053c0fe85eb88ed81e123269300dec383a79d3f6e0c6d9e280ab4afb690d9b3564f4eeed9489113a8b3c0edded063eb7c48bdcaf93e267f33df58c0e430e98de403f27270c4825f2f94fda76b935d72137d54ed3a9e2676ea2092dd141270fb97081be2b48f3fe3ccd43d2f9e3d759a9f825985a4ce4c72064acbb40cbc10d73cc2b47d152d03aae7a9c95dae12909ae6990e399b34b33e70b4bc9bdaac3be02f38d402e374e2e1b04941d63096520b0f3fd6dd5abcb8f74dd63f0f8824e4ded2b62c96ae93d11abcfa196020606b1069febe1deb45d6021f97acd2cb7abdaa928cf9703d429a05913f3f46fbce431e70eeb73d3ff12d14f8ee3be3df924f2601b84df23366b28d0f7f7444a6501542551fb0f51bf64b4de49c9447e908fda8c2d318d0e5793644fff2996ec0d055e4eeaa4e35e7bed597835bb17ff1bc959f43bbedf60ccac4bbb833fa821c2067c2f03271611b89c93b97cbba73d0e6c240050c901b56129889b94b345b7082372d1d3046fce33965f2bed008f2960ce400a9fc0151ed504e40da8dd728d935feb420edd938f4b482cc704ec2f1601613f22f8507f447ccf3ae98a4c790aef5e963d84b152fca1c40307d5568874c65204582b8adb2efd8db8166690e8bee9fd12297df11600c602e03806bb1a96eccd968192ca0ccc11813bb92deea2b7aee4d4dcbe2f22b7a9945e3fc780b53027e9a018e28a0f14b936b96e59282218612c12a1d0db65ae0820bc18fef83294152a7027a87d6675c96db0c72db4da2ba038234fa48f47ca204811e9b586d3a541d8d8bd4e80994bf1bd85d57251e7c3bd8fabcfad04fb902be957d9438461e7505182241cbafedfc98ac3fd38120bb27d68c09ff81a2f6af3dd7225b69cd0a95945207f60d179c04b295c1e0d10d31776ad4637418145aba6abc9c60d1c69362bb5d13135bef2f6936e1f3d7ee7990f6a1f84516ecbf9586c3dcdf00dec9c79beb985642b64879f7106d64028a8760dfde3322ac3bee221e7f6b29efd0a5eff641f50e32ca1707f6d59101d4c771ef44ea50b882a1ef4220a849ad679282601978d27fb5890a84ff8cc4e4ad1d7ef7dedca176b488e639f466ae617c232e231987b15d9aceb7d288ed8e3eeef7bfadfb54771420f08d91c6f5b3b8716a3273fab4eecd4821e62dcbb61a1d5d9f68a5ea9043607f221fa46cede54537a2b1b897e2a7e4af64ad1c4316fa584494002fc3d345f1607d762cc88a591e14bcaa8187a5ad5bf06fb8968bac5d0da559a246c765f299a85489d28948d9b3bdbf88d1e856f76657f98246bfa07fa5536278e882d37ee3501966866efdc23e1021e35d30002708ca9e02515c0c509c2e21e757d27f8774e454ee8721bbf3a66791620abfb582207182f8feff020a3b8aad24f1ba8473d054a67449a2c7219f110240e50238111e9fd36b45165e40669aa05a0521243aa75a8e0b96798e0a822ba2a5db921a0d6e9c3838fa7fe5af4bb07d80972921b2c75c82c5790efbf80120b411913c66b9fc48a1f3283b4e3cc1241e8d89c7253c8697140951de891c8bddd3ddfdb66a11fec15068061652dc03bde71a9b6bee20a05924a09e5cee839b1b02586375be924b4856b053c50bbe39ac10cd8718e08fbffd499012ce1306834fa87686f9308140581bfe06220e089279f1374def0883327a17a68f36b4c7ea88c0513cfcb5192d74f5f44f74837384b81a54688b7fe7b178ff77aa248208832929f701d33ab19b5759806628c9494e518121874cf0988c89df031f1604922336f6d3977e885018e02a4d828c174b0185e4e52d28ff83257ffe7627aaedbfabb21c591c0ea3ed3432928837d4d259a48526b0165f6c81bc35947e2b18830be0058c79c18d806d4cbe45a4816248af91a5e9ee5c9b8bb00e7248f91949aaf97bf63b03beb4d745ee7aded73029310bdc8ecfec8a634bd5155638ae170a956a061f743c7b0016e4cf7ce09fc7a1c3f32c7b43b599d68706861b45189a6ce54b272218226660b4289629635fa5f99d7d416be50eeaf40b43d7f51b16013f241c4b66e250135a031f3178f5ca75636fb134fdb1056dc8fb48550472c8f5f28aa260a0c500fd02e08efa5b7639da1ebf02f1848469dc0d25b9f073b1296f87e7be02292f37838f18673c5ce89bded9fa4e194078d2c26d10b26a22c642ead0b6eb3e058ad972c4bcecb24a582bec86b50fb24bfd7be76506e71b9cee78e93f4eeb7995f266a0477541f335516c7ed6195d8a6268d03542a65756667180a6f52064acc63659058417c759d63dd4fa17065f3a2f2703231f4f68ff56954d02286d5fa0cef483511b1401ae8972710ab54232202cc358dba3d46ae71a308a9be06cac3496eec8a7950d9a18fedc5df0f6f9e573d59b8788271380ccb6f2586f3a3216b1fd7c715c9038c39899d2d6cce4a7c90b7a73fa822f3605ae0652caa5a5be1ee956a4c5f37fca22933052f729bb4ae5050fba28a0eafd29a257b123c3a7b349690977b717fd6a5fc2ac81279a4a942a2fe18f111ba3abfec8d3d375c068a2354ef9d120a19364b1971eac8018d32453947a0873ad37f23507e21bf749e073b88fe2594d41b2974314ddaf01011e770a9fc9a380e737d84cdab95cf16b1e98185019cf972cc9c9df6a80bf02758bda96a0e4a2c463bf92f297a4d66138d5cc82673516afbb7bf5420c7400b7f3cfd61d00704c655e5a9ab86214d72b064340434553321defab4ec945e99d6dde1d72b99ec4b17be965658220942afade061894cd940ade8b4b8a7d19235bd5e6e74b912138c5ea5ae12266f42d89da9d86b6577a335668914075f4c894a5c40920ef1b4f8dc4ff12d3a53594d452b5cfe9de53d2f63d699dc482e09e5755185b8d4c08d08324a0dc906a2f1751847cfffbea5c40f32e23df59e491af0a77c190a2bf572e74e5103eaef38c52083797a6df724f9f6efc503cef3f50699e75fbebf960414f7d249ed01e0982dc366bc1fb838f6e1eb5e6b59c6f32ddd430cf695d49e7b8b3cd492ca6115014cfa3819ca54337d143e42d0e75f673f24b9683a520b9d6a1e9c37026a34fd22fb3f4861678f374c728bf47474336415e3d169cea62f48e8947bc7096667d1307ca17f493ad67dfc2e3590097a73cf740f538af3d76f415fa11e41128f450101fe319dc0e5fcedcee7a766971f86bcf4200d9eb70f25b0923b9670b610dad0311ef9d28084932e97713219b7491198560ce1f209dd071cef49a55c988e8c52b739a0f48232ebfb95605227c0e6e3f57dd115717ac098aaaf338c2c0c3a673b3222e27a79776ec2f20b78a14eb054f4c918c2fe4c40d7c215df399676fd483c42dc207ec6263391d09865dcc20ce4417a004d56f5309cc5acaae873e318148469","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f8d625e41f3aa9733f460b6960d42df9"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
