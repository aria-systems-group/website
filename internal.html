<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f237ca54b8db2813e13bcc8fda94d098ff4177ee026dfb29315972f83b4c17d84d6ad7cb7a832765451e9c6f546f44cf0b0ea12bb06f7bdf4185fdf492af7189bcc09759883b3b8557e7da65e6c31f301c4af90264692ea7a8602e7adc8ef5ca86924ff727f5994cbe16851ad5e0038271549c1746c9023723b764cece18507c01445fd50d2a9bb294f6ec3cf098d91b10cd8125ee329cfd88f5b32c02f216c2337bcb6abf7770e19fa7da88deabc3b48d6c318ca02a892292a62d2aa90da20d82f1514a0111afbe6326e58875f3695447cdd7f65c04526592e81a52961224831a04100d641ceb2adf989f67321217ebe1efdbe1c8c445f9d9a7dcd5769d91b98f41941a7969068ef1279cef42c8bf2d18eaf1884ee282f8d2eb583d244ec332978ebd7ec9893f9ca40e4d8aba40692c1b9bb66fc22d5513bae43b497d4e75d58e6a176afbfa6be429ec2353afead2baf621e1f9856a3c81047313927d4b4ed307ac1812057733f5c3688362159d459c47e3a5f7459fb51a21018129aa77d33915fea2f92f55823c5ffaf0f8b077c903b9aa9e556356288794e0612b87cc11f639d1f4cf1c51824f1a5be0ac935fa9e45fa319409d0a28ee00d4e9e05b1e897aabae6dc9f84f512b25fe512bef23944373d853d1076d5f4cfe0182b6bfa8cde4000ef321f27f952ad78a93cd7da50b0ed23b0dcff065e78dea267a68cdea0b7778058e7063b560a6da32a82fddaa4716bfd9763ee4b868bc3f9c0506a49afa48fdf97e2fe9981c96493a7823353ddfbda8a4c4593be1e11b5e9111bc1121c53f882d5e4a492763bc726e66194b77f53a4634e6961adf6a06859486fdd20939cbc36c8c28ecb0d423228777005e896ce275bab8e932b772d7281c79a5f4b2adc0750ec27e2ed74ab6b7612419352757393a1b42cf1ba2a0c7b1a86b04078989337c847279bf16b94f067c045cab4ca30d5a00bb6f0bb675ad856eae61a93b53a2cdd2de687509f2d2df9724c47c4a24c5f2bcd22b422ead5d1b274ec7d981a089ae49a8d7513b1d530890f16363765cb55bc8cc5e0591419c2f366057630570ded50e62c4717708da0b26d5e7dfbd5ae8d093b5d8f59c2abf2b61d701d56cafec55fa063ce1977e4e26f7060d9062caac37a6f10ad132243f105f1dd97f6ab567aa307c05a5a4fb0303fd3e82fde43eb29e5ead1a79368af6862cdcc6057cfae064338b987bb6a14ccccaa82c0e173dabbf32b4fe8f7e044f7ce89fecf85b7a7346f48db6c5ce69616b82015edbda62bdeb55745bd17b24d110e5620f106b16c8e8fd5ce3649cd391ec3bc04a5334e37740f6f2f286c869a1ba9294e5b96e147333a8e70a64c7cb475a5b9b98e089ee579f34fe4fc6d77e1fd6fcf27eacd50136a7ab44256e48ab31dd4c342ac33b31c772195982ca3bd04bad3d32a6146e07c6758936c3b126b9c98ef78f4515e692e39990c5a4a78d2d2f0f3ac40b574a107dc9bd478511e54213b9e7bcabc57f61d6487f68184661608de046f4b04384db2a61c2a01cb9f9616a47fcf99b994c9e7f95b41afed76dc4527073585d276dd0c5e5f0d70a5ec02cbb676ac3353aa787ad98eb3e26e93b2b40b06c86c3bfc9bc04cc2bd9d8a6cd23c43b9cda47192e6a7f394787403ac27b798f1493fbb238ada0f48b34046112e44e69faebd7066224903bc31571c741ea3abe96e4ea3d0ee88fff461cbe7c8f909fa61031fc6ef19cff685bb19a8db54d0f7282fde6b97b4125005e0e16292b8dcdbfd7ff3b6c4be84f2937c084303419f13c90fc8deaf14c761a9894bb167c40e14f7a21fbd61679d57e1c19daab83b69f89ab5c54a22a4ff007c10a8d1a381063296f8bfee74da5f1215a80cbe789390c13f7b7801b1bf9093de6b5e61129e742edbbd8183d360899b8a0599902c0a768f308c85547fbeef51e96432e766a544ef236431439856e6503bff225af40691882a54483e20a65afee37e4d3a2cc7d0261a272aba41df1b80cc4f15582ce32a351d28dca1f80576e178ad53165ec0cd9621b55e3500f695170fcf2cba32cdb61510f283e24752d61eae0348a006f6a92201145b62ea23ee12bcf9307b55d45cdab99e113adc6d6620b99644720957137e5b4c82f7ea8dee2818b6a6bcf01bcc26299db796187216c9611a42f882d58ad1e63bc099fb599899d940e26d8040b2bf33f8164dea00822bf689643f0ee54178ea7d47997f8e1873e539d764ca207a574a774ed33c8bd5c3e8eae280a85faa2a465103b784e3a9a1d96c2e2783978b860ce164f5b2f03bdbaa219c1a02b22641f1644b7a027da944797db3db9ee65dfb062e5fd33b74704ff90d233604ee74700a33a1805519fe10f738500245bae251f4a70ac6ec68b6fe163c4e158192e10f11d5bfe06ffc036da3a7f81c743fdcc9c641f0795a8eed3d988069f3c3e62f1ec5049a8ffdc9fad0e6600edced470292baf36d035c662fce671b03e659b6acc6ec7ba5fc77209788cc70acb8edee1f2e460020170bd52cf592bebbc1927ca5cf4f7ec39bbd322246728901fbf27857e20c5b1b06b9259a2127f7aff7f9fb365e1655b2ff5af124201f730b45df392bfaca7b71ea514dc3d913665c5fc67a3faf8a878208fa5859877ddf4c8eb621e593491f0b49f73b9ce15ccf69408099ddf5dc42147344aa10aab0592f060d5c7f1fffadcd775fcfad2f8b580a6624c7179080dc31e81a811480a926cc6b4cdc4c53b4ec287d52fcd899a65d8b0335c5147ed172d9319f5ad93570e3132a86a0e06e4eb530e30dc666886137ad5f87090cd84e3bde1a548597fa20c400caeb5624e64819d88e29bff4a9edf467e451f018d37082d8575512e5e91b8fb2f04bb28b5dface8ea15bd7d22d5d3ece5ecf535da47d51694d23d65e1d8eaf075e26df81aba23e401c0a1bd59e3e0da264717f8ea074415c20f1e49885be971f1c239f74066b0d2b1cca354dc41852cea757c2b87db8d2b5b952d89cadb29beb235160a5414f8144aa6369b175c8cc37f621913d6a468acf6e4005e14945d4b0dea2266e820fde95809ae4ab4afbdb8a47869331c761cf7da1362d1cef26e51bda38fa2aae79417db6a505d6688feb3f3ad74887d293b9748c0ef6532b75b3b822d7a3f0912e5cf1b377692aa1ba19b0e14a5f9d386c09de1c676ca7209dd6fd5ce1181fb451e3153e4b9659e395abc31b2b7498ec86f7a2123343eaac3cff1f713e7cdc4bad046f6ae1066430c16815a665a435f51f1d9dafe4c82073da3a38ad21ec7aebeb6abe86e6651d33e6852e5d6cdaed9353a285e15fc9187930b5dc5a44cfdff732797df87104807d4ca1474a4b30350197d657c8a0b1babd59faa63da9a3afeaae1d05000d5909871f4d39c6516c536fdf383a3eebe539703af5f287559fce7cea0a9767801515daf2c3b78434f3be38b87ce23ab94b3401813790e32276c5b6bf3229603b010064ff76980b5c85c25ba31be60239b6f98d663e54b6d60c6f0b978185ff7459bc98165dd796c020dae2e7e62d1a5f1cbf8c00db25aee2dede6a724735055df0f27ff215ac58249737628815419b7105834a325b8466564b4fcfd7b50b09059c3d8d6ebb8c33e73e731413ee574a8744da148478c23320187d68ead2d4a744e26a378a4e96ddd766b3aee6b7a55114380a9244dad99211e3890cd21245b3507354afe888a91d26e45a4fc0aee6568a14969a79f740d369f5a4dbe1ad062e5a8cd53512c1ac9a08ddea76c6e4a22caa81132760b4871bf5e7d43c762247c549c9d7ff118ef0155043b6d9612f21fbe636f242424a70fea185ff4a447af9efbe659c51d98d1fe00048172b06b49687214acb9bde079f8c7aeb601728c3988b27358f51582b9bff74b7b829b59ee4668d17fd7419dd1a872d169d0e40ca8ce6bdd554b5eedd89ff2d97d976ccee50108ee4ec1471032ff002a2e33cb4da589b98fc25af66f4c9883e92c08cc80319fcc7db6262de9b64fe102eae135bb6600a2079f8cb5cf178da4fe0c73eb8c7bc1a31c517992804001813c6714e9ab11cdc97c6bd26dc2726114ba53284761bd7fe7fcbf0449fb6093f209eac5ae91e5be22739058f1ba5e58609d46024c8f0b9c7f519654ef42df1926dae383665a1420d3ec0bc2c5bbbc1208b0535f42a1a1800c6e6b39e2bbbdb3107312ed5c7a6e53e1b70b38c9d7c9b86069f4387767f831e45e7dee0f23b442dd52aa29e023915ba1fd5484110f4cd712161e9d0a316f983a83a559edd790fe530e22575c61ee669fe9c721dfb4c0af8714d758ab7bc4847423f555e0e2f2fb9c93283944366bae8c7be39db4f4ffa11fcc5002d15ea46039c806c8a0467f5be07b15842a46a3b7cc1d74151f728c9df18b57a76058d1b9695b1008011110d6c2be65204cce974c9aa2d1d4ce721253bc7caecd5a79eea47358f8ed85d95f4e08111d19ae292fd8caa201870c9e4e4c76a36f52c346c016149d9ab0f70bbf0ce7d3f15e38da32d0e7c3ed73218076359f1e284c02663e4db229ef096f03e4b34687ba62b61c323c7bd2d867133ec7ca75f2345bbbfbfcc4d7a2263722b85ac02dc0121f13100400f1b5f04844b09b8b3c8f53c44aeadf31cf634da35b0c3e13a16fe5f1ddbf1801268a79cb194a93f42c33d3f1f02dd3e1ba4cd171dc5b12e89ddb9e4ac7f840febf4e544e64653e2cf195aec9ce6d410be6a3ae96b0de46a77d455c6f5b490186b36ada789162bfa423365e93d853096df68a8a32443be51c049f3e06f1144845d737c5e4b7667fc42964558a5959dbcdb523ddaf74acf31c16d78b7fffe2f4711c852290b1a6b8dadf20a400850eaab0c4115306f09a96c7ba5590a44c5afadd8968b6ac07390b2eb3ba68df66b0891fba905a730b1fecd579bf1adff78ded9c9fc0ff8df158ee1ed890ad6638dd9a741ebbbda641288f9078b914160f4d757e3b384152cc2a95226daea21f0cb5429cc841c7595d38c3632bada6019e7c8cba8a96c8ec240a46d7c1a5c4259187378ed9ba532fe4850d839c10fbbdae732b6bd8330035a2f4766df5723cfdbbdacbba3ac8aa2368efccffcd6cf192c490b3be0a6157654c5594954b03e038ac646506ac7d7920cefb8b883e7924318ae49bf9be7aecf45f91dd92ffb43da122917bdc57a8061bb9129d04b852d44877aa4b31008e8343f10eb43cc55a0b7c1e001ee8587071bf0ea56008fe90e23302990b5e1b739482456500434bdacd01f744dcc46b3cb7029fcf76e4f62f8d4a770e36a67c9a1b402635a0a99e5ffd6e8cd0d1c11914bf23f86a4789fe95aa193e88d091077ec0e9ab7e1317ae72763178fce54c9bf31e51b1b54cd100da29e544d20dd448177d7a54922797b2ca5183c0b9b361cdc4306dbf117f42c2bb94a50479362cfe19d42bd3bba80c4e31271634355c9d15a7d429122ea576c837eb5748f15a170160fa9d1041b3f5ed16d2b0621fc977301524cb1e6a5c4c283e0adc68eebf4fc26698717803602e22ead4e72a84e2ee2dbe1917a9160760e21e88c04ed1897be948fa83ba68e07e593b213df8382426b3d376181d612e86aae205ab52aec91c3d0e4748a4adf6befd2fea6db0967842d0eb26106d6dab15420c536f21c7fe20f7c6f8ffbb6a1c090b48677bb9f3d3d975f300bd23ffeea51a17f6615f761ec0a9026fb7dda372e3566e40ef9dfbbdbbdfb89648a17fafa044eb392f55f19f73139dfc516df0941a0e3821e9faa13e88b9fa433e5fb2262c31656f10157f36d6f5ed7730ee2e721319d8cffd8dac1a5a73dbdb704e2d38961d24f5d7957cca139a8ccd882a7667ca2ac2326944d04967a96b9d4c4c8d210d268677516e01d026b25169edce7d29d24c06907ccd78d992d2864327d79ed61d8db47b997c229b89eb2c0ffef3bb234dd729178f2ad81df7c3e822a56deba22d318d51a5e2a290d87933680b4a25582a1002687a579b626629a624aaf92a9ec275b3bd6e69195f0797c6c5c49927c76995b6dd8020ee6b4edfdfbb213d54549c7304ec972adb9efce07a9672b5470934a22460b3e1899c6b635507fd3fe54ef3d717a49f6497a9029b9bed90a7544245922d7b61edc7beb2a4a9a0d62aca3a62bc8bff9b1843d7c8a5e616e3e57f4c484188d95024810fd8e9a2b5895396d045f9599b6ba750ec7c8eb278601c4e12762e26faa19b6c1e0ed59a4fd001f359a980bb364b263027e29bab835be7041bce00bbf2fa73334cbe0fe295da98c7bae1e6c652c2d3762354bce672524516fd891c12d351ccc2d9c2e872232da03c4c44544af7915b36fe6f257a52d0859216b52a8485af68a2c8a1d44179d5fd974af2824507638c648217e7200b8d5d1f2ed0dcf0854e32e3c665e38ea65c071353b216e660a9066799e3d9e461ccd1114f01ac0a286141a718519536a803462030e1267a5f2bd162d8bf893fe6050a73291605399ca063385f26fd1ce73943a8e1ec3f64f2f5b608663c80f7ca9da5ce9d0ebfc9076dcbc65ec0847f297cb15efa8599b25fa709180776bd98b8537dffe2529ef5a647d2e170a7de9704256cc3efb18db5898ffeb11e76a6badcf1b397f481570071ac6b95f1d77323328a991c8fd1e042073785b743414458607f0124c9ea17bdad47087dbb1a78295c7b2b52ab33f0194d52e0e439dcbfe7f92c05669b2edbebacb822f26e4570cdd412f9c030611157368719b7a3cdf94b2e6259e390c43190c618f808a4c614888a7d56f77550785f7705f90a60d30afe29668dd2729367f823d56fdc55dbf99e85681e161021feced520d967a9a67c35ce9753acadd2c5d863997cb0faf9ec8f2ebe5799abc11462d9018df3fc2db7a205247fd57333260969ee94fd1e7d9d1cf8136484ce95017d4891d8c68fd629a2c2eb8a91bcb88970973845ccc5a9c4027c857c10a63f1d77b480e883ff22661275a8688c273351ad8a52fc8a66987da7619fd2e23ca3dc13106030926a8b4755e0fa740906eb49a9f8637940b4b54db5932431b03f54e77c8491f773208952673ca09d03004886be7e374a670267358a392fd7e96d3ac890a14a580fff9a546a8c1effca29cf25d4613b8905d8f181450c57e124a227b712a93590935c8fcfb703704ca5e47f1d2433832ab2a1e1beed2ccdef6566e508b6a20cff3aa06ce7f722b2b25a671099f497226c6f958fe8a29757d19f834e16c27672e8add942e1249dbc33903032a14a51ac3f84cc55576d69ffdbc1d5a713ceccbbc6a086b516dddd20a8dea4bb7cf4929b85ea8a3349c60fff6f7e5d8acdbb2214e071b4db0f492e7e4f3faf5678f84a343ef0c48b13e8b30f2ad2ec1cdf5b0ffa73d74bb9931985ce30e59c0450c26f63eeffc6ba6e8039250c27a3cca89e5bf823095ec124768011ea767bd9e082e28a1836d1c1c98b7dd803e98d8136d3f98257747ff4bf4b9dc8c7601bbe5558e16d96451eab6ea7dd8d40f21688d6809821710076d14087b0fef9eb4247a9f54f5b2e9d829fba6ce4b5a6881843c82f6d632a931f49e99438f787e25e981ee89f6ea0375767a2a995b39cfaa346e729b8de4577cc992e23a2e9bdd3d8e26ac2118871d5632c356abe4ae4b32ed57fdcb7b626c2f2850e5d1d8a96220dbec7af7f111b74999644cff7ea26561e49ef3083a936af325c7dbe766ff8f2a110fa19396bb45cc751bf9d0aa992cf4a8556b1f7f644db780d8e30c0df0f38e745ab6b2fea3c887b9e475b7e8278a945d6aaf6b2fdfc0c950b5a854fa21672c192c344b361ea0c122ac0f439435a346c0577fda79affaef0c36630b1c443fce23b20ccfafdcd542fe0fc27fad843d3d06c738dc06e15cfc1bf44fa406ad2f59ed62cae6bd2b189c952a4ae3fb04bd24fd4ddb1036d6459aa85ae7170bc3c6bb01e3deb10cf311478c4307a4145cff5dbb3bd63f8087b9d0acf97783cffc7281f629e73fbae65bb2ed2354b2882827666b7deb9decc0f2c72cc07e7d64c326dc1f182f59112402c24fa9bc814f7eb863fc3d4dc192e95826f9c3f41e9a7b34b7a74249e3f9982dad305997b199f8ac1aedced80b0655fb023e490b84194ab417689d483550d664dc3355efe0a9714329d8c9e7025b75df62c605483036e9b114d5e019594103e3435f3d0702df9905ff7d22ffb86d60cda23e161f698c15cab9892be415ed59569c885566328a82d1911a64732a0e0a2ad76061341d8f06c555f34948abb101496f41a6592a9545e522a20b5533c64b6010707b91df4304103e46731d3355c918878fcbfec87d0baad73143e47a21701006f31930eddf3fba62c30db956c362b261fb5ba5db23fc880c6757bb692d641da9e1fa421e98b63bbc6f6db1cb066f93ca46272e22ccec2e90e976baad67b4761c3cd1213498a0e4f203e7c31e8cccc9025feb709ad27a31c8aeac20c97831b8aedeaefeef1df970c03d013f1f0e863de83ee262bfb4396cb12cc5257be928d01d2ad2bfa3842248abe3bdf65f263a3fbbae9877bd297d8fb9e09f1a3503385fe7b62fc3dd9e90db7e4bddb04b602e42ca3d2cd2d1097ab4bcd20af22bf9fd1a6642d2eaa023870132bef5ec74ba567fb5d4cee6f7d548201389f6de3afa54882404c484b7a6ddabe9cfdaabdf2a33ea15e88d4cf3200c55e8005a452084c386530cb7520c6442f33c7e895c90afc1fcac74e5a67c9ea68f400146aa77a3550282d4a5ffd3d8835da60655c17f0cd90f380a14dbd20d54760861537562336b83e2af71032474fd245c7c407e5028efb1be57b40bff1572c479c223c2ec0651eb6d0990e9f71edc8d356f2e20a9ad61d92454e30c2809b7ebafe32e176f76ce91738767b5f6be0861e8e9fdda4bb5a0e8510d800a2606d08fee580897f7d91e57841c6a2b6f791140d03385efa03d1340adbf602ee2aea7ccccfcc8600882c5afacdc2215bd7683f60df09fe92ffd086d01610756de2295418ddb0626f65f0211b16f76d6b100ce56179c80f6ad55d1802406e0d84e7d4d61329829129a5dab9304f8edc9c70bbbea3ef201d503fd518b6db5f5a508ee728f3d0c76d7df0d5a3f7112ffb433080c2faafa01ce65be9316d24ca03248d572168fe9bd2f0b186af88291ccc68950396bdb145539c1789dc99f97cd6b1b56e28c5dfc77f8034143752598b370909d74e8ca14dff33f748f47d94424ef4d65e6816b86ea90c08bbe3c07ce77c4b678c88eb848c05f4ebce44611e8bb942d170b9e54fbcca60af400d679de2e013d2449f0f0fc67297652635a28c785fdf540bc83b46b72f5826917f8a18cb476d097f0db6a86df08a434884d1bd164c9058ce5720399be993629390db8d878c04cffbfa2515a7e1e71750f13dcdb474f29e06e98406720c3c72cfff79c28b8d4f578bbbf5339d8b76624c9cc7ba273dfdd0185d0e9c15aace91bad983a2dd26042a3983b8931be295894eb98f1ca9ad93455a72a5446ffaed5b9f2c28ac506937725d8b45eaf9559646ab139adaa943aab6061b7c7232df7d01a602361eff37a622adf3ead8239531addb14fca96868d74f2bf45381b79f54450a8a2df752012a1df2da9b91b3651e6540332c0cc7b04f22c7d143908aa7fc9649c7144ed82324f212023cadd04f7cb595034e8f0545c03075c6277e8f65954e6a4d9e234ef766534ca44f1b7ab96fa9bd16aa07999d9a52d52640e5ed22d3a20bb1b5b0ad3b7c64f850b403070e908ec4274a938a0415c9308836efc2172d5284d8337c0f00f24143a0bc829fa1db79e8c34e51995ae3b8dbecfed4e4cccb402408eb27ffca8e99206bad297f2262ab894a74401e5a67cb4c4385ed8711583431f55b9a7937d94da7fd518ff25257bf1a258e74339063ea433039f34304e3c12ef4d48ce8a67f759f9cb7d63c982fae103951b66ae569875c6721f964e1a9d181d23fc7d4099be0bf9c6d31ab8cf2fc880f9cbfe2fe6119aaa279a225a786959efe81e969c196a4ac28948bb77e9f7fb8b83182abbe48932b8f44f21e570e9617537c85258e9175fca09ff714079d5e8a521b7468dd8297cba764ce4828d88c42bc16c95e01730ea1566184d61b8fc1b452b9ce4e2d02eb9db6812177ac83400a085f944a83e862228526090cf56bdbd00de36a5124329e3e4fadacc2773309167faf97c4b8ef85f4cf3a9c9ddbb9009aee256e932aea0f843e195dbf82f1e3080d827e801dabe27d7a11266a688e2b1e0c4150eda264cb0f0f814e567ba655eaa6dd4279ca3c01f02f82ba3425d1d64b3fd9a38a3cdd755eaca7738142010039a74909687b0bf82bca644d44e67425cd2e0d21245c2acbb7dbc6f4bbda9ecc94d72e5e43c651f7f6574e16f641174dc272cc9533429a6722e084ff7d88431a88324c276d161ed67385316b7530df7c013a2a8e06b3c042279b4d9ad46fa079caf2799278e04bc24fde39fd32700e10165dc84f06a3073b77a3d05a3a8cdbaad888240b330b98f0294c78b5210eed69dbb3c75341360ec09734d4033a447c683a2ce8e2d9562969d5a78c9ca40270b13894329d770e5c45073a9fa8f5166d4615ecca0b837dde8122476300463288d702eda4b48ebd47f3ceec96bd4f667a4ab6cc90cb8b081ab8fa9a99a9f3f7b51bd0f6060fc182e7066742b09452984873cf8886c3294196fbbb045d6efc2a5c534aaecc205ac917caec456b778ee5926ba1ff4b3a30a94304ddfa2afc6e6d8445424b21a03806a38c45944b1b25dbd4413f1a80740435d0a1d6012be0852d0814a62e95fd987aea4ce6912ebfb94bade80bc4d1785d064bdb13c39e9b2f9b84038c2b1491b81b1c041e97463b3cca390711841ed3b51308a3b9f631b137bc15307b697cb08f21b56a4e72c330b595f0ef7b57f1ed89d8e45978f8be408e7af1c7c683905112614b090a2babb49dfa106c51c28a22985f8c02ca0f283f9ee32f241563e6cc8c0bdda0ee95d71566c391880b6207ae7ce61281f26bd34222c3e67e67111c7fa0815ecf16c3e541520164fb12f721883c438bee6a745289bc5b44ceb8fa0d7ba43c4f2d96474694e83e570b5810dc8ab2bd5ece2f829ecd61f81d22bd89162f3631600a3626244a4c2f68302c84ad03e2e6c4654e281fcec8d593b91f17115c98eeeb336eaeccf8519bd248094410ed135ba7c8613968f0f1ce3e027e79f2024a04498d2425e0f0b288c00739c6a4ced498bc1a803f3e9e8493a66ef3fd10ebb7ead16c5a8f5cc0a1593bde44c0726623cb0aa0f2699acec8ae261adf8b0adb4026f77cca6c278d25522ae8ade63a493b6342629c36049c77c8dd6d4549c2eae2dab5a1ba451404f603cc4fc0d416e18700589348fe8d9e7869a6c406e25f4bc7529465973aac809a48368ca92a9af7c749243b350cef148fa6fba5431bdd2006fc3c5f1ccd1b69db22a3fa396eebf40c018461d79de8b5d447dca77a9bbb66f51931af33af062f2c591d5270d619c98884770c30cb3a1802f69979914208a58479e42f9bfd81f407c06a6d64fd3ebb1f050eb68f6089f49c6b4d50a36595a5e9cbdbe37ef95d3fb1dafc4848586973de231b06092566023fa6506453a6d63ee323fd3c01731fee493194fb18233c590f072dfd24109ca4657c6afa8636878a7421b4297469be8ce6bdfc841367d4d44ffe86b5e7b961abac70b9532607a0ee62f2b9189c5163859febd4142cc32e1c7a30d40bae07667fb530a5ee07515124a536a74d07f2aaa30003d064142cb8864b428ae709f2bd79517708c0e1b653dca0d9cd99e19075f982976afbfac9618ff153e2bc5659bc75af70ca1125db5b22b8c90317cdc1569523efc3aed09a3a2d0d374de7aa07424622983e1a75a350e4de81d8b0ba8bc298ddff561f3a48d360511d3a60ffbcfad150066d9bfe7648320a632bfb22f89c3b9400452ca6e55a6b8a7e4c70ec2007a79e0c8db959d4de856fe5564a125c5703d52f455c59b2cb415ae314c15803a34df153b34df9f6115c6cc0eb74b203403d008e0d917366dd50f9a7146a920b8d0e57030e774bc467da0cc2bf7bfb8bec8b82834696e301f4c56fc31983a4cdfa14037e33ee00c4ac75ec26b98feb318bf2d5a4ebc1444d68da9af508334d9eae3cc9c7ea979272550ad3e0cb703dbf1706b99e37f28966231ad2a772f9d16001da1cd57eab946c47933db7b302ed5feb5606e1000c8b6a753e81f0dba20ca9b9d79ae3aea6687f57d99b464606a8428234d8010bd3e8494002a8bd9cfe74e3929264851247f09a571a0d9b347507e4eb598a8dd42965e6c89b86e3f735b7ba9b8df626880d311176a3315467e76772b3a5bb3600b9ee99a0d13734ed23cf62a7df3fb914ac780be4ad3ab800390d2a9a216a78523678edc8a2538d5b9e78ff10fc11d95772eb5a015dea9c14558fb059bc39921fe5cf6e2685c88c8e1b4cb86a016de93b4b1ab04b013e2d4a9f9d47ee7630c7bb880a5c1321d0f645e4caf965e379144659b92011345511b1f40b1d746a3c3305c04c537287e86d05e5eac7b989af079d7efd80145f53c3dba81014bd5c609d230670d937b2980fa162cdcba9b31014d7e92c8ab4a893b6645a7a2a2b63093d4d77f460703299a9b7abc5eddfdf62836d581e4acf062d3903ccd0fb76d244a10606b6025b37f077d9b9ea2bdf50c8953ef595d98e38d006c6d357ba595b6be64aa114f7585c3e122e297a119293afa33b27a7196dbeb5b598d94582a7a8b102e2fb0561e6fd065279cecfb11cda2e72b57724f738f259b6cd0bb41032482b81ee3a8ab1234f72b539ab4921f5e0c6a0960459626b1e3e9d5423c72c2feb8bc8cabae1ce16291154c6c329e42e91b2afb3c691a791fd0caff7894337cd8877b833cde61f22219628270ffa5c41b98831cf74a20b06e5ee8a666ad61ff6b7e95daf94607260a9ea0e35c0e7c0add6a5e7d26ec01276be884cfe37d3396bc3c792834fca22c521536d98178e74ea7a2c7b6d7684a8b8da40ec62e0071c4a1db519c0d2533c2dbdf552f970c7fc050185f885ea0b6dfe70d9638797c5277e20dd154099f8d62bc239bfb36c5f9b0734c1de43f412e10d4b8e23b1b5238d0bb209c1b490d557f8ed0a25a8202265fb4b6e136237bfc56772a6e10d94f03cfa23f6a79606c19f886b21c6fad8b05926b895a6d95302a24c322bd66544f742f76afe8901592bdb771611b84d44e897d1fc0081b7ccd0a8aa64a364a5a63a71d920493c1332391335a2048fe5504ef9887698992686c1c27afe77734e2f28537b31ef511126aab015e091bb9b3f0044d9ff6eca3af220e4a9d80eba20e1c62ec91b7d55e18d17dd9c5cfbfe176cfe2fbca8a870c38b4e4b67974a7963e282868d2cf91eb3194e315b74f2749812b6512e8b04865787ffebb1f7758fc09eaaefcded5933e8adb2d1becad258de78efe362015ac9b834f1df934e609d7749362557f5e1d7ccb78fb7fbb9b419f5997704c8dd554aed565351bfee56e94e292d3ba600afe44539359d528607e1e1e28dd8908531be3eb9a4a93eb007465f804a75a06797510693adfe858bb0790e00b5bb3f44c290cf0c464e94b99df7b07486c1f3d59fffb505406896fbbdd833283e058f278a5260b76304c42aba5c1684fe820d6238ce52f7cf4395068ef704c85064da33df5b11a88ff9362d2729244fe9c07ab9c28c9e1a87cad64730383dd4ae11011bb14d2b94a1863086f323cf26940b27e271e2d464cef3ea7be76c78281d07f675d8f1b38fab1a2477c873344628c706be93f0f977e076f63b8658e034f23620d0bc07afd00c761c60fb3066f9595c53b3bcfea37ad954646bf6e2b66f0a43c3764c56a7bf2bb9caaa4b20b482d0fcade5ed6bf1990c6083ae6bebd369d236d10cd4d98f21b50058026e55e4aeb97454a285b3b6ff7381d234ffc46ccce67dc3702e2530a6c29ce6a6a7ecce7416858c19e7ac3b80b596b78c3213deac61bae0acf02cdbf5fe0c1d3097d7b6e5458b0bf9ae4456d6aed276d60e1661c3c45570b9a820aad09a9f77160654955c5e0a57a9af712ad75dbbe4fbc6f373ea252c30de73d83157afe2a6cce21415dcf378b8a30db57581125504f2ede3dd969d56d79ba5891086f54df9fe093205ce96e7fb8107094cf78679dfded92b79f41f303b5a4205ebb369193b8138e60e9246dd087d1ca543276ad5343d6c63cee3ae2195485ad4503dc7aceadd7ffa2754856f83f140a5b105797732f023be1916bc7bc5df2bb029e6bf248a1693bdedcd90e53252905c0d1541fb799ce60c152fbae8ae9c6235d35a1b993c4ecc9644a085fe66cf2c9164a146d9a90a6c08e562557b2c5400af23c923a3fc6d9659200100f328b8dfbb671031f2723601e20d23c431a98dd100b274ce825c6a766407674d39c97f3e666139439c9334598d12f04500304b45df56d416fbeb839fbd5715317ab237dc7daa2a3b17ed2cb331888bae055d513c95eb07b7a78dcf441ffa14a195bb5a17bd5951f9ca73b237db501dcad8076b4b95f544f70f44a681ea2175bf524e082355bfd65f2f77a9105c44e6335403c791bb258d1814b590799bf382b705871874b615f3a44081c4d8b8a91e98b792f48901ece241f1f74a82e8986eb6b175623c98e354778d0a66be85fd941f10604bdaa677d63003c077754529790118fa63559cb6cabd732553fc0c465b9cdaa3968f36315c34a3005abcedfa82695632995bd266c8203cea4026dab7fd541e0d6bb6c634b35da5bbc8c182f99a95dac7eaf74e66b97e5c7f092ed3e5271cb28185a229fe024cbed220641029561e9fe78b54336e7e1fc685f7a9d3ccebca36332a6cc9f619ecca63e1e34f3b59ec3b6aeb4b1585e3f5147baaafe969556eab8b4e42d6038fd44f3c4a10238a727f5299bab37964acc31ff05dc2c90e20451613c2f97de40ea4171e784c1b284814e9a7cd85b8ac26d8469bf9d09d622e9b52f3047bb1790c6af595a14d22a5a6d38239bd251cbfb7b342bcba5736a0777657917d4e11fe24c25ea54f73fe29d453158148b20add9fa06c7d6d07745e31530f729a07a29f4bb106ee521d48a3ca187eba4554d53c2c39c8bf9a36a1a7d63db424a283f5cd66ab5cd581066fea9ca61ca42be1d06d7db05f9c8cf47a2ba6ed6d17ce64fcd3e20f47a16dde1018ef2283c0554c6ecfb5c2085f1858d8f2578cbda2a0b7b1213e674ad20a508b16805f5fc220af0c808a629fdf322f2922819d43e6f572adac076210c5f5117e5ba61d20f01ccdbab4ce006ec9a633897d9ebfc7c4b22b9df13a123e12681ad0f94cfffafca2e59bf93796ac0e23cafe9a0ee68df115b1fced947a890ab575897625a1b025822d4553f0982b3d3222039db9abd7c57197f3a6de18a8dfc56ea343b57397552f387d2a92c477badc88b8a256023abdea13ce2f71037046a929e86e62e47b2dedf357b37940a564400fd36e2ae8874a47e8a9d2f2221cf98644298f592b9691a6cf93d627b057311b38b2a3a0dc75a90089739373419c2221247c5e4d1fd708ce08ce4b384e79c892fff6be79ba5b01a02b3033e8bad23445a531d72d858bfb6396bfbaf9d24d64a39f2046cbaeed3d5a29d4378846afe16d0c5edef3d7d731293af471ea0e94d6274b184bf682d4f49a127a004e747dbd8105e5a50fb46a7045851da46da8e751eb5db1a8a6b5045539f18d9243c4703cd5d5c6251d7fdc349ad0889b7612b464b6e3f12c2d7f76c5da21a568b1924ce920bee94d1e3dbb176f1caccab471b9c24d79fdab600b26a954dd726fbf3fdcef52a41d5b47d31b575d7e4f9733574ab14573a848a1405c6a898753ea8580753f61acf8226134a20f7856659d3b5c6c1693564932c6b8e818bd17345947c16663e0fe6bc5f002293defb666cbe7d72d6af503014cc44b924eac429da9203fb49bf628131834638ccca051a173c67a44e31c56554bfff48615104c9d49bfd89461f120ad21f2fcad6cc9db5f364ea095a0a9c8bbba00485bda02269196e3245223182284e810b23aa87c3f0d9d66987ac24401dc9124d7b8d1e800b265af9afdd3f3e8b3016dcab7e93fed27c984c8517d0a8e317451cb56f4ec3cb834d10a4ab9c9eceebacc9430eedeb8a665f212d03a168ed6ae886eb2b5ed57f8126b82b41f68d1eae781c6f61add3853b7524281c21955b8aef9cd492ab5224feb5c3b8eac2c0a4527ad5f82ce4f5943543ff5cfe958592b729ae0fb2cd6e756cdb46881f7aa49494e5aa8efda9cd2c31e4949e13e8911e089dcb0518cd8ec9f48397a5752212c2695554206c7fab6443dee412254acc73ede9d2147cf64b9ab2d25acc12c43bd798e116314e277f6883c3223c8b2c8c5c6d3f6806ca8bf9db2adc3419f8e829d8fbd8a9e961f977cc018caf2f5fb3cb0e7367ea21d65fe8e336601ca0a315d7095c6b31a673a1511ca092ef7f336a2bd2aa1e00f22d804e0b2c2c58a2d1740d1cd78120b1b30f2d72400b39a0d137183578c7b9c8da5f084382b37db2488d892996863961f8a9f4e173ce9710164d2c339f41a50d45862ac6992882e82fa87b614495452b085292669c36822cf23fd26f502cff8856a0e8fe935ae6a0d0bdd344ae3ac78d8540d7d24aa6a671116e3dd081528cd63aadff8cfe9ae9ad5fadc8f73c5bf47063cacff7e7025f9c529e4e751acfde6191131c99fc9ba827197918f72ee47103a78c1f6e0fcb8820c730f5fb6341f96337dc9978313cdf9be3d8332bcf54b0ce2f7d08ce504fdb4efa98f081d7800558026312006596863b72793c4c54540936426cc102b1a145b1601cbbf39ebfb21a299d4940b62e53d493797d0d0ea35feb182a5108facf9b7a6fc4f549c8252524f3d0300752013233d8c5f3653a56a763b1e9cf3d8687676dc13d7bc47c5fae46443c86882ac7bb8c685b256f4cfbb075df72947bfe239cabb693a6d9c74ef1507e4d096fdbd16a99d91da3306e5405c1f741180ac1c61e94f1723e8ff952d0c91f691ad64a72df4c6e72964fad9cf868dbd80062b5cb26d39339d107ad35f22d43c894f67cf0509d4e5369ec8ef93d4d377ba292b2e9852d8ac893c3a186d5cd74bbd3f887349473d036a71ec5a441c61e32311570b0169aa2860b9fa50feafe37c0f4b6f32adc5af61ee00e7efd8703de23bb88c7948547bffb4662ce0b5b3c96be0c0ae305dccf61a35c6668e2772288eb9ba348575a990a69930f00e8563be580c4a1b76fde8b53bedb02faff3e30f3094efb3f4d943c1f0df9805f89f6d8450609c6027651058da8437c05ea36be71ea69ee92c0fe3e280eef1723e96c12cdd9042f2fcc3312e0ada286de01ebc1519b63cdcf1398f5b8bb3afff2471605dc4c1fa03591747c7e8262d1b2520620809c36c29c4400311c9915a842d1e6fe2e33f983eae783f59a79aa6ba47a2d9ccf6f281c55dc6da67bc6a4a84b36bc49000a55ab5438cdac8bfda01d5dc2a1e9874fbe0480d2bc80aaddb8965a2450668c054001b3ee1a44de9786561a5c095f27cfe8c1015504faaa718a02c412d561ab505c79bc2789dc037d09bff8e040aea4a5f3aa3889c35a30151e5910be2451c7366cb5eb62830e3b2bda4abe48192f4a6a4fda22d1c4959f9b033555f38a097cf14dbd924b97fb103cbd0e64c8302","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"eeeecded81d5de7783f7f164c84491a4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
