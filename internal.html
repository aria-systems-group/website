<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6533e514a6fa34c4e09ee167ab7befaa087dde9f60b4e1bb4d4cc4a95cb6f9464bdb7daf4ae0a674937f06aa14192a1764275536b9de4a90855dbd5a5d6712df49869dbac536161e0888d9a065b36cc78331571d35778871630533a0a15a34046de1c0a4586976fc47d26572339759f6a4b33be609cacf2527f23abb2e0c39049790d86128fa806ed275711126b93995ac2e0a0bad2d117d6b66dd62ecae99944e29c546188531cf2b7158831646ad25186bac12b0d673072398b6a59eebbde59f4f811dc8c2a474f464e4e28bde7e1e82ca2d4d64e2d850601722b7b4bd52cc4c9b3ab0b85a6674fea7d4c279b124f5addfd56d73caae9f39b78907a10ebe4cd4f138ac37eda79c83363d949f4f16ecb3c73c5673b34ba236054794377f00af045487f71673fb5692fc3bc1a497391e5e5ad8f86c70dad829e55ac03d78131023761687311f26b4e0e074566b479f450796c6e171a3d04c7b03200c61ecce67914f1af9d3a5030fe461081c751c59c5ce62b8dfd8bf8bdaf86ef8d56b645d9b22fe0c58bdfe309b2a19b7871898a526c99550082f43aa0cc6252f38ea60f19791fcb2777fe2315382cb1cc713840225754a2db334dc5cb931bdef1db8d5466bcf03a77f5b38e3937b4972e6de67b4240f4f05ae2ef3ccbc84f5a2be7465253702cab57ac2205d5d2d6069d3daef9e3111e3f3e698ee1ac179d46e034c338fb05c74908311737d6b38772ed022a48196239e962d4ea16f13cddeb9b9f9f18036bb53b08f88cf0d3eaa9d21bad20178caef8583f4309d469b6a6534d195d0494dc8e24fe7f4354ccea99450673a8bf3a3a7fbb4673837f84b07733014245fd711a940abcf6c9439cf4b3b5a6818b83f2f48c4523b7bd9aaf46bb52dc64568fafee22c09044d50da130b9c5cc9ede53d230cab1ff83972f812bcfd2765306974d2a8b454601a4469568b5fa2398bcc9b633011a23b13825667114e319201dd51d8fb380316699d51d708ce2cefe883c74b096c1a2f27c605d9f9aa1e9857da11200e5cb3ce0d368dd1990b061af3c95641413127f7764378a9d3b1e8f92bfce445b5a6800b74f84fa772f1c072dbf06f1625c2cb01f806da50932f39eda30698212568b4024854a97240d5d29ae9373dba920338f6bd019cb3190b09c3348367d624efa5296434ca952cbedeb622417920d5c5419def995f7479dc93d42b66731f812be99f600410d0d054afa2fae44d3978478dde743ded4b41bb61b336409080c3e75f3215657f98719364d36075d5698bf257f4570a8e8e5cbf16e90c5fe387500e6b786304c63228a3c6859bad2a1af88cc60df485e6ae625b5026f609d72186f18d22c2b9a24d703aa56396a299981b852801353bb187c31d291d762b3899744f5524f42520db3bcbd3e6136ffa418e69e323e0be4711ba6880efc813d9512fffb4ab7004909796cceca8397b25145e538ab93b8811911b2dd7609cbf4d2c3c380d4da6db1c6e6d11f350edced136ca1418e105641b80350b6bacbc7d73ff1a67db6f9187dd201e73500caf7d499bfa4727ededbaada3b920aa05c6600bcd1a1d84c2066ed55fecf010a8e944a4c2462acdd35b31029ed1aa1c18c8b2c162e5e702c77b56203468e9d37adaaf8e0c9a51131e83ac214de46165471d95588be162c8c5074a9d119794f40bdbea178b9a396d539bea91d46121f0bd8cda115acf6b548c60abfdadb8d044438b167f1fdc333f1e712ef68fa4397959bb7fa2d50557cc23fd86697f8973c4246373e78df9c5359e63492e564f7a4a11e76f2d00c8141b3383751452ab4505e21623b4e76cf019ba7392a2b42ba57cfd8e593794d4592d5189bae239b9a9edce3c9b52f76ec0572f6864bd8a853af6962edabce352f0db8eb81a5048edf54255205fd29b3e0130b69188d116fb95b3c85558f5928b84e73244151675bbbc19a5f98eee72d4bb83819e34fbac92258d89ec109c0073f1649f24a8246beca226e0019fb702dea20c1b2ff933d69f4afeb94e05315d8ce9e1e81c542d805efa6eeba524b099d5708466c7bb6c6e702a99c1d1e736e6c380b15b85d3b770ee69eaa4cc5eee2b6f7962e07f03a949c7e7ffd81c597f6ae0ab5363e57c9289210c9e44e71dd4f82dc2ce7b94446e515e5a1ed59e0faf69367dab800b301e60bdef49978e3fa692e6903a804366b03183f4c65c649ff53bfb37b8562912a319078dade7772a1ad3f849b9088d39c219a3111b82b24bbeb3227ca27d467377513cf4595f499eccbd50a3cae2c8b7f32d4e5c1980fe951aba84fed8ba94036d88ace0850b0994578e97f2c53904c2e03874c7d9298a58c029eabc20d2d682a2c6f28a0137bc4f51639bcd1c25ec3d5c9f29f0f8326b66b87d77b418cfc41b72b778b17ff48507c5994a18f11e7ede29d8563986614bd9462c61637e3002c7756b24c9e998e40e8305f94c5cad891a2be407ace1f49319a4508775aee30e1f9d22f43a48e0e7d1da25cc8aab4b900b0628ae069e238b6cffc9d06bc2f5e3c53ddaabcc3b169b8127824179e01b01dd962203408289d37d382feef9a7b8f70899478e94c684e9533806d556154750dae2d6e78724372b0e6a5b12f776ac7669876ace6419a8237dbe4ee941f7f7695144c71b26758117872f48e512a0fbfa11b397cf4ce38084bdb102034d8247ea2d60ebc0cb332d8599b9cddf1f3007d249ba504dc07544466bcdb47f107f67bc3e24fdbfc3724d779eb413579135eacdc0fb0c33d68a99d49adb937a161ceb3e1035f89b924eb88ce66b50bb005a9f4fa6cec3de35de3ea35fd56f96649b71d0844b990227f1a72da923c728629406aa9bbd87e769ba03d59acba3f22e24eeae644a6dbf0df38baa8206351324be01b8ead00137a1698fcd75c6cf11c2fd2d632b3d3867a07d90fcc32b97e43aca0567d3149ed26912e0344df01baf4a93203ee95ba25425f622081fa22ce631dfa259141c569e9fc85dd281c651916860c2bf321f76d9807711f8deadaa6e20157d4ba58911be541d2cc2dca88f100dbd3230c70c9fbbefd90d4db1fb073de3d96e9929281bf9af3bd70ace29cab1e24aae04ff74b845842648f97e4d4100b0103090d259d5fe24aba775031af6347ef096aec1513d2354dd3160db75fde55ebb29e8328dc32fdf1e77a317d902301665e85acff74df24af155bc8216ec182d6ad4cc6ad6f7255655cd8cca54d1cc7e1f919a26db0577cc04c1ddab1e285401154dcb1e26326ee7ef02074964498e10bc9b796b336bcadd0f6cae84805af2f30b57043f411c45ed73af616456935fc4fd2fae5cd808e3b517fd854e31042d430fb4a57dd91cfd2813e68b05519ebff01233b6368c4fc2e7e03a7fd6e399dfe2912092eb92b161484ff5611f23ec33e88435ff6f2b3becac11dd32a8ca34aa1fdb584939dfeab3776561439c63af3d99101fd06a95c2d34d8a31436f5c239689978c876931bc1fda18871e0047857bc6b67e3d362a6e36e352d965ce6b28d1b9158ee0c139524c4e70518e06401eaa559d55397086df0011f9f8fed2b89532518dd5953ff4493428d951f925a5133ebbdae60b054baedb096605114dfd6cce288fab5a00dcf55663d0be19a0ec11e4ae64e10f522304238b1966fded3dc6c1938420c37d93d5107b6e6b1a42d56cc1a0ca67a005b2dc5c8495eaefd81be71bf96a3678333e2e116632c261d9ad91fb4ba946548e523fef6a466d00ffe284ca6c66992bd767289aa7e27f7e6183022a8b90ea9ddd2a97f1a68b53b8a391fcbe2dc9eabe2ae1687478ec58eae7f6e2496d94c116cfd9339be4a5fde71f1d241f2db86ec42981d39829c3ecf8f32e16c16426e95f52d1b34cadd61f5a86209ec793f7b9ee56945f1ff70633f8881334cc2772529ace63c643e769e3ed78e50d1356dbafbd86299bba6f09362bd2e3dafa755b8f2bbb81cc26f451eb9623e9614434b8256becb56337835cc26db17dc2f7f8db5c87320fe3fb9773124977734fef6b9b5f49a14c3ca2187b0b0a2fae1bb9afc3e169ab95c4ccb0645fa8e0c05a7a4e1d0a03b71041d32413f6cea4d66dc99e21d82bbca6b06e466563569d5fdfe8e2a8e058072f0853697431d52e12367c447b7cbe06891fe77c3428aeb2f185ba8805a6b825992c932405c2d1c9430d7f3cf951de37fab88173cd90387555485a8ddd24053b8af254d3aa08158c99e3da69a8997fcecd137c30fb016318a84e06382da137c594fa22ac4b2bffeb9121a9a1f7895814376683f3f743971e92688837df9ae73696ba8d4548d02d45eeaea243266a9f4a2dcd6261b3c0086ff3aa45b368a38c8b7438cab9d903a48a039460d09137abaab5c896b482b21cc14389b220963e6942422db88c73df04784e49c064b0f63ecd42486c9e26579a80ca0dbb9fdf85758963594957bc41ee9da692054fcfa683860a460ee99028c69a6a62bb87205e9ca7b3b1154e119650c981ac73b75c13465451f18904d9948ca8ae11cde0425c6d4fb5ff278ca9a5f2a693da72634430204bbb979e4150f138aff43401c6b17e5f4c4bed329d39994a28dd77f694e470c4d0d1fa3c82639953bfacf7366bfb6d4096392bbcace3f0b768e94f1c3008082bd693ee90c40f48b2c78cafbdc8592448d2ae49336b4efee64d507faf4d9f32e8fe302aacdc05681bb7b62271f452df60008419fbb4a350403bd71639e5c650320f5f28199cdf6d9c8a6127b1acdd8e4bd8899ee4de167176baebd10f2dd64d4a94cbf67a13fa14240ec09e08e7e7dbd8697128a60392a173d1923e9f37909494abfa48a06ee0cadef2ff99fa864abf5048852e59f3dd464b169732078dc0bc4f68bd487ad1d3ac996858d1052b9310027701be4e4f86e326d6d5dfe585fbfc14ef3b5d056f59c0b8b1f58005465f217ae5672854ac05757437a162dba6974d784ae9d8105bcd29d7af2fed9d7e8dfe4cf236462ff9ddf7e4dbe28512c7771c1424e761d4d88bc354c7b33398e3bfdcc8d9454546a1c5137e6524c7018e0a8b86ec319ac24a83c5f71c2dec5cefb11b11095248610fefc5c338e7c02791156e4d9635d57f9d996f0d50921b8ae0f593e095bc1bcc642d0aa788fb108a6640a8fedc27b0a638c1976b5fdca6af3fbc10049e9bf91714722b4ae3f016f252df7e2ae7042cd3cda917845d3118afcee944da9371741aa4aec77ede31146f58ef3be6e0bd32ffe543d4ea7a23acb4ac963c343256973bc30351b1bd58b7e0b13817fc91a013ad107f2ae6ca1bd9bdf1d64d48559b3989670bf37dea300af4cb9fe42a71753450e8d6a9ba646c9314737c1915fbd448b98be37aae203ecdcb5da30f58d5acc141888073a54af47c1e9fb8e3ecca3b74287a632101586c8261a4f060950a8de8d0c986168cc6739b7ad8538c811476cef687baed920ad059eaab8b43b56645ebccafa763bfbd05d637685a2fe369cbd8da0aa7b9fe38830d9f102a2b47d6ec6390fedfe657b90cb351fd2968de1502cbabf820dcd0d08251951647cb32ee01bea109cb19926fafb7f53facdc0e9a65be1777af4d9de4df563399d84272c53729d71227fe12c5d8abcd5fd9915c358aedcbaed13efd7967fb23f6df809924de17e908c583d6e47fcccf2ebaa478857fe2389f109a4b4737299a8dc4c7b3a95eddce107312db24432951b452bdd01615b44f166cf440f4f732fb8751f7c45c410fbfc72bd3ddf2cd42fbb8e5a511bcaa86e96770d88849e76ece33af0f83ba7c3ea134407e082a398b630d0911563a581e9c70e8dd48a9d308c3b9f0b3db7731ecd0fda9674e66055974e75615f8d29acb05c0af03146228d5deb3ba3831ff0b3b0aaca6c0746ce7708e9d9767dcf1c14fe738635c1c3db105a5b89e16ae3e435a813b7ecd630d9a96bea964ee7917bd2af7bd4bf71020b1ddb7e9b143d702a180169ddbd19d7a9927e2533f6c5dc4da58503bf74f6e5b6072e7019f59c139b4fbf623a9718a683a32714d95c969ece9747d4197fa9c0e0dca2088fd2a9ad87a8457a7d1a5fb4216ab42ad244dd15d2427f60f22728ce4a66e66a43f0b5ce7d1784f569f2dc10e8ccbb699e8a3f0ecee82cb833c28c535ad32fb0df34ed65656234340d2a353d78ef73bb7a4c00fe93b8ac65ca82304ea2f39a777f91855adf2a575fb9fb0238c8697030d954af299828e03db63ffdc1e42a4c47872a34e34063b6d48d91cc9f32fb2dd2d72c39b5e882f3bd926aa970c5ba422a772ee293a73b6306f7ccc46424bcfcdf6902bf75308dc5f547df3a6e12f9aac86d8b367e4fd09e85ab6a6ff24db5a0b12a3fda515626c0c3265036aa86d5be7f300d3b02ba6e221af44f4a04b73b84626f6d84b818e2c086292eb872b4f346e5c838868364f3c6655e78b9b1bf5d25abf2a73d177f22753920dbf634a77a82af255bb152cc59797133131266013365421cb50a4cebff73901b2b3902016e996cddf813445a7ae1733d201a8541a01e3fdec63f9fd39155bb35c05a6d6457cb6ffa71195d20efffefbb49bf99bd8032dc22a86bcd0f1e95cecf4e23a8787124f15be44c07a8eff0e133876ab9c6f401432708601d45d5d57ddae4a2dffd8b2594d8614fbaab0062518b7c59bde9ed64e98ed128b3ad88688dd6e11c2a2191c2929961c2c09dff746c544d9f48cc130dae2860e4b810ad746519044be62538125a5d69de97f25aec36c2f9ff4fce9745689ce6949479b88527ad906a24d14185fd734fa8389cf8d2ca93ed0825e4ae70a5333463655008c538f656bd5f7850633e989a9c9893fada12a5c6470aa10db2009cd233c13184f5b8e9ab7f96d72ab38b32d9d5e45bea57c8c621812397e786b834403bbdbcc90c6910d3998350dbfba4da7e1dec586ab245eaa94e8b752109d923b3974d69b0341c0f3bcaa995c4af5a06b0c9c0d9eb242f172e72881f782db1998cee4b0303249646006aea258687e25e83ade0eab8148cff7c998f4e63b7dbbc11005fe551caf7d4f692742a8cfeb5afe01302b63cdf9749900ff9439c7224d5ddde6a46ca703514d4d06544c1026c6bc59078c03a097814722bb95ef32ebd1b25e9d1a45d0ec781e1ef24e6e5fb4714d6be90cb133d47f3735ae554a8f22a1df4e4f7c46d861b647f5206055dca6d73e45eb0428f339f8874b2be84085102ab626797ce80bee4dde6f8d30a0b980540bdb4764441046eeafdab816dac557cbbc668ed9b65a873bde6a65d29f6e4d2cc570d558b1f2b7a17fdab41f828bdf545e4092ce7a67c1724da55b1efb2c06e137626821fcc63126f9d67945cd18bae6d429d1c0dac63f9fb51a57c6f076defbc98d07d862f929aa8e86eddf32fd9627b0a5d05b727c95711dec18d7da55f976e1a3dbc2040652c793a3d6b71912a673e8d209c0f37da4d669e895047e2af55794b7b18f9626bdbcafe11aa14184dadee21d8b111f9b9d38bafa3549d959ad86e8187303dad954277566342bcc8b308f6bc7b6a747b9be52d20740a770f662d6d1ee601aad604d047410675f741f73aeda407c34b20b90e7229457430de1c6e8640fb89637fea519aa9e559e33393977b805870711d3b31d0a810be81938fa51a7ef89c30354c3123907e2a270220b7505f90292ab48f3f6f451f63fd598789b0c7f7cb2b40a26098c775c2e5bfea5bad7a6a769582af6436908e320315c5eaccbf5a525df581fbefe55ba0b16bb7fdc15e090a75a7bfc070a9eb893329130c46d5c6b11ae52d651f1a7256ffff6012b7def0dc9557b78fe86463fc988f4adfb118b7f1384639ddd651dc4ab0863098a7513f3feaed6f91688817111b9bc56ec44cb1db1d7df496909532fa94102c006b5b5f144dcba1962a8d02999b7ce0e8fabfbdb6e23b56b49ae6df254ef0454f950087cdb2d05657c7db8f04913dc5bdd1bbc2b47f64be3fd86e94923b5e45be6b2da062e64805788d77508694930c8ea23d8493f59da634f99e8fa7e2b35ee41f0c8a4d866b67627791df5e1f17186c65896ffb3d841e871c417d969ce00545f083ccf525f38717de6ffba4b253bff7e953aba2e884c4752126debc082df43052bcab57f71b64a8b6a7fbb97fd438291d80ac5c3d953961ae81e494379471613ad08d51c920b94b21d21cf9b2281f210eaf0201843664a107b2dbb156f13822b198f4f5d2289dbe2225948011c89bf8f8cf2c26c3b17308ca192af6867d8cd5bc6f9a8e8ea31bcb44034792fd57d417a5a32a373844fd9c17dc49087f7ad829ecc8563b4471fb2f9653d2b07694added33fcd7ff87f67cfe8f3e11a308439433e84a5d52c22d5068d03b56bb37a4123657bc20b1362cff22565c5f443f86447ce75a8195043041c8a2df5cd79384a8bf3b57bd4ace65716512de104b9a92a4f3187ded6d2906b07a273f2ce95bacf31d3a147e50ef9b25673f953fcfe5d27234beb52cbb6b211db8323b5a24e2bee5a5accbd1f507b6a88ff3b702ea8da19c01e616ca7f19a2a3d394a638d9ae05dfa56581cf499a1928dc6d396a0c06b22ae19afa953cf1628f4398dce7dbcfcb2dde0f92d3c54589054c0c7e07314cc52ef9bcfecda77b5833711ccce57257c921173ecbea9e2623a913a2afbdc8e6c830e6a300f5ac25f8bab221b81a17f6b87790335a4a8db637df4c9fc652f94803e1232391b534e053d8521e57fef5fec9a0788953cf8cd4d9de1ed93d03b0f11222b27b76861d0534643b4cc0e62695baa68d4b8009ba58e794a0bf1d3828d877a1223d75517ef93732f08ae2a0646c93a5341b5c5f9e8f134bc2c9c4d97f144f7d84b5ba84c1c81ba4f05e01916188ad71246ccf828489ead5a0d2b99b19ba432130a3d3bf61fc3fe625f7a73873dbb449ddb8d0ffc20823c26b58473a9d8eb3c0c5d8750bf6c56322d73e3c3da4ff1ebb6a369c635e19fcf805342d8ec9c9996a7f0ce1b6dc51a5b60a10fb6f5306284596126c1a668719a9eac6f1888e5d5145c67b43abb58f1b92b73e69c59d3f3e6752d7416b10b9abb40b2d277e661da7d241dbbc0f8d6f81da2abb6e01425efb9c93e330affe34e90fd8ee40a883cf150eed38c259e11f7e2d2f8b5bdcb2a93978f7e7896f5208235dae69b33c03cf4e43f02de6e19deef10673b230063bf85f0f7f404c54a807da6ad1a45bef1653046ab1f72c397e145bbbcfa29b57af4e2df9288ec92bbc5dc6f71388da54d9ae837e904bd7aef3709267e0dde12425523da6ad2cc1b7f0f7dcc9bd9a704118ea765a999b857eef25643662be2716f67a0dffa2e88714e1ee1cedea75d30f0ccc9521424422621e3e6ae8fcc64d4a9660d94afdd5a30f081d5b5a8b59398c99b2e92ae03ac0588c66991fe6df55aabea44a0914147fcd8a78d9f4e62336c1bf988ab774f7e3f76b9f427b7f0595984c6a991cf1b1934ff0caa4626ed242fba8d77020ee53d4b7f7e2b30bd097cecf9830d8b7af6c98c9fbbd5b23331b8b65210515fa1b2d66dab3d650883840c8452ed932a1c0dd9051caa368f50fd3cb627b04b09291077fa341d05de35dd499a781e1d48125826af9c997dcf74deb3262ea0d9ff4330fddbe9198593323dc553412cb8f0d2603cb2b7bb340b7be70b3eb772de2fd4ba756cd57bc036378023867c58403bad42a8e139410f1f3171a92e28191833c32dd7d4ef8944b411858a129735b33388fd34cddf82ffe7425cc0e990b3b3e42f639d34009b4c5a125ae45604279957e7ea4bfc383d2f503dc80b4b20dc2835d145472bf4a76dd28b40cd650574689c4f27973806a1581e185a7b87d963dd98ad911593145fa554e8f4e6908efef86ae31902ed9ec9c84f4ccf93b3ea9bb1bce2eededa396058536594098dcb97d4dd2343bb5a666ce48a6128150baa726fb04babc1990db9c1c3bfad176e4219852d66870b4e336dd6b444a26530dee4917aeed0d7db79c4756124a46fb1d19b4ff98331f12e0bb05b1e0e74804db7e8ad3ecf29f92fad6a13cb844337934bd328670214577c6aeefb2b0fba5e4f2848a77187a2b3f8f6d82d6b4ef6c1f5f185ce212972454eb2f3b2a0918cb815b96391839fabd4d79d2a76acbf9c37321fe671a36cd1bab8259ae1e3bc60bcc6a35800fbfc4af0ffab20d701278b6e9cfea1ef2e7425d4046a92197ba166c493c19e85d3c3047af731f438ded102c889eb8c1eed77e2c93e29dac99c83e01ce1de64f39010163cfd2c4c8f3b8aff2782d64811c53e788104cd655d5e855e8b591169fbe719fcb280f1d7aab4bd4f9da88e78bceeca0bfc19315b2d7409e2c2af3d04872f7d29e01723f5a4b93ab24c46095666efb71e04a5f895872c8cde5363586966f757fa8225217027b9059df7f469cd19be97653a4ade2f6aece00f6b70915ebf3e73a2121b2cb89ff2cfb0ab24a6c611ec5702fa05a0c06b8c11036133032a649f63af2218e720bd5dc95b41b8763e77a4e8e3b0c167970ad70cfd943eae1f772d56167ac693f4f6bd82de891a8fcf8cdf15c9070d9a9205767c70395fa87efcd697de53a019f3fcd266af81b66a3f0958b9047397c77528607c1c007b56b0cda0486cb99f99689cd0176a588c3ea34a294096902a9019c9541ed76d8af91602c2a385e55322bb5dc3c4917de1f1557ada34bb02ecac743be66e354ab8b9590f9077e14ac6d561485b52d804bd37c52aabda7a46d5850c5d1942c310ce0b2cf761362088d2af06712c54c07b3bd93692e5f322c6c4843b89ad70ea30890a962c6e411e3299f1af14fb2cad92a5ba6122b9be0e5f0802e9acc1f3a4b5f38ea97481709d770ba5a2c75f2242a29157d6ba7d0ad1daf3c5b1494660aaf4f01cc0a10da5a41724a6f45cf71f49ad775105b25d9d5e57b26fbee7ba963ee98861a11f19c776723b26a0243a9f4cf3805a24fa3fa35f90639f6b3443a9824aef91c17de63cf2c43557218d082c6074eeeaa5984d0c53106b78083999588466270f4dc448cf70cddec18cadbec90ad2228c6b299e28614c80e4608b31b9d30b3b7f6aebf59d5c50bfb7199b6b219baf205db082864352362aa9b070768401c927eb1f86140376e5a8b8bb5970258832ae9a76cd826e9ec5da9717628fc033a2b1148e5e969b470ba42bb42cc5bbc3eb9e5a208cd86637e326dc56b25baab5be6ab38e5736ea0d1d9d1a1c3c2cc64d2e9b851e1ab2e1e6aa3dd4102c5dc82afecbbf5bf58e4aef47dc564bb5c128ae16ce808e34b65b2529a6da51243108cb5510cd65e44659eeb65c967a485b6b443222a777df3d903301dcbc39bb978079ee1e77f4b7a5f75c2e096423cc711325387c669690884870faae04454a3b7a9499aa1f4d031e836d84f9b3b67d5d426590640367ff7c5782d27af458fb2df3cc51d7ae94d23aa638fa4a140f15a7692b3720cfccdbfbc15f4c4a63e0cc5f07cddb9fef171ae256a1afa82671588683c94100eccf6df131801f25f91b3c209921a8763b97d963daed1326511ff76172e095d4c956206716037fb6fdfd1fef619fb41f9a56b937cfea78002726ef00ecc13c95318316d0def8c47f51d22e51b91c63c8665ea64404f36636ae288e4e29611fbfa4e00c95d7002f0587669bdc221e4fb5ce411771424f5b6e273d76224102915fe055eb13b07d004e10420a9e1bea81a2a47256d5f6e8dfb3d1592df36d1186251f42b02299d31a53a68a9b309668ae839a2d0abb5daff479a0892a9262c82999873c2127ebfae965e4bd425bddd45479bc3bc3072b28057ef7ea2a0166694e1712ce83da072215e0b3e23b3929719a2eae6b4f90dc69130c7cd213016092563ae36c483f1cc781dfffe4c5223d902800d94c7ab078540afc6c2785201ba6c9b7aa1dcf451f07041b2649197de17d3b0b63fa5792578a9ebefbabbe66d5bc11a95697c924226512f209da512a5ad7c7fc0fe7f15a5f887030b289a259fe38a5636fa805ab10169ba162b20b0b7c001aee86b5bd821e2e726f889a22f7a68d45d81e726b4992bb076875eb378fd492b345ad74eb93c3a584dcaf7e602b9f28cff8ec3ba28fa4fb92e2a3d55b04aa97587674ba42e3c57908e30e2c67d76a52251dbdb406c803b8a37c18daca97807d817983f324db4aa9ebddd3e9725e32200362fdb5b7f71727eb8602ab397c1dd622641af14c16b94673b5d79b6304ef34e632d834f4bdee62dbb1b5dd4dc48a391068dcc39dfeb3b57e11c1751b0b20978ba4074d1cb18cb892841464490aa6a17abc755267c79c437c808747befed5b31cff47bb6b8aff8bbce7839b92d41dfaec819d2caefa8b6fc84b1f818bdbe840bf7ca562f6d78f729c791ab6876c82e57dcca3fbbe69fb3040549ee8d2d1c7aca7869a83d3b83d574a0e7115af3c4b643bfeb7643fbfab79fb8b56f558389ba1bfa4c8012879375b5dad5a741dc4bab360b9915af52a75645ac2c11fcc935af4e90c59feac1e404dbecdf56ad0e4b93b51bf6f810d352936dea5f776874a5202a3a39919f1613c3a58a2c92573c02391c3b2f2e03ca1e4b2e2fe6a1de4c1470a4a17d0977ae657e0dad627d5249700613ee7f6384287651c9c418c881671cda2137a3057d4ce1a839664c926b39c793850ee2ed2493b16a0c04e7b50b37fb81a965ad8050abb85a7131704897e7a3d3fce1dbcfc1f25e23d8e91ef6d8478559aea7406b592316a14ab31fda0b018a9cb06f706ebe63730fdc9f8a10525b8b052de0381bade831a7c579e39a2d3f31f28e7de5723d33756474984d0ae654375e57b4e094acae134ff040bf86ff5cb1833e08686cf96fd439a845fabf386e860f8efd1eccd79f2e91ff1207811e79d575dd5afce9f6d41cf8e4161ed85aa5ab7c5bd9832a1461c5f49d123e74b4905093d5569e3694f6da5a4ea8b50b291892ae9edb616e00481d68b1e13ca8fc53fee2d3769608c948b19b11a196586c63d78abd53838cb04b0e031d5552fdd6c5370922b2d2730602918a8c7b07053af58847a3e3f625ee3219ef7ead5f9057566c891057dabe69046532fb4e9baa40a026c401116b8f621919fb3ead16677c9d636fa9a3954d4d46e3af96e2ad0b144dc0c2bd54a9fbaba8fe3f4030cc3e55eeb06039b55c106baadab8ac7733308575c03a091e926628a4dcfee365dc5a5373979a30ac7cfac4de7a54d17eac3c81f86dad2cc27c1cc9097f2755607be7ec67bd4b7c00dcb895aa10bd5fd5e4452869bba1f2c2494d861465957a55887c02987f49217f1f85c02a17ec74455bc513939c28f44d9a9f180db1686da997d1d585a90d9957d4acd30f9f5c3be8551813fbb0f6a028c464ab69483309b1f6426a060d829c91115e0c0585d50895264819e62eee294ec5ee0e5bc841659ce08bced9466eac4911a41759829b344f026432613d384d57c26141e6f0199874301b68980b8a708effcf36a4c37b67cdce8eadbb5eefb12d35f2f8de01b01b8702a0e24522ea32bef4459df77a34c0db0e9690455693d53aa395e9d7403d3de7516a51ec783d9762ea19abeac18e3490d227d413b8aec196102e9b9e20f07ffc42006e5c3ef9dc04eb10cdd089f02ec86b7a2243a862279470829bbdc4ecc4d0a66d4742cdb61a9a264cb3c34b1edf827eece9af146a6ec9c471ab4f73b54ca93cd2d0eb03c70e5f489338760503e17c3a88907f16413bfd1d8cb4712c94c0391a5ff7429cf05a4ad9559a6d7d0b5a9ec8625c5b49c9ce8649aa28a467674afa155768cf95ffebacdf223626c0dba346c67eab02b6776c9bcce23125e178b20ee332d959be0be064d0c7462eb119e6eb276ae21875c49bbeb4d75d2641e515e90ce50996b33e9738b096668b0b58b8b5c247c59c9004a43b907f38c4515ed4b3a1ddf0fde0bd6128a98b81c0265d666f83bad893f17e7bbf8fb6b35f130b4f875d1bd1ba3ae22562817ba088cd420ef62aa318cc3872b85718774b63f7c12977036d63ecd815abb00c96399eeff111959ac37a77cfc06e710297e9326606d93b4e5f84f16a6423330f627ff3d87535874c1d11d319e982394ca036771a6b98da686a5778e44f388bc542b2611403b8779572ad2e69630094f3b672bbd84fc4409f7af7fbff253208ec526616d4f805beb96f2cd1c4552becc4c4203100f2eebb62c010ecdb478a4cd2ee7e168ef1e9f9115171d4d10dfe3459b9a1bc02339bba646dad2c6538ee0cf011c0788827deb1d239c1a987f99ac8db5ff81be1f6bbb770dcd9db7b12515af156e12f3960b2b784c497573ace8925cd682faa4673d652a98034cd558a8840c9e0d5f518730054463756939b087cceccd4ae4aa7ef0b8c3d4a2f0d2b6f28d9716d216bc09ff8ede309b488562a9846504b17a609baa4e5584fe68349719dee76432ff56c5d8472af7dc8da24f016de99a378e7b0257a05053d48cc829ee0d4abdd40a37e7b89cb258df7862b6108970a554c3024afcbed0e51f92e5a4c2927237092a7a6ad5e997739e921b036928b7a887e4a013889d57da0585bd5e756b85b6d52a264075c1512b1d820e061210987722714412a320ef79255b2616305a1d273e2727db4e58052e9df8d1b09309baa78daac1dd01c8e3734c9a50dce0f3406f4d228931c82bd3e1b7879518b0ab3369cda6b12c19f81460ef831aaf1f9e71b112261fa529d3279dfb2d2171cd36028dd9de07be755b6390f7587e5d25194fe54a7b54ea295918aa43ec6267af9f9304f681021ac8d13e39a3e1fb59d31efde3aba689df6442f134a9de8763980f255bd39d68be5a9669785fb7c838a382fb881c911d23127931c331bf4968521ee9078383d0ed982679a55917477a96850be9ebf012ba7cf87a1b0f8884d3ed25c7d9dff184ec321c1c26a8057e2bca6b2809907d034753ecd53b5fefecde1de6f0e1b76bdc992f6fd080833d4c18f87c50f73f68edf6c03a115139b7bb400bf3966fd66fd55d31124724c3ee9a5e88b67f34fa0d93c5879125e7d1c2cccaeada3b47b6f3a47c6c9b083ee466a37384bbc7cb8397ad2057f703d3538a1da05f6b35431903a85739e0b3ede74ce501bcc9a7cba263c74eda2afb961b194158d48607b6add0187ba9bffb419ab37e2c2f0b85d15bbccafaffd2fe9d0adc107935f356264918e969175b754171237da21a0c85adffa2a008cc63a2ecf6101cd76a6f3c429046f283ae88dcb1b47a9715531e3e7bf3642f0c3e21f2fcccf3e9d837df2f734c61a66ca0528da32e91fc133d813e92b4153d7e0e25674fa793ce9e1a7e53885271bf647727ec5395d101725306a94c9b78a4833f5b95cca2aa2f0b979c5219e16399e24aa35afdf7426fe401535718dc045362530ab262a1b7938fd572cd13895f7f1505caf9c103a1f385f3840942584641976163c7437cd2f9d4d4ef7ea3b77b1b25f12737c9a897aad71ad2667fdd0edfd570af5438e0e6c004129955fe1cf54903ed217781e72b5006cb560d28688674471b5e7915c3ea25ba6d5bb9e7fb6bf6ce6bb1b336d59444f3139fb9fa881258652b8b9e0895baba391914c6388dc214bbece7f092a9691676b96a71d1cca7d375953a6277b0907bd3b89e509eb5a5af8690c38793179a7ede7a9bc7252f4809b869b0e5941ca7e7ec994c2fffcd2ff7bc95575a13eb686ac0b2f2e4863dfaff90a3a2b28c3f962fd71f4c3bed13f0f7de6e17a814d5214c19f352c934ca78fafea42db4d67cbae86c35796fb18f5ae2eae69103403d3f628da38615587116efeb5b97315edb2c38c7d4d1408194e09930de00dc4932fb25a85b961e49d3fd4e19f3e1f363c9475706047f5f983f44c3e524f915f6aab1b3b355056b1faaec53bdcd5f70f8b1aab1897aa1e17198bd784f4accf2f63da566077a5142ba7deddf041bdda40686fcb19b09c6404ea6ebd00138dc071203b79c667de3892ca4ee5a8d3ed50c4f36619ad0520faf46cb099a412f9d1ebedded3c9cc2f6751145d50444d79ce45977bda8f8b374f5e9e104c7b6234289ff2784bb95803453bedd000dfc7c5e18be33ef460ee36c40004a8d74ec2d0a64c5cc86f3592e5ca96dc07bb14a5e3eca97ad2d90784f0976f26768a1dd3593332f184f182ba1cf76078602e34c71cbdfc3e96ab8162d5402ff6d719c67e7b3ec52b99dcbe7d1d6a69ca99590f41844106daa035bbe425fe935c967cd8be16bd90b42fe7bd0a153e8194081492389a3d072378947928758b38546f1a3775035d3500a01e0b4d28cf32614079dc4b12b3d28312a0e3d78075938a5102d7110c9bf072f3c5537291beabce9cd33c0ace4893e7fdd0746d72e47f5fe794b7a2222b62a18b53ca3454ba69069cbe6a1833a6c8c96c6f106ad7b98253b43e2d10dde93d009e8b35e874edbf3fc9dc667c68d42640b12b8b4542d0e717df460651c8de0b98ce0ed57943d4e4a2bf5af482659cedf57b40d74bf528f10a2007d5817b2c745fb547bcbfcc1b48576f68e1260d53ad10811059424d696efe670d60a736ed04ff22c0ca000663ad2d8378e5bc71095827955e0b7afd79f244a1881a28e9320ac0a68bdc4ae09be38310493f3b67be41775a14e6aae08dfe1485683f84593ad6dbed69aa0a56c83181ee0c9a67f09a13bc84b26abf0f93167b765ae75b8fbe3c2c44c1719c7e24b9d3a267376d3148922c73402c87c2b25bc4a73d5229aa3375e07c1c1d0aab6aa004dfe665b4602542db11d367d4559d826dfb5b525cf90c33afc5ddb723ec82469b4c84e027030b807cd48cd57b5d3de76ee6428b35b04fb15455ce30d4439b2c61a3244fae4d7b6c1cec136831b8215f9cff201cc44743930ba8606b0b634a347a3abf2e4c112f1376e1381a6ade57632758154f1510b7a199534f973aaf74cd452be90b6e90f55a35c6306a8ff3b5f168aa25efa83e4fea5491d3076d7a9528ce283903003084670fd8eff3153ead9b0bbe73816d0f5017dd90b993cc5e75bf0147fe12abe0ea283cad2a62dcf1010a624b0bc484bc82d322d0b4dbd788bd6e27597837aa036d6ca4e0c7b5de9256327a2cdf2cbaa0eb51d33b082bcdd03b3ddefb2c7f13e680f58e2116cf537ecf26095222504ee99c1e12d1c4cc0394703778f32f006a7d7a39040cd67652defdfcf982760eb6275ee0b9f7af20a7d5bc5f97c51c44206b7cd0aad2b0eeb1f51a684ca5f0ab89db7afc8faff8755906e1a9c36e9b22b59fd2d465417d36adac123fbe06d0ae927d76099ff43cc968a7e38fed9363fba6d170ca0734f39c02f0149e6a79e2b18f75386d4da8c6ebd733e045a3a34bb331a9731c8cb5298b71f63ebf462fc10f7ff3acdc2119699c275c54c1aba59d3780ad17402bc2c20c4de9fc7493a0697e1290932a37e39a46d0584fd70aa5d37235248aa3405d4300e9804ee5d16c3e49ed3c0c1cd7a4b2531e17e7a6905bff86b4dc8367dd209977b953e70d5f9335b9bed8ac8edeaee1727fdf07ceb096802bd7fb3bcf5279efd53faba57e556f27130b6e3ae564aaede0020d4c32da9fcd15c570ea8db1244014025d0709cb9b019d5f77539aa275d4d6f712316f7243fc08ead8b6819233866757792d697334cc12e4c96eca1afaee8acccec19178bf653ba4e392fd195c7a21353e724507da5dfccfc9c78609c53510c77c6bd890f996e1e8a6b825ebbdf79e136335059176f6db87cbb8642a3c22dd7ecb1be9389c8805536ec804619f4b425781c8516aa7dc4f3e00d6c7dd71a942350f2b6a449c49ed8e6d227750b0d457780a4b1d450ee074394a5036dcbb6ced866f28944507cc65bb500a05feb7a3fac6e9d87d506eff3c8c6decc212ec469f54af2716569a943fd29700073711c64d8314b210b2bfa7e6ef5c3dd16ed0cf8215a719b9f4d27872574131336f790211a6c0d204e5fff88eb23a941aa905e89f8e36c4b2562306f44b172f2d715666878c68043ebbb975b6d9cb7608a1e386783d852a422fa792d239eda2f4b566042d6e035e7d2d4cc02e74a03a6dcbc130a318457226111ad385137c0bc1831c2bb164c582fa51b8711417914126b77cd4a771cc60af8d094dc1f83786220d0248b912a7c0e8df8be39e83f5a60461c033df28bc1510d281f9c0d3f1c9a9cc2a65ce68af42b255db210ec72760bd89f3f08be55bc05ea69779764e81b5769c8f0564560d975a3a74dac3b231209fde14eb59876719c79ef604e6c23fa4e4dbec5dd11bb871078e4024d00ccd221a41b77b1e4536601a73518f0f88b3ec5092ce7539b466844a170546a2b6ac4013171a0217ba117cbd47e30bf15d2cd9e69f0097d794ea2ce0b6f45109f4febfc9e6526bfe2ec8d0001b54d8ed719edb80b54313b80f0dc0f37f6e698d50ee717c122a67630f44fb30a9614cc39ca264782f57a0d0c6ce181ab8d80c69dbc7ae26fb226eab16848ba28227ca866d6eb2e0f7648faa42c5044121596e6c228aeff8945f9a5ca5aa157be80b03e31972faf829ae6aa8fc3d460fa9515197347b3fb1278f80f8966a82ee182b6b2ce38aa7185040aa37fe8be915f489348be4de844e78410a29c25af4414588052a773f4c949b59edc92c67193ac369aba3805f39d069b17856eee8c83137d931db178c491465ab927199b469e1398b5ff13c39b71c9e3d064952730608707e7f2930b7b9c7b8599b12a4008d995080f000a5fecf497463ef70f322407c6fdddf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f02e507664820d17f13b83db77fd31b1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
