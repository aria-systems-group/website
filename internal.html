<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f91dd851a95778984ccfa79eac9ab6e515668f65ae35306ec84524a6a05e416032831d783961cfd2855dd750dd156311ab8ed2d3248f5e5809646d033c4dcc933100b20812071913730ab0faa75613e88e5c5fd8ec6ca933f4cfa54166f8878eeb70692e173ecd25ab8b18751f06302cf91a1fe53ed745962e765d15063b11935c8684231bcebcf7524b4bf21cb0a51aafe078917a27de9f05022ceb9783687837e1c7980dc4120aae53e7361a96ee0bff573df50572ab20818e5296ed03e6c126398714d4e6c66510fa7e52a4fbadd8badfe65a9c8871c1be9e11d7488febe9a45e377871c8ebc849c4e4ff80019bf730c9b49f1046f473642eace3d953ba280d96556a33d093983936c74f6af000e7e93dbaf0a79e83483be2e1bda4cfe9815322f2cb715bec655f064ed4ef044ec166c98267ffb9a9b459b7200f031b06c121f6b952ea5c6d599ac71811bb1ead6bb7cc964127d4dbae9cba9f5fd4180c477c5c5a59901bbd1b60b4f3c81d6fed7d87949f39e570d9aac5f91f9b6391b8bc44f11b6194e22e8ad4c06365038662a531ae1d319b26bade055abc8d4e61dce780bacbe970cb7574d37bb7e9c2a9228e2c728aa98d261c0dfa88fa7276f37d973963716f15df39708ab153c99c8d5c050f80b230f098a0d60604b2f930122aeb24f4921df7b6639213993d772832f7c6d03b0399a0d4473188e433a868caa1b8c956a7e78398144239bd47bbcb43804773503c461a28c08cd734fc74faf45d98cc463c436179c450352ac5a6986f8e4a9910d5c451e91cdbbf911c3b0d05d556446af6962322d6cf0da8ebc7569dd1a40199ed11252ec6e11d3e4f355fda29c8305f141699cc3d0cb7eef119fb108e8db25c9649f437a53cbfaf82aeb3fece7619c42852b394a148c25f07333c6e2fbcb5cb88bdbb1c7b2679cd3840a9a5f7aea48b12059aa5b0022a5bc3ff734a339775a6ebe355b41d8e0f00c6faaa84b19f4770be9230558ce9f868c14c521590c4ea4f311f3b5bd2503e8320083d908dcfc502f65a1bd23f9522552d5863430ad47f8113aea9cf4ff55862839fbe63a354666bd2c766cad0f948f65fef5dcef37a10523c2b0ae1aa381cc7016b07de09bbd80362b45f06ec740a2b11549ea471e1a9026e41636ac58cde54ef08582cee39fa39c88ef33b15f7cd7172097389c1851c93ef4bb03e6a56cafd3e26a16468ff75ca589b4039cafc4f7f1d08ce3495b6e6f8a9e40652c0437e1f3ea45bfc105454847be401bdcd9a7ebf582fca2e6ea6c8e53d05334c3f25012d18a013ace4cc355dae6c1e192fd3bbcd13aaaf5968e9da876ba3c45622ea337877208c676e9976f00e856caa1bfa00d969c30324b95a1589b09ecd2f1db4b394ea0616d0d54c5dff05c7512150a1d7744e8e334c1b5d5e64d5294a3947b5b5acf95eee3e29d59a963e7d1bcbb9b8715fd4be185a72ed18a16ffa3ef2cdca1ff1ed6d835c477dfc30249994325cdb624d1e383eb6712f70a1c3b75a94c8216f2b2049f0317282012197aed161e4e516c8f6cda85d3a559cc89d286f7bf9e615d662a30c813da67d6a416d9a5d599dc0bdd00002a1e632e3572e69f940ac4b2d73366588c492941fec589c2bb5ddb660208d63ba539c6fa264fa59a429c9cb3b9ce76457cfc7beb7e16c7c2f1bb69b7d11efe418543389f04aabe9618b39e09130b1b933c44a36a1db603c9b609ebcb3ba26e465a2c15ed566f957d425f5f43a8993df3088c61a59be33d4a5d1f9b8bc87b5aa524df0daf2ba4399b796a0d61245a3498f3cf833739b3b88a7e0f243bb79d62c8e006ce9f3cfe5e9bbf2ad08f72977930968ae54914a47d543bc7715cf49b2370bea86129bd9d6d14b0ef3fe1e08771f7a9f43ac4c9c06af6f9f15e04b0f9238e520cb123402e1133dd81bf8997e17286c3345e9d9aff3c1175058450a96a2fe388e753184946fe5e443c1282c77f50e1ec7bd27ffa0e4a4410d097104ae5efd3511f8d266b6e7dc65dbbb15e7a844b7393b055f58fb6a799f5baa0fe3b861d2cf427446f470df8f20d25e0631ffa2473736cb3e5d8359f1ba3eb25e3933e5eae0c534a46803b51a6d0c8997055e27cd8def4c93e557ddd8041ca28fdf0e55b74258c7c70fde4754bec6fe1359f97d85d5058970425b06584901fbeb4a00f156a9d0186d4a13319ee6cd1dbf6a583fa186a68ef99024c0dadf03fb3cd59d3ede41fd033b05d54c58c2fc9a4e91d1bc8b5e40dfe39e61210307310e2cd3abcc24f5f3fa4a8ccedaf39a9bdf71520e035782f0836a5891d6f5c5fc829e95df2d9f6ccfa24db7eaa19f5966865e73344ed25594819871aa0d4a8a03ae3e081296dd8af9702d00da791ae2dc8af3fa1930ded21e346dfa35f76a3eabe73f4fddfd59543c124295baf07fada0fda08d8dd56a8f11b50ff07815a3c6cb482508c10c6bfaa4ad332801a79c28269ea5b132f86203d46c60562613ff3c4bea7e30fe2975c621ea60dfdab762efa60675c01705d0f931e55add4ee6662604d4f296cf94a4d1cf38c82046dc5112cb06140d5b2b56160526a375603c30e5f961e0645e9ccaeff34772620e405d5aa9498ec18425f1e03f8e28fa3b0952a6552727f0321dd8abdf3cf4c1ba6d3ea9db97abba3afeece440883874fdf3be586b6c114b78cf453a33404dc1f9e68141cba8f28dadd597744439877e17e8afcf410d8a18ac88c533b6fb0f6b753f1cc050e3e637c8913402248d2eea49b465bd7a05154a0d765ae5f169c55d6d86a42f29bdcf55cedd7f12cadbfad8e52ce9d270a1190b6dc0d114ebc5ab9867695646fb4ecbc3e739d9a2fc85cd8e263962c4059ebf4063c451352c7458fa7ecbadc3d1f8af29cd00068a575a3483ae9677c300f84309a155ddf3f51cd5f7a0a79f4bc736831b54cf5980ef5768f48b4c72d3b8ae7865462f96d971a02ad51aa622129f9e6e091f8f629000c54498e0a65fe7aea903bbb5f960df5d289eb1b7f2199ff18a3dad91649dada54909f97f215b2adcae8c3e07a7a38e699f83b77ad341ba067098c34b0a63f3b220ada79bf9c8b546aa29a575a3ee7d2dcb361d8c34a8c208ac719d3fe3ba9221d4835c7b02afc32aaa42a60209ff0385722e50275f683089045d6aa6e4e3c6d02f73db650d96a6fa1ad2517b62659c47dd41bc325e34f11fffdf3cc807ed1ab5bef7309982017c0f019eafc2833ddb03fc6bdfcfea3d93728d31a3d9edba67ef4435075912d055cfd415ffa4dfdbce37d1ae2273df06e321b67778bd1a6b9450089f1bcd9d7e3f0403fa554d47cb1a53accab9d0afbe909d1d1a221a6ab93d8883cdde8c4441c4aa9ea74ae11cd8a20ac4291beb7031fd78b37645ca602c71bf61951d08e1e706ddafa8f9962cbb30e6c51a4ad69b652fef6be62089966b995801c5a6acb716a456cfacb49e466a688ce983699aaa64b2a7a7ba56efcd05ae09ac093eb764a537b54b02a126f4aab068d2bfc1a4c59cac7661c75b9817d243117dc32c1f2699e18490dc6b00a59caad9d8232f69446b5479a445c62ce9ca8aa1e4e7009d04fab394f1e5c916af851d0bac238a67ddfd64999bd32ffd7c146cea895fcde13a52ded9bfaca4623f09dc76ae01aba48210610dbbc494e7272078479ee80ab3d1a21e51f60bf128319f08800a3ed9fa307f939c8e6f933a3e4febf4dfff28731aa0aa7f9cf7119c76672971bb2e749a5b46ffddd83b0b22091e54e0dc15c0edb0f4fe43d2a8d84a55f9bc49904e2e8a1b8a2e800e49ee3ed467a99864d86ab529f813a8709d869308a55ec88756fd48a9c35a3fb1a85b43f8cca7c8e8f751b1fd7ac394b11247461707356d744bd30789c5ca0f16d801efeae6b4a7dec1efc16ebc4827dd31450245addb2857b61c32f773d35a0240f50b08593e0b3da771e7093a7835143917929ee65ea1593f3dad714059fff1c98232645b2e1fd1681f91603c8cc4a7a4cbd176dfe49b1be5236d051e2295e8ec4e4a569b5cb307f472f5e8d256f21c3eeb0d13c445be847681df3cbd36cd9b4f3e2d31231053dc06379df2627c65398dd7ca0aa3fd6ae2b97d81be57225395c88d269a4fb2b06e9318a0ed56562aad5aca58c0e26056db0298b27d86cf15994337f9e1b9eff36a74ee9c94e566468c2ac7523690008fc48831601355732d76fc42f8adf6225965612ff9dee1b054acc7a8bf2d9cc176ef61f7952db620535cc63f235e8729f18c3dd75d38a096d9f29568eb44b78d802c6d1898d6da0dc647547f56fcbc3c394d76ff43bc04b3d727809e435f29c8ca6a457e9d018fe58f240bc1b755b032d6a4f5234b4e4b437b20e895aa3beded9f7f7416581c560075cbe52012f5976723e5704af8e3c16cf45a7551994c7166251fd48ae2ba4bfd5c63e9e0d32f3d9c0ae690e2d9e03c37b560e31f843ae7b92340fb3acedac501b99fdfd8c4067877c9939b35cac8f315fe70f518e0acf50aa6f756469976c7af1807d2a59a08a840ce8caa8d9f1950ab1bf2db5c42b39241b439cc337f1b9169ec9dc0e36943b373665f179a6220b2c0c3bb3534583ea8dbb8c602a756dc78884698997aa439a6f985d84cea1699c86fea03046e4fbb7b723befc34257a44c92d0012d2311ad7fc10b18750cb39e4de5882cd07a4be500db8e742b3e2b671a6432898a1c91f63b6f6b3a8af319a2536554ec639b52ee5bef9c0ed0d8f61468e641c723608ff697c4c91a0b7e6113dcbd75e5b6d5dbe19c4ab1108d41f4c02d5ce8357182c4ffa75f7aa0e3dd8099f77bdc38bb90bd94b150c2f9cb4fb7386d6305b08e223e7011b2826c60de569dd34928425d6b60a55ba75d32aa27235a16245c3dbbe3928c2e8d2603e93cb55694d1eaa00a604c002cbedbde95b50b1b9b68b7427f355ffd4aa1ed67560696a2bbe57d5ea9d7170234ace97c7e63cbe9a26b7fbcd282ff485a164d2f982d65cead698e1bf52fd0abd1803a0238f208509482e440310e7f47941866186111c2e230e2beedf2abfd41ce509ea2127e9058298afb10782f73ad53dedbd518c616eb45b5594855f61f867c264b5708f126bad463b0304009a218001212c31d8d9d174a8ccd0d5d985ddcb8b7ab1e7dbf0ae00334bdb123e05f585ab77be07c4967b48f615c9077387f878540e9cbc87de3e04c34bf74050ef81514acd46d43d4ce9b4ba5dbc876608f75d380823112face46a071593e81e0d11c9e9c4bd1738dee73ad346c49d996e7550dd6adb18cbc88079a63538f87c0f48dabb6e19dbba8934d0277919e760b349e4d29a62872a70fe24c27309fadac351efae56efba40c7262cb384c8f763806fa6aa8d170942750e52c3ea263e6df0f5fdc11fd7f5100d8c0edd6b126fa60975ce270a228b5b2de9ab8b8111acdff25095f758e1eec79c35baa858b261ce9aba3e8a020b81b4443dfbfeaf198635cb71ad66e8aae6b49d20085bef66fe416cf389d8b5ffe7d517d1216d43dadba07553eaea56c88f93f703ac5511c63c9b95effcbbbac1ef22dab5830ea36248e3def135956e7033bb8de6d154e7023bc76bba777847ed1f4fbd1c8bbaa9608e9502da75bdddfd602ba5040e54991bd53fee49d01473cf6e32f7e678af2cf4fba4f164d2f549e6c48bb7d41b98f73f7d281bcffd04cc902e8d78c30b25aa15190df289573d0eb7e54df4ed41dedcf353fe875e087796b0f703ec91e96ba751d3e0341b3f13a8ca38706489353271ec384cf2651a394653e55eceddda8789cab5f6bd86e47836af83254a92228ae29741522225d9af534dc91bae8fcb1f4ae5f22e84f25080479f98edc2f55aaed8d8d43faadb7c9c8a5926d12710cb4f26eecfdd8e71051b9d18f703c251892910e27dfd81252ce97532ddfa85b34664a2a46f9dfe798a6ec048778132f48ebfc6192ddcb384f9377db4be7c91facd8ff2c07f52fb35686b8c2432c327a4290965426a51410bd95fe3d12028da4356cb19a7a4d22b99f4e55ff33e29fea5eac8af10be03a2c2062958c1bd742dfb158e0b1fa022de29c47ce44dc27198c3ba36816defc4b34770acbf8681b035d5f03a937e73f78fe2808bcee9caf9fdacc50aa6232d91240e3ea37397d451530f6b19bbafd317cf2e70332a364cade1c63a5b81c8c2a03a0202d5f77864e0455dae07041f7203c58090ea6bd8c02d060efb3f7181577e82f0bd851f1f5146cccbb00a21e8c275475984fd4b96c5e21cce3c9e4128ec1abc0be4a4aeea166dc016b4168ace6fbc719bba188645d8d9f30ff231bc61891adc061835d13c3b18eee570f1016e3bf4e08484b32f044143a5ab44eee8194b13a8b44e1103e95fd6bcece171ba1300d63f0fb8a46ed3c0f2606a92a30578d928e2fb9f3dec3113a9d9107d4512dbf28b47bfaf82f9ac56681cab02b4c20c06b63ad03a7b18fb289794d117efaf33e390759b2917c23ca98944c9faaea96ba0f80cac34b7f877152b06336a393204b1a0c9b62594c2ff620e7118220bd5a375c27522accb77af5c1ca69f4c4fccf410a2efa17d35948fb6b11df14f25db88fe160633668a5fc38b6d4a3c158b8cba5078de6b81b66e50525222cfb9eed9262120f111f76492123ca68ef576b0139f23662a79f3ada9a6f9b99cdd9125aac194ced0e717ea95646d4e163c9b94cefc17b4caa2edfd193298a7c0540c8a9b21a70a56839c8a91d0f304a1e458fc7294fb94c1d2fe1b025bdf5532c967b54a681875a694edb74255912881645c6683676dec2f8c9bd3cf9b438831718cda2752f4f2e1e094de9ba44a28be71025c1b19dc463d9396dd153cf164ece2ae864e281d50ce759ceaa0abaeb9246fe32dfb57d929f8cde9a85f02ae890acf95feadd24a382ffec54c86e3af43966b97146f102a7b19704ad288f4bcfc320815b2996c579b571cb2c481fbb46f0a4e50a134276fc8e2745016cd81501f7804f78cff5a1f50ebc737f699251cb93879a1371ed944b45449e2bd670e8bbeb7817e4065288e68c39b52601520837224ee7b6b555be959e3a44e067ec715edc8b43ceb59ee8c85fec81fa78f6fc33b653f766f3e6d0e4549cdbcb7711d1dd379585c3404c67d4ab88d506f34c6d56039c8083c5992b4396a121ad55230644f6734ceff5e0c05736708d6514ebfba366c1fd43110770761adaabd19ab0e3733f117f37c8dc442efb1e7114da8f154e7c2abb84d2435c28bac83d87f332ceba371dc3e10175e2fe69e251ae4e341f281089add1b2756668839ffdf1eb0861fe6fadd6e914c0eeeecc525cbcdefa8374d5d7dbfe47a31997b3bd082406fd40d2609fec3f412d2f760f08873b79931420ad8d661cb39dd4b2297d5f075067c6db0eb7ab0ff996f832cb7e16aa168989b60eac9a3cf91efdfcbcc3f6ae9c0543306eb829fc2f8469e6833ace2355c5b69e87288618d4ef9b8a7a87fa275c343813386538238a6f5752f9ac6813595ed220dfe045045ebf58407c063ff7cd20ead45756be1d32ebb705c836c459c70e76d27d6e2bf0dc3ec2c8e5cf80c52f5d919b29268862eda01ebb7ceb4bca4e1b51bcd32726da890e5b0e5078cf402402788d439274e088df047fff55a92cb59940f39bb70e656e5109145ef26d7479fb5000a31e4e6dc713a7c4209d20589976cfb1477504891eebe9be55c1044ec2cee4497e2817ac36b2b599b4fc784380562005f3bb80777caf488a7934084f5293c1634c6f2e5dec5780ccf286f44159ba2e77fb54d750bbb04f0b55363f175599fecc9571f086c7c976e214fe13bde681e0e1c1e60d562824e00aac540eccf7c53402813fac3978be060f300ac31af4a6b08cdfa322446014de74e349f87cf6cd901cfb119afb3f477191bcb1ef3b132e786190f89f887e4566d91aee6be8d43c8222c48f528635676a55545688d7e52f15dc51cc512cc6a1b5773c8a374e8dffa69dff043e6cf8e3141081fd3f4a3be36f722dd6257f4c27dac4ffb64a9f2cdce505c5561cfce4f957159c9518dd688e1b10f11af908ae72fd1131b24de3ebdc21183e3b88ac33c7f2dc9025d9343823109a1dc0bdda85eac9b56e0d70f65b8ac7e27140a5a89917b5b6cadd04bc3c2ac61e1a10aaf0510e18e2c4f233891f5273daad39ff91a1e3f551b45a2547080077cdb2e5fe8cb0fa040571d74b2115adaab37853480735066ea0568da2ed92c4b928a14d391510d6617d1eb4f3e23e6fac27dd892d4f236032db973af2f231ac93183f1c25e6be3e7c3543c9d5f4134e2fd7db4561191a1329b0a3cc122e441c4e254793e0afd38c494e52fced3cbbc012b96497c89fb6e45f17f88fca2265a5e1aacbb4f8468fc8fcf27c6e0a8843d121d3d6087e5b8f749a8b7d23f9bd4e2a1cc852cd6b19c7df3d0e8246026cc901e557040cd3f012f43bce29e2c9f35710e050354a1b0e6af886c6d36a9ae1b14c510d197f914007831ad5d89de3f3a9b39e1e229b67e4886d6941ed2e72290fcb0387339ef32b80b54f12b2452a397b8f6890fdb3d4090266e9df6ce8c75ef5553bb310aeacd3c07331c975fec15f0da2704099c5d52ff84c0234b969c9cda78d6857cfeb5874401d2ff3f61d6ec1dd43b8da872b4156915c86bde27d2ac430aaa16e2c2e2ec7f23467315d6704455229abb3b9f179b008736c13f01cc0566b2bc9f7dbe5f1da0cfcf348dd87810124dcbf1395e647df7b0128523d150c3094fb22116579f281f119eb5dedc95f0f6a0c7ca377d0ceb00a871349890e10555f4f2ab846757dfcc631d9c68497ef3cfebc266dbe002aeb076f1c40ebb3b70a20098bbc4a6261d4a793b80685e90e51d6ddb1e7a209d099c4b05307156ada2c6dcddd0adc3247af86dff48280a703102d6fd7cb318f51d6d91aca21b64be54d20dcee90baf90e35731a82f5076c31072691be770954b0a48ea8a64d53d59f7df1fb0dd13c207c72fc5b8cea8987bdb199846a52c6b589270ba98b6e29750be855a1e287d3576ab1c7d816d14980d4e7301ccf0ab7d337aa07fbfc5073712491541dd1ed435815667c046130b2dddedda8c3bd64e3d4e8de9bcf2a8a0c6a6a98ddb1ed32507495dba6d834540e9543677e8a69d78619c1bd8fcb738554fb779c679877d3c74dac9cd50b437ef6d7af7a7a7dd0d4c7dc878baf7f259ca9fdddad8420c1fa31db757b825f3d96e480861cdde4ad12694a84c98c1ff62dc88a39e13dc310d30b782f74be752dfd74a618cace6630d7c9d13574be08a932a43548b5708e84997381bbbbc68396a00a82d10aa2754b2d6c3fadb7d7948875ae44f7ade8a443f0964dcf63db2a7c1a89a2414d91f7509899aab6b26c732c94fc7b8515f84d73cee1522e463243733cc237c2a49eb79b715398327e993ec2331f067469ccbfb8e6bc6a91db33fa2758f8f86acceef8dce15d0d3c9f415a5d9e178d88ee63a95942f472fdd74fee7ac18f5ce23774a6063e1168292d3b80e9e772662b3d857579a0b1e232d7f27a24eff325fb9c65f95cff0932d634d975696b4cf1dc3e21c460cc48460006d6462a1165cbfbf6f68377039c111ca4c92af2cb060af890df5d8121f88a2f1ca46ed4c8d37d6875a47f3ff276e45c1ca26a8c1518864d3ba95c12c51628f0e5c9e0d7b5c99f478a8cf7b313f16fba7982be0256b023b3e68c52a828294cc7256798bb8ea41c8b8c0349e206d5a736686a9f66d2d2eb342d498806cd21e1390674433d2149475ca819dd029afc71aa6df445b07beb99b05c3936856752ccdad166ec9efce31533f152bc1a68e69ef9ce7e1292b8f16fe2174e3c1ec803297cb855df3b2ab11f2f0e7192c76c1baaa8ddebfade8f673e19d1832292aa4c4e5be881d7b540b733f57d68e503547d22782ce4d91f7019d67f3ef2ed77d911989cb92a90f982a8396f1582eb4f0b53b2da9f67559194609d505719171011464f2588d8dde26ba938de93c97575f1eb3bf1bf2cdfbfa689641198fd86695710412a3bc5e589f1c6a6f2b24bbc63d7e804f20a6f5c19e82af6df2c755e25f8a4534acd81400acddd4d66d5687cf749f9f9c90ab2a55e82300452e2302b7dcab50724d9786891b4ec416371beae2c94c3f07bb4f5ed61edcc855ff569e7f0707aa12cf27371b00a85965da70f036319346e9198e6d02b9f56d5c67e05621fe61f7c6bdbde654038223543a867593dfd72a9939b334a95c8e94fcde5d6c0029e3ab7ce806d919be343744b0141dbd49880695a25d1621d9398f746233928b0669ff3890bb8426f881991e303868fcc0a3d3f858becc4bc41a9c7eae8e6f7e0819008d1fb94631479baf98b8af1ad0cc5a2a8fd7101a6b8a84b07aff05ecf625e0de55206957539956da5b63df45570def2604ac936e3a37c8c9cadd04b4b5319862f1178a7cb49d463e5b44ca4bbd973760053a0072a3b79b437651196208c35fc46feccea425d119fde94592397ec478f37b2a5e145f849339c8004b9ae3bd2cf42675a14bc81e85037a0094553cf549633f1f0e7761fe2982742d04a5cb4c567944cdf2b9e74d8b8a321de3fb03dcb5d156edd636d20a2a72a430c59921e75fe67ca7fdffabff6dbb790d68e076065c484eb779438a006d502398aec5eb9e6d1f95b8ceebb99a255d188e3d2972974645cf470cafb510063a2d7aa87ed2a088c4708b440723b1820eecd4ff043b698e0b85743dc70bb75389594e6900d307427182bb7ab72fc47aca29d7e7d9e5471140b8a052f59a9e1aa79e06cdaedefae2bf2a5d33d7aa2e27621829c4b2ddec89642652da4fdf8fb25087afdf750e9eed3c9c4f07bd5c5ad54687cdab08fabe5e8b588dc5b46ddb13edc7a2436982a7eace5b847a04ac0984ac08b3dad77f7f0d40bf8c7cdc15e60d86ffb007622b265987ddea4944c16880fb13fc58e0f79b44b2e578b12ddd6c48ad7cc92f8e974097cfb5e45838ab2e90f6d817e7faa7513a4e3a810c9c2ca51cb2538a10b1a6e167f50e347d0ad9f7dae77ef26f0b67655562cd57618b181cc79819e52b813b561a650388dcaa750a122f9038f453c4788f392c7340e9f66218727c1ff0bc4373fdcec5251a354d3f5b574198db4e9d76124ea54ab6e348c048f38159ed01ed2f011a9b4f3868e927fbf5699764680802350c3d0cda337ae4f5a31d106f86e2a88423aef346a85a49dca997125ecd577af6ffbb9919d72021e438275b8b88b029c265431767bd537806cc1cce09aeada6602da0ceae44ea261082fbc1e08fddce510ec5acb073fe72f8447513ad52665b2e7bff3f2cd109a8cc0bf99fd27a0cd3183844ebe9e4365c037bcafec6d992aee3b26ba77fa82c1916169ef0657fe1aff4f34fb91a9555a51d6e897d936465dd79a8db6c49a3ffa72a888692da34a2c75318c4d5ef91287036f86b072088245df98230f031fcaef1105dc2e69d9430c7b978178550b180d13cdb940e56460bab5484d6ce7f9f1c2979f2e96da271b792e834a2d07a5485bb322d6787b9c9a9c0b75e22c5810ee37add08451a42a45a6ed3685fa47a786f571a6f7bf4776873bad3a00b2722585d29975cc5509dd9350d78b10e755cfd4ce7d046967b57873cfe053747e449c516d53ef2a3d8f2232cd2703c8aac25dffd222922f93f178083224aa0007a252103dd99772ccfa1598086c33cae187e08383e94ce6bf1a9e5a4d8ec4819c5f6f2a43216d3a7b27e746a369f4313cac8e2dae0b538c439801870a06e355fb0d55139d3b47b823a1ce7ccbb7083b03f441a588b601aeb7acb347d1b505a24add8e9942415865a3899d0b6b2f353ff9fbc496eb8e3746a3d3f38acb00f6a15628580e7de3e8e947aba8e4f5b3bbb1fe575ec87cbc51305ebc0fe5c04cdc876a8c6c1bca0c26b44e066553cea9f72ac83ab259371bb9c6edfcd30e08fa2eef537975254f9a6e64b503a3f451b5485e95ddbdf88ee668b5c6d6ece29b9b80860e15f01fbd42e54a354a538da5642eaa39a525df04e2b9e1c2d091315768b92715c5aa772556003609feb91fa0de0296cf256620ba33b6ae9fd046de6b33ae7ace269108cfc887f1578db80170ceef64dac8c297033d2d6d6ff45a2a2919ca8bcdf0844f8aa47ce5a1ddc202a5eba0ad9cb1ff4d84649c110c4bbaa4300181eab3cc35170a42ca38a50a7daac9b6b4dff1c4f92707053e9f3b0860ae5fd58757ef2f8abe7d936ae488f30bb8d15b68ac45ed68024de43b503556bc5af93532ce3ee66dba5a459780c1802fc85da965759504501ab02ae018c5f969e80f7dde9f7e849c41a6203b8fc3eeb4240c68faa0a013679319468f491cf490c0cd111aa25c205ea493b4204a74d01ad55c0d6dcbcd0d26d35bb2abf7a4b534daf6200e5ce7125e54d59c164611e95c35564194ba40f1def5d5641d25b4f05b34c333dc1de33a50ca999b4825386b1602b187193c4a005d4661e8c39ee012be30579ef678a051686e27ef67db2473c42dd9ef955a44a4d563733e6601c67e0b449e8b1d7593ae6da133e69da1596f303d3a62f67fda3720c254dc0391fe650814b15058383a4af2ddd607c60d3145151af3462e5644fc48af8d6605991258167211967b3cefb8c0f21b35ab248b71436790f87d9e7213457adfc2f538c086fb418fba0970fc33f2ed7147faf1f84d50b1b907aa781ceb8a11b51834d8398aefd55810db97a6c2eb8b2a9491bdc7b825326b971ecbc61183d4ee660a575c077562941864ef647e0dbeeee828d4030c35fa14e73066e2f9b8327f27db476bde419108ffc6898447fb339c9373d40643ac3ca7473493a9853f3d18ab3c7f5b99a92a765285d7ef3f63f2d0fadab4dfdd98d1cc6baefc7f3781246277932df09fd4388c7046aef133f9743a22967f51d848ded99e14687a49a698049add80f174927eea3e26351c505f86bfee4962deca7d83a2079ddceca1851b5aea894186cea7425cd421c1d8e928ee170a89ee6c938e88266063da85d2c02a2cfce8505dbc96f2b202f74fc4a1eff8351f0788e74606a8ae54fa95b464377a4909caebc4eb74cce35f2c345044e1716dcb3a533a4408752daffa5aa9ef25b5c9d22646d8d94bcc41a5d35473c019e7af6aa6186ed38c6eb776b66808ccb2a0c139a2f3976a828273e2ce3bdc606d5aa1e46e442615d89c4ee4f85ee2499ec860627e2410b278d5913db9905cde7b92409667cd2aa9f8e91193a746bc1468a2e28b1cc40188a2cae4cfd5c102012df1f6aff9b013491865554f09656f787e29cbf7a061f9c68ed3219845f2fa5c8374aee8f4b91545d6bdd1558673fa64585ad2e4a055f828042d3554270e1c17db36d47b20539ce65d4829f47d333fd65472c709874d40094cc702a64f63788706ff28bd22636d147c3d79a3d5746aeae519ec08d3f75ee262f996b2bbf41b57ee38982a840619f0309e36aea614c92e77f40c24a6ae65527ffe9c46ca1bb6f37e9b80c47470e95e797d3d751a29cdb2a168af24609143aa11cb3373e4ed799ea6c803d4391263f5e477e3e021977cffe876dfd8c3f63583dae5b904ec4c66615814bc75c9bf8d5e4729aac1513db099b4d29ced2120716706d05710952ab65ae357299c743386b89f96b459f0d91a5c71e2837115093974d6de084e02af3555b9576db42f8fe263030d1e4758111adafeb35062a85a93faae757ea1a382b5f57df479913ca06ed3cafa205321ea377e8a12a9f9ab0050a6437ff87c2567988075c97f3ad429789d06ccf7759e54de1fee8dd29b30da652e4163f441b5c7eeefc3952be1e2225dd53ddf234566b245e345182275cb706d24be79d8c1f6edafb5f45dff072c2949a0b39db6c4cb388f9ecc6dde202601b6fe4a9ba79ba894cb576c54b00963e5107cc7410704c20bdf1b70b91a4c0d7ce5f6309aec040180a43a582c8d9c2ffa1a05d408eab4a1d497c2391896e4e8a9f651d4b869c08c58bddea82a91c54e65a4ceb71f7bd7aba4f14b19f0b5b2c64d08468effa2669853e38eea41822f52c7c7ff2144196bfb82871db0ad62eebaef0d439f18aa51bf55e7c38085fd68975fe2396a9a5a65fb2bb146774dc2683b4a5f224ddea1982e125af4ec84131473153bb59354319e2bc395c3525f9a1cd2a51d4464678259d05a98571ba275d1205c9450a0e2f367cb98a7969281be6e8c9dcb89997b55547759827f509ffd0ebf70d4f3b971b5aff4bce3673a169f592bbd21cf6e21314069a2f50023a0995b70efa3712199a892d90db685b4daf12d64cf3ebc89ae69431a0fd0a652f42e266310d966f803a776d7d994dcb3431a0323b0a6bfe16d01fa9b07cc280b0b3bd4f996e97789f04dd922234283a3e91fdda7d73fe4d034110d6a65ed30df90d375a34f64fa57341e01e84576cd60780bb1c9d02b952c55be6c4d7c4a663639ff322ce0aa93b1a85f7c14707139cabca29c239ece3a9c7db0cea2d01984d6f4787c4669a75cd7936e5d8dc3450b91b9065373f892a181023df3568a693e8d2c1f2f94478ac69cb1527d2e297efb487e6f3bfeb59d7d4590be6c240e81887583bee061fdf5e6b333d99207c4e6a1862772c0491cd2f78ca4e7afc551d7cafc5b4fd686db8f1e1ff923816760a0906300c229ce303988953f5c2f0c3d504e670743d044cf460b6ac0e168227dc053a976851bfb78b3e07f01a9e28808f1715afc1c5c6cf0353e7c7cbaf5960fad211411bd5d75b5f0d60c97c6e21f9571b138617f0bbbd2575b980f56852aa507296af94214c279539442dad94a93b0cd23b0221d77ce86f9ff3f69237e30a0a93a0e6a7eb53ac1394b61c6a79722cfd940e1eaa237a112da4b0630af60ad7faa3a7dfe599f029d3d7fe1877cdefd6c75ac21dfed2aebb54710815807b02f2ae859cd3da7ac8826a7d9896619fb54e4bf629bdb76b1034c3d148708bf42dd4d007e32562695edec604840d78ce8164ab35d347e0929dda7db3b433eeb029fd5f3c030c57fbfb8734eaf3175bf4298110222af735d1c14389443340f2c1270b160f6db9754e94a37550f9062de11a6bc13e2184b1e027c009fdfe6931b47424fabe53a1162f6063cbb341c34a42ca06f50dea5663f5ce7c4d55f9f4bc18b58917122b5c63a347fc89eaf5d60873c78cef9f56c882a090ecd16edb2d15cd3b9447497d6aab3ef6a74c2827b5e09c0ec19a1442a37d3af2b4354a56d00a4dbe5849f3c8c062d360d67afbb01b1589a109f96e5a99fb9ee2d288fbca0020c1a76f39d6aeef3a54c589d152778cde278e0df57a80e37e56efd0cd9f604ef0eed0f41c636917cc38b6245aa2d893f79ce4ab645110b3ebe73a88cf16a01cc371877832f3d505cce1e5f6c70310d3fce81661982665bcd50f21bed4b4e2e7e7ec892098082e1e29f1119ec7f0eefb8a250548dac1468e1fc98b593fd3ed93421a23fc9d9a2b1d187d19caea457dfd7b6bff7fa21da1bb1bed53a8097ecacfee32b4d6679ada1164348ed6c310031f8c187de414cb3ccb3abe01cbe08f0ec70711018818ca4f860a81598404453e30d4c9670fdb8cb76ac73c22930830ea29bfc3eb9e03afdaf9af3fc7e625bead5ce95df7ecad853030b561a7e51f51db42f6aa04e3ccc03beea9d9ce3ce81f5cb473b6ae1f1f1a397e85bd920ac14d17019d993d00ac9567fd084f0955e9958c8d1d56e8c79ed0e91cb50bc577d065658b05b56f012a99c9ff0cad15e882ebd0ccc23a7b8fca9d69cae95b02e1f886b0e15128c9b1c3fcbe56946b8d03ad23f689421284d39e6c6de08de781ea55a66c8b1349a2614a5e4e91cf4d404580acff22d1d4100339bc00442778270eb32bd7d8342d0f7f0314267f38841c8da0e336c3e087ccc722375ad79efe11d28ccb53d1781053676f9c068c374184072a4010e36a458f6a96bbf0384f34ee14d34001b7f30e7fc3533ac0b539cf1bd3e23cca15b5c53bd3c2ea66c45ef8983c94f451f582334692b27a23f8536b0585a2ee4ebcf255383b3466b78fea8b2e2b8d39dcb63ad6146fdcc51e6c8f1f15685e3770c4c6599b9b3f25cf92dd68bdb2eb08116624139db3a36842dcaac4b8f17544279a44777e6de699386badf8736a58792b77dd710d5cbbfc40842aa5097bd6732431a2c89269174f2b05fa6363b7b5524ed8a4f3f57037339560cd3ab39ebac04f218bb71a6fecf7be5d61db1f1becbc2109bafa6f0563d561e794d1cd22d14efce5704197062f7f4bae27f6e3832e06b44c62443a89598ee83801050a2525f2774701962e15ea9bfa7599542a6b0d4d5e87556c0e96f91bb1a9d4a620bac2957b3c75cb12f6a8580c519cb4574479170eea722a6a6550ce72dfd50cf116ec3240ec4fce98ee4aa2c06f936d64afe7d53f346b11eb5b532ac4c684a6833dfa1fe2d5c8586e0a1325f905b349cbeb6be0cd8c8993379bf0304ba86a96334a1b857f61e7372b93a8fba3b87e16f62452cd9018fd565be31e2c740ce884374a276ed9491498dd9b184f38c3fa0a91e023b5c3f40f9e4cbfc37f5be6634043b6cdd0fbafb25f95d7eb3d893955521804f64dcdaa4e25c2bc7d7f028802d674df1ed8f3f3d96e8379dd4d1f9d0668261f6c9bd1b17e71680573e17e6371b917e9927fb461bbb8ee1d78cc115135110a286300739e2ad3c06e699dd331ad7244363b14178ba5d5e06657981eb3739a32fe1562e944d3de8c50ce2986441d61f9a11589286f85b8653d8adb653765d27f50905abf8f7d3f50fd06dc0159aa51ba143c063c4fd1c75f9cbff7db4c3f4c36b10d5d2acccffa7b426cbe9f3f87cc5f09817403f610341392884374c9e7b2b623bd194cc50615e7e3aeb341625953b72238ba68f63ffc886b38b0dbb187728cbc1940996b5bd169fa6f46d011741907862e950720f4a976ff1f2c3c3b83c85db8b845707a4209110e4efdf0bbe7a6e4f1b6bce0d000aa2d5244a67c26b503ce775fdf823bfe488b3e850c3d8cc6a1733ab425f7ad70e309cdb678f0e144c7d0e65c3ceb91317683555a9b4ea592811ac0470fedc53a035941fcb46863b8914352fbd9cf1de8f59df94cca1378bfcf5deed5bb940da438714de373c04c234bfc4c758eda6dacbce6fe3444e4cc726b72952c7a18c9bfc57c620bbc70976161c23d45dce9643934a5b9dee81e5cebaced0d387edbeb43b1216c1ba2f388c4c9f7914540e72c6bd56ad281229c4b3dc8f135fe086eb77d1d0496f6dd1bab2f03a604df6e9a91f943d87b21fb20909f9aceb9f898d2392fecd1664c60c2d7fb1691b8b1dc1cff63a46f69f29cc331be4dce92dd47b0ecb82181bfa13434e0781b39fbae1418ed176cad40a8b50c016f54912293d7cf62163a0182a131730a6f1e7a340cfc05fe17919b1a01dbc6e530be9bf8ba49a3ce69071ea8325fdd93a21d9f3c10978b90403ffe128c69f54852303c0d7573b24356a9ad78b50d54be2d62dde728b4fa3564bb509d60e15f7ef49f68ae3bb4a33f0b9e33f90d3ffcbc3ce0a282c8b5c7e07792a1036c4694b9a6b53f8385752028bbea3ee4fd354da42f2ff139bdb74fd6fa67e8029ba76dd2a1f574820939a2d1205ddb8bd548a91f6e34f8fe7882ddb47c6ffdff40fad28c988c521140b37c19a99ceaf194572793cd2d306c3f5b16d7ff004e277f1de970f9c1873faf446e959e15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4d34e5e3f5cd239c8e2e8baa942647c1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
