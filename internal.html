<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78c817012ac7a42399e3547bc212a47ac46a81d910409aa42935a3bdcc86c1e783f9e672926107235f6eff1c6f24d8486591e04dc9b8fab7f516f33a8dd2f4f0a482a6623b80ce8fea7b1b42134598a8f6899c0103eb0587f6fadc2e9fcb2a1039ce0890a91e5dfb953ba55fe5fb34be9d95470c42ff443febd65682c3c2a8b7ad215940c488667d9ff574266040c3ce28606d41fce172823c6b6bfa0b548ec2aa7c81f31a512e95da88cbc6e4e37b133415d892893158717b7b58529e194b4424e0777266b810502555170ec8581ae067f873efe2b5e34e6340352db419c209df743d0e9eb5f970f3bf60c3e8f748491bee6762469e0ed23af8dbd023a57c9943a25ac27369f85cf70ca45835f915599e3a9643eb94415756c506536576b5a24a121a7cf6f7f398c41ef7a0cc25c6f76bc8d4bf2dafe74770d95bd388496288d21d22de1d8c81c61bfe4b4ec0deef00df7d2e37e3c0285f40328c44b865a15e0587f00eb37b6bf75fccbe4e2bf2314740f898be7fb66b6e6f7b0c556c9c6d6c315b22a8a83b96340fc4db7ce3180c56e0574193adecea67f5c3478b15b151a01b3c622a0e93765261a3fea643b629934bc79585bde055ffe43cbc8e50ad65d6e49157b653e4acb7b295967d7f1bb9604ff1cabb76b3592335a05df50b8b7a97be0d3228928dae4dd9d2304eacf268beb44396914ea28e8c4f53e35349151c7ed5a3980c48b61b94158df490d628bcc5aa02e44cecd1b558e8d6798c3591bab8ab4855c19d3b60cb8134c617049d0e0128691071fbf3e26b7bf143c6a3eb0dca690a466783d46b5981119b349e27ccddca5cb99e249375544af3c9837835dbaa04c7b71a44b9bd08bdef3de2d47947ecd769ce472ace77b94bd8d3d9b6dbd8f5ea3d6958a0f57d770d0be70d7ceb64b07966f454050c445f7c97696512c82a4878302830b42f24e43cb50977c7ae2a45caf92bbfda138b824469547702b48b88adc693ef64ad092b332e8c031544bf6ee20fbacd91ecda6bf59b7219a87e6d64572d80af8fc44a2c76fa6f99b0c1882740ba937dd4300c04e9f1c577418be51274afbec0e18072a62f917c9e89cdf7aae0a7d05f7b4617c22f997fcc7753f4113cea99ee8e1760c11627de4dc43d4282b701561a157441836c0580f9e8143f081a13d9f58ca71457922f35c106c5894aa864eb967ccb971da816f0bbb03525c16644ff2e4bcddd5ccebf401ec40c29b4847211ebaba2ead4a4632574744c5409f083d4070104efb05b5d0010ec6542f38d19b2d7fae5d725cb164d22f06b40fc86834cd51afb1dbb189dd5894feaa97eed87a361d7ff733e1bda4471c4ae61db3e46ce0f463184cca2561264acf7785140f24b3c28f81593e9c1a6a39240fe71978d2a75a6bd4bf02c559848c1a83878659a85bd1d18c4e9cbe0adb6cabaacffe78d742dcebf39b829cdd0245683dfef6f5e9e4395627610f6ba96c2ac07b5b16f66553afa5b40580abff5952f4fadba2b9ecebff1f2c81e4b37d303d80108dcf9afae332505979b4241d74d57af40f88a959c54609aaf24c4847e77e0e44067887e35b061259622ff53dd74bbb4752e018b5f42cd1c2fcdd4476bf803405c50de676ce182eba7213a006cf8fb4d6a5401facbe5d0e7b43886f9bd5546a2cc6bb11a5a8ea9e6a987e7c42fec9ebf0eeb5057951e33f3fa5fb56f6f4358d0d3c7328583da64c4fbdb2b57c9a86479c3c3639b2282f237663a6fe83560fdac38f4fa1be24991b81a36a0f1afc9bbe14044f628762809203b3fa170256672f087853806a761dc0462fae9c8ebccbf25fbc5e1c9f944ef0e2066b86dba1e27d4db0a06717c9085b416356127cf5a79624eb9259d468b4c10e2505eeba9713de5f48e0a422e2578bb700d5d685a1456b1261438a4f087eb5ffaea7837e2b8f07b765c4f092eb08a282b80659f59769601a0520b918d89cb9f854a1dde2d5a38b28e1c325c075732e71f0b377804626e40ea1a726701998b9f9bf1af48810c480d437cd1cba2c6a1f8f0d8e07faeddb8ca0af3a80094e1de7d48b6889540e91f47142178d8f49df3d6ff332aeeea9cf402b0176cf70c98c70566238ada65fa96dea84161de2b2878df6300480d0e04648a3c3d779e900f9d94800a0cb9624c5e577f1dcef69938d8111eb62a72db04dd73c38f19a39639128d007b7aa281c34607f5679ff80971dfca510da32aed1dd2a772ba9ee728b82fb1657d9831ed3bdc74a8cac84def08bf714b98ea7d692e8cfe48a15728540ad9e23c98125f29603685c3986bc622bf4ef73578cfcbbcec061da25662a9594a5e5117c3ddf90bb7530db2e8b067763883049ec47894a2576720020cc236bdee55ac02699ba5b2f86ea6136ca101536001db50c10466afbf68e88383db08bb2ad34ee0b2bd5445a70206f2d9543ca7d39c8d81b6f74851213a7744a6516cacec44926af5262ca7a45b6714defec800967d645dcac3dfaba910a6839a92749d4f7ce88b94cc4e3a5fcf48e1aa9bf0a6faa6abdd63dc0a8acee8d1bc88049565ca8fc5261e78217690b884c81f2fb7a93d1e6b1bcefd2a5b67eb3ea52fc6b7bc1aec546efa1cd8570ce2b271860182a81fa3aa7d1ce98eca900850fe423b303c7b6f31b4bef8fa4015e43203b52ef2dd7b68046b9c33d416981079754484183cf71ad563202a96e169f747ccb8309bb51cf25d4f871739da17035652e5320992359d9f8b89aa25cfbd1caa5475ced4763a9bbc60ea63c43b4cf17b370012472afa5d122fb85d9f6a58f44a8d4eef66abe369206aad663c6213d40c53bb76e0301ba7d2279a00333de6f59b9231705fc4ad51774e20a6b9850f1b3055102fb76603812edd76e3c6f5d8cb5be70f3ff0d565f73d5159a8852207012c5d7a19def3b85d648450ef3e079a8325e5b5f3a40c30b671a470647f609b8d920990676d7997d25d1d25775e4a76d7a20781008feeea0490acf568a84eb28637f012a74bdfddb035cff1af7abddb2f8be59cbc1fcf8c39a814cdcbec57f25df64c5483bc819fe4e1f2bd68d1a7af7686453b541a12cc79ed66d746abfeeacd04b1e69ce149de1c5452bcf7ddab110a32ae44407c563b752602869de0bf9ecc4d3f4e7c3f22f0d3ba96e710855411910caaf0abe6aa97441cc5e0f4f11469eed747e6ef4cf625a56ebe98c9fc334631fdbb8338b8cab05d79e7b99d52519cb1426a5a9c7014387f6108994aaf073bec3c06256669190d13d4d6f054438e5fd0aa214f9ba5c55fb53efaf99a0907146e9832a74c0c20daf57535cdc6991f0f230b15e8587471b355110ace1cd0fdf06855b9053a6d281eceea9488b295cc3230a4aed7313f24075c0f28af5971ea572f66909cdb07958dce2d8255c2a363cec63a1a2d5a8c7225cbec320edb316f396a1f82a0e2986b73c11e2e71017b8d5964c978ff9e35e501605c03e038237a2b04c15cc8aaf1a24786053c00650d7126cb22c012963497bffc65c32d489f5b08e234f8dbfa0f71653098c1682fbd03044792b26da6ca1f01acd80b3630278f5a70bc04b7ecabd882f4716ce7a30fa6fc1169752a2d117f224f76df91e7b20f768bd30fe7756d071a8a51054b65341c53723155b3a758b7470665eb5cb47dcc3dda66699e81fb466e38a1b4da6cdc4a1462bc4565beb54202c0d2e47e2b518b0cb1de1c8e87f72ba0364fc4424e8471246d412111e10d816fc65377e76d716f95d3718c208cb110d4ebb08e9701de2b00658838f04cb6bf79029cc2b616533266f28c044dbdc3eca5c129e2c1d119d5d79d666475dc7e4a42a481acbaa3573d024d9e0fcc7a8716a9fc19a3ae326d102684e100b982cba7a5ad3750611cfcbfbc5bc79fa4eca20f5a2f5a20d8fb7beec4c59245bf756a8e0c0574a04084ae375715a62056b05e55f3fefc708d2e45e06fc76cd15d071f21613d68952edde0aadbe2bac272d9767878598c92cfeb24be2e14b35e08c9eb8c49f0054e5acbbfa8f8ceebe57b66556d5e765c558dde76bc4705cfaa72d509169560447b8766460af26f551d7957b16475557dc0e83462ea4808199cc656e0cb944cd0b056ad99d66901e2d2354d30a4f3637e79bd08ef9d75d0b4fb60ab4e1bd2e0cfc37cc04cad576f29b47ff1ce5d43e52a90bd70328f8a6d02af0503c4181244f31ad7228fa0e28164cd1f9f634caed39fcfb41e029dc5f82f8091d27be8ee4c49a30e40bbfec935a3deb12b3ea891c528510df5088af67b9d13e42cd33f852d338b8f728fb5c72f0d4d1e7c33150686c5a707ac31c0b40d1fb7b057b4174863b34ee9c0a0953ef496e5f38d85a495842c89183a6bfaeb9a3fd8038434fc7928177d80f38f8e5cc0cc335232da6798544acb7a1b2df9cd2d56cf97a9ee79d5ea06766e4108bb809b7bb01a1ed9f5753f558d9d4e9f1fba153eec7b66007ff5479130f2005227d7fd4a21674c1c04f930a5c5fc48db2d3e0e70891e914455486e467ed03e406f7b802f2a508e44f19ac8a61dca5abbc80fb7d63f5a7bb26699e6a80f3bb47e9606fbaa48765602bbadefe0f9494eeb6d8b5b33470db5097caed71a3d7f20c47199086ec2959b3bd433f45de111de38c873043ba872e26ab199e5f5229baa2e6a643d063034639411b52a46d5d54cc042714ee11301b260c759ebfa5232150a94eadc9da59f52d0e2cb00a3838fd3809059bff163f3bf4c6732eb36a39dca51fe663f1d279c4feb5566527b75f2a07f28ced03c27f82f4ff55d4225d66a9edeb38a5c0476dab56838e7189d6db7fd62928601464af56d44c77b339e5a167993f676da2e01a4fa60c6410cf6ca8739e3f2dbeb1ed68e81efaafb9a36460ad771974ea11991874e6930fb5071e7645858480f2a6ef8860c8689bf2efef05ec3d494ff76941eb81efa23d9938def617ee85ce53122d86324679a875de457e6410065c5fc706872f2da487697e814953d192c46e1a5127e39f5da251d94c6e86858a9aa86288cefda60dfe78d2edc0456ec25e2a5577a9f5b9f4a1b0fa5e4af6e758d8fbada7742fc9675c3d2eec737185a884fdc7a6013fd087315f35acb70ed832e630a9a0720c13ef9a59e08606f07a8d814db10660c1a9985e04719481cb2c17b7e50655ab6f17c04bfcd1bbe7d7aae1a8e537ac5791a32c35adedfceec89141e0682f852c03f633d84050ec5ce3df4764ac033ad34305efff1a906b3b603451046a52907e56391e0364fe3a9c6efd4c7e736898ad0f2ef53affd793fc0cfd162c994c8ec7003de78e478f5ad8f0509b4cf33ce50f091401bec86ba4a5255b9674a68c967f48f0f437e98675c3cb1dcbcbb1d9beeb4196bea68793b961ea7532263c7d01837a77edd4fa616d025af284fda3cdbd682c28ccb0953132706b85b58879534409b31bc54edaa889c6a3c2c5dc56eb7a18ecb341970e1b5423815cd1a5bb694b8d497ad6736fab8973b5ed6da4241b1a8537879927361f848e4b4ad68bb85c82ab7ab76f2e57acadddbce0f66416bcc6ce69897c98fb9a0e8553df37eb416f9c11fafd2f5b4bcdf00b843af992ebb2f223c5c2163eb696f1e6225f232bf3f288df8df790fa157a234d54c0d45dda8622be39caa68a9d5b05d587c794d2db168e193d89696e9ccddc229cc72ece00a71e20c61ee5bf1e95ef5892b96108871b9cb69a7fb659b0e7864c1a00640537d93a1c3fbb3e0300d7b5318a759f53a7a9ef4842e78448bd94d408fa78bab494588c645fbf367b587559007511a947bb51eb4f0972a2ef37c9e715af4fb52839c4d2971b518904446f1e291d4b597765785d5ce81ea593d3e56ad559be3f4bdb421c6506a896f862a46de9f7a0be2b90525ea8a287df7d69011afe832a53e225e05ddfdd0b1e7ddfb229ab09e735a4bea42b0a3ea1cc801e92a92590b83520fe135628d45b5e2f227801f4be01021b721691be75912ee7aaadd2ab54d9b9408190c37c7044f794721e46dc5a5a295d26782f2b8afcc215e6346c8d41b0b6fcc97c7f5f64bac066201186c61b14a282350ec9db621cf81608d1c07ba5675193d5b0549b1d4a6d5ca306e5a2a953b5ac95edef3f971ce50b151f7303f2d0b5798dc6bf790b5ebbf40961d6f3c4735e736a5f31e4bd9ab5ca96f8275482edfb525ca6f6ca7a450042020651ee6a43a7d5537295b7b63f3f146ef431a250de52a81fb12cb3c4641c62b1000e1e17aa8c9e037dd2d319e8db925ae8efddb3060f3db0f26441c7552ddec01d595a018973ba2b48c2366cca58dc3162f8833deba991708c7c02a7ceab83ebb5a6f5eb4804b73deb60369d85f37fe1594dece0dc125b861397a1c70a2146e47133337da802aa081cb4f1fcab4714bd214d7e3a74b6f213a473abc2c966fdaa174c15d57e464179feb4e80885aa31b16dcd94f379128ed47f240bfae37065260e6d73848bef1f4ebf19a8079e524d2f433b008c990aaa71c04cb444c824da529f6f8ee23e52023e01836b3281c18d48a2c4845d2a0e3028c58bb1f461b7776c8a3071efdd03beeb461219fd9818ca6ffd0c616e0a6dedb335f6e62e61b293d5aef69668db4f425a40f1fac77fdadfc871e492b2b8761bb35ed11e69a260800d0b676b2b392daf76f5e00738f58056dcd50a296c08aec1666d21cf9712902bd8402d5175e160d9422562c5a850d907a5e87a41199440c768c22aa93c7783a60aa5ef578d1bf49654a04f33503b1a227021b5b2243337ee3d683713c4703ab3f6c9c2e871ec05a35ec5e90c93a21062d924090e4d4f0130e7de5d953cd747cdb4fdda0fd3efbcde8ba85d936699a330d7227a1d5ff2cc632e5f5f1b703b3ab54327a65a3cf5726b7cec7ea8cedda92606515e64ec15f0706f0c078ba2749c841e662252fbd254ed1954a451595ebfa4e376932816a9da974679d9b83357d9813c14be259d39440b8cc9faf498f14ed7c4624a082bc2a32afdca3c994accbd5081a6356c0a0245fd80df9d3bbdaa770d42b29cb30bd9dade09400858885a1527d8fe4a2c7fe938fd1f57bd39e256bd3419730d4655679e784fb7f0135eabef8ef72dea54068be071da77b7a7d677e80f74329b4b74a5ffa9dc6da5039b72f5033f7c13e4d02e4608e279c480a6d5cbab83381f91f72319f2acfd9bbf57a6be7b810a2bf6b07f74381f596f5671bd849731149d230accafe290ae68d2bf4d375b1c8dc8379107d1dabea48c0862fad5c230d970a56f7d6e7758e5136523b73010ad0b23b5c179a12c89d4d67ea2bc137af58a8ad5aad1c9fdc5669182e219d4435a768855d3a1e9e43715f7ead14db28dd78e841ed926ec91e3a351dd9e109c1dc168b30441f0e613b8b4af2c76ed58730e4abcac17fdf743445f9c04f1462e35d5a29692b682eb38c45ee5338b8f9911a086be0fb75745f0740c22b56540c67e6728acf96db13f82fc579a0de9f84bb3ed41e23fc251b04c7c3c6e7f83c5a709127f25fef31644def4b70d5244fd7da5063babf4c5950a97768f559bec12ec92f55cbabb6a6103f3cdb2a6c3708292505d2c0e201dad26a2352abc69c0465a0cc8fe5cc3090d27e1cc273dccb7eb38cd37e04d6a5a8fef9248dd63420cc6be7f32e4b230d75a14f83480f863665cc4fba1073728f054110c14a72144a53dc1e0bb11129e81ca58a3e4ea4fa64452c54cf9248b376625edaf11289a66934fdf331e5f772c4bca4299e2774a4ad14873e8fdb8eb77a0591a4745274f813d761d7aa29757471f56ea93d5a0d703b6c0c785a115b8a08a95229b253c1cf34dfbbc7e63f5bb3633d0168870e1d84a9b35fc9d0b1c6927519222d6786688fbfdfa6735f63fb6e36653725c18f01a6b17699eb1acbcae2cba11e2298848eb5b66b72fb741651d1baf1dd94dd4f903d3c9c6fd6e280aac8b1ac6b6022cef4cc0cb8a30df1809118e0f23c1f69afdf68d46bea01819abb0e5178f1489f1bef9214d26f5557414a2c1c662f0775873cffcc017f04b40e2f9fe9667b15a7e4a2bf63edb9ed421af809fe6a61c387b130ba9c542733ab3b046afde809687b06f4283555552df514b789f2d82f34851cb6542fcb8e9bc11e6ee0eeb28d34fb2ba2641f9b5396e13c1b388e283e6a21c4d18394cc5727c4270a19cfd924776ceebd67b79f2e1e0a5b982d3ccda46234a1c9e6240cfb39c251ef375f1f7e1f670552ff6940bf98fe80b558ec4d8774c711c4263e0d5c04e795c98c9bf993c2afdb801e464dfdc14a412d96e57078b18267eed0bb9d8e1e3b7235fe70f4d98083694606a1ef5cfb8c99d0d883551d04e4b1d1572786f5403f27f4db48b845b5ad275a9881828d286d7e61c020bab81c6d14eca43d6677f1387af1e75975b29b6cfae2d2ac298073fa523cd6f911866d72d65858fef2bb72b43ac06ecd9aae69d04f9b96149ad2c059437d65a02d94fb78d31aaf042a272057cca65fe58a2d40805830da0b8544f1bd556cb25343301e5d38497a8b197698e62ab2085b890f5cf758a8ec4cc6d441701aa0c0915a5ed0f62d16e8248d3a567a649398acd037e2cecd5536375d89d282f7de682f96fc8ef3d34bc4248fafc473fd5a8808a6ab69b55b39061fdec59519c0b301fbc09061f611d1a9b72428822e3fec39719e3834babb9b962b15165a4968ae599cae162d6c73a4a5038fae55a37b87b304ba34ba00b441bc672ed124303d07be7021e267a75a026ad9e6ecbdb067f3a97723caa0dc952572e217d389cd142e1b76aa18860362c581d47f82c33ba477cb3f7f7f0e20227dcc31025f165f58e5a463e57a9d3620031cab57aefd9a81ca1552c1fe6269bc7b7aa7302492fbe087149a35c1150f3d52a9f222b1f0be3f2423234b4df9d76c8323b38e0a7ed63483895e2e001567fb882ca3fafefc1cfdeac626c5fab299767b7fcea2fd3dc2700848f8249446ecaf45766da31877a2cf27b09abd2cc03d3c2262812c6c7c1b34fae16cfe71e4f36fb7615e2ec68887fcb28517e69a4b03fdf70a0fa58af354cfbf2cea8536168a453c956607a8c541828743829f2bc2363fe6f833cc0af9dd78b812066bb3690a30dfc43809f47dd2a7736c63d40d3c50450fb750a04fd70fc5abec4cf4b12b99188baae5e65ff62ad592156154965b6856b38aeed60488acb305503971a98e1d58aace112be39881f503417612b7a49ffb9b772876ee402fc2b2ff352ad5c6d98c8755086dbec7a600e31311b24720f6968d9d0c0647cfcf7997cdc43cc5c6498bb5e5247fd65fd9cde70d83568e911a0a0875242f97481aeefde67d09071fcff336bdad82e046f238b1bcd1ba3bfea5067dae32d414ecff4cdf2854fd8803ef2388298061102582832acbcd9451774e6bbbc74438436b2ea92be3edc1c5c5e8f7cface75c00d4ff6a351ed574e6f84e456134d1420d49ecea9de5944bde6677586503b1a8ef16ae735cd390dd41cd7dcd704c2a71b0656f414bd0035895b2980d73157f546350cf5b599d8c8e1f93fb8c63a300a012869e4df70c01081edc9535ff2f78b9fc0683699d9e992f343165bf5b2a304e75e1e89aecba4d1977986018e3754fa27c58a5d63698dbde6bdf19d4ec0e054139b6d211d7e183b722be9a529d03391db34fb0acb349889eeb7623112808d32d6ad4aa7d57c0a52d91cc73baca626390a01b67784191d2fde5b30515d8e184ca001d9af7f47ac859409537ee5812059ee39c6cf2b5d4cb647508fd7ce8b378700d584d8880c342999034c496f560b766ec74f35931eb6a02b9107527de9d6a4b0eb97e1cc0e3fa2d5fdabd275f55f3a171c3ece8f8187d944d3bd3959c5ce4d4bce584b3213d032395094a7ef94a8aaa721be771df64296e33ec048bcf1fcb40b4df0ec9b7288fbfcb8001d164aff067449ceaa138d0e2eec4dd5e177136e651e2b353e0ed71c27fb31bd358fa36566a146012907bc7392aefe4a053852a4022d3fb0cfa7318624300e4dd05856d34791d83fc52348ba6cc6e60310f85611a234c55a68d1c2eabb8171d4b2cf277a835b5e788a12d999fbab1b46982c751923646d2c1cced30088e2d0318080d42cacc64c7127d23a230e28872710e95dfaee7fc25ae54eacac2f6b2580b76c350c0049cc98d0ec0ac41e6a6c2c1316e85a3bf0b0821f28c4d501817ea970476dba202af9adafc2f3510887cb5993fec48292ccf9529953aff59a044b7742e8db247906df784cd5e65350f20ac7fec743cb66a19ad3ffb2c2456152c4a41bd2903067f1127d42e51d43b507e22c593215efebef93523e82a5882af0e7624b12b4a00054a8c7573415a6e4943c9a82838c8b1a0a8ed9f3293a6e91646552363ad1bb5ebfa06a4f808dd59bae9bd78733ad44a0c3ec5f033c9f27b1986ab77c824a3ee824d663ef01f48246fe4e0b419b019e14ccf9337f3b46abc5d656972b6eea1a6253227f4af08b854e59d8b367a4cba4dda6ca038b9184819a77e98680b6b81b6267bd199c6393b4caa0d73d53cbe535332287c0ea9ff2cce03b9de5bdcff28a639adf652ebac78ae98c0ab22204feedaef71fa3ebb98a521761bc5d3d64e351d044b6241558a827f5cf0c1501cd4a42f35e9ce8bb1c7573fe029bacb3f25a10f5b2b154b9a97fe645c84cf8db76c297fba6bf7caade257ab7cbe05d3fc463e2b6d776b0fb5776a6ff27ccca5bb938470ad6013b545e61a8d547caa19c018c6eb9fece0b0c5d7abffb6635fe928bf93fdf532a4b59d2a7e69f8ff99670991a5fafba586a868793a317682d8b113e0faee4e0ca2e3c39b81f843a44e0fe00b86fae6aeb2d7f75b6ff7eb0a6caca5c03895183df4723b6e986ead89ecb88f2b195638896c0d6b7938ec01c08e8183846f365b0e2fe1655e0ea68f47f3bf4019b5b5fdb57f00780fad14227977b603ab3de8ae2036240140356f82604b0dab61aaae35822269a40a939ee89aee5f888b63baa2b86d6ccd53d850575c2342a2e8e53bde4725954300a9c203964f2c9191606177a1e76a899a0a6475b1c5274902facdc56f0f07a9f512236ae969091ce96b00464f6c7f1112338ff574f886454c857c89d8e114cf3fba996098516336735d52d041393b77a3cf6548ee54010e95ac1bf2e30d69a1c31ec8d1f3d6abbaaf51f607d7b23bec070008069858aa922e5f27819bf883a40a2be51681ebe85920efdf2f40384c26fe4bb5f28c29e599f92f6d25d937e7667b4d16090e28cfa429cfd986ccc766be1ffcd228020f6eac0d28fa9e818217f4287858be176c6fd30c41772208ec71656f8c97f484534a60247eff5ee2611c5c1808d608843158419dbc43c2ac698da5c08e554881488d58452971f63047829720023cbd5d9ceb9a18dcdf9c4f5e6efd515a0bc9988ad3d79953a6fa13661ddb3df1504e42b1fd432dfa2be944c1cf90a74f53de05028520e4cdd6a09fa2ca181bb554f90a2a0bd17e5ae23113f49fd6f28fb736bf54700677f09d87a84509d97326b7facd76a0a8cde30012c70a73b86d29f300b0a94f0bdff1d9743c97959750ff9f6331abbccf3fe10155a9e5293adf63151ea476b03db2268a25c07b26026642508b58595e0e2ae990de4f547512834692beab27478f6a94a9f4d95d8bf502dc6b608a6f8ca55aef0968b9606f62f63fd48bfc19a4683c6fd4c7122df2e3871043f266fe1f3f7372a78a38e6367711fd3db43eb5ac6eb697bd69a39df8d1f725269bc1c6bd0bcc89e51d0955e29dcd5b1cec53338431bb2e260337edab5a355ed257e29f67dc3caaa90813b626b07d757bf088a0912aa4069cc7d2b9c5ea545885598d3c45e033c9e43c291b7b222ca5c8964618ff57f8ae2f56461996abb0c25c54a57de49446c22b2b12cdbfe32c8958bf13c2cdd26a59ad5ec5757b7902012258d0c627c0e54d71b7b7000888211709bbf011bf56d5c4d31883b04251244944740ee8b5d58640ea541356d0da7da41c79692b8d1ea5644797a0db6e01d4cd795d8dcb9f8d11ba1780c2097fa6dbd0b37c43eed6d7e37a950313dc63ce1d3ff5f9da30e18d02b17f279c8f5bf8877660636c57abde9585230d23188273de2798eb16e0dd27e0d616fc40fa9c9eb139134f9791fcf89262df3971a47626689f40aa7cd8bf61914c952a7d8b148a16edfa1e2ae03873340e97b548e30560cf99ccb44b551df30490671d03159959a953f934fc1d07b644c63a800166dc9ba97e71675059c582a19e70976f2c975d19e11b5e2777ccada816ba032075bf6ff8dd43e3ee21eb0ec080a93860545a5bf764d1ebdbee878464b651646dde6f3cdcd7479b1c38339927827121d0cc942293ab7a44dacecbe67f02dba4199dcfc61f2d4f60d9abe4ba4f6e78aa9f127dcd59b136c94595da18c2b1c3043a33a28a1ca3da294d2551d8c294c298d8fa040aea38698f268ef8629e78b8223ff64a6aa14a4aae84f40a04c255d73c30377358eef471b0f1a0f08ba4c107a5a98a5b86d26de0d03abc3c9f099a1a65cdcc4b50b542efb8560acf3b0f3530d86e091bea7738603c8bb39cfe271b0348416a2269522ce7ec1bed2d1f5c9afba4e32aa5ae96d6f0d905f93c145eaea4324176196404349728c4b5cf871250f73cb94e4c2e8c28d7be3ef13471ee231701e49206a524d1d71df6e0cb38f1907ae396732143586cba7b05d2c0a5a60580623d41136e82a30ee5434a54cb50bc3139046e58f8dc52a171c133cf0cfb7058f7461c8f54c976215aaf13be190d94ba26ee9ebd5de7abdc954fc1bb236227918e3115053b51045e4fadce6078122579d5a0dd09fe8eccbf447a40a56d81b9a59d37ef99e9a6d797a1b7f7466dcc808b5ee92e7d4ea51523aa9d3914b23b5ee25432d36670296332e6ab0eca4f65aaadbedc388e9fb9be4b19d1b17fe1472a2ee5ebff487ea3e0df67b06d565202b6c31f8170e5d6441f7d0ecfe0e59554432b115a6467d376fd071f4460bc7d11baf040c0bce19d3010e399e739b5236cf1140286572371f75f6b83864f1146f2257b25d94c980cedea5663c76e5a7772d83740b625f7761de657f9d678749240ddcf18738f83a09a5a5501af9a37f45c1985d06b3eb64b7d9298e6308b43a1c53c1269627a53ce4d95cff1b5214fa18d156a5ccfcd67f870adc8c996a87ab534b42b2eac4c898ca33234e5368b01763fd750c51cacfe26c4a029d15251486914dd520b2ee3460f031943781b71e5eeab8f3ffca502d0d64437795772e18484d043a87596aed0624852676a38baa68e4e186e644ef17a99e8dbd6bec0e50393acef84226a848d7639a04de65ecc0689304ab9660340ce258f6ede2a2d43278a7325a824e1ad82953b8a37f3f250531485e16022cac0554ede74fa474f1dbd5240ebe2806098fa7ce40b330136839f1ea0d5f26fff8c08ff8946d972ae9a8bcf2d8a0b02a4dbb7a2cecf33df7f44809b6aad7c95cdcd4ddbba0f1bbed5923e83345c48a10cf7b93f6ce8d6bb74a414b3b516d7d43da1ca8a55b06b444c3df58a722a8f66dd150c74184766fa9fadaf29c8cd4a0108cfd31e5b17be65442fceb072c141a416689a6f720f9c06eca988fe788c06497b9bf17f112d0842b3cc2b210c1d55f78551f69f54a11e23283f2b86a31a6ac7fe7e74d1b851a68c5febf10c6c99bf171f0e23ef9436d2228942ee1fbbd19ec74f5e1ef6dce4d7bbd78676cbd6614c5f325dc024431615326eea50cfe398664d6103d96dc5b7aafc01f64149b80f7bae8cc6db8b4dd5ca78e88e764b521a4124d59d4484840d4cff9ee700c6bc9838bb818012e9e20460b95a4b2ea83af6b6f8da4798e89d12fc702585c6e02bb6149d824fe8ada32356ee1a7b7b8337a4747ce113b5f97c2112f3de77f8b2d92dd3c4341f397a1527e175db4f7ae0cf8d513ad4d043e7c15f2592824118d8213956e9c42bc7e2bb6977557d43ff8cb52dfa0fa1ada9a5bda68a7ae1584ea44ece31b67ecc02a80ab71f3a4f7f36f4345c953b680247bee3b410ed30de07ba14198fe313e4270ea731f5ce2cac2e4dee5e80fbcb03487ada72f01926fe665aa3725bd3de3c4e2cb46c50e0ec09cf48802ba874fc189fc14c1dd099e5cb7310b7eee75df1f0d9680767a1762c3836a846c36f528b5843faaaa804be91d8b7294781d84a2af05114450604f5a64dc4b501a3a91e1545a80efdac71cba1015aa34968bfc7927e58f7858d4e3640cbdbf35b0eb609748f39423ca105cc173bf83f4177fef30b595db3594a6bdbf0705e5797e20d9245361df409882f5b0d4e32121d7b2b3aaa0e8bb9883522b096f10e4820446a4e7afaa3361ae9b241a2eeb86068f6483a47d02036c7efcbf6bd91ef14ddc63df113e311e7ed0d08e5948c5fca944609f7312512c818f227f4d8ea91c73a27c20bb637c18429a11c13a3d229ecee04e0b562b5eab3fd08d1c934873e8899934ae1da8156d9a2755d5fa5fe3419f0dd66603a33c52451dddd1ca884f8118e1cd20a29d2c6fa9dd0017a266278bd975a1a7173ee6c912ffce9a59dd6099b9d00d1c514d4bdf13cab17cd2c234fe8e535543ff31ea777b7d37621a1888055f0b019a4b3d5afa471f7b17805ad4defe77badfa0ebba6bf94f019913a611d6a5d609900a713e6d8bcbf89c990fbd33609ab7a3c116c93a04e08ce422a081cceb677a43dd8eb33d939b8d4cdf41b3bb2c194be1e1d824325294a2973688e1f87b6c3a2831ee0c7d6bf9ad139ebabeabbb87df8041023858f431719d0a60ddcc9219667fbf39fc63284be9be5291ca0d19e34686e711c26b9797bbaa7124db99d5fb8a8623884223c28dfeb56f5ea787e7bf389e9c81f8cfa9b509282fd229fc4193c95a980118463230bae3d4e3829c8fe5e9d002753df88627d512073ff7a161d3b72a81a6f4cc5e9d5a6af653183ba5be7fcf74b3f9f32af6c12b34cbf3929fb3b15c4df1dd9472e4fda29155f0817fc219edf962a5437f56ea03feb92ecae71fcc34bb00e39e346094f017c9f177a8faf77b676d6e1f76e7082946f6bf3c0abbc8f6f615ff40db6c04e71d8c51d6401e22be25e5b67744bd395f1eaab0623cfa0d779f296b39d16f94325b463ed91dc60d8976bc73b91b5bdf03222729a00124334e67681e589e0e69ec279bf9283e02520c665b2a9ebc39aad3a0af179686e92d0b356ea224ee30133cb951bc51e53a147a5cd8c7679ff4d418b9a7c433b571c987893e94806bbc9d46f3ebcf8e5d789e424f1c4fe586fb5bbb2dbfdba91b324581295ec384b022c2b7217d9819dda7a338cf05a9806fe9dc875634aae045da9fb3a2c3e657118a78ddf1c034f9c75169c07be4f4bd54dea1f9eeee18714891d248c8d64ef17d746dd27b593ffada13c3031e67a799fa1c7ded526ac99ce29ffcaa1ea125ac39184fb32ee76dda2c97caaf0ba1ec2729655d8793e8cbc674d6387fbbab6e15e0911d0c4fb2fcaa26cbc3ddb6279c5f20f797870f2a3b9b2e8910e81af50002109244c1a88aabc6b6728cf7b8e26536ea1383700e4b85e09fa9f6e75808a2208545e395b0a702643d486beaba0922a4a084b4eac1d6d3f016619bdfbcf658ef042e902204c9519cf520abfb70236dda645ba5de3551e12428f71241833ff5dcc9b21dfc93c02c3c5af9da2443ab93a594a0713534f159965cbb28dd4d118337979146536148308ad52b1266e73068122d1ff02fc673dd80d1991a179d0ad6278cae3f035dbb0e740777101941751e33f0986be4e80eb678f690b69cc1dffce3bda30368e15b80d8975bfedc879e4c51ecd470bba2a439e68cf1f9b5aba58d547cf094deea4f1bf71bd17b1273621a514f5aae0ff70034b1b83ee44deeec3ac7a5de9f470579354fadcaff20dd14d5de48d05b73a052fb3d6f46573fc6b49801673e2fca6cec8c64b47eb452d2c7476201a5cadbb1f989efeca6ebce57284eb445ed1ec5a1cc56307f0d57d6caedf9f84808d6db57e2f33006be5e3dfd1bb2026d1c6e2d1c2e9f19bde160ef138cfec3c5107aa32df850a25f55e0616a586a4967ec2c45bce1a016749c72adc6de408fbbf5db6cd28a9c9691c5669675af6e1fbd47777dbb4c9e00ddd2e1f06be01623d9570266de738589b08d5c39d78f8c309f7bfde7eb389ce562cd13c6e5a0bbebbc171b01578ac82154415bb4976fe6235d8d67053a128eee85108c59b389dc61835e37ddb2413360ed116fa2632f7399ddc82c4539d8e59320026583d938d82f1b8615ba038c9646092d3b19a52194de4dff1e5e74eee9d0a95218e07bb706b975233d82883b52e8282292fa30fe9246b901e2500fec2f67fa83ddd9dfe1b5400c2a754a7207fbf3f31e0fda24deb42383d8faf2b56b4180ee22511502ed2b47ca20aaf942ae26414f6ed0e9d2e8386d0f1bef66164a89eae2ededbbab25e2634ef658dd241f7420f85c9f3f9c6204069e48922da228932ac6a2c8e35797e8f7164fe9fabfdcec4a5c82727da103c9adae5fb5162d8533ede1bbb222deebc83d0ffd0d6e446038ee338795645bd400cab842c786b98d893bd989c2cea66fb254c3d0e5bac66790251aad51f9b2471e9d68849230218e7f1c3bcbff82c6b6496c9f0f03663c73e00e2021df9d5740274495dc2ef0a185bd944b42db08ec8bfbf97de27eb0ad5c48988bd896e0fac4abd2a2b26de8e8b6bfb665e4b37a4ee775e32dddfcd69c2f6f4ada6ab0039e123b7551bc10c62317a6bc144838f839d929c0fd1f30c4c2dec401f6aba662b3cff498558b8253c1576f98b97ccdadd9627b95e73eac516996b3abbd3039cb94ae33656ca77cf317547b2730b5fb124bead1de51f6dd6ca0529e3716148e34fd0653f979952a9a445919f042873a65b0429646fe86cee52074e0eadf66a8f88fe077b01faabe5812d9cdd9adffc697128450a250a14c3e8a4b39e21239d7132853e1439b8d8c170f4bc7aa966230bcf0e13d29178c49186a8ea066a6ce360c3c8f5f920a3294073cb2d492d80f466d69c6b91e3b588cbe4d8418b3290bedb438a9f1fdd8e26b24987b5d30c1c8224cacf4f94f5b46601e105b602ff50b93330761f4cf74d5a3d86cb21c81f7bbfcd41258044873a3a9bef2e1cf0415a80de6d479f44bb43919918efe60338aad4d4fc78108564fc4d2158b8c1074f60c01029c5962dee0d46d856714ebfd171716502233e3bc1446b3c419ffda54536cfbeabe361af2e122424a65539b1bf917e9b847bdd87148b5ff228e739b23eb01af96c156d4119b5836413c565976a8dcee0c61939f4ea9674a77cd5440abe3f5394556c95f4e4fa9adb99b95275f490b672928429c5806f7b9c41236a9a6b9ecc41687e0d8e7a63aa999a1f16f67b112eb917681b8dd9c043403e39ca40a35636c8fda63a73e6bd8dc44337216cf6a7742f92b7c024445324310a371f577740e97e01dca36f1c0231d8765ecc9e7adbac06a5fff5b7d10fb4b82ea91036f592f9df5c4b82c81b99534799754b458a0b8dba499fcca854720aaa07e23df9a81d578ca22ec1b700f526f51a8fd06f053a6a40b641228d56ab1c057001ab9874a0aff94bd4968ab4a669d81947b142c6918930c0d34c26666dca09e141b8a59f218afbcc149ffab697457061128bb1016eb3a4b7efae78bbd4b6e160ca2290aedf3e1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f8a1a1ecd202d259f97dd691a2139d87"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
