<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ca8e948a45fc3ec12d3657676dac85367512c139c6095136dc14420d50c1c0baadc0425d92f9d40b015ef32eb92734dbb88fddf3b9e685dc0b7f5e5f426e922e668515fbcca6a7c185a1f56087549d6aabc50468a48a8a1f4a431a22e5a02b383826be8012cd798e5253a7c002e1bcd218d1cbd25ccb218be686c73d9b5fba71fb4d7b55391b61d60e65429c7d32ca28cbffab435e5682f87a77b592bdb8e779d92603ab4c44c902a4d5f63b340b948f3dddae8e1eceec57aa760cd7b0312c0c6d543c2634d56022c768efdc2e68545fc6929c65be086f72801bfd5b4488c3af535da145d85a54b4c7dcfe4dbc0e22691ba8df9ecc8856f5c1ca36a0fe84ec313672e006983a3a35cfe6c5b71a6e58bd213be08b22d1856818081665a2d46e99c56d2d99f17ac8b76c5a95495014a5836a1d55679d689b3f80effa6edbffff04266ddb8ec546a897c878345506401ee91094288970b91b70585e6614c85726bc4b29ae5a0837843bb1971aca936e43e472f786e8cc0039c55294bab2bc4684669040be3e058a32fea1cc003be65eeae3acabb133403e9ca6dbfc8dcc8c5a6fc10e4633ff948f10cc2081efa89d3c73465c1ab3e41020c7352f9a9b569058f30286d8a4b15b33d04c22615b12399a8e6b27bb55d9242235cac7aff73810e1bd5adc962478d54c4459a191c2dcf51d9004aeeb3092d76ba33f363cabd368293eed602fb825fe7c7d13ed3ede4e2689b56023f7b6f19f1244c7755c0b5046e59bf5312b7d413308afc0b965de0dddbbdc28449cd4bf9653c5ff49f9c948dd65d1ac5c940adf049755d7f4899d6965f1a0d4be98bea3611539f652b9feb43014d44a1a07fd2b8ea182b96c0bbec1e4e4932c359535a1fe4114cefb15adb7bd296dd253e8e7812f5f456220a3a6b08bd01e1110f67ef0db6032353f2114b89a2921c39cafc8203dec82379e754ad2ea6340bfe2a3dc183d9ad1ad5751b96a7d8f33b180c93a47e45115e5f1a8afe7784dbf0641b5c09849be8f5fe76b51ec89dfbcefa7fa337a87deb616aecc24b9362a6f592bb0245058240e45fc4e392e3c253b9e18d2cc8256a169874bd2b9c243b0241e9529a4c7a6fd5f36b567baccc642a0cbfe84f9ef8c7131fe7d330d8d48715113fc2fb55929d1522d86e4ce0f1c8391a6ed5aacacd33378df7a701fc63b94c5855f4973db503bae92f6b28498b5d3733038d3d04059a79f6b7acddd28882308095bbcc7ca2fa868d3d1ffca5dd43d33103b07d10e824ef14ee907819f69ba497c33bbcc13038b40f21013a19d691458d7491d26713542aff18ee76b1f4df42d39692c0325d575bcfe6d89917f265956aeb89be5c14bf6ad72ed56a667442cde905348165eec0cbf4dfca078c51892b2fe66e390d6d2f07449568e9167b2bea15e8d9f9008d16813bdc8792f1d0c0d76940af9a1d7a1463c81e57bdac0ee4e004b17c20864fb2121c42d48708f8eb41e11dee9fff06cbaf7b171d2f49518677ac6adbbf282a119cb30afb2764e190f2ad283e8d9d7cce40e790ca36c6b8beaa49f611a151a34aa95e66f4c8f7dd1bcd03d507a417c1afa4a165ba5cf831e1e53766c8b47ebdc6526d76cefa93444f4767ff66e4659bb9e102143429e9b2c3121368a7d1c86175998e6ca887361ecd0d5739d2c4ad2e2ce0cf08d6c9b5847cef9c71f4bfd005b7ceb7af8409ea3099272fca522dd5dd91b795a20ffefef5e7bca416dcd0afd858af862536561695ad96929171b4160a2d43ddfbecaad72548c66facc5d6320e3e51039bc13b9340b302804db5d4a9341525aa8d0964b3c0417f1b0c86fe77ec8062572c356bbc6e5ebca2a75eed0a43aed96dbf3e9032ef755ed7282cb28ef59604f264f283ca046916fe88d7354d9dc9e639faa739b7be595ff6284c7aaedebed89486853360f35d5bb3b2033c657e7a88d1aeae9b8afce125a07b6bffd753477206afca3fb6684db13db03c8f54960bb6a564a767548bb1b99164cf54934043eb56578c1fe37c050ae452ca549495213d49b2bd9e0c82ccf4f9f9166b4a764ea61144ac4ef5578606be6cd0c01d6f35465bf25aebc9b0d7b23a7653bedf17bcf78ccb2ed33a61c4c96315025995912877010a4ecf6a60a1c78714e43ed18b51b4fad46fba37a2fa12c5e14692354a60eb3354fd0193d682033b24bd410deef1dbf9ffd50b23d2a706a8b6b387b9263a43ee018a34ea2e5b3b4367f80301aa205ae8ade6bbdfe3071ac25c1720f35c7d541edd52e036bcb244e69b706d7967ac79083b33719deb29d1ac0d8d523d30692a34d4eda587d9700dda616ff9c491882b61cec2fc3053bbfd54e2ff7d4cf945052b53b5a579e7b144c794c06e84724e0494950ae98c332feefbec724813c444a2d342466e490df5d9cb9a598753aa564f8240d817c071fef7757819b33d68aa5f4270f7b0f10469a2843652e74f0d7444c596185c7b9a9abe4cedbad77cffe5175c8ac52f183989549f20238947a615c40bd5e9ab47512c0290fd39ffe581b5b3bdbe846bf1c80e33853c7f7e4a861e14fc98c7bfe08fdb28857b06180ceba08c08d345fa83a8577af1ec163e9b84e93d23b2d5e3a46c9a9af554b0458c6fb1b6bf1365b6fa603744c82a9b970c1f022740f3f816c4bb6151eb15a5b91719b17e4a07b6336bb81538ab9f5db85d659138c4e236a66ab231f808ddcedd87de5c36cb7dae5fa753e70068b8ce8cf0f75c02d7fd48c7b511810cdbaf57473d1e060680431c9126fad8cec8eddff404158b8399a71a852e165ebecf3ed7f8be284b5da6bba059c78c715d0abb10ad57755af7f0556aa030916d04e70b32a8d313929b6f0235b84c1bf4604ee037924c16d6c69253816cc4c64ee623358e3521ce7b0290044c8c46ea4fc0fc67fc58c2f996ce41001004520e2f4502050fd38f04801d7f098a8435b2fa8ec97b8752022cc4e994e43f54be2fdae301f032576d56c6a0739ef6b6f8bcc796f383c2dd46b25be45fb330032e8b2162abd92d8b50435c242a98bce5d0a5701ace4c140275c3382f18b825ca89a5798322ee2b2dd379fb61225fa9d024c0eaa91c239bac6e1c4f2a2763061593f1ca576ef5b88074963abe9629b61be5123ad6a8e0d31862a8ce123d005005277b6186157a04b5fd35831ead76935fc8f9f4fca3a341fc78e59ecbcb3b9212200847fdd4c52330e8f568055de5fc961002fd73d1848dbe572594eb5686c90f5e84d4fa6da9b6041a3bfb9f9a04ada654131554a9c89c03994167a80111a7c57d8d7682d066807d0669f6a0e2061fb2ea43a940fc15ece9c7dd778b27f0794ae60683e3bd1665c289c296f57c0d2ffb35851de14ee84f81bac9c121513d7cb71abd8402ea23aa4d6c045536d07f0e9b6ded605d7849a4cccd12bc82c4f6138f55fd64a745a0b005b8b3dc903f3bb4716bd0d3db61bfa63145a137fce0286f28318cd43a8b8ff70e9513d062d16d34f79981732e9eed2168ecf47ec52b103133fa1748f3e6397a165417d3677c574bdc3d6e8cd58bf42edf2df005ced53c2465b932d578e7fc1a560557ac64f61f3e3a12dc276e53cbd256687236d3f0df7fa6adfbfdc4e2a38253cc291c5835bf94d88acc77c8325055fd35dfb75f12ff7aa1a119168b1e7bac3203cac62c74c1f7064e19457fcd7a899122d1763237675e2ef846a4614d20a061f88dea243b76b1914560b59b85390f0d12a698b3b24703904d35b52c2b2ba87d84b80ded153bbd2921e737f967beb9dfe6ac6e466ae35ad3c5b10a4afde654222ce1c2f9adb8cabeb54c2513b7db97699e72b84849eabc17063f016dd5d31da733ad8032476afd80db026652e00da7166321a373885e5d21d65fd9030507f2e321c3062c09e7e405c4943b7189a67109e6e9ed1195a5a33fd7d24630a6c28ab66d7e49b4f68be60bc28cb35392ab7219f13fe5aed3361fddd5e77db13fd5fc3addc1b26622dd1e5afce84c35411a766002b044c67611e4f0ca1b6b9f4d4c0bba6ba0d1d367642c5987a823d2d3f528fc8e6b65ee0909903ce18a017c4cf326f8fb97f9dd0e3799b9b499675c3b801badb2202a182e6ccf90c58561a8d11be915c09c5ac783a4768a934eef5e1b6d2c368704c05bb57a59f556722737f2a9933e20632b3a5f04ddf4f6d2b44626b84634049c463546b32aae2411dd80bad4a94588fcc4e4a97fc77d0d140fd14c1a6d51d87ad36d821508bb7f89be426c99b8d2c3630dfabe6846d5319806852cf17b502e304f23a61ce4b572c99d9cc015b627d16aac3e5225d9e16a4961a801bd670b0d843b2197dcb49d2226bed92b378c0be07c0fed650bdb30e691ee143360fa67823c7b7a1e3a4f841f5fb0f5aa82fc18af9e21f6b2d865be0277821caab65091c557d3b0a80ef7a5fdc2a81fceed3282e7f0d25d308dff223aee877b03262466c621533113b313f34f3bfa97a53c96d765ff2d646c1890d0ea659122839047b6dd0e25f19718c96fccb13d719b32edc035c791b3da96fa89fa243abe49f3ca8592928fff468a0712e561aff7840bab1f37630a8cc6dfe3427bc85802a19a9b5a4aa5efd5d6887f3585a5bbcd1f74bcf57ab98a29b788e2b7be9a4f5ee69f9416477036e54c22fae5bd1992ff64cc8e2e468644c8462ca321cf0bb3e9809e162cbb86a19ee564a14fc6f991e780a236145f3ec08a83b28b9e854a66f324187f47199f41c4c63d5af2b94aa665e35227e3f95a8ed5f1eb0a51e1738a0b619e4cc7b2a9ce6039a56c11a72782a7cbc7d99ab66e265d334cd66d4b5c3032c754698f69b39d0d6b4a0105598f082c3b59688b7c37cb3317529567d9b6effc64b730e365427101c61b98bcba721d821315336db4127292a6844b60ec461dc762c0a36ba233e98c2840442419fc18ea8294dd37276f3417014135458236d22ee2e9918a85999838d93b07a7f5276a593ce0f276781843de55f3a3a2e6664ae4f42c57a4d69b1ff4c79b92afa14b21f13598b728f046410161eb790663c0d3c5e06c051f128d0d2e55987387579eb3bd297d49a7c55f005b7f1b963451d945cbf6b804d9ecdb4e9dc572ed79e874f4ae53df908d1af75164f2a733840ddb25ca60ecd2fed93f592ecf4c97bacfbb0fd4679ad8b6950badb983f0fce8aa995ef8c2da36afd881b68d336848001e18d2fabf37c0c0014c8e5cba195c4aa1de3733602aa95ebc6fe5c35ca2e4c980266b57f465fe3ba1b6274cf454ab16ed21215ed9dad74fe3e86231bb8cd8f733f6abfa3b86e6b59dcee727269f2a7f92fca246e4cd4c5ac11ab7fc39678b7f3cb5d04b801ff78ef1d8b3e2b5b1d65d75f772a4d250f3f109dddf2f3b8610499ebe5c3ea268932551c6f739ce33cf4e6f957bd8a851fe3297b5c9d1934ef1fdf0878bd940ad5f4c5e0f2949bb33656914f781cf779ffd198a348f81728f6508a63241d4fb2375da646d2e0658e0ea52b8cc2ddc9f9ffdec07b4a2e51516a71b7d71abe0a759b8b5f61a2d460cb358e675cb2869dd82e0a2bb9aa75743ad5a2d3346284ccbed00d662a11ac35733e278e5c0060d2e31d958bf736b3e000fc87c51d709a89e6a6929610748e6b749d0cff7732efb210ab30f03b90b66e06f795e5800d20d571c2889eaeb5c70df1d616a7c854a038c97a0548c4ac6b30125214a94cab64aa4b65cee84fe0fc49a15488758fa877bbef9d214c2c430d96a3d2802b64866d68e4971da75b4071d6923d2cabf8993aaefcfb7cc20d7ed17bc0826e7bf6b9534555c2277ec9682903583cb646f6605174688a1a79ae5eb11fa64c59b80c280e50a14ecf9fc7f5421705a1c22236cf877b90f0409d0d9d3c643ecf36162013bcd9a30605ef5b32dc29bf10f71bab621a5bb7e8905947ca6c8d6fdf645d056dd41c52c2b638847b6777a596bc2fbb1ba9af80bb5e8b7cea9cb6a8df45679c2ad0e3ab5c20445001139ce57ddc951deb7d3456d02a9224d1c1b7aafca7cfa3ce0bda406cd4d9a6302bca3284b79ecf4180c40296d8e9ea86060bd1f2628d9c44cf0907c2236712de893b30ca2aa988d7bfe47f093392e85c51191f51a4aa4d13df87ad534ab8e818ebd897ca6113ae29e2264502676336a83185fdbfe35cbe8079936bcbbadf131f9320da4f9ce2d7aaf7a8ff46829c2314fe2ae8bf86bfd06e11b85ad7a8938d595f8e482afe3fd9764efa05ec50840dad749ac46b13062aa4d8b59dadb433c208bdc52e62f7572b9f90d00918a63f3d971a1b72e7bee1730bb0348b6c2a88a1be5e9fc9e57985954a7da3b518b06348221da1ed3f543d40ea66d599da455649191e5ba0df5526ae3f4f38e3cd35cd827eeee663b2d7d41f74883af1b6b55fcecce7227bbd336b69d79471d058434c59beaf6d84ebbf03f9ed0ed123937e37616e563de81829348176f87acf21f35ac76cbdcd7e222159e3bd4020c1031d3f6c37822802492e5744eb813731ab9d70aaf7a6523e621a2b39229de81a7fd5455137c23069e1bfab4a3ac18de005e590c7bb8d7b523771b64ad0946031eafdacb70c6772d97462b35a1507ccf88d9dda7b13cb29f5a1e087ed37d81df68ea357c79fbc318149fad3da587c18ca9d7a981053d2bff313fc98af94304be2933421eeace3ede5df1e20fbe9e9a09d366afb338d9a8e7a9ba511eeab336fb8261d0d36d6adafd65829859411b09e185b19558ef8087a8737199d85d0fd90645c4f719e7952c506e140314bd865ea7f6e8ea2f6f4d4cb698b7bb18eb410f969dcaa81e306baaff42433efff4ca1dd71dff2a30acf9c2925fbca72429e2d9862fd001d06555395bcbd9136ec48265d6af2c70e0d0ce1aa10c5f2a873f7d91bd568dcaa8a7ffd4dafd82b91a22b451154f0ebc975bb7fc494e80340ae651f71c21a88024005dbdc099bf767ac60f91bf31c69c3459026f9c47e68707a41f39d12a7f8e886f9119fd25b95189741742a1318c342d6fdd915bbd527a510dc5f0c545776c73e5b18f557f0663dacf935136cde002d402f4cb435ccd681f75a0e4d2f4943d2f510ec59e9ada5c9fd3334e206cd765fef0f86da0c5435792f88bd2a8fe56203b20dba9ac50f8d442426fcce6f482eb553b8105b4ca15f601f263025d8c2417446d693765cec9978a0b4e17466c3154a99e0fc6a07014c4d6c7a9e00804e36137261244aa51b4c964ddd7edfff894b8740550fbcc6ac43b73b371f0c9d766c5c04cbd66fcde33912be6c77708e0ebb8b636e1d1758c84f1545b164c234d072172c125b714bf95161e18ee35f28958b9b2506ec46ee83e70fdc7cb86370e66190559bbb4fd3d5c990c5961c3a69a905dee7df683d179ea6f1803cdda53c85d29f99b0f044b646109b06bb1def53010acf6801b8dd7ec53450495cd920e3f8cd2566ad7b2330dae5ea3c949de172d0a2eecb24e13ceb2e7dc696dd4e39a63e7d2f668eabd7f11e3da37c293c37da5f338da61dcfe744fda1d73a821a4933fa50288eb8ad5daaf202a74c6796f18533407f21e4a23f3828d0369aa0b297dbb152e02a54b378dde89a5b5091336dfdb07155968153b3f42512ab34f794a08e1c3e1adabc1fca388fc256ac1d1bbde07d1e3d952dc860820bbe9bf429a083b4422e9f984d1ea1ab88aac22029fe99c8818fd04ca5dc31279da2d9a23fedc80ba84ac20504dcc2108e64ed8774d0534f1c23873c301cd7c9665004f02e4e7ee83ffd1941a802c2007bcb615a96a1bb672dc3ee265c77eb145d98d498ebd9dfd8cae32e6fc0d4f6fcc51f5e713f7fd057dad39633052f872ead80b2ea35698282712632472a8efd88d7207d68c40406c09ee60032003c380abaf16af88f4fb517b00dbd68c67fa6262df08fa1a994695fb73e853ac3acbd4d9051056097fdb102f9252125adbbe2b975ea8f2bdd6691dcda22848685d0bb8e325216db53c5d1e521067efec99b88bfb9d07a921818124ac2cf930150cf5870cb3e33d172e3c080c90cc69c4185c80c7cc6d58976f7c5e5bf4c1be0fea589109808c16934cb22c8c35ee224c22f1cb5220c29a4da88642b2b3c4e0ed121fc7bccdd5cf5fba2a5e327abecf29e75cfa95897e4d82206ffa335cb15226b613c9c32e7bd96ef49e52cbf13b8bf9982bdd63a093920e17b4cae3987a02e83c4a26c9074a358ff167077d8674b3a849cdcecc2602c9e08a50ff9bf173ecd48c7cdb28a74826aa06e72d74d2d1cf247b3a0a1e114a0a0f1d22eeba503698389b21e3806f47e465f2b520c764deb4c9c725286964505a3ec569aca166565a9314ab2e955b9cddae7b8ad72dc281216350d5dafe74c19b643aba9c6b0a11ef10a5d05484539afdaf53c51f106775e05978858e1b6837b110f518d4f2eeaf4f8fd55dff321eb1eaccbc9000402393d0adb9563a89066e0294c340444f19cd89456297852c7444a8dc0447f449f9c76a5b3f7dc1a6142158b6462ff27fcb13a8d98748adf7fce8aaacc60738f9bc6a8b2ced766d55668177d2d1071509e5d84255c66638c6039eca397f6245b87e0760b892a901dbd6e85c651886005f3c34173eb0a81cf3d78addd707791ec0aa0769d6bd6905e0b54d9cc3f350cf6b27a841e214c5fdd63d0ac21cb78ac20b180d44d58c781cc6ad7cdd37f2245914067267dc7af523f6d6fa7c697e6fcbd12d7338a7fe84ebc741682f3d419bc87eab0776c3a5c8fbe81618c0f7f68506bd21e790d1aa0cddecb753d657179a325c0311ae54367bf922fcf73d36ee24604093428ca8034b837684a57a2e5743f3ef5a6c6b9a2ca37d99fbff273907490074a1add0cadcffac8d89e2c2ce61ce47578033fac8c72307e42b83ef13d2d2a8052c8162326803898c87baeb506443965b713c339c4c77e37104b489ed2c916122021e8d0c84342ee7f9ec15dae9aa233e968b2bd94dbe38cb5802eac7f42aa1dd4cccccdede3dedbc6991f07ebc8ff38e71bbbafa6cb18ef256e8c70c6eed8da9ce8659130379c121199c92ff56fa22ba8a9c108c18378b0abd6b24bd3e90cc2a94484f157df0662ff782f1497200f9cabe851df1c5391d09700e06cd42c66bea0059859292f14d787538e28cd5fc3e8464ba502b9be94cbde0bfe8d72a2ade7fd724ad3eadedc548d3d8d31782dd01b937c23fa8c181d34e620af012223ac12e7b404c882ada78a2a07f32e2bb648f7947ef35820439777f2d5c03ceeffc5e3967ee3bc932313c9cde416b3c045cebd61e6dfac04a00ce42b3d29e8526a98c5b36fdde3d63fd9999f89621e79409319a709911ce58eb68aa8dce88041e343f341a136152224277e3af74def421cbed423fc9c5ac4ef1db393b74a8edc1e3f33bf9bab1a09da4953b77162defcec1e4f3ae17b54cc1087e41f31ca74d8bef836db608a5083af3a3e012ef5d081fbf18b1679d3938a60200d1b64a3fd42d71876a17ff25a455b16cc4bf24e293aa125c74b838b146bcde4a78cf3dc2b37ca8afd2f920a04a859b624bc7f20d3f2ff8828156ef933cd23e31280316cf72e623ecdd370122050c04a315bf1d392ddafa57247c637127c09cf9bed4f36177215ce63dca525bc546d309cad121d096b20b5edc6ef3106da6bd5a528428d83d76f6ac8d07230a0ca970219f94910793ad39d4d57f39fc9cfefebc9a026e3cc19b547a0ba9cb91395a6c1243cdc9f8d8c20966cc37438a1922c86699980a79bcfdb703da067abc2a18f64d71f0bcc3827b7775153e8c17681549c4182e9f5d3bac9d0908da04f8efd3eac24271cfedea02e0f2228f19dcac21d25af0c859f9472b22f9f60e13fff1ab35cf35c0b68cb03fe2f1e972dbe56020a05fdf03669db4dfda184345dfa4a270124c1fd9c616d9ce552c2853725cad7bc809c29ffe176a7f8d2081cb63dbd7c1f987344f42ad6d58019157404328310d5d88e604302be7f502207f884dbe253fda83288cb8f05b36bedbae8a817f91354200f2d3630bd63f5d562772992d030606bd78d7b0492b00d28a1fff417d0a95cba6ed3c62a2c3526c072370ba2696c93ba4a7fcb4f8e861e3c76e3f412acb4d48c973d94da38909ad83b744a3a4d5968a20c09f9bbf7af8c6611cda0b7c0a86bf64e90cb2584512ca30ff34b9f301cb4e305dd733cb453e04ecb869ea5a5c2f8e667f96871eac594bbc0ad7962c921bace70b5211c7ae8f2cac948a73aa4e7167b4be592f07be732e03a48b6e4fc759ba2de18a863ebec6fa354caab36f5a1b065763bfe20f58ad9de35a61ccb43beb585bbd133d6b5affc8a0cbe0bf0fc43a23ae1e645487d5d9c4a13b01064eb6d865210dd5d116ebfa3aa976bbc64406393b7ed19bc83037dc3fde188b1f710971138185b1b30d5d698f1a581ed3d759152cc67fd48756fa75734be76ac94bd59ef8a80be8770d5ddd03c43ee74ea9f84d3cc04430f2e1c45698553a9e6e355171fe8c57786a4c543cf0ca80ce942840bb069e63a988381127da88e11405a0b2824fd417d8f49abc388351bf18b148d15f87f25c96c408dcfea2967a5ec78f8738c9679994a38726164ae137a50199573e5c649412811d082b19aca1c1d138076bc3e09805ab3c411434744676ee5c404ea04784bb67d87105ae76d6c11f11a66f3ca99745f59380e6284dedc1ec90bf6e66164bc8d5131555b6a603472d98c4169f2f182427f87bf30108b7edb0d4f965d568d52f5a6a70e2fbd1bf87d1d155286bb14e0c7d3ad3b93ab783a2c72f08ee7c64b20aad168522e76c8b9386ea44efb239a6978100edf00f2f2e944cc6b2de09a912e2db4e8e6ff5083081d3af89a0707cdafb1ccde49276ed7eb4b2ef736442632e3bd6881e2977d47d791ba9ef9915dee09a6edab02344928abe52fe9b0f9f6e5127948930401273c5402d6f2b1c821dcc6b15f91cc976b80bd3e96adda68dc9581ed1d6b086d5a7e6afc23b15548cc1fd5356b47f425936ffed21b15520e1ef6d2f3783f923c331f7b8cceac55c6a914b8472e79491a0f08e99365667a2aea985654256058ab3c6b50f11ea4d468351d4e07795a2d32bb046cb42d57c530c838145955c12cab70676cc8e3b4c05a2c67d67433d8e7e944738413bf99cc84b2036888618ee38a3c00d9335750d22b38702640974d264491eb0624a2d131f60bdc4e8f784ef668131dbcd59de296f50527e26aff9fb8474921f4ee24ffa8fa816bcd19eef81ca5f7dc9501f33d0e31597dfe65d5800001a8ecf86224f2fa37bd3332bac906a818aa70be727e1ec2cc01aa50939a1c27394937ff77c174414d82a0f5c9a1c4872d74872dc60606a16e51b4306b66669c3e4ba79e0a013016e3c058303cac215cb00387b0118662a2b5045d0c1b1e65350ad4a120493593cc0e96ee4f4d0b6990166cd5240cfa3ca1a488c96e307c4ca75ab3756d84f4922fcedecf628fb4636480eed3edc6bdd780d8f7486fc79af806ec3edef2dd1f1eae81faec4b4e2ae6425662c4b28bab61cb315f34624217c9038f9c92585c3dfb7b7b18615e4b14e0b2516c8bc232945d63bc7a760849babc7f52db3d23c79f5d835f782a56656cbed3316d7ed770edf6b7b9df651d9c7452aa80b69b08db93e508e6d11d65ab6ec0b4c50e93ad73b6ad7bd6abedff222a6ac19415650b30945d5620ea7f084e303d9a50a3f909d808d9a6fc2fb1c16ae6f06b19a5e04bb9b4a25b6bdfdd7f84c7ab26c6bf9c2f5798d7704ff74599b77b737314ebf1cd707a96ba56eccffef732643b7abacfeee3c1a5397abab94142706402415f8632bb1eb98855c0af3c2853ecadd2e50862765d617095560df9bd50335b46a92e61f7ff0a45e5f6b2ffd7899b993d2699fc577b2bd2e4e1c73df7067fb104ce37b0d498e253c5efe54f3d0f791f9a89e1669fbedb24f02441d53f307677a7c69136562057aaef1735b2852b53b3e5f7ffa329e00523bf52b06dbed8f586febed26c8dc2aa477ba2559635669c5b0659e4ee28180d301267ca6be58b7cd87cbadb7161bdabf2ac1190650e702ffc1f2a6497f6ccc5e1cf48422fab1c1916d4b9a8cd1a734ff646de1748bcfa2d6a9d9fbf61f83495277feedc8bad2ff685e0eec257ed67445ca266a9cbe439131d24704a69a61801cc34377f6cc1e0b3f124adc6de1a1b5537dedd5e10e2a2e34a9b3ac411fad2f5e48d2bafa2eafc804cd912f77aad99a25c09ed90744112c3ecbf812c7fe24c6cd945e3b3b6fa963b113f68095febe1adbcedb94465de42ddff1609f18762dfc832ddc699719168b329265a2568b68c231ff851557cd4ba1105bcf04e0c8cf964da12557fafaf93d47a88db7a24b854c311bcc7d552c149447a7584010d4e310ad1adf88a5cca803ba263105344b1988414efec11ae3c461c3252753674a55642f1357bec51be9006120ba4d669537a2410ebdcec3a7cd4af50bc7d145f2a39eae1c5e86e9d01e966f30c95d99f368a42a90c4e6ac6d75927830cdb437bd11e7015c136c4aaa61f68da23af9dde2bdcd949432ba35cf4f12560074492a055ce7e652053784336b5e1b28c27299927230c472f02db07f488e6a2d2630d2cf49e237fd5745fb90436ee5c5678f3ef3f750dc6881c98568046a6e29e8c3f66ba9561957f803f18308ea3abece231ed7c8134d6e381914b7e5a573177b35b3ea15fb8a0e2433cdd1844b2f08b4c75fa2cebd23b9e8ed747027417d3babfc6505413fd139647e852b08499a0349e038e1b91628ac772f3260a363571544122ee9a158bb92855defdd61cebb77d38c08768b220809eaac3e581cf1a654341360f5b03ffbffde42ce9698de309424715feac85da1abbd9c34114529ee7693a29fab874313464c98fc57d57ea2a38f6514171cdfffbec98bdcce52f29ff2ef462dc6be8eca345b61ef59be91aa2e6b58435441af1e2ca3c9d2735f906a56374be1f79b27e7bbb5ec6106451c9ce1b1bdfc81dc4c923cc08f2e9b6d442289e63d3cd66889641674c334de772d75ec9bd2dd3a4ace6d39f10f7f3e4d12346b1cf1e177ccd98b41d562868f300a154eae3da6d85edece29c05c4a2bf489b0a5157924099a6bf442d55cf1c9b1fdd4c082261891fed44fce258cf6ce25780320ac04822fb680ee75a0f4938fcf98c8f962e074fe96860a0eed5900bf89fa3faf6cdff6966d9d800ae3610c32b6d9ea0d3c1840495139177e3c19b1bef9651007975ed3e093e435298d9090e3c04a5518968f2560fc558851b969904dae9feb70c927c3ded361ace220748bc63f4af5e390987448870e72a6e0950c4c7af26236f75d24d00222f2d312fd4d91e2255f437b8202593d027b6e6c2ca758d83d35b21d190e65586817c1ff47343950f392023536c885fa079119e4a36efd81b75d2216d095625b05052d76d23ec60cea5e1153da874b47fdb90c46bf195585cd047e78aa03421172e60a1ce816bafd7181bc9a2a4d5b6a1b338938453448f4ea34dc8ea91b4fd8bb53679f7353e8ab85d96e9eed078d93b85ff540e737f27cdf586268f1c23d41f4d5d529464574d10e2b7c568787aa945ed7e9ecb4361edb997340887ac034334bfa0ca146e0e8c2ad81fded7730026afa860cf939a764f060f367686895ecb3ef8b21f03552937d8b2a92be42ab2fb49567b7cd2b5463680c555f6a35a93911d93a560901b25d6543800cf89b253347cdfc9981ca7154ad02ffb24a79b0344d9d6bc4e04aa93076ecdcb709c9cd03b50dde4b1edba86561c2ba8a50aebc553ebce49ead7c88f78e260d940233541162dfc4cb8fa137a65f4896b369d8722a5a183d024df295a1b7e2d84b62eaa64e45e57d84f47f6311cf104a17dc5b66f2531b79e2f93fd523cdad6d6446dab8c016e0ddaaca922ae096b3074109e133721d0fcadd4b9f7a399f5e07fca32ae4ca3a183791a5f83f54f57fdbaaf1c415e10ea751e90e9727931b5dcb3d86293e37d613476d8381c50e13936a87e3de711b4252a075ea69ab2da495c6ceb727f37b418e822e31d71c942156b62e4c5cafc06c239c22265d5502c51ddca9c66683851aceae7e441f1dd5d471a4e89fbf6240460dace01ed1073e4d375471b2a0121aef7eaf01e66993156cc967357a9a6c9ea3f2244ac71d0870925a73b13333253e7caec2bfdacafeff3a32a10569bc84da677d6139279a2dabe6374dfe6dde54d2a7dbe71721e4f456a2da1e8706223fc1d3ae4cfe3db5e7caa6f0d18622deb97eb8b84881e7ae12a7a4057629a68e83735069f09ce7456bc8eb1421bd57ef3cd06d77eecf97dbd98a1d26819e51d9db627961f2e603ea63643d8c54533838325819922e92999945a618560a2a860c28783743b7e1bbbe522bf183767b4d1a848045f31886f28ced894ae8a0a9655baff83988b2c7d454eac3d751022a381550a630700facc2ba2c45cdfb3d8c3b28038d2ede97a0b3cd3debafc014ee08c89f601e4243c37f9dc5c7b9532a542b2e7002e1578e9fbf6248c9fa2a93f7dc5ea484f9bdac9113329c1ce5377ccedf45d3a35bdaabfa78f240807c11107cc603bf81a4541f3abe09e87068f9f6df8cf8c7940d001196cb6e1f0c4e7ad21724ff778369aaffaef30e5221c7d2684997fe8594f8f8084e47894dd6ff71bb014cef4417f946d4841ffa4d8f4eca8f30c310f329cc45385dec4444fe6218704a233ca7ae22b916251ae7c70d68b7f74d695fc21fe886f71a13c1b100992bc451128b96b68474e67794bcbbba8176d68246e73164176873dee3fb90b17f4d79d18ff0d1b0ced2366eacb29cd2b944a1d4e9b3addee1916b77e8bc02fb0bd83236ae7182f3bc68f86826d712d6713ba399756f5946e36e0d4b925a3369a254f37986305b91e5b584c760fa62b0a938c4034f7b2bdf3c9ae693b422d7abdce96612fb33bce760e8a356801e3eb865f159f4d8171ce72335d89f1bb1023d26fb570cabb83e7f9c6ea102fd27f88a0d47fd8f0c6e1a6a065e62d2cddc7d597452daddb0fd365e920310bbfd1f12efa7ef85ce07f6ebe5fd4c601e1def90f1bf1d162c7d79fe54803781ba0292fe9b2baf752b5159a55c52389d8670a38e926794042030a7c4e07c1e3650ad07d9b32346a0999523a2c0d6f629576d40483d086a7cb1e9827dffd737d84911babd7f6bb3a58fd4df0586ffb8991883ebab3ea3c353fac97a68005b0b0e7a358b8f86cf94fb5eb725ca5b3a11ddb241e4e21d19d43ac79a21cca256574f754795fd6648f92e8f28cdef2ca1fed6048ea3c8517224102e1b12a07351c91ec90c65646e572e1d4dfba62c2f674315e3aaf95820a36389b824fb70ab471c05c953d0c880e27e64020ef6f57bfde7f6c300e3d913dd395cf7efa02e5e9f98e7bb7f9441187f85cb5c9d3f27c5e5922b0455c49b8f711a30beeaeb3f1fa429bab290045d39a3f4b77e0276c936c8bff5fb06e20d016ee325fb683ecb7c3b9bb720631137af9e7c35bbde14626cf8797bf642a4402f31d05c0be0238dadc0b945c068702ba9afc037b9c952937ce3c851cb6a4517f9bd54b48e7cc5e8fc0803882f7c7537ac190daa11ad2b9c46f17a5a6d0bac5fe0a51af479068ab3d33dd988d31d633722cd0e9534d148a2d27e5c8ef8a2acaa312025458ec47be81382ac95c9537e9dd3ee7212fd7ee3c3bc5f3a029279085fc5644db8a6dc6e25a838e43688a0e07db0b4e0f2277663b28992776c519e78e7c0d37b0d09de15fee0a6cc02c8b46c0bce33452bcafa084dfbd10e0da994c6dc952a5c82c51b42ae507cb0cee96a444126d018d9be95195c4330dc12f766e219e0a5639e26ce7838d9401e76f813422da5f49967e68685eb045ca8c78b0e171deda221cbfdc304c40c2be1adc42b9cbd2e6a9c5070ffe80cdd0a4b7e0fe49e4a07da7828dff90c96a947234eea81d4cb4158f7ea75805343759946f55f81a3e681f2927be1288d1b073e2ff41eef8efc2c800b21d61cd4d74d725c4aadf4b4ba6731a1e8cf4b309923af43146ba01c246fa0e286ad6a1e69ad14fd6cc7cbc34400afc77ddbbd98db109c06ad3e9f68a98fc31807f53b5e1a5142d725a42cf1b7a6300df5cb18a20216caa977d9c83476696b412ce1e6eeaaecc80910673a1b46618623c29407a5b917a214361b918524afb40951c23e9f84f0c6c2d9da1045d3d3624d9584bf1d1ad2a27bb5ee3dbfad27f6bcfbd6749825f2fc6912dad6eec23c94a7a30d178c5c16cce0ee84754bed2b0cf1d87d1c6e1f777bb952998f79f0ae30feba1bd4acd24d79055c1c6ec0ae54e7ac86fe3028b21167394f8eb2ef5d01bf057f1f8228e326c8e1cfa406020f6630ff1bccfc236903a54e39468164370a9bd26c723f3a3cec7b81d6611cee4a4036d4bda11c912c25365b040b7429db3dc91c7d82e837b7c76f8a977b2f255a6a5be0f613f88192134350653de2a5a863aa8e51309acdd9c68dbcfa2cdf791649989adea24fbf82878ad67864a08bff8a8b768ab74af3937a9a1268c15729a3e741990e162990807b3cafc783f2f32d697cafbd65bbf21a406b908324ebc8a51eec1c0bc8746d3438c7bc3a059379a12d381283617b15e6cf5bfb212ac4f422d62e4618af0bd459d07db48fed5f5106094f062d8f06f9b2904e74985172e0a10e9b537fe7d4b221e7b3c779b34e588d48e3a3d7088ae2b6e1dc22c4ea8e0e096aa3d1d91c989103714e31035baacdc415537d741cc4a03096d74de5c9d98fa701dcd2d2d460c455239a82b2d5f2830ba493b08e854e97afcb9df84fefd5ce5c3141bdb67cdad0fc689bedaea47bf6f205da1764926b3a31dd3870470a5410de51dc4e5ae1a913bb62cbf019b352a108842caff69dd229fc0ca619b02c774dc5e4c11293caacd4259606e6c19547b5dad8416e7835e9a30e002b4571ff95931289e8459cedbebec8a4eb88f0275d924bea88757c9a6dc4a5fff0f522ecc13503bd4d772f81298bce93286baf836f3ba2f36594fa0b816de95ac16b9e9fa3e3cc68934ae8a398ec3ea06baf0b8a30c5ee9cefab93b1d43609e75330520261fbc3416d16c44d424228c7083b39d1cdd80821063a1fcefb4f6e7cc4aa7fad705355f55eef7b02ea05b401f0fcb31b4fe2d7662c597bbcc3ad211aa3bc9b0fcbaebba1fb30da5ecfddfef3b5ea236add9e9f88cd2e9bbcdbfe13bbe4e6d1328168de8461a094dac3b02e8079d87f15227afa04a28ea49d0582e4c4daa96219176c00f45be9a34029e0eef18c8542ddd5855bb2ebcedd03b14ca14298e7302e0c60116bbc21d8a2806ef1ec525b10004832c2e9fd22dec108ed0f8bc80b5a7781dc5b387fd4f3b3686475424d06734eed079da46e65c1bcf14b0cb9f0b2d3c68e3b1756435e6b224fd3517ff10665b7ec7241c9d564e445ec443dc0081a0f1d8101e11c97878131240841369465993885c6a02fc3a0450ed0fb39f2f05d00de2429b45b818e11846bbb06cb99a721b0331020d620c89b4e8fe973f8635f1b189223fc020265eb2fc5ff6db0ce53c2d95c96c64516e8cecc6d376cd32030d12e6b5227514f0e8f4834ec661296d56cf9b241d936a89f8bb571efb9e4c067ec0c4aaaf29dc182cf91f5156eadb92f5ed98a03b7de7894745a6adec7b7b40dd23622e2acd994af4cd2d3078b2f20396394b8b009b492fb6745db2b96790e553a49a0773299916d324d5eeb86086953c6e6f8a198ffee87fc57ea1a01ff5b4ee8f3304e9270fc606c02e6374254fb1312873d23ad142cd06b4a94655f396f19ddf6845763ba8c7ec6bcd3555c1827c151ffce59bd23894fe4cd42f796cfe8ad511c0400f4379eddb962189b4229d633b75489dc8dec115a1071aa7107c57435dc600e555329f93d637273a6b733f5de58982063f33153da8b443ac26e27c6803d4973f8c0499975b2ecb5eadddb872b46dec3b95f8ab65331122d0b70a7f6f56f43a3b769403734f52a33b9ccd9a8eba3133ad16c1d91baa0a43f5ed84755643dc37a20eef0d11a3f82585d203ec4d6c3b1399aba38a525e419b5a2f5e6618f75c90018b664ebe2ce8b0bec200a21b8187533cda118c1a43a0d7ad07550e8279b96f16bfcc4ed1f2b72b9e208acad74e90a4e7daf0de87a5b996b4efef48e95a62acc0e43fd1fee439ad5d1f5a0b7187b91a334efc468e1e0b3df531f779b18943b1ab63175691c732beb162830ea0c42f8184fd1fab4631dd6ce88b8439c13bdc87918abfb5ac57623acf6ed4e7317d5b59e7d56d3bb0e551a91dcd311a4b1b94bc5a28e9de2f10aa8a10097859ea8f1dc7c383ae4525deb28ec647f33ba6c422c0678979bfb05d8842ef96bed97c1ba6f8008c0da870e0c50a84b8a243e51547ab0682ee96ad0385d14900aaf4414acd2ecfc07762bc057a8d01fd5f4817d705214d3b5804cdfcb2628f28dc7dc4ea47f6e1d2b25a854b537426dd70e4171aed5049995b60b07bbf96223774b0a4f43a1dd9e341cdf3a08f4e807859fea1c33860c862a596f003e6c2e61814dec5484923756ef07f62867de9999d657c78a07c72e287dc386c1c5dae22728e1b61d3c4f12d4a27efb7184c1e87e708eee3bb33eaa75c0c91e8b0c70a10520ecef3fd7f316d0cf492f8bb81e174f9d628cbc05b208791696087fc3ac32e8b0599d7fa8697aee9192691966063057faff3266c5c52536914a22a388f81e0a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b7a66e6969ba0c0f8e9f6151080b6367"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
