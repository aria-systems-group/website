<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b442fabfb82f700e4562ea6ce132e5723705676b2de9d41ce62202f0b9193fea35453d54b278a86f7f0d14ce761a37b38e22feae1dd94ad5492e0c5e9b8b4e3ea47f29c4c70f10767913d942d7e939ed3e93aefa6df487d634b820780f4080452542fb0127311498588b7ee70aa8d6738e6d4c88c0dd4fdd539f0ed379c08f7bcbe02a0a5dd45607ba77f71eedf1c998b716daaf910892e4bafe96d641ff4e0bcc6f64f32b75ad6ea335a24316b3eb30f36115fce1fd5faa07c393485b01be8f9cbdafcfa2f98afb8b0d9bb269f53451afcd59c5a7ade60f590a15e412c28700229a12d60e5b492b5e2978c6713e2dc8d13dbd76ace355619c022b6c061b8be6917efbb878e7706d5e81b1e893f27511d994555b255c2f1b566bf0570e1c77bd9628aa7e57d94df2204627e57beae358913bf7355689ac2133c2d8c1236817aa13536be06b8be198069afee25443dfd8308550997c55d7966cc6c857f1c8d81f9230b23eca871056fd6a9721c0e9783a35d51568c342dc9a342faa9d1deb75a992134b1e7e2405d69d8f879713b9f23da448a00ef00388420f348cf517a3c5bd4107bba2190856a55ff061e88a20c5af909ba51426b70a0fbc398456177738508cd23d07611a2fedb2756cdb0b11e811c97685643c03ba162b2ce3d64e7eec3f4f0fbf360b2e99cdf04a88cc541964abab3714025533cca1b2b69c29ba0336efdda06ab379c70594a6d7943cd736e20441796a826ec3dfa7024c9e59f381d8173201eb909fdcca139958a232afecc1005ddeaa94acbe24a5cd6731019bc305ecc0bfbccdb0a7a5b3e5acb3f232f630a65a616f8e649147bd56248a91eb0e5f95f32e60deff6501f826ee7fb977cde0220e901d141f49a67dbcc5d2fd057fb2b9cbfe707dbd528ca885255425b7e2b8bd197c0bf37852d017b382d38ec8de2d73dda44ec5c3671ddee590552c3461fadf1cdc660468af0a1b69b0463ccb45a289bea816573868916ce27a23b6d12d427c479ec61838a3c2a746c1853b1d76626d99c2b2b4f2c4338c83b0a55281198ef383d193ad8a234a522c1d517acab84c799369f75ff31b0052d42d0396fa38674c682e555d126d7748b3f457fd9c62e5f1cb4cc70f94842cdc05f3b1771fd6d85ee0b425cd950db6940ae57e9652de8dabb429042898541ca9bd86733f051b38c7d3265c3e1043b508514a3f82590d7b8bb5d76ddd87ece05120ceb80edbdd86bc865efaf1b3e31fcb4f41acc07e3c23074fad81741eee30559f2869a6c1feb77aac199b9b22bc7006f817fbed9fcca9697c7a809341d72e28d22e556d9caa02f781b9c4c96937722694f435b38e69fc549774315f3a5cca0ac469ee329a3786aacd27d9d2d858fe604614f01850a873e842c8366ed3b3656463a6c71af51bb2570cc9e78f9d7f7ad7976a02d6a01580939dade3a592b00b7bcda485cac46c82ad4fdacb22b812d79f614bb8cc2fea7dcc1774e970366789b376f4ca9a7f9296d4e9b8a0ac359e87a2c3127fecfe462f3478da97575fac5284700343721a3b7990e1faf9a025cca8b52d2ee25eb53f1f1f25cebf98f77ae9799ca5e0e6e6b746b0b3dc75133c1b1cabaf5c4ae674d6f947c46e2114f99224410ac3d371377b31c2ae2fd9cc8f82f9497d15d7c822329ca476326a918ca3435d7c4198bf2838962e706f7cf9cc81a297283bbefc3546297e8ea4e6a16c5f557b4b71038435ffe9c6585b539aacbfa65753f679feba2b3ce8ef78b75079aac1f9d59e63f3b019fe1db709b6a805729c97829957c03d5fdc0ef1b784246b184585893189c4d5d2c63b4bdf76aeb5a10dc2dc430a6fb5e746925ba59be6433256ea55443a8864742de835ab821047b5ec1d2b0978bf075a3a72efc162000afd175fbff310f10b03e75694c7576f91dec613ed9508fb1a83fd7b5ccecdd4e4a91dce9b31cd52d437fbbc1d7fdf3142d025b68ef438c17f9218df2aea3d70f67884964c70120c447b446fa156ad05609852177bf07dd4145881bb9604ed39040d02365fecc538118c20244eccb2ecb951827416f8589cd0dec697b77766b2a5c7a5221da51c9f4685908032b277e0bbc5868c23c43a0e51729674d5e887ec6925def51df3b29066069ca11bfaf02401db8df4cadd756dcf88745f818c87dad6e487e355031bea36272a4c94005d51d7d4802188096ead3bd2aa2eac6ab40704872b3ae7ae1c0feece83d6c780dc89de410663bf9b0ed972799778111ed4b655787281d91f44bc0c4b2d6dd05b1cc9ddc8a01bd1ae792b4322829a84dd04500a29c6c94eb9ba136327825b4034d097d294b163cc418e143d1197c04cecfa02f03815aa958865750a60c5cabdf6407c4fb0cd3eec0011330fe376b323c8e6ad39d81dbe9796affcbcded5dada13bfa0749c95f1a37ed1153d01d3c9515f52e62d4416311601c2a6740c08a9eea738e0e0f868e396c1baabc7fdf262185ea27b883479397aecb12ff774da8d6a5b29c516b3c270eecae31a878d0877632929cb834dc8ba5d72729c13387ff768afb0b2f3d7a984759f9c5a56411f013918eaae788a3715b05b570ac9410195301475ec5c67f7d74e084ed702fcc6461023525bdbd128b03d13984c61b4d5920906cc5a3a70b4a9c35c63bf372a3ceeb1acabc61aec80d62a2cc53f0422f5742819fbdc67bb0f2a45d456eb22a8ff4bc09fdb0f5ab40fe365eaaccca384995f859ccf585bcaaf658027a6d80aa4e766b9d784e401ddacd2b44e5e014053a9dac9b770c914f97f723b1c3dc8d36f4257147ba1ea23d217dc578e83835ad922dc4b63cf2d9f94919266cff7b70fde1c23da1c6e88f139866d8406339491c793b8f77efc6bdda5c3e937601bd8eff1f77369ebe5e39ad6b72b12e294dd5af8fdc4371fe7fc36e15359c63d372e4fcf67b30599672d50b9c144d19914de35df50e4be5e298afdb34f4876b80a003fd7c74657cff95f973340631aff25368a34981ef9b6348d44515d9fc206b18312ae802f4968b81f1fc7fa868b394b15855aa98a0a6d1ee0ace85bf209aec7c22dfbe03ebe853949fc8c9f0c5915eaee7ae1e7ae3c0548f760e37bd72308f8d96abb56c00d440e9cf0cd5f61f623513ccb370aa7b81d59bfc80cb115157d3bf78e5773b48fccd990618ace0964c892fb7084f1fcc10fe4f8dde0b190bb143ea85a7f12364c52869ba4442d0cb6a3336b083a02ee18df96101db3a74562e565647352de953b1d35ffa1ff61ecb3c919ddef0135ec7417e965b20ce44738c11e15c878aa7f6b25ad4f7b3930f2a68aa96466663038cc020085c1163ef36113ade6ed585ad38c3b7cf7eadb972062fcbad94f249463ff8eb8a0dfc09d4e280064bf37d22ba16d069a1b02b401cf1228c426d1e165f2df993513ec2abf46eb2537033884eefb33a28e09cdd699b30c52fd2822f6989bc6d87ff5ae81eec606c69ebe8ffc427d04d13e11daa87ff038eb047c0f9d56a317100f5dea0edf58c414e4dc19648d4f11f92eab52e1a85e343c896620b5007e1572b7573baf9a3b91fd608e7268f44ea87a587e28d0307ac74cfe0a0d23b0735105b61ad938dc6192e9dfac5ee140465d711248a112211ddf559c2dfb8eab86d16b837c9a027afb5e56f41ef7f9964abbacc7f79e3aebbc651d0bd03602bd269a97406511dc11cd1c36213b5caa736b749bbbfe4a02aac363f14822296af610fc51b6d0406e2804f137a3e52c72e1a3f82bf9af102007d3ce6c6c5fdc81c052a4f4f3e33347959b0f4d52ab47fc28c1510f1d594ed7e4d3111ccf37cb5dd2e0569df602170f2fbf897f3b2da7a405378552575883f6f2e3e9002930de90ee5b1048b176d07f56e363def3530a56e3e1d41b5c0cc5edbd89c0284f0562ccec06f1e1c2f4f0f473020d7321e4d744337e9d40208b0ad85953a907e112cfc36919fd046b2c9e587b3374cfff4386de48455479d5664695b071631d2bce5395692eb9521b427bd2eadf144c0e92acb0407e782537b1df30e4a47197cca61c7a7d4a1675f31818c688a963a700dcb32cdc00649f543a21660d00f5ff5fec35ee06cc96471f0ddba019479fe3450f119b7c7513afb37811419cfb0c5aea722d251ff42d083a56d2b8780e18f06cfc15e046f418a18f82fb992c14805441efd7e27fdb3171c1dad2d55cec9106055e4acd4f3645681afbbe79a1961d52145321576fff5e30e0c02a6e5c345ac78c072ad0d1616752e96e0bb1cbae814c4e1db1ef6b94678848987c90eac904cbeef7d7fd11b4de997fca72b427352280461704ce55f960f22ff3673f41154ce9b3947368ae615b959f5386189de1cdfa5080d686d73705cd0b95905be7936146f9beebdfe40ccbe927b91139401a5a971b95a4d42773f203d8919595bb5ff02d8c6ed444152a232ba2627e56e0cd9d023858348944e64a55461d802b7f60f4cc2e7d142d18e4e738840711265cbd1ce2895a7e9bffdf00d16eb19022e05ff4adc0d39416aa31868a2e3f2cd99b8bf7d915be2dffa7e81a5a782d366734790813d5b0b1809c432e0f0418e3669e41464f491a641e68499fda2ba6d854d22f497d4e73fddd84e21f2b35019a6b2813d1a8f964c9e8d2d6ec439a7a099e21f4d977dd8cd70e76fce117052b1100d32533e53140a3abc7cc494765dd3e217aaa6814151b3ebd7171568b07cdab4a8a3abaccaa68e3733d5846ecf619b227c99cd6d3ffff3ce0078eea4035b121da4cd07520e5aeb63af57405f03acb996219190c5edec4297cace1eb55276f8833c04c7a4c84f74902f89f935fa6716a9a85bbbddc9946c4b15c800c62f60c6241cd0a1b30c08d6e87e41bcfbd13ce8735903467ce9ee68a7264af7855edb93f4360c701d5587ba84007d4e6d286a3431a98f78bab31a47209f758bcea2b1f4d2c4409390fb8aee243732a08dceeaa98dbdca6c118ddb791352aa0d3e73361c30963fabd31acebf51634f397c4c0c39198ba52304eb7a7eb51f8110d8c4be29189af7164697b55263c6b8a352ecac4c21ea6e91f350378dc1560498c495dc03b63e3dd448f2ca21f075e6ae8ac76a26835cbca0ac153e5cd4556766e40497570b254038737833c6087c0e73a9438607c325e5a6861ad3bb217fd9b1f13f474f8a42f16343c0c12fb59a78de913560d6c3803ed089c6eb9b843d4414d004f00b835fdd7115fd1fc5525cdbb353604a9edd762756a6dc66c3c88ff4dfd1ad0cfb7282f309bcae0cee1e0e841afff8624c083b0125bfc4f3e6e89eb021fa105b54343d30f3d1877b3bbade4f73b13d8b67a4e527812daf837a1ab3ba2d23feb8bbc3892fa2524f52647b6042df176640fe27023bf5158c415642c4df4614c51a04f0553b659e54b66dd78e108e32e651d950003334933d9f9da9ae94802aa2751ad08554c85d644866bd1dd3083ac65e5f5c6710352d0226da2b87474bb09744b1da1351fcb319ed7166f9a9e88f3b249a396fff2c0f3918158b09911d55876890ec78aebb83ad7aa7760191b2757d749ef955d2c7322a8b0f2b340736b027f94052c1ec0577fa13d9e4b332810a8b99f0cef32a8ea5baca2a88edce622977651415be8b9f40b889344ae35e7b5f972fde8740f841d934a676264d45e03667190017d0b4c97fe1ddc35a604130137c1d17979c7622aada6efefeba398185cf9ffad5bf4a85f2e5068544112227d85e28c4d2ccf67a4bd0b391f706a657057fca91d886240d5a509b9ef514411c3568980f2b38cd6132fd6fe3560f8362b9e2ac63cd4e8d11f2b4a612c9c09c60c96d9f2f9a8a029fcc241c9c0154e1e8dfe43eb3b67cc471da45a30bec9ba566f55618ad62f0a48b05a29bafea291d97e2bd46114fbf80b02ac4daeba8375ae13fed6152919d1db474dca03a155213d5db5377d6907aaf8d8c0bed884e3c6a5a75caaadde39a588616cc5921dd27e4678481cd6d1a30cb6af61adb7ae9a41195a6009a362e1f442627865183aa09e54184902f951330eb1bdf7addc63a38ab263534623c5a308b761f28dcc1b549a047c7670f479a5c4e73efe328691941d572ed36b36c2832f39614b8b33924e6f591d0f45aa64a6ab7694bd8c89b565781ed4f1518960307cd6de33981ec91dbbbefae375aee26ed235a03271005565a894280737ce1f766787c3da49fe6f7b442fa178e1a46bb7084467969c06563cb23613cee4fd236478ff706b2e7d069cd384da08a2a80006d5e020f0d7b6bccda4d9b89d91d3059d1feae3e8778e6055f2ac99b191ea799ab435770f8c77aa67a6a787adad367022bec301f888a6873d0ab07658a4d36c2eefd8ed17a593851aa40b1c84c21a0d5cb381b89300f799317e8757318418208ac9df63554025e8a62b082a42d41818bb2f9ed21387f215af242055fae5cbbbddf3c66f2b4b89b7e074e14fe1a874ddb7f3855830cc3d277465f3d7f5d48ce02cf93f374cf5658d3fb9610432cf5da8f9698ddd583bc4939088f916c332a9e8c4b71e26044854abfbb8eebc0e2f1fe2829550304d0957ed991188faf070933036d74ab95261b240ed45acc847056557f2beb5f2c57c782a9f1685dbfd1392b3fe19ff60caa163cdc5b9718d536a9fbb3c7012330cf8051900582862fbb03ac4557ea92b8f3095a998f31689420f7d14b6ef387df9723469eeffbd7c31ec5995795ee95d1ad2f315867ca1359a95690354dcc6fb669cc15dc6a314bbdd992a2d1d7747c4745befce602f6ca8ead4e98835c600c21b8323e2d3ea82e15690b265bc6850482908fefea6ef1edce0ff21458ee422d159572ef419d35bee588598573e19b82f76f7f56ff882bd4be5e6335673f6e113547c5f1f3ec3820fdc030e1c3737a969dc893fbb0d0c544109e8fa9e7f666edb9e66c99749007778e882f121c7e04b19b80cb8010d989273ecabee5dccc33812e64e20f740baacf825ce17f87c46cf6da620990a326e95ed1f84ec85554165efc98c750081f891743adc8588f8fd7228adaa8979fcd896d5026ca3d6a88942605298f9a8b4c6a2fcf2d9d9076cb62da2529c1e05d87b9af8ff92f4d0f13264af8ebc54b6144d8d396a212345a0c8db5fcfe0cda7538d54eb93d35c66cc05176ee75deefca3e043bc634b108282db2628c54f447548fbef92051eb7965798ceea11d1be1ab37d46e00e5663d50efc72f5b33ff3a6fcf630596f1721c829815f1f7554a734f3d161309bf9f1676b4dbb9187554685e271f01da933f3922dcc11eab8d5746addf433205d27b6787484dc4040d0a9e1eb33c75f132c346a473a8eb8b6dac158ffeed6ff8ba2f6a06290d04d799cfb171268a44df5000914793e19b18d0ccdc914fe61332498e099cf08df32b93a9aec8d6ebd24f798426a04d2336547829a5cc928a157290e5c45f140fb62ebe386695a575adbb9b67b09cac1d5e10f62b653199ea79127fb75a0434908ddfb30a990fb5479a994b7a5bcacd32824586b224a9dd03db98c0596633cc353c527cfe234d0f364b67a06a004ebce29402a945d4daf76adf6a1afc6961a75001b8bda3224e8c6cfab1d0b7ebaef16f98bd3cbc0a21be18f9ec95ef067b53ead342c8e5f055d2afbc230a472a15e146552b42137edabf9b1ba5409189b8ace0fdf73adab30179cd605e10ecb8a7553cf76a68b2c2f24ba5aa674ca6d70e62ba465ac90d196e9cfa72aa430146f4009fae5ef8e79d5336e6908fec3d323810456e659625c389f5c699150d1c0a26811305d91fe682257065bd5bed4d8ebe58c1b36b6f3d299294dd01327703c7a207fe4413de83d1f4bb3f3e57f207af3bd6eee232642d0d8afbbe701c60d48e0b4bff33c28bd7f9c55fec9d0869ee7ab7eca83ab795b3de52858508bde5d2b8a63e7daed1c7cea3c83c88594c5f45f0de6f48058728fddae2e2b9bf1943414aa4b8c8fea35ae7f16b47ffcbcd254e992e18c8cd0cc26b5aafcb0a2115c4f484b5cf059d97f125641c9fef90f9cfd2ff4d2cce008b133320f4c09db723ccaf780d4877cdb49afa0c474c30f02115da094da9c25fb6ad008e444f4982583327b20362c38ce0634f76393666fcc0e2e64ad6b7a11accde3e3427a0fcf394c450eba0197bdf194f5f578eed22ecf0cb359d70fe27038edd3558a4d8cf229c243cdea7d1a1084ae5b2559c1bf48e3c5d6aa87dde3a46fb7550d529c5ad5e3e760bc5d217108278a9f3030a2e3f37ea7f56f01d262a54ea088933c387273b81e07923aab11db2bb017c4125a4677e838d8e243ddc4a7b539164e355bfb56f4f0fe52c0e3db6aff0fec663a1bf0f8535f32552f489b3a9857d3d4e1962cc2b715b423fd837cee8ad8f11a18fd847dae4342f45f6c1db18f12a22391cb11b5cb7687bce32f0d7cd55bee709b9b796727cb59d4ed56f2be19b6aba785bdee303cbe098c5b403da0cd3b2b91570354b7ec29aa6212d4c89b0b32358a92f6e727da2219fb80a0f2f1dec0937ff36297c67384a2a0c6a368f1ee7ccd7caa18083c6d4fe6a17a9741cdc60514567201fa1349b57ca63f397b2adca24b7458bbca82344d7a626eb6e0abac6e1c1c6681bbbcfd73ee2a16d8c3f96faa956b099264df3ae2993380190067a007dbeea09e8711d170b6c1ece25a34ad9903220b561d58707ba620a89929e06b05baeea655900262369d4086dc7aa6134857a510cf43b2e04f279a9aad5b1dd8fba4399355aad076b37e5e84fcf76705e0a12aca2593b4a0acba0bade6f6a3e6ea3c0244753324ea8bbf3a639c82715ade4450a1c50c62a94cde2d769a5d8232edffb18e0ea6d374af5d5482ac49f1b3aa9a97eb89bfa4b08cb279091a16d6641bf3bf9d64cc5a610929df548b6e4300c45f7ffe07c3978bcf6bb24fe853c438d5a7a62a218985a5c27bec6a4e13d8cabb014aa1f9db55bcaf3508d1b2946fa33271cdc9eef79cd0f01185c1b272ee3360714eea2550e61d142bf150536356a3659f3fde3ea4410d08679d99d879f14e0af621f96486a5824fd51956aa55716ad26693d81dd46829e69daa3c9eab7b974065c4274836818eea3ce31f432263d0174bd3120093398225d3ac0495bc7410e7baabd717e441e0fe10c8840b0415412ee4064666a565403d9577a2ee2b030ce4a9c9e83785f18ea9cd15d02fdeb3018691c6984b3be7b480f932822d935ce449d8515e0f84aebf18a6fc80a99f55c409c2153004910b4a954eec7ad5f5480dfe36d7d9ed495770c4f17ce3668e716186ced05113b0740a32a01cf5f4d808e2c1b513c9f627e9b18f40f8e3b2fa42d91296714aff8f9e3d13d52efc358d9499699466d5636d9240404aa44afef934117ae60df977c30a349b89814eaef29cec413cfdb4f68f45a50d441ebf5a8bf63614617d6c690f540615772bced4903d6d65fd60a1d128fe4b1896dbc03540759107b01bdc11d54bc7b6a90e9e351b5e81af5c386b9458b5f87649381d2beb84b2e68df7a32658addcc02fe03b0571344e5613347b562b02b72388356831f626c4c6aa96a7d3e5b6f7d36801f45b03eb665371ac1534124f79339d4ee8940224a8e904650458f64c12aa41d428caeb10ad7a5997146af6114f3980226698dc0770ef600e485629ee7765ab9d285dea234d1ff7ea429708e18fce0c09ede22f2a3aa5eb421d067e312190fde14e821b64acc8df676960b14f8062b0d52646273de1847521421bd8a86a8166cfa1baf11085d4d38c76a5a89d040befc6061f2a438f95062a3363fb89830e16cfc1fd392f6fbe7e4256c63feb36a72518a49aae2227604fe84670072c936b1463ef70977002937df4346f5db5ed8b8447992711b5652b8003328e1a797e8e084dc92f032044eb4d01eaea905c1bfcc8c95a736b6c5c6754ff0f56d690123a888174a7a77c57af751164099a0dec52abf926107ba25331261fb48b9935258fd990259021dd771a5e4c0bc21a2f22234009f0e94ca40a5f3b4ef80b82cc7dd2a0033514c38c67af955b3cba092d10db02a9ece24e005fbf45c56cd1638b6cd3379e5e26855584185fb795aa76f61414ff7adf79a89eff76fabd58772e578da6ae28fab1195a59c7207aaa4616c84bd108ecc7cead66151ad90f1d4442d7453c44a53d7844b456986e405be4ea702e3f95615a16743844478bb7cd9b36f0dea30f74327cb4cdf3acbc1f80c214bb53af01ba86af867ce7c1d868b7527bab4cb8bf7529de6f0fffe6fea344d366519527405537ed3cba4d59f4bcb9bc95e66461036b6bb10e6cbf2ea238e05b1d23f2d507a5f1bba09d17bda158ea1ae37c125ce67d96255c28d431d2f36fa97404e0656032a642c9141255563aa5d43807a2b192b0ecb840f38d034828dc627a6ce3e49e55bde0143df6faa756d5bf2f0f3c6155886c57b2e0ab3ace08d7209ade57e4de3ef25919080abdc54cc39351b4fc0e390a1706a4f6b6e983f611e1df2172084cc8e23b5df53687752c2eac05718b7bfd406e95c5bd8f0dc568bf5129707169fbc560ed98f15dad917d3ff1f8e9fcd8aa8c7266926984fc0fd9b57a48dc6eac105b1bd516ae3e45e4167eabd375b13bdb26c5b391c4a3151abfdec7ff9698ff20e275a4861d09d2f600cae3d7e3d944ea132f6e0304e1ddb4c29e49e18d9bcf6655fd9acff977996a656758e131c974f77023de96ba07b7c146e3b1db95d9763ddca0473d4efc0b5371343d8092552a5774d706c84b5e064b8efca999a74ac3e4167d37e686147d0305dc2fb0f05879a5ab05cb78693213bee6d17ad91375548ab59724f3cc80fa4d142c46a352526968891a39fc1bb36ded9b61cc8e1582a95cb569a697ef1fce031a0f162f2fb16d278f9880eac694a83b4b7421834fdda93e066da6a681f830238837c2e905cd48de4664ecb1447b52b0e73d26c556056f08ec1d98535143c8e85d226af6bfdbe678da063a6bd77e7c6b1864844e3806b1a4704bd7aa1ccb609cb6f719367f3f3d10d3d2dab0355e874aa56a7c5827f438f83c1a133c2adb5f9327ade71ab1d1e234c74d2084539e43961f5ead2e74e67f77695c46f810a02079430eba00ddfecc51da16c6763e87df2f3641b0bcb705321ac0fae5371f91c0646cfbff0e7416b4269572a8254f9c2a4a45b638b8d0e4b19bc559614fb1fdc9ffea2a67fae47956e73dd86db441e5b6cea46204305311ed67570300219ada76d98847ba1790e92d9c9cb84e9761ce87e513ed292baf54fafe2c705e83a4e529dca6ea2d3502e778de293a362c4a2a660e7dc701fd5ef2143ffdfbf08697089d8c439ef651b6da57e7a5243313feb21f21797292de0d563636956273ec90baf702ce2349653af1e91d58987df89859cc7387f942a7fa2e0c8cf3029597960f32b149cfc6f23e0487def1a4c479c9196edd765e2152b489a064a13fbef3ce734710ca2f62c2a21bd05e983a1c9f3d621b9c55c468fac8017a639260ef608560ab369e22441422f91c862e09ed928df215e8942ffe40ecf0849e86250dd6e488c1c494f96f26f231b1512ec5a6582755cde662caa160cd45a8d0a54421f6c6012afb0a22d40f866570616093e790786e74580c31dd97d640da2bc748292ecc6c4d8ea1476830c211b1bd4f175983c460868ba68580de3d0c34016e79648733494e021ff88620c08f69d3d32bc268784e4081b6d706b0fe871b9d7781836db1791551b29ba268ce20bf9adfff88877e68761e1e148e51cf43587c531ed7cdf411d14689153eb356925e461e791bba221404a7b0d86a3b01bf4f9b693e2b2c6cbc7ca1b217d829c1313a2a4daf0c589250662b03ff35fcc1818361adca1b2a1fe0fadd8f7a8821e302617795641764e2ce34d93da1934c4bd65d6daa07f9cbb6f92b6b57235967fe009d056fe7a2e067509e30d5326158fe6d3998170fc6ecdb1406f51921ff9a8d97485f5037caac595f2d44edf66434e6d29c9ff495394b88eb52545b1e7fd89ab28cf7739259d74210fb3a128f79e19b677a0ee7d8c2e29ad29d29701b5fa4ec44e9dba563cc20b938b10f9b256e5b80e5b36c9750905035f608073a3c57dd8acb19c2a6628ea23a6e0c51483e91ef531363f8eb6e750576dbe5f74f1dcac412c02cf779a3271e6d29dbcca4d391db16c9dffca888ef1ac5c4ab551af25b2d8f38d3f5d68b4d53382edc3f2705dfd8aced4fc1dd83f7a169cdbe73392b33e7c4b7898967aec5d71950083a56bf84109a0b9c81412f523670111adeeee79a20f2ddb54c941d26916dc4c11583a01d3521d2f4ada6e28874bf557ab0fb4e19cd392f85daa615d1b99217f1a9090b5a0336248467026983aba42c8b72d71633f3b1f8a8bfdfc3ef7958edad5024f6e49ad3ee0315becd57a28143318a341d5f0554c6cd31d5071708c6a6aa3408732a2ac8405cbc5eb303ea3b882fafd91c6ccebe5507101a6344c182f7335bdc4b8e1608b48b549fbef97371bd8ea22a149e2a5fc85101232d85c97382431ae1968440a86d3e4f60070ae888bb2bae7f5b5d120f281d5565c57b388ecebf638c48ab1d68d5ffa1979a66778000faaa6c0fbdc4126a487e7ccfbbf8d936fc8987443e1b365d0a0d4c529375d40318dc94c0da5cea8413465ef7c97408aa9c8f0260b3b311cda41f8ecdacebe0ca8eda0e57ca34996e1a32427b2d1f1d2a72336119f2c55241d5131d23b39ce195023105da7a70ff91ffdc7545d2021aec29486df53918326a3dcdd7b7437d74ae681892db1221bb84b5d50b3a214cd8388ca93ecd4de610e39609b0b7c242ae86ffe316f56437397783a9e33d6c2bccee9f8a11f2e5d876082356607903c0aa298f8d5a872b032f22491b077de5b7354aa8918e5da725872a31dbc4f5def826cf44dc66ea662b789c4b2176feb2cb428e1aee179363062def17ba72413669e3e57f83e07645d9fb5089876ab796cccb11a1a50decdecabf62bc24da3eb0549bb823fbef5d21bb386d7f5b72abbe05a2903c8f6e952febb532fa8ca7ed44e9b8d2724309e4700661b3e7576372324f6368d24c48f9ed63cb2bb3278cba3691439f0275b240ea65735849f1c3a12a42365bb9a2519eda03899353900cafb654a166c578df9a68f2676fff1afc3198cfa9aa447424842749e5577e2464d729f2fa80103a26d8c566c18dac33ad510d912777a3901f5bdee8f59765543fe699e1e0a4bb657045c9d88fa7f3636cc31cecb252d0dcf85783152992634df78b72c6041a7912699e78c1ee41f32f691ea368252b7b2cc67444c9fb1383628d5652328b56476f10c792f5a37b8bc016c631a11b45dcbcf8d600139a0d67723fcf47d3af45a34d30d15d5795de0b44f6c62a06331e1a4a62bb9c50a7872a4c8191755c347ae6fdb91ec18d7fdb801613ce0807d92f431989f30b60b8f67c59e101753f0813e18ccc21960ef8558ef2288ab767856620f7ba850116071e483649fb07a45cdcb841266167a8b374edd64e2c33678e8f9ebe2401908ed322efe7a1d1ab98d18c03352003a9f5871040e387e4375c817d8abcb6a93e636f61d7b81543fd2ca85a5ea2517f7b5c5b2cd716d7b29eb50ccfa996d232378f7ae875293757661a6f8dbd198b109d4cc2d159c8eebdaf76791c853cb9856f47ee6fc4aae8605fabcb71c96a92aafcb7f18ad15fa59feb059b3bb1ed976c03cbc7f678621854da0989e75fba5a8f40ec02d3816b403f50b00944a32953a99aca264332696eddb80da027620206e73117d9718f17518e7d4246e38b0f395ba16359a3793cda00d1c22242286aad6c3f500662f4da148b45ef3ba41529c7cff142f208fb628dc671197e074462e630a299a04fedfb751c0dc3e46d19d865d5cfa7de35a07c658b9c4eb7aefdf348a034089408d59a3a48b86930649ba53f47c58a11de3c4722f663fd27a68dc786fb0e597decb3c0bc36fae0cb4cab574cc7b66546a5e91af5327419d7e17b5c08a66785936973ea537d9159b0cd6d6959edb851e7982716851cb857257f101c49052d9bd81a6ecb2e87e5cc8393c4147e48f68ff5e6a9918a0832e2886010212acd2811d251aca60caea4f3fb39010c2e710f8129607f364d9fd1eadbb33a087ed5e953feef6acf5cbd082f54ec29807d8c9fad3748c3098b0ef52c64c00ad9463824935221fea93de15e386b039c4137eb4f47346655bce1efdcc64f60e3583dbae1b89acc295ef491829af6f0c516e983bab5bac3dc2b2831ad13991276b18c3a9fb89621bc735e0408f32c413279e3474a0a8b4c8e6da3b56dbb0914b461884972b46e9015908b0d4081a7473773ef60b9a1b0504d8bd5af904a5b4ff59fd53e2ac815bb39d4e3c791e7c00eca3012362f09935310d687ec94d1c1dd277912b988de747e1531c6d707f3b5d8c86080f9413a1a958f7b0926359b0e271d63697f20af3ec14046b12a68ca33d1380a705dd5e86be0676e9cf640f646d55e6f8650da812a25c2af7d5e9ea5b2b827d9b418aae15920c3ee8d2b85abda6dc3e18164baf0c308143befe0d60a3ff7cfcd964c2138a8848371092a503a2d7b587a11300e576bb6b53a142b8988dddc35acdeaf4fa06b7369a09438e1cee66fcfa34a9dfe1d2f2509db6c3036367ac7ac91356198c3b0cd555a43636d4668d26ac6c168102f72602cf0b624b9ad08baffbf0f5ea74ece0a3d615d1902570fdaee48e7cdf9c4d99fb3c7c981533e58e79135497f55aa63effdffe3efcb0678d4799ce45381dbdec74dc41a3f45aa5ec12d3aa99bae349d3c6d4118b6678521ec2e51a04c2f952109c9eb199dfb37566a3e604fa9ad2bdf9f789ca455786d2e71a2d3682a15e8d53ef508d58992f6b935a0879cbf01055cedc40d45bc203fd82dd8b53130b8c03d08bb018c1199f33422de4444fd72a15d749e410ee25490f78ce6d788dddc283f06f36347ccf16d7f3a5ab98080dda71111bea7b55c438b25ff021aa47808c7a00f026a290580045d9e6cef62de70f2240e022fca2b761949dff59793b3f8095957dc376d73e97d1dbb342127c7dd6f637523f6d6f7a6e0c67d9c4d548bc7226fb013c64abcaf5d37d87636ea86de51dd63264f139158d96b8d060a135d35865a1cc4632a7edeb791f9bab394a5ff049f326a54653a14bed7c2dbfaf7d4c8f434950f62989171f8ddcde6521d38e21fe41be2018124ef5594212c52c06e6df862465dce347e7412b19e3e7146200261ab2c8f934deb465461f0b979db3f1bddc2012356974c730307fd232c1d8c0178ccff29adaff3d1e475e693c60893ba289a2579d64c016cfbbaadb2d5ee295bb3cc2984b22ff03a1e974fb7450e38a11cce9b51f3fd51b129aaeb558baa81e61857a1b72847f0190703caec9f0eaf4e48de5a779baa3e5161b4a9e8487a3bcf4e8190ee09aed764a622784393fba360c6760e69cbc7e8fee4da59e53a213235164fa2f719f63ed1a048af7232b47b84cda6da2502e39cd2b02a6d93c57fd2dacb69f64e1bd52e066f99bb5c7f33bcb1386f54e99b44f01d2f17c2c428bfc4bef196729962c957904335bccd064f0a1f7d6703e6757d2d1b38720f2ebf93b02e4d1df612e8aa3b514137bbb8b4ad659c2398b954e10430805c4b3b75a8ea06be0d14c19b86666ce8b68adb5898e1795e865f638eff97122dd53ea9b51538e478cf9c1f9464015af8fbca075810c461a7c603e014001bd98b8e13d43848afe385afd02e9a940c6ec71235ddda046a14be7b2c59096a9201563837be90499cf7038db9844ae9d224a25c64dd4f62a84662c8f031cd79dfaf88c3c6c7610ba2166cd4302d19a058fdf4cb5dd5880684c4af4f3eb0611805b81f7104da103ea90a89c47007e431002354857a802c22f9daae49f5d8c6778ef0f8b28049f132fbd1fc135532e29d4571e69681ea271cf3e71735c284959adef2001483d4438360c72eec1a5a781d3e166605653469d8757b979191f7ac81ca0289ecea383c0598ee13aadd6e638a037271cd1c64f725cefdca9fe3c3f2b84990ed26622cacebdb733d63311fa681329e1c3035d42355ec0fa313d25cfb936ce962b17933ff66c3e54b7913f04a36d2965d08bd241ac56791ebb9908bc0090f53cd1ac1d9414c6f5e42a2a2bb803b0efc2d5d648dee943661ad1abd23242d43e0fd8963ee99354bb51c72beb8438b7850868afd0dd0116f37c824976e05ed86f8201b95a054739b4b8ac39aa8d3e39df0c8080ec330431aa481b11634689891a40e301edd91cce89cc6910c2529680aa60d149be133b922f1a460736c35d32f394e4ceabb1a608c0310ee6001c1570e780fa3c775583a594fa7b120d191f06cc0ba7a0e1e844067a8b57a004c63ea603f451e7ebbc52875939cfddcfc2243072f8bb1578224ac798c736da77e03a0808a0f94e40080d3f5da516c42ffcf4bae69cc6e88728d58c47ef8803ad3d615930b98c3bc7cac48bdeb2d584b98b016af2661ca81324d54e7d05153f212fa068c0c31861630e46be421ba1c0298f3dff6e355a52e98ed7c3ac43f09689d7dfe3fa329a62e0dc3ff49c63bd5f65aca5434cbda0e404f3d5385b268318bf78217b09aa799bd3673e666b56a2e547daec0664d6ef0ceb92f0a614216085f1698f612f1fe22a001224bde28d254c5836d3cf6686f6b3045702a8a48c4aa90104007c7f7afb1e3f77c2713f3ec161ba0e55d62328a83985ed1434b0de41d6d086b5ea3ddd6afbce4422d0820c9590b509ef9ebf55c44131aea5a207b864796230ee4d69e7c3091673f3a0fbf46a9427deb8e13634c5f5b9c7a3b37a14aa7ea3e570dca492d3f256214cd2fbaa2a300515385dfe2b26e9b0fb005e653d604908d395235cae45a61c07c199d647743bcf8e27a0289bd2a5557326238d401d70ef712509ac9052d9bdddb3caf7e47ca84df2d486e0714d007b7cc5c2111f3dc56e986ba6f4eaeb2b14993c743d089d5f766c64269d3eccfd0d8845ceb8710e2a672b7912655558be47a8b9fabe2816b3b9fc175813bd68128a45d79128eecc778b30615982500e06de3f0e05b12a8412b6cc342f8f57d5be9cdd9b27f6192cca380348fa48e400750a21a7a40f8308db14a94b5cb8f02644ee96078eb786c8e8d8af8a0bdb53cc40a04205002b9437e858b687b429651fb608a358bea057e011be0495ca9ff3900bdb1dcd75c36d2d6195436c723ab6b8b215289a1abd3d2f4bdcc3947628535164ff9786c5d1e442b78f2d87b372877d41c8f78025aea5b9aa3303041a367e50ddddd96ec8f4bd17f7ecbeda0a1881bf753f990541986b87cdd4966cf94af46f71cdaa4be01224e161c10a4f1e3e639a39f7c0d9e199b6fa8e6a4f7d45be7d17e453fe91c991791a6c795713e00a4298d1b9a0a5b5197413687c33ae865cb41793fa8275b5e877de3ef064f3d92c2a7d963a88ebb121cd57a796b3fab12c5f74374ac25de94e9c8fa4e893b5dc8e744d5c9a668a99fff1093acd4f47a990f8d68e192f4e2a72580d3614afee9c5c4dd397fba4cdd4b349197244d59155ade66b1ae2d6ed83bc5c2720f33509bfd5f7f91317daf586430e198f657db3686ca8b0d618890f8789036701cc1de07c432f8469a6722ca38053fac38ba5ca8f1647c8a151f5bc9005ed54143bc5df8e935f9d1357651314f0ac8e600","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e32b2872bc29ce8020f8f326b3fe9d3b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
