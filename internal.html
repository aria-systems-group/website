<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d3f148def3057cea0ef08a81ac87003a426af04e676d85fcb2a59ae3001f348df2f1ed486113298cf5935474ded3eca71e3b2b8472121bde0c5104e032f8462af7f84aee93cbf7b5c5395aedf4ca024890addc7b07f041c70861ca7a357532a783ebb06580fddc8ba60c687c6978367e84db280ea8c495b7f0fc84eaf8e45f902043a0f8dd8d87f68a9f5a86a59f16fe989e4b371cf813a992274fd6ba4aa267efa6dfe417feb69abed43fb99a5f1ae68339bca36b4fa108c155447effa123193a1bdf604ac487a755bdea0a47ee3b323db5e7b23e4382bdb453e6fb68231c287a41adeb746225fb4d53bd1802205c03bdb86b99d5a165ea74e0744540372c057c287c55f7bab460f21ea8465e9c1989e2a21e8f4d844dfe0e8d158fb9bf0ddc2881973e11082462367b63d26f4df4ddd3f6d0af8402ec890d556ad3a1205d87ef0d0ed4136c96e9faad657dd2467fd86d70b35e74091447d56b8f779bd4dea3901ce48d7d11e14361a9f6b82d5249ae4cd90b610b0ca4701590bb72bb2fbaff22a358d40a5a0b1f957f44f5ecf9b3ef4593218da93716f587393df8efd1aa6be1dc0edf66789cb8878fccc175a5cf411ce5b6c1c164bc0d4b2324803f70bd416b95c5ea6d73598de25a89327439ebb3d86bd856fff33e9e715f38652eb4bb372189f6bdc9d28b3042be67c86912214d348a55976fbe040ee650dc2662dd33387f72f800a7bff32da409a75066d4911da06906701cb97cedb046c5ccde8dfefb93a290fefd357c5c01f7be7af7aa554c5d473cb472df64d935adbfe53605ca27b86a645682980ed0e0f85be11b2d1a493d99cbd7f6d72f642857eb048a2444a369095db352c994c33ac277ec4569a1d9c55aa30ddec3dae116fde0cf0d5f9e2c2ebeeef317adc5d1813a9998b89df79f438a408c3d1bd7dc905f21ed234788aa05410d9f3798664934023885266ce1f0bbc88a372a9dd000d618ec313ea7965d3d013e01e64cc566638d48516cb525cba3fee001b2703821a3c5bd6953d9e0313004bcef7db39c92a3cae5915c0e7d36bfe1df8c206da85edb23a5a896b265bdceba007a405bb27407c989e6e8ac9492d36fb1a96da31b6b90504110b1e20feefa67c086336bc117b7661a09ddb56f01f24b2332383fab596fb83cc0a3900cc0678d7486bcfa2ac57d049e5a6b43b4058c7261f4a7c2b65f2c445f0ee81a75a51b923002c5404995e19c2fca070401437c21239c88a332affc86f5fc4fce4d14b1f1a6a861f1315634c571e44bdfcd8beaef8bcb645e342c3fd8c0bfe913e11309df2e24a52979cd29729fbe00ad80b4b147d5be75734da6b976848cb8d96e4502154eaac63ed4f1fd0398118fc6d4ab60d941cfa200bd719fe37a99127fcf0ed1874cd6666f07efd2fb4c2e588b15c71ee86bc56c2f2d8a6c8f36228b2eeff34943f11536bb05f6b294a7825e893b3f2950cb8a081529c854d56040c14059c4030fc1a87036eb5506cec85f2a423eb1b08e520b7c8992348d99d453a7ee01dafc0306c47f623ee0677a83de2631f2a1f9bfb4d926d800d684811fb7ffdbeb93570a8ac23b2052f94a5879538093ea580aa0b3f38174f44fbc10ea104fa9ad94e8c44a54ce2c4944cfeaee2f4e34ce54f982d9d275b70debd2b7bb803639afe8901566ab7eff9d09d05878048bb4dd9c4ad64177427ac253cf65104a00f9bdb7af323a76fc3b5b9ba8b0a56d14f845729534959315f242d87ddb6bf31fb7990a71f8ab6cd81e2c795cfcf5aecfc45d915e5d79e6425e1e40e0be910616e510f92539b6b786912c3179be8e20c08327ac121a37e3f86277ebb72b17bd6a76a6948004bc63f683c9e0e941f5f6be5af009e1bec65426383bf6ad9a2fab1be27da0f015c7d2e6ef82e772c2661a16d72b44f8a80dd237ac6e6b43f242d8900b85ef6155595112cdb7bfa2b05840296112f1b1842bc773fb9a9ccbe83329d267995d273c61cdc728d774be7df9479577c73dc6a7b64653117aab5bfce9714486d405085eb71ed8aba7245684cb9285ae61993da3871281a799176ca5748eb38a4b7b50436bca3a393af00f2f45ec5be38643c952df4472490b6ce0a22b12bcc9e188b0be7c16680031e1e3302198fe3b160cd79ce8980cd51fdb830075ef50586d370d853a68d6a6a6b26fcfc5979bd062bf65df86a3b6c16b1c6ac0b0d7c2d4f2c79c603e806225194bdc94544b1614799f1f25fe6d029f1b816b9a36d59e5cd66848b5f38521e32c06c529293ee72cdb5805841d5a68cbcd9f10dec2d4cb6c8e92814e51fccd04a9fc431e91cf79f1e833be1d76d02a00f2413660734df33de8969d82b68d85f98b90f0331eeed80a10084382ca4762864cf370bdd6de6fff31931114662c142b1c5d4f1943096a4abba4f801a369996f3509531a147c6bcb96d06b94ec94ec28785f5d529f1f419f7216296c720b6cbf66efd6bde3aca230a94783d68b8e3f726a83a0cb93cef65e586c52c3d357938fe6cc92f44d711eeb23efbad56f58d1cb1512c61d9001478967b3bb7c38a1e2daa2fab5a38d780d38a0e3186b24960d3b26190cf27fd6158df14e717c0bead888207a5815a8950a0428d7eb129ff07372dbf0163e866f340cf56e0466d06e24371e60dffbd4338b051439e5be2af5518d2b90c0ea9cd7fdab6ec4b06d44ff62509dbd7c2d7a032000b274171ddc14a2d13d1991513a7093c2bf42fb2a1d9f873ab08a586976797c118ce375f5b94e810b7856161c9f437c37e4de67a4040277cc9def5d74924098714918a4d5ce08ee979e1b8d1ac316b07432630dfb85fe4ecb1ae948cbb2a535e0a89827459f13c6b8befbf1c446b8c1b704c6d9403a82c275c81d742d19f06f17f696225ff23e0aef9c33642ca3ea79513dd85bc1c28134c335603d49c388de756699918fa2a98a7075c3497ad075a38fdacfc6de0730eb79def41304814f0bcc482c91eadacb7342581eec89609a929d7ac79e43e82e3e6c26b589169e0ca503df30dd32c6ad573bd4a3bdca4450eb130bae893e8cd51fc73134e27d2ace1816d788c345b933f1d4329b8c9cd9db7dd98242da8cbbf641b546ded536c9617306d4a67be77abf9eaf9a3f38e59f725694484bad77408c33060ba561b7e11219457f7cd3dae3b53b41b0c2d518b0aca4d0a491dc4cb42fa87d141f6f74356e2fccf37cc1ac32b1de5873856c406e225ae7c36f18614ec97637a98ac6f92c129fd8d92b179621cbcbbd92ead296a4e88c8b43c094e98263a2120306eca331d2e3126e87c97fbbca5baa8a6070e63ba407bb2b7d6d589dd403992332e5448de388388135890082e83fa8ea95929c487bfb0990e7ec70e209e0fbc727c0f95098863407fad78d5bbeb266a4e20acd217222f069fb12d72d44eb7021974c2e88aa52a43fd848ec9f8441753d4a122e1c7cfb174f440f59daa3809111c4afc8d73d18bb0938d88eae6ab20c7ea0b147ca971abfdb0cecce30ca6058b0f9f7edee3b1dac7c9017e8e01f85563a16d690fb74da44f6eed1e102b4913e869599721f3175e8574747f415abf8b0015bd05c2b3835bca6e2a21d9e349c18f26b677454a1814879b36151231b38bde08843dee371253b425f2407c924aa69549d6002bb800906e6fd64a92fec3de4cd3c6404403f57bfee1b889e71e13629eff9acc7d5a513835581ff4b1ce58894034516a59a90f7a621e57a9bc125ea328291a27cf3fc8b1e953925e8d915d044e059a8d1ca905acd0428f32f88d498a7bcec3717ae3ab5ca129b7989c478f524609bb89b2c963b4f8ce934edc13f100072ae8c56e304ec616ac378186c725899709912c4428abad0dd9b11251b05a09f8c7d2bba5a29dc52e11df039c628418508cddac8d9a20d387507da673802489f28a295be2125a1ed4bb7cd41f306f7f499f4c7fe44c7ecbfdf9ea67ce99f927593502692941378dfd6c92d33f4c995deba978ac50e2c4e2fd8fa6cd04dc6ca54c4b9c36f3b67612a89f84f82d6ef9f7cd048b46381e8b08298117b1fdc7a68f37526ba82a8914af40ddb78e30b9823be1c67480a39178841927a445f2565d1680f497a2e2bcd6c9845c80b36074261298392e0ac84b8fbe6f2943627aa616cebdb49aab099e8c8a05e0bf15acacd22fa7ccfee44706f17120cf75e37e956f492c241603ab4411af5781632523cf1228b47a30e2a4688c692350a1e5bd35ecf37753f872abce0ff0004387549d20ad2c0e2547e15ab98c07690a4eb2e53acd9271a3da2fa30e2b575d822e0abcf8d28a2c3ef7888f5bd755dd11d94e4b19efc002645715668effae27b9e14f2b6af88515934c22c65451248bb5c1e236dc1457d85b836e31646c2ebe9bb24da57b432c0159a9990a4add1f4b2ae1fa46c4269e14a4f85c30b95a15f35ca5ce8c59fe8db1678d1400ddffb1252426d3c65d9b411ee65611fca25d055697f867460f5892c4e9cca91953c06413d693d31ed5304a1b7ff334e626b7cbf616891d1072991100800c3da81472a9728eb77ba5446bd1539339f986624ebf5e7130a50991c72a2e349fcc460f663dd9baa1ef876730e51be61e399811791c271e0e8f7cc7701bdc5b2f5148efbd15f6e15f7f7e7677f655af14d7e50b1d35eb178aec3f159b55e8eaeb5faadd09d30b0bc6eaecf889fffaacc73bd692e007db600e72075dde7a39792cd7badaad30c6e36a2365d7ed91a6fdc5a79bfc761ab0f50d107387a97cb985ee87cc42848848954f86bdd160f2f50d7c966893c4e0862be538d5c7f21e3b0fe19bd6b579e374d12063a43ed8f96a49b5cbcdc7308a16573309659c5705e262b2d2da99102e9c6c5e66427fdd3255c503e0b233a4368bc8ca8b895525bfe64a5ee21b2ec87f90b3379febf03f1d72d8d5d8fd1923f1165451bc55233be0904be8482c340956a215eb2aa9c2c341765f9e6ae2958460f82ec7db20a1bc4ebdb917712a4bbdaeee836330e2c8697cdf73c0c3dd2a8dc292cd53cd4fb4d76f7c7bf9f1f7b34c2f9c8fe809bc188266d0d3384718310909289a5ee1293767dc0e9073a8ac4c5ca5a0d59da470062c55b6afe7a02adaf5f335c87387658e804d2f3351f6f35b6fd0ddbc944b787acfd6e07cb36d8dcef94043ae316259c6a92d61781872b96d21305ad5a7985bf1d0c57c95eecb3203a688fb8d0eeef38b102050f6ba3c727023e9b71ceb85f08abdd46859609f2a0b2d3fdfd9755ae8a1a263271cb3d6ab057ff1817ad6e3ffc6df5124355edb6e24fbeee9ea65091f212e3d25b32bff06d2cdc19130b7b46e8f375109aae44b0243f94f262ec3858c8b76b369dd8a3c32c619828f5130300c4f4cd910e7e67660aae2cdaa033049b832fcdaf26b206b2abf3323503f438a85d287ff110dec796e9837e6dba48c7260b56c75f9281a499c30c82a8ee916007411ab94517a5f1e0533ac63615f5419ee67508beeb67511c8c44d89ab13d59146e2557d55f909b2f226723d559289b33d4519d5fca5b2c60008e3696571dd3098e13bd3c607bb5b92838cd06e9a73768fe188b4348c0660dccd3d5c8bfcfe30b51cb27279eedb0352132b76deebbd4e094bef8c7dadf59c2bace28094e2df6b692dbe81acbc1321e36eaf10c19ab3b0a6eb5ac00d01e47e6121f2d8ea776903208408663e3900285898b39f93b526fc27e48f416f9671594960791848c3c57613c17d4c09e9d8f2c7ea836fb3a9441f3ecc8bd09512271d8355101f95dc3c6e45f175fb1870d2650c8b17336a6a1dd1b74ad6d56222b00c904007f0fc59daae6a23896a6b2ca0af781fd2e9083f60fc9dcf14cd24d6a3311047e1e361543bd14d68b226ebcee6e59c336ba494bffbea33f0653a1761a3ff405a7d854e4423f4cc8bf323c9be17274c779fc411ab77bf6408105d45e4d767b0af3d5a8edf589e2b85f2b9b39d2e78c126b378c19ae4ea30c4e9ed49bc448a410624161a2ab54bac6f9ccc84add6a2e122881945177a7c3fe72e204c25a49473ffc6af127a198bf8016666c66e7821b179f2f374494ec2631423d58f005310b6fe10f7e0697513193a5102a9769fc103f21ea39b7a11345c374a0fc1c5f5b4e8c585b80ca4d7a02fb5496622bc4c70e478d953e508d5d920e5e6b43109788a1bdb33b34a63be8ec24eeb80377034aa231bddb87a034edb7c5b83ef38beb867aa57502b503ecdd3658d06e88acbed34bb82baf95763cf5e048693ae8e2034b83098868e349fbe0bf003cae4081fd7c3a6befdbc7f4d251b382be0eef6dabda5a2988914579318f31c1682bd227aedf2a31bd124b3feb67bcc1e3f6a5f4e07e393a3e18a2556fecc304601375f88c7b9566e322b6e5cd2b6d844b5e2a69e4304b188a894224556a6e32e00a7427e1f66eedfa72c8dbb900ee95f5a80eb17f07f87287cf5e69d2e0575c0e9c61b3e87114e4884e8db72e8195aa4177bbbae47ebcbdc8ccafc256684c62c3ba9a0169bef0fb40b4faab50e11690d885e097b8b8de788faa0357164169676fa0aa83724b2b0e69ac68c68b3a39edca1506bd4fa3cf929956b699def6f08665378706b1eb1b11212a002e95bab1758d2c6ac8f48975ae70b11da0f0b6977d9173c7d0d8c6aa2f37c76025d3ac9f57bb5822e06c488e51abe2d3b4d0375dd8880bf2a16d4c48d0a616fe5c5936ceb5174a3bc1b5b835f6f9590618f44a0fe8cd4976a105ffcb570b8c053698b7fe7b9cf18886d048b8ddc9dfcfb096c78680cb23b793bd2f8420fb8288f6c65a74ea89c6dafd1ea9a134202d9c223c6e54af12c07d8d138ac090840ed881858c084057793f95eb9a8a286f8d56e43c01fccdba0fba73cb065e50ca68fa52b7e81202e7eb6e9da4ddc99d9a0fb9fc949e21d1256ac645a985bfdfb596f1ffa33bf8cf0b18c150d5d2bbf82bfcb4c071a20262723b5a3132f6cf5759ddca93ce8675e162a530c2acb9188a0132b01cfc309267fa9c82ec8292fe7ff54a7e077134299f9a60b86eee8a72adbda29424bd1730155f47b5ef27ebc95ebcf32849631a3757485b42e6ee00421bf64d31d042d5b38bb770415a6056fae42abbe6ce5dd9eb9d2b9159789fa40a08cf1ce988580115e10b686e7e801ae0098421c1035e51ab610a358b1cc7aa74a593e00b47086afad19833f4695e30c3056acaa704fc0c6ee73edb610bdf78b78f3f677a741d389db8c277f206b85290b026d20139e9ca9f82c7cc6377b5f60463cd140e277f2577084ebf06c9349c22bc94346c1aad9e48b34bcf3aa7b7a68284942ba743e0efe37c58a20cdf8145d649547a549dabec196d003ee83fa65bba5c8c98576177b35537cb990db2a409fa2c128e2b93357e81ebbac7f6b1d1be740266602729ed43f1d776c8af5ef95bc688b052c101dd61119038175ab6771e48b27075af75f8b33de98dcf3257d5b2687a0ffebdb69854c7ebad2d1ce0aa3580ac0994ddd4b658b91731c4e7f4714abe10429f6a0323635cde74392d613400b0d69b558440c3fa55b3964b732a7ce4612fefdae53c5d5a6a0509f4f04cc4578aae5206c02ac615cd18f254ac3d71c82bb7ad215b59b8b9b0e345a3dce6264c0d56c1b1577f29c47f67ec28dc299f9014c93779928c94a89e4f5cd512bf5bc5790f8635c334c04bd388e1caf71aa39dfbbfc63cc16b2867281585a9688430dc79d4bed03669caf2a2810d81d684985147267ebf74b3e1066d0065753306be92ad8c1f2937af3e4bab3c2fc9a24286794be907c41ea192fc6132199ea0196c85c4838f3c2471168f694482aca3251c590db77037ba1f4654b727ec8ef0f8336fa794d9bfb61a80f20b8cf2390c883915451a3061482c0e40559f50c38edca214f16a81262a199bae60882fea9b018862ea610642624d80a6a0de700534b4c1fcb8a1bca32ba05024547023d42c1a76ccfca9c1e0f61c6fef275938df5f57efe6490c0adb439f5fbdffeefd2facf965dbc4f8c43e21065cca68b774c0c9e0a23d329c9c35906631a86c8872c6870c6d06994d4ff6333d4d98f4590acca5ea27431dfe49ad5b7c3e6963d1b88cd6a832b6f05bfce8ae434b41e5bbfbc6082aeeb05e465b8eb2385a9d5621adf542ec194218b8aa2f1c3f7c77a754db7120e5a7b5d7143df1e6eaab19bc9c99eb82d99f74892974c7b9072bfdd88e2fedaf8249bba981dcc9220de55db8394c7b7803e9abe7ae1bac076da9958fc20af6417e122f35fde048d2fc9c2a3cd836825152673ebdacaedcf5671b3701b0bbe061254f3fec209e4a68e08a1d7483ecaab7506465bbf2825f3e078745a8a3a10eef025fd1a5cb7e7e6bfdeea59550f791f076e1a46c8de95b578952a1eaa1386649782aa1db730967825f73cda7e70da72393ca30e0338c13f546bac0c5a1e234f2829ac3aa7cef250b78364990610df759616c979b0ac9a28d8f4873224f316c7fd2f1f0d626ddeda3065ed08bc5280bc11110cae9af06906f5cf93e2640dc45c48907a5ba795d778190f1f010aa5b0fd45c25be76581b1ace0630da3ef5194053ff618b66b721a5b5be8eacc0424b7ef0356603d20405aaa46fb8169d3c685d5b0f26932cdc9f194de32a30b0a324010a2b8ccba48d7cdc2cc8ea294f015cffb40bb62b1ee23f10a6cd2fb841605eea44278113c1a799b77bcdd3f50893214a64159ae3222ecfc26ebe4bf1f0f25e66e6c2600a8449a7e37173a0cb6390e9bd8b22ee9906d915a608162d560f37ed1e6e94a65c6a476d3cca80092727b9485e70ab2671d7e48221f063a2c7ad738e82e481bede9040102bad1ca9ff69c74a559702e8b745c31972631d530b8471cf648a41e1b73e0e29004ba9224aaaa9bcacde00511793f7cb93a87d800dc95d0ec5e2353b8c86152a9b78b800ec1b927733318f5e742073c6aae29202401c6f5ae082bd043d08123197702cad9f81b8e881db3f1b11495635701d698aa61e78cc5a72b927301f0c463694d085487099ca7d3ea367e63de3cf6e77998e9d777cd6a797fd1436c1c3a8453605ac0a57ebd4af2689b720b81d5c33b784ea9a42d35c73c4638f4cef761cc06f6a8877efbb499894d2db4c39c4259c573bb97edf114c923748218446095d8bb03b03fdbd9637e7d2488a3b560b4bf7a2181f10763f209b66fc18ee773ea706cc81b85ba3ec22348ee21790f22626b727bdfad19bdfc44250cd3a0803e086aca977bf70a0f24fd77b6e5fc655fdf8fe25265b97fc14c7a93a7469935f686239d3497123f5156b8a98b2a341b3a06e07b32e981d8c9d87564f26e381b5015f8a79bf93f79d29136e7dc8d9496062ccb8169c98a6dd336a829983c0f419f85a39b6e416314333647c72f53c1aad9e667dbbdd327fc81154fd1b10e21015a99300464941eccbacfeac906843dc289772808f3d3ce084a2b387e1eb2b01b8506b84c641456c010f385cc0186455ec70a67479fef67f3f10b1057d2c18432c5a9b7312cdd86eb8c0af82fc286fb39083abcc61c50c9dd1f67b9990210a0f1faea8522bf5ff95d2172a4c560b097529729e4791f50db63924a146685f8939bac38ff0d13529a776bae7a518562f1c49a174e8d58096800a2c52753b686ffaaa8cdfaee1c9b42dd7dc3806bf74a94391efc6134da2ced1c10c54109293dda60b69431d1676b6b8efd9058a80cf108b066813f8a72bd1aa5f6c49994b51c5d3743bc22e44c66c2f5459c3fec8a618e3399b2a560bedccb55de4ed8be02b5fbe9ea869bc07cc74345aa6af6d8fb0e283ce0a7d1ff03a89a7597f727ee67be44a76af3acaca08f451d197381631178f5198835eacebe41d3a5095e855250f5a967bfebc4cfb30d2646339497d3646938f36a4b31b1323cafae6f07ed3f2c91813cc7a65777bb7110961011ed866279543983b6f5bc30db8e1773d97fb27ac0f6c1ca8443c1004a68dc506b97efe20a9e2d171ae0afd3ad12b67448b2264095d3da128653954e938afaeb0f7731f92e72997863200b82e18508fa869d82f5d0ac37c947f7af24a7d8a727add54e4fedfad61ba00e3fb3f04962bd72e3f3737c529763bec56121e65c2cd504e632611933f9fef10904c76f7a95e94577d817cceb6bdecbb9eb78a94df70e205029cf20b122306f94a75b13428ef1c50dc3ce69bcc9c522c4babfd8e7c28d68935e8d624d3b32d4d9e1f7258e67ab60609f9df1e627d70dafdd8a073878a25a06948570d1cd8ede024cfe7c279c8a92e9bba61ea301801a374ee7da00f1ff2365e8db20589ec94c0ce59eae3f0d622e08d0c142d68a318b1f6c24e26d7937836d6470c1f5aa02ac9da3d4b4d14cceaefac051f7600c4e250998e95121e5cbc4d97f5e230e0874cc5a5e95743ac33f229d0eacbbab902c9bc344ddfe9f567cef14df296d78c742bed22bec01a0a82c625c20d6304bd4f70e3657aa0c9379939a1d39460aac96b694bd60fd6c6c831b14224a20c3624f236660c9cafd7f1523c6eb97d09de31b0899f562257545b9f9036340b39769c2b03e377f06d37bc23311f1d675d8885051d9a8c1896dfe4b282ea41bd6c8ba5f398409df423c62fc64e1ab7f6cd64c4f7bdbe05955f820da1dcde85ea7ed790987365549fa030d298386c508536c6cb6891696cfd8ce02e24e34b061fa30ee9f287b56e4a35d359c6504231ab79a81e169d5fac4e2e08929209a398921ad89a1372b07db1b71e265a9e663b1f622e1a6ba012b52ae601124d2e2e130d6a572c85564499fb8dd115693a7279e9e8d395ff469c5b987cbf013a0dcba1fc1816cab4d485cce424c5d5810d28dba483f93f6d642e34d0ff0cf4e36f86b1c3b9145499bf56b8ff6cea8d26c08bcf72badc47a67371aaef9bbbde779c564ef54369073a5f723fb5d77fc37bb875ce4948e4f0edd405b35ff301d1d332f8a75201eed963d94c2f96a316b2b235dd63c3b537152cfe1cb3f2bd9d04ae765a1c15e3ef38b1ea178aed2674e782a06d5b0b84c20bdfc6a46756ce9f95b1dfaa2d75d2042b3e1bf83ad1084a906f3afdeb1240b4992d18c5ee9c6cdcaf97d671784c4e33ee95f07958fd983eaf95ce7979520efc58a78932223d12255084a07c0710b6376786918005ee1162f0128554329fe20ec6cb64d3c7d225b72dfea9d64908fd1881d2e1b35ac1fe59aa3d4ed073ce09849658201506d31dfea99d2ec55ef4f415cf29f13b4ac5db501ec86d82b1a73848c2fd056a3b4f69f42e0a800f6be891521bcc8dcc8407f5ebba7193bf6d13fd2766f71c5d6ea6f9837ba371af85a26a4c711af7b0b57fd33e28aa709d5bb0d08b1ce10094fce1dcfc32172342eb85d8fe9b5eeb095741e1eba5386a0edb4e0da78fad5ce1a4ad22d24986647553c8be4119441b470a24b5f5c1651993f40c88740ec0aaf205f277d0990ecc0e888e7c1795fd8f2404bac53c324067bfea3af91027523795f0cd249042ec497f38d50898041bebff33f291587f915f75ba807f68ac50d358bec232d37ec79d67996d34e47948608fc3df26cb71d8c4e99243e834cd251b536b626b42924be205dc2c782c46aa1f1bd7ab4251e02f9204594a30bbfc233916b677bff633680972849ced5dbf7a5d40dad8915e90fd0a865a701078df0dca08cdcfac9fcb643f6c637711d18a2484889b5436f498b7b2a9f35c8d55185dff785413a2af46b4e9bd30ac0d7c28b57c171298cb375bb820ce8980414822637aede436ca9db4bcb4665b2e01c840d2ea813f6fb3088824b280cc736451795f8dc4fe0047950eab189c8778866edae26b9bce54ceeb12c52461e1c915e6974be73d712016ba348b50d52d78d6d2476e4d64ae3c6f2f24d83599ba24b0209fa333850e738795e4269cf65098513fb71a60b789d6791fe01a35379740704d210673df3c67542f83654161060a8e85598af896b8255dfdfc1e0fe061ba94b6c781cfa3d3c2a9fa360da15f65793e6cc6215dd3c668c84b8137226c8da450d8dddd35b04a3406e86fa8b4893722bf3ea6ab6ee29de226c6f916723aa17df1816fd4df03000db650bd6d5d403924f69cc2721d9e2f69019158500983fed67bef96ab25b92dcc830e3ca8e91766dffbbc9247fb8bf0f15a418979f8d4ca8235a91f778a859702bc59520fa4da4a60afd014ad69d01a39249433ccf5346a59fe3a84e7ce88f0f89cce1fae6c709af1f0025ed6caf2c29b1e3b4432c5edf50841c7874a9bfb1648e96dea2e10dae024c51713e00bbee5fee5149198c1e1d508cb21ba393c5ca889222afd89208b2ab4bde0dd4f5eba6ebbcc0d596e89ee710854c57c703b24168add8551ea6108e5653617d6585ad57f8aa548887cbe1e9e0c1d0ae6e2ecc748e9a71f2c25d17061f2116d03c7d8d91d0c8318803e8f9250af78e9082a36e051cc591783a686c526483479b3ca58dd3c489dc49dab42c9eae4c1bdc111e5754b7d0b2c998fcd2722f58cc65753daeb2aa0909254c88c7e244a883217428f2a81980c8a477c10edbcccbe6f8862000d3bac40b7c41b017b755c3f1751b6d6b194287c4706c1206eccad52fc21e2f15b2fcff1512fabc7a4abef862328e1bfa6ee8b887bd512dc1ae2b98364dbba9877e7e773dd1fa00d2aad2639d866c50d5ea27756101d542475dfeb148dbe5eebedd96df13f242b787f86626dce029266fb1f8fd64af1412808df45a94dbf2783e1fef9f9b13997a28638a51df2e46cdbe18beda670afe6f6288f8ee3c54a0675e23c052c1a391afb293d1ed4d36456d16dbe860f7f2605c39c4454c405ba0c99c5c289ccdbf18c8e5b4619cd554f5476c0245b8aa285d279909acc29e5b25781df22b9d593b74405fd6cda69c65b9422c5f11de2a099356ee5cdbadcab2ea72778f465de60d972798105ead8ba471e3cceaac27ccceaa9fdb82693fba57b0c316fc64f1f83aa6dcec4f5e8ade267a04287a565842776a8e10ce03e72af9a6ea0b3519c6183644083d077bad0c3fc0fa9c195ea6d6d3ad536a5f8810a7dd84a13fb9fb7fbe138b64f2e6f747a6933bd27dd483c0c73f819b5caa050c56c5c2b7f731cc5aedc111784090707eb9628dcb90e928909a1e16cd616fe9846a02955a112688c62635e452df5caafa7db8515132ef1c90011150122698aa3569ccf3d66a96691a17b30d8bffb9f99d0b7cd44e99df30315b604d586f0d61850379e422b302ef79b20c54dd1a06414b1d5bcb7983ba97abbd657c55d52d5badbef449583f330a1d6822fc4fb495d983395f8c3f7ed217203d4bfa13cc69cc95a2190320d2dd779055a187a77571ff6078ff0555016ea8c11cbbebe7d470bc6b81d666a76c239438fca3cc82f1d7fa6e054cf72267e8aeb51e875b686017d40ed8ed8b79dbd1b0c805143e96e9a8f2884004b9210906ceb1a377892b1b4f38d01478f47a240fafeecb438ac35bd4d89435ae67569375f0f22a62c552351aab797ce0471122948ff804e34e79ecd93a731fb51dcf7c08b343d00ca57170b580fae1356ec605a0c8b99f5d46545454d8a5b91c07a65896b9ae4feeae26ce306259ea26873115b57aa2954df9587f49801fc43d59dfd885cbeea3494422f40488bf90516f5565e4d2b8ce16afc5ab847cee947631a4fa0b1df2d9e0e95fe52b90ce84a22f283de645bf17d15faf8a4903b617f3eccdd7a5fa20aaf56ca1c0fbc1b87f911781a39fa26f7b5e82f75b5210289fdd5d74f06b596e47f030cadf69638ae80f337a6dc2f19eec7dde557209986e8827f3d951d0bb5256cea6d413bfe557af56405cbcd6de344293c79fde8669ce886675d3a1a07eb3aafb199ef5e31256eb448d2a7fe835e2141490fd71775c78d1c78343478e293abb9f952cb9e6d8ee5ce855b48ba207972fb3485b5c0ed6c75582eaf9b7bb9319e34d5ecb2c79d099a01bbfd873b10379292c0b31a5db3b12be782c0c9b00b95542eed92b5c287791b1c403c1f723e17d1f3aa370d289bf1bcd26a52361c3b3c0924c0a33fe7099c310103899655e1ab412c295828336f6a821e258985eb839a1ebaa0e89035c4bc79120e6375a5d25af2e3d0312247316a11afa5f0ecfa5c1324298b8f92da9e06b47f8643fd53db2a8c4ea7084f56824d0f69ca09a42abb3c4211166abfba0964b2c791c0514507ea35839aff161fa9e483277c2761e8cdfe85030f21a4881c760b6ca5dc53e150780f5a2c73a0b4e0e4fd69a6dd273d326462d0beaa44e16770491e0bc330423baa83ec725f3770fda3c2d1004f2b56f245dd2cb3f359e507ff66dc5e513ee8289b4e8dca0aaf8555faa9ba5f8e6cf7ad4c544e46960c6104dba00afc539ed69099c17b98bdecef9f4e778efbdf81e2d9d2cfa843c3b1a326308aa7bf97a40cf825d196abe1fa8a05ad15849625ca573fc9b3c0cc46873b34a02234a781483882168fc6d20869b99b11328e5aeaa495bb35da3835cd1561b2f257113b5bc0fcd5b9fc044e780cadf580c68999fc898ab9fffa39e2f0365b8230bc0055bd7754d26679aa883d7476995a29f8ac5d7c6174e016a37c75d23fc10626b361142c3fea7ad13c7a8796c023812d4394b7dc6fea3b2cfc31a03b232b0aa1e564e54aa2c741adc34a5792dd98194ce7694745cefffb694d38e778d443fdfc609501f8364ed065f8da9b68179a57f5b824d22a48a0cde7965ea63b7400eac2f9df8d657a72e91562f652e43ffc0a3bbeda7d8552ca96d7254262018bedda416d3d06eb1e3e350805476e764fc65a2208a5774407aa0befdc035dd5c35ac624a1776cc9ca3f4c8c05574c9b3026d4b3dba893dc9bf80e324750b55285fd88497e2b65aa4b1a6caed0037d4a35777537de37809bd7b77c6c72a8f9ecdc40ed2f790d6ae94518a96c1495567201b44201428667fdf2f1fde232bfca0bd42401970f12648e8b6040fe0e33c6486f1d8de4c099612fe3a09804d4b4f39ce7c0405a63145f0453a5bcfd356475b0311ed2602bef1c50385a92b0f9d9c0426827000c53fd546c83beeb6e42ce7480af3f60b8a019eb1d34a4fadc3afbef045aa54dd2d811687c56637513ef1a1664f1c5b282ffe8e6cdaf0c63e3b333bf331346e56a344ffefee161d172795aac2a57988f199329ea0ec96c3d6bf45eb45cf5892221b06941bafe9c989c71b32b61d521425794a8b0d16e59e93bc78c600a857285e62b16f5320c9b9bb6bc75c6403b77a7eb6ac65e915bbd32d4e5c2e65e9d4f4832e5f047e44f632b93d72028cbbdd7fec4d787985bce5e209714c6c8cd03b59bc377cdcb4ece34a5e3db02d704463c97720de219effabe1311e222a2bd90ac902b3b5f4f0bef2b875aef5952dd7bcaa266ebd309f87f448a365b8793e687a16336bbd3b812337757454fddbae404810f78579368158d1f1467c70cb0f983824291c9c9afbfe61aaf49a6367cb001ca3b86cadb4c94639f580f6b708e70de215e7e2f526ff24ea64393d9df625f1225db156ce1bfc7606b0cd1f3ad65437edc097a5eca12a834758ccc1ea6176b416dbb4c2e703d0e6b3bef02bceecf1d5597a0ada888fae1f8e310856166707a9073ebe7ee198bed45293e82030631eec48ee841495bdad32aa7b837e028488f5c2990103a3c3e0d46505926a83e0eb937a1aa8a20eaa5d60ae9923ba8f96874489fe96c987c030bc5ccfbc538fd2925c4c8c82e3d32afe558f8ad654acdfcf284a8aeb6a6b7aee896e79b55d625051f5532462fcc1e3aa1983328cb1934f857a8fa7ce42cb9d8ed79ba8dabc6454a6ae4e6f5b40c38c24fe8f50f6e4a87ea1172b838b96e04b3c5f966e005e05efcffdd33346e2ea089f7646228b60becb38c6f6147e7f3d43388db3c476cb99cf303bdfb0a4b010d92f689dfc57fd4f21deb1aa0d4874670873126b1e3c1a33fdfd2c689d14529b630c8f63616c70ab41282d1b4204eb7efd2c00ae80a57f48d76c67e5c8d063aaeb0c79e9583a96d3c048f550053c2aa36842a54e6914c3ad2961d61e28561df117eb9cfc87775614b74e516c5bc2223506e258910626dd541d3de85fd9c6aa8be8e73ff8a4179ffad3084c5fd2fd059c6b8e96f6c540b2cabe8b110109229a7e428527b6e16b6fd7df310827cec7ca840ebe99fc62f2943f0db37f6d54daa0cde2f95046df2b7b68e4b1093dba311630c1e242b94fb19a4552015de77de306fc5cfcfedcc06330bdcf9c5c3b6eb13aec6453a59ba6afe86333f58ce59dff75b9ac6c19c4f8de4d4dd509961808830693d76da68945b55524181a682d51c578095fe8d0c870896fa2e088b7673a36f25dec1069e51d305167ead06a4a44575d128b6659ff68b8c98279b91fff33504f304ce7a9565dd9b9a5bddebcfcd61ba14c6d44467a409a4b0a651e4efaa03c617005c3ca2d7291219dcf661ad621b6a099bc525494f92317bd9f9213bb6e231cc49a56577a35d236384ab5879cfcd3e861d896e20945d46aa640dd02413e22e0ca8354f8cfc90ce7ab6282f6b42a3bb12037ce2c2ef124d3e1b181672d5618cdac18ce36cdec5db005430e572474f9b8c7d279bf10ee8c3c070e0c56e4754f31f327c573ec3f6c3473d9c003fdaa8d53cda2b820942ae0486b3be1ce5f2dd1ad2b1f243ed361c69d848700325b920d196d96d4ef685810e5821c820861b32c876ef2e11476108174452d6bbe970fe11c71dac15b121da38a53f56d142d2180b1a8236cdd81ec9a84e0788d2c3c8141697364553c4b92bbff762c1b3a016147d46e4d0ca3c9a29449eea337a3f8b52f31ebaa2233db0653f421d8960eb1f132c87f28468fdfb05cb9cd201339203920bba4e0e535bec3519c7a8adfc26bbca939b963c1cdc96802a8b4d1a0bf3b418580b1890e7f5cd0b9c16e8d776e17c7e4aa4658cc187048aca5c54570597854c3f0f59a7b981fc9481602e9f324c76ec9b3f9aff8f4787be6f0c21cff6420141f7436d8186048fff57c7874a3b2f1bd837e1f4d1420e34cda275cbf69d48f6b2ece5b544a7380e3fa03f07b31f37d4ecee82a326c8643d7c3c3ba15049f5b0c98c2f1fa3ad6937cdf94498b56294333c1a827057878f6bb3d67b227bf06136151f0f3971e8ab2a11414906536b50e1b1d92a4e37384e3402621b0db66e956bde222fd87e7ee2757b84479fb26c83e09e6c20e73df4358f1e45a71c83d238f4599b3897883e686261a20eabb7c5644ada4c538b74c105b27cea89c91f2625c0223bcfd7f092231391b97a0f2add1238e1a86bca718e21807c0c59a54fb46f86c59ee20bbae6627387f8a62095f714a74912367d675051a1cd45045507437dc7858b05ad955d7325becc9c6a581b1550e4784788920b0142f421acda38eb7f41e3ec1e2f92f80da930dd19bfa7853e6d1b7731ab989bb7ccb1cbdca6703e7aa30676b62f139a261fc3814d19eaf5d398e42b6ff384ee7c26c3c38d7c01053639d3587db0fc5103ef0e8df087ee23ce82eacb6b49046a714b21266f86b4f3b3b361a0e99b76136ae188fa9b6fdeb0716117218f4deef31b32edbda90e831b95fef8350f2b6d4299b7a7c7adc980d3e1a8880011fc7646264207ff4d23fc61c46654f11b14b8469c36d22b87d916446df954b47e8634b21d629af03deace9a3efac093f91f73faabf8479579ab4591cec7700be2a968527372c4beaf104dca70b3b6a89e4db59658389885a93498f27635f1bcb5ac12770fc437cff2a2a7ac223498416c80437e1343b9c81d94bda32d54e48241003cf4cb5bc360e09060e5e02ffd11928c1d9ea0e7e7f1735062685c0ac6a118424124c46cb83c7aacadb0200222168e6ffc08a5b861542147ce588626cbf0d96bea4df90eb8d0e89854dd08d5072445b7d4b8cebc72f08184f5e5cd506f04df003fd520081b1a17890f1ac328af80fe7be0c1aa1beefff89609f5b9de79936f0ec5455e57a4ed60e635adbb5c2326ecebaa4e82a18e8d996eb6f169ae3b18f2cc9cb0d31b5f6ffee6d5bff77d8b46863c3c020a0b86b21136fd91e7909d445b9556651d94e2823de9aefdac57ca384edc3d4f6a1adb182131e15e6623d72c81b45e7a2c943173c93081fb24052b8603c331aafe895e7295619eba51542095f315ae8815300e1d24dc7636c47ba38a250e406f8b7b0b4506d1b1a9df84b4a989bc93eff2cfd3c3dc16ea9c1f42c500df7d91093baa9e97840264d5bfbb857aa6aa987af636cdf2e51c1e0d9fd8eacbad9c238f66377d76b58a2fafc2ee38d0a8482d87cef428fdcd4805363b13644e55ecca46797edb9ca740afe757ad134b5535321b753dc0a2f491b13d4672b7a341853b0f29750bd208d5bb17c90a5449c567887b97b8cac1824eb5658ed73399b026310df0d7eeee261e46108e505f9deecda22b14aaf96a36f3f24b441b268651be1c198de9cc21db1d92fc457e628b904fd933fb62d70d0836dff27cfd7a6d7611d476daca223523dac4567f12eafd225293188671fef37bacb4f25ea9b9e4fe4d4eaa6469b7fbcdee4dfd08d22f87f8fb8de2a8a9d3062e2e9a3e4345235fb49873069fdd7ea44b8eeca79bba8012a44081152b46f17612648c1859b7a7612674981c9e92299e95c3fab7270228e39966f0658137ee364acf05519d62ac444c1fd8876e2ad14d254de4fd843a694b2100ae1bc471b1cf7d23effbddf367689d5fcf878df9a65a3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"99905b2fbb63833975750c6f8ae13285"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
