<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27d8574799cf39a990c479b81c51ebcd8f84d4f9b94f73c26d1b1f62fb5f5cc2fffd0feee447bdc8249c444653516453853a777c4e3c7e522146a8e37af66eb682d000e64246612bc6318ca08b36a427013a8fc42dd498a5244dd67e7a53e941321f205c35bf5a66b9d7e91e96b85950bfe435e4303461a4cdc1b4adfb03a9c78744c2a2f9983d3dc213b3a22b7fd3140ce343e07395237883c1614a43f10fe9fde2f8d06ed239246ed83d8dd041e50fe4005b6d8f2e51fac630c5e84cf9ddbad338428d6da4f04da47b05251445e1d4da83f7a773d4cc4d24f6586d8e05caab45ca7a20216f53b28d6dee4e126777843f63ae22bbe7dad014b7d34602ec5d824b809f807fbeef124521ad6fb504f7a46ed9bef4efe10d2bb229130ba73b16ea1930156f1c20837e1fee704ca2b4ee6692f8bdd303ff319f89d71928b181888dafdabdbcb10185ea432697b0b1e3b906d8ee82247a0e52f76aec9f379455c4fc11b9c8bbdcaf6421edc968231bc48ff35d9f5aed01b89b2419957ff95051107a5a71fa57687059eb190d7edf2be41eecaffecf7890bec41c01d4cb2e53a739bf5895d10d03052b4b136a1a96f0f1cde55629d873839c9e18ff721e015478a749266b25e8ebb6dcd3d98d13acdba0eac35cb5e1ddc0f9eec2588bf5d0cda062635f202797bc4ca1357df269d5094856489a817dc109996474df76e3f58ffdbf4b6d4c814e6fa22d39dcc6abb6a0f09eb0b679edc98edd4a0eb405464b630323b1c8437ee02bc786996193234e9636097cd27f6544777be540a44005484aae4cfac6d6b31ae6d4b0a4f727274a80fa8ff419f0243ff068acfe269901c3da3b55c972c932685ccc20836392154564c8f06b15c445cf7ce4d2fbef6015f0f60ff476d9485aa2c4f9fac8aa68d239d106dba3266ce4dd923b2fd9e8c4f1cc18779dfcfb2ad0d4f6669f2dda353ac22aaee019cad2e340000a04f57e385cb467a54cd546c36e48d1ac16d96214431caa7cc39a0ba6c2542f91e2acb394b9b66ae4e23c981c2dc97a6668488062e2064aca87abc432121b5722c3142749f5e3e913030af868c0417998cc8b017d1f15881d1b50d9223e8ecfeb0f772064af9bf19c71890de73dce5656f810e0247928605ce4df9d683585998708bb7e4e1d67391741c71368b5c95fb365f807453509ae461dc29aa7f07be7f557d7a5023dfe5beb83145940c83594a34c5fe4099458404f0f8c43c6f3a7e0c4f4b337993bfbb51acd477d1e611a6e89f57837dc9bf303b44b40bee99918bb6bba972131fbe326bc59061a99dc9c5e257f9875db3ee8afb0a38e719c6d1cb58aae47b0fa6367db448879f0c06b5d494af302c383ffa63fa132aa0e1311badac33224272bedb8f99ce1d200abd298e502467215d2f0effefea91100a7e74edcf6cba2e7919c229d817f33e3456775a16ff220841aecd51d2feff3da22a29e7110a4df0476e8150d84d2cc4cbbfa3b929d328cdddb0d892fd9ffab7566dedfff6c9c63ec5290c2ada15e63d73ebeee5ecba2e192e456003f6090953d4a04de35e2774243fe0c475a79eaf872a89c160b4101c9d0e895114a30accf97c72beac839cad7b02baafda93668820a1daa623c9e02100e8fed3a5074f2a70c0343f247f4adc1604b110a7a61f08d06aedd67002899dade9f10ca15406357e46bbb6de5d062c7cd4e7ad0173c3852978fde6f78d0e08e95f937842222be744342995f70bc99502226af531a6974eaed9ef5ba64f84ef7011bddaf1f5b786ff79292efbb2720df6e5fd699cd150a32996a24442f89f7bd6a485883c0fb0b26fef6def386af034b46f9d306e5cb09cec96a2f5c54e248c5ba5fe5d48c04792960b219f74ecffb0341d026f960ae112c28194e39bcab1b0442c76a4801e4e42b03224577624986c57cc7f886426164c492fd7762634396b40efa336a1c912d8a038a81e59d45547cf96be9ed0889c1e15c863bb47bbb55138f4e52f0a3cef485e57ab0cc80933401c2dbcf141ce1872999b3c3b252750e925167f53cb244822c76b6d911328a505a3754d36418c2ecad422c03013a15a521ac65b19a487b6c64f5ce13ff2cb574bac492f841374a9aff7d4766564d2e27781705548f17c2f0a03433714642703ca80b689904f74ef59ec9b1cf65ad13b226e736a1412de17074c50865c8d1f9a6459c7d38cb300b170244cf13ea5d2702639de62e4975bad4037a6ef260f46db8b78fe9fecdb4bf458664ae71ab4585d11fce53318b7d61e2c63079fd8319619952ce9d0bd1ecab720e02871ac5369475f388e5a50c806f2929a9868afb360fa4cfad16a7ecbbabdca1a5df61e90927e3f7c20e6c2de1c6ac820cf9163950bf45397e55be31adaddbc848d7cf40af55a8b3b10fe8c1249657d426c6c6e51b1341d67eec7f3f92fa142b24963c22e4392286f1a9e41035fb0a79502714d2002f0ca34c6917390b2fa36bd967e613fe24de735e8d1c892146b24c4f1f0637e9495ade782c13cce9885c88171d763d7e1c3d12d963ee1285ddf0bb5938ae1034f898dfe047c1867336a40e59b9722d7e1af6b7dfd3deb3cc31d11056ba6f5b66a87598888b64907452c06ae32adbf87fbeb2d1373a37eb41705a5bf940030af3da7afcdde516fbdc294bbcadf24c959581d00dcee9c405ac1a1ba2b95f41880de43ed333fd2f90763abe016ead5a5c98dc99b14021e354298c34dc509e2a9d80f54b6a9ae93c178c19ba2dd9dd5080bb7f1b4a7b4fdc59b1f29fb54b3b87713463ba6ed69e65815e911d5d6b725d5ec0c350de0d442b52e2a7c74b4e9536e5b5c86d1629ebdca007a4bd6920c8a42e5f7c64b6a70576d32b71c95384f337baa5312f49d655b46ca67cca3eb5522b3db62f894b5a8364ae57ffa292b3a8aa54603bcc389d2668947fc258de13f9fe808fd09764d9293ba2b2fc7926c5a2212a316eef1f7dd1bcc964f43251b8284e9313029461fed9c9bb03d26aa598d83c2ba6da14cdfde846bbc7ace0e54f5e114883627a444ff88b5a4ba83ddee40d0feca7223deacc69654c3c972788b6905b5bbe95ce65ae7042fc6000c9f156fa8aaa124a48547c016a281f1a1cca368b2b41fcad691e951a1307ea466dfa09ee620d630a4e113a041b2c7e85572214c6d2ecb914f3d271297317169d21e3aa5f6d35c1960aa0cc784f932e21a01e889fb15d45fb93ecc95e4bcaaa8f08ed905b55cb6e9a3718652bb64df3c381fafeac41e5c82971d7de22126d9c10762bfe6f68955b33fcb672dd5fe6c6c912344f2e6f4d8ecc3bb5f05da62b29835354a2d68e6b7223adca54aa94f7749432c86ca39ff0aa257a263d00207368706f0c34b4c34b54b58c4979c90a19c337a9c504803ab9776dabf46936a1a4520570eb488079d948e4b210566d8494f4ea4d931cd3621e8e46624f0493fc9e555d99ce4847f971b57c6efad8452eab12dc10b1013b3164624a6cc732551c096dd4ca99d430af5a6935d8036ef65de95c666ef3b84d32be231ccd565456aad7d89505c0d8abf521fc8e6dc1259917a1d67af165084f19a9c32db706d7b84d04e28fb2d0b43d121c55abc3931546356d310df0374f4de189b50de7806760ebad2140ed0d6d66468fc3d0bb1bc312c4e4dd5e90b06d79effafaf7c126e53b4aac081afec5da6aa1e4cb6bd83f030046a9057905b13bddccf407e7aea0a85b5439a3d25dc69d8fa7538f4dd7da6d30e43b006a9ca373013da98a21e146e2a3b9b7753fc53343299043969e7293edd6f6bd5463490ece3b1a12d4756ebb85028ecbe552b2c5e597cab6288ca5ac2684c8bcc9020798412f32b9501be286677e56009bf187e31ed08f7de184e11890941de28bac316200dd5d680168b6c09117a9de800d31f712be38dcac955c455c2f34652cc1203297e9cbf97a45056ce93cd93c0796e366e54a32008ff7d43db13ec2c024dba48eb2ec10ad62dd7d50bf4195f52d3e92d83fa2c458e219443e94caf7616c64ce741da13147b9237fdcfc8e3ead09d965c5c0ef45a131a35571c323d59bbb9769c28dfc24e353889f5497fe761054d01d8ec0a976ec4493d471001de85b49282af93a53bb19a5284493596195b6effd32b289ce019fbdb2a012b4d1c6085bbd406f97ee569eb207b54d8cf21dd37dc4f9c47cdedbd6a9cb99ef9ff02b0bac1dcd7e76c4dfe5e9eea22568c627acefb2d750ce58898ce1e38d1d86ab9763375cf2bec345a897afd231b4232f0e5a515bb2bdda74882bcccd6da0e781c692bc110bacfad58e0c348c78a75ca7d1b06a239c400d4cd3dad0a02bca0fc9c673f6a67c56672cccbd5e591b87772d6293c343ce824ff85e3ec0fe1d91c76eae518918f9301a5de4f3216cd6d6c83ec3ef8a16eb8a49194cf6ad14086a8e88a0dc1bc248ef926a03610ab74daeff4d0fa2f1b459cfbbb4cc4be7aad3882d02b99f9ffd99dcc94ff1a67a7f05e5bdf7381667677724e9ed721e79c61ab75d052c05714a0a14262cd4cc395091151046cfab6106f25af5f875ea33c4692fa973c57d6e397cfe9036e1e923a03a54e6c60c38ef5eec608113991f373738c9c0e8b8a6e7aaa3c3166005c2126f9929b1aeb72dfc044f8480c6dc30306ab3ad730c8300bd7b0d58e065b766088a674e4eaca651394468aa0c0426e0edccac7592fc3b910f17b268116c1f9978ab9ed544ac05dd0b608861e0b5a0b0f28454228b916b225b069cead646745573635ec65052eff3f07629f16add1f64c0d8c326b673a34343af077831ef412ed9d50d40116787baaa7c02131213466ced6478a1cb2f8e0a86a45491a72b9cf3437e6ad967832fbf9f8cea8233ebe5f8c79f23845f7f1bc3dfcfd9416432acb42e90ca3a739b3198729b0070b9ac6a72a22f2dc3b44d948a4acda101f8cc8be56517f41b7913e56072a919bda94339d8d0ac9740c52d182ae57118ac56c7573c72662893ae46e8bd4856dbb9db9751fabf12e74cf47b6def0f1ec11cfb5d43bc31a1c1886b6552407364f955d89ed0b1d00df24127c7d07f42ba746e0929b59ef8c8d5902d18b238140b378e7c951f58c086a27758eaa621964a1e86466f46c73ff65a553e2daeff982533b330bf3ad2d8b0d1a000dbbbe755c7092223f6f59abd663e233dbf051bcf9e2ffd831ae4c527ec0004ddf93f9097b6de4b6eedd6663e5f4c5e42e4bbc63642f89198aeae1ca6b0f239ec4a7a799cfee6ccd55a57f4135787d0b914bf1b2d8168bc09ae5179c0944703088ee3a733bdd49b93999cbd8ed386491725561dfae25bb2dfbe0b4be7d87ad33799b9e21769b5c19b316af2dcf81702259ec4fe6e423d10b27a7db4033ed8e56db1f30231b624cbe8f2db99a33568e539af6937148e6e22a7b13a906f435fd11b65b8ea904cdac3dea5a99ecdd3399be1380a1efdfb28d7dc2ce5cc706749ede6efa50c8e0f078ef0b25c670ef34845814c2c7e4202d80a5d4b3d7513e54654c2894d5c408d759512c478fa64065f7d68fa6836e0816949e6da62d47a669df96a1b0ebe1e952bfd6f9018d65e3dcd2052455d8397ccc32560eb1a92eb1f3e572ee24041ba531dee12b138d73fbd37a31073078798ed0d57c0e092747f62fa48a49a989328e3ecb4bf04c70b4fefdf1b03d54624dc2f2a6eb4da32d1cd8d6f2b5e5e9e4481e3a1036a651b8d57a47f89b38607f7cc027b8818fa4d51479e4728d3efee795b227bb849ca61404b0d2ce94ff714d2451792a9ab6b69f406ce9c55ad77df5736932e8c660e8b8dec42c6a25e4ba4b6801343c849804b98c8929addf228139bdbf85d7677d0be0326f45706d6fd0859829a91290bfec9980943e680753edf91ed2fd4f27843d222b0281472bd375f9fb2630a6646eb176c062a6bf648e5a6f35db7a200b7bf99a9669b9d4a18d07984e8583c5768ae0d1cc2a960c74354165f306a1c77d82dfcf654cac8b71dba22a106964a779f4cad37ad08f6ddff4ea120baed874eac27677572807f24ab9b61f3f21368c708083af6fad9757e4c987aa60597fb7f358452dc9c4b2e297618446d866ca615f2aebca82aa14beed9010930bdd7ea391f3852b95ead563b0fbbfef1d9ec3fabf2068aa428b16aca5e4ba380931ed56b081324c8138d86600776d00d561bff4244840300133f56118a2bdd30eaf3de4a3c13330e429ba74729c4585b30d02ed9b0ee88e20cb7633c89defe82c7ee3e0637fd816382a654564567af69ed6be6c2b118a7351666186812ef92cfe0816d9478d06710c681e45f278a01c9631e411b836ee0371e1d643c6dbc375af6d4a47e634d2724f3eb2bf7bbb87cc622ec13a1b0c7236822bab4a3b9f51d6c04b948e6613abca39104d3866524be24997ef258ad6a280ace4f3b93c3a290cd5e2536b8f4c1c82dd76911f837c495ba6613b100e6e007bd12b5513fd590bccb943d9c74b266dcc13cb8f5755e246dad984cc4aede64221a0d3cd8eec9af41ff916737a97264a67c484ea3ed64e9aaf833c900bc9014a0ee8c3ae1088bf656795e8a4e158ca2c21f0d65bb0953af91735b2f4ff78f52a03dadf58d557ae9d6385a36a19854d29c6e74a6bfc870c0c4e1f07f537b875636b27f3726c2040daae7ea784c918472a42d73aeda4f5a28de4a6c08286365d463bfc086e745dc29505416e3b7412da1d3916a3d7b43069145e22781600716c6a3ef3c1b450b279ba314f79988997df24782c1a0d47bcf678ce6892c1a872cbfe06ac4e4784733c4f9587b9d7ce9dfb2e85db8b1df52a2fa225ef35192df7f9008efd305ad1d7a727c5d324a2e10be5e328a8667be4af6d9ad30f23e67fbe2bb29c5be6b12fd292653e8f65dde095c61c1cd93d7359011a17bd14aa2157d87ae5b95c839fc90d8b2326c6e8a41e93309870a3047a1cc77aa9b69ff911da058cd3b9a67e4362c6f10eca6b544ef6536229d9a0ee3458b6828a936247c01d71df54a3baef2d9f57092c57eb84ad308fe890def5e773016bc73beab884b003be260704207f7d1f7a622e2df2cb310d4f690fb670ece6f07cd67aad3bca6bd2bad3e50335ad061d388dc049b06ed80cf3cf8920a6b9ae90a3472b73e0fabb27d08d723fff727bacf325366058ffd88eb7a8f3136f629e957a3282bb5d92c4438bbe15ac9394be349f6de6cb1e27ff65645762fea8159f0d901667f07349abca816d00bdd3c2d888a4b1ef989b1ed84a28166cc68f4b5d1251b00df3805b4cde92f785395cbf948df71f39057784418ea864ed21ef9f80ad0b3a7c426caf029b4a62c5bce6b8fcb6ccd9161b28cd5cb37d4a95afa99af1b9218f4c24988e4252d5a288c217314ed054dcff28096b82e212b89faa702ea8a1dd2b06e86c1d397c09a7fbb9993d04e99d8479db5a08521a225c80610aae3fa141dbdf4c213bc0692649ab2ad51f945713e92d4f3d4ab718ecaec3e325e5b1f6e5dfac2d5563176d0621777ccdc6bbbb7bde731696a011b4fc51b453a02e3fef485f2f1de1c19fa8bdce21eede44024fffe30dc9e9e5484c3dd5f511928a4322de3be926e91fb57bbc41513ee18b6911e3504be1417ec303c1a2f61ec0e779118d9d301f3ceea51e2b00c13f24351438410a51ef21e25d433bab294c2998e6135cb516dd95535ff18e5c34b3babd927334cdb7876a157deccfba4e3155fd206c184b2a9ae83481f751eb4fc2df94d95d3659ab389ae72db1291a7fa03a7d9ff74f07b869bc52739463e0767230e04a703d26b414fc76785d663b9486ac6f842122fbfdc7a481a1d392bb371f5b71271d1981f64d01a5dc906845a49c9989fdd1dfc78aa45ee3dc6042a4da05a47b0fc05d10d6838c9097b2e4796b2af30a965f1de9c74d90951168fde724e1d41a4b92abfdcc75a06aaa5997cef78ca3467fa74cd1ad73fa57628ed9d58fae53ab1b959fd46a3ddccf67048e4daf2f22c51fdf7744a9e2868462be323646a4f261ae2182bf50e1899380cd3c071efc19e61aacf81d11608f33094a1304befbe57288e57e275066a9ebe03f967c7b016582da5a40ca9a4c8edb868078a6bbd331e0ba24460836e1ec07696620e17096b93159accf8e3954b5c37f72e10fe572c4efdb222940a46fdba13ceb95689e17bb0b3f947d1eff98183dd119f48eb3f2443ea726f7245b463048d885a6964f4d1fee95041610aa9a4cb0a5233bdfee9ccc2b0d302bb69277ab5df17c48ca9e99af4297f160f4cf66374de67af0bfd7f91262c29aa0131a46c531a0c6c188a9a7a4e09a508c722d80a3aca8381f5114fedc43e870058ccdf849475602a68cf2ff816411dc044d38c828389e52a98240b488cee9d85b568cf418365826d7aa7e247d1a48c3203627cd09824267265c562a129118d4d79570aa689d360392ba7b950b1abe40bc2eca75eb9aed31dd1b32542e98d85130992ccca44155bc3b60527d6fd8bdfda80e471ea39a9c1ba3cc1fb5bba319927b72a14b7d20a33f5601fa5b5a44a4b4425e7c9f3482f6ed0d610535043b7d6eba19d7492b4e9fc864feece10e545dd5f2f41bc8c1074dac2bef0ddce13b8ecaa73fdfe0030d8697e7c6b5e0a3c5b524ca062435748f14fa3018d086336903e37afdd3f5dd9b86817fd56349f6561a5e3c4052e484cede735e7d2784eeb8a0f95f3279b8eb70c5d68be5bfa8d01caff828e4901bd3731f954d236b0508f4f0aa2cd853504e57d3a7d1ca313ea51bb3e28e75f2028544a7e6268f82529f4536fa3320e439a453d3aa71419a312f4e45988509c7890285a0c94be5f19c15bca30b7135fa8e8e93795a2429686d777c7f025e216e64279520babc17fd651e12195fef730ab10ef6412a86a26c43e3aad1e3acf387a6898ad5e85361d928f95f6671a2603729d0c423a8f8fe6e3898205b4d1d9b0194c9a7164cda4c8e2143e4f5e862a552e3f7b2c9c070f57088ac229acc035b367affece5a0628ff94a19dd3191a307931396215dd4a00640cb8fc822f2a9bdfce7ff6ac2a06b9adc6415db8dc8e8f8b131e3d27b588e3e691ae9aaeb28793112c296b8eeadb8b4e48dc9c5ca6052b807a2c0d8f2e0c1f421fd5e2cc5aeb65d0db4a87f126673718c41ec986b9c7c93c868e2bcc32fb6c1440b01861f991344ae259604f7af0274574cc00a884b27fdefa917df6b928e5e64946789a0b36d20fcb1823e6837010dbe89fc640f04b720773f53a723a5391aa0c382e77408cf24c29da6a4469f331b8962eb0c89417380a36662f41efb00f4185bc460ef07c10d57f770c3a620f2c430b0c8aae2a4ad06abcb463aadb2d058158ae7b1b470027a3ec7029114b17dbd7ccd3100e85f09a900abb2f3f234ce224ca62c0de09903b546d43d4838b7b071dda0120e618db6734b451e1df0573249341616ea486058e2d0673f4961d15ffa81f8edcd48e17a27711a4d183ac52923517a4fb7e3e87d1a6d95a6040926598e4bb6d5b40a208993025af314b9da75dd3ca9c6d5b8e44598a7e782ecf49d50db09cb7fde28ec759c4a68aa3b2bf200791dca6da7789d0884447f1654102a99b1ce6b3a907c9bd7e2e4d09b93c3d2be814fbcf94d147688803d62b297c81e6e608573a600a4bb6fb595a9fd81b92103d175c9980fe34437c373f3880b82429acc22a057551a70a19687dfa012e1fe39a72d061c8ac6b6d24d42d751be5c0506899612419dad7ab72ad7d5b663842481e1f5c151fa1ae5e36fc973011511a1c13b8e9a86141d0fcac84c1052397de830bef0bbdf18a0c4fd280dc921ea56af57d3f6af4587e2c02b7d79fa29edb47b07b74fe23590a98227a2f6c3fa90e0e90f53060eebf05e406ca201d7c11a8dcae2fc7ca167bf5e9b06733fc855d9da80b6925ae83b21f351288e3969949374b0805d475bddca6e01d951563ddb17fc577f905e886bd53fe22eda9646d741f14cbc1e575494888d25c1aaf15926c61f9a1d3144ec33558c62704782058a1561408ec0430009eff28a44720a5475f920e8b73d994f543f6e75639526864a5e5a5668b3ad76a3fcf4e7bf0d224bbb2b9c3de7972b167767a1e5628cbc71ca52eba7a185e0e533bcc259984a5039e6da9fc2a21011749a858119c9a1ab8253dc64a75b257f4ff56690d6a3e2868bb8b0179e144bafe477513ef6befa272b5af57f702ba43632203ea2a626682a9cdc53e4020aea39256273f9b1403cc63d947ccd71c8970bbd5d5e1fe7b5bf19c32fac5c3484064ee99a6c5d62a55628c414465ccb4ec82f55153e12d7f6236fa602a05cb526e7bd5693b80354eab2bf079fc2bf256c6c6f34a8a1f429806fc753348ffa5610b9f9c924029a64275a77e45e8de9ff7e4b7e84ca3feb98d40a6b57d2bc50ca71f73cf823dc97ee1ef82f8ae6be8f56ce238e2ce869693010d889055a959a11aa189a344123fe3c06d18c75453919eb1fc33501781a93ecdf0c3ff33e8fb848f60a89062ce95b4898a48397d2f78a99e398cbc0f63baea4de35cd4d0389b55f8df340c3214e8200a30db6a91f32fb33c978c2f8fcbb66e37c478031e2b4f083fec0e9026ffd5cd2ddc7c42d9ea8031d3f51c156e5a75462fbd6610fd56a1540973ddbdaed09100c73a8d809aa1f7e73386eb2b3b88e1062869b36c461c7560a3cb109d0bdf4fd5686da8a0cfe38f3b539df391619a71d01486406a3879f8a90e08b9f0f0b795b6b0d29873227c49b0f1a2b60882493fe4ac051b04d9e45ece651698a9f5cd14c6ead873c994545ff0d347d17a36bc0ff7c13d05b41a73d119c4a9323be7936b540ea323320b7e866ec6f307fa314edec560b1ca850c7092dbfdfab7b2da6d64a8d2baf8e20d3219c0842a388dbefe1e02f523fb51a938e1fcb9603c70ec247f486ce0f83979681e571c16e7444b044cff8af33ab1f7b8007e546728d8bcc3e91b285ad9e46989450dcdb687dd91364cb5823538628199b04a910b04825a4a2ed26aef4d17b0d08eb39989bb6ef9e55fb92476ddf25f862baef4226c34b228133f515c51546459ea4fc936ee3e70035bacd4d0ad1a9d286ecfcf3488a731a4d13f82e91f3bac727486c4779a8fd4db790c4e6ef0069c4a1152bda3ea249963e7c391581955d8ff61da0644ad396242ca57a8337aa8a2b687adedc5d2a0cb15f0962595d12a40edb8ce051f80e046835da5a453e220da1b651d48dced3283b1f30e9813d04c6d6bf334768eee9cbc3a56ec058da97431bee435b6d90db024d4482f54241900c410d9472586a9fa6d6ad840177b10825cd0bd4689c1a18e4218104193768085743eeab7734f509010a6e037d662d0a38c7773e25743efc726c4b2cbab0b4cb33e432ef1d9d9020278b26ef1f2bb4129b08df1f70f86bef410dc1667be8941f1765d18161d3b5c70b40a93def5cb013eaf291d450dc94d93d38533e318565ace64ac61c41a7a2314c27f938a7976ff65345a74a147bbde92a32479e4e5a435cd2d6811ff9c82ac3355e489a73b858dd59bbf4562a5267b578f83236ee34ac371dd4c8f3db3a02b5d9c63357f0aec761011dab731acbe813ec761ad45ddbaa6faf48a492954651ea1b32908bd9ecec584eac605219a9478955be706f175535425979812c75910ba756414cb747640ade56259ae337888843fa5a8075ca225d6af0acd24dae5196afad48b3cb825cb3331faf8bfde7c820569cdda8783ef3f470ae2416b9b6a82a130e7e0322af70b21db7a4e53e8472061840746f7b8e2f6ad1364f1a2e79964fd06f45ed5e17870cd98058b5547f153dd11f62cb87f6ecbcd5be70a3a5e423af44ca8f2213a99fcc924eafb6ba89fefdef33cac552fb7bd962be3f2960f2cef06360ab18440cf7f6dc1b54f2c62c46e8defa92e92f9121ded207652d4947efde44a5e6c768ed186ef197fa7ded685969fec80bd33c6ba3f6f5377934aad1f630137f5c85b7b4dd31bcaa1a763e2df40aa9b7bb378e886db3a09af442a40ee8daf70d10033ae2b14a0aab8c4367e7f98b1f9607ec42663c5f7f7d2e34aa729f708cb81e16ed3a5f22bde1d98df4d4cf206a2bb6c47fa7590a70d64d3aed774abc0b12c1d97ae3b6027e735ad5d1ae2ba29ff7c0637c19dce86e977d90ea96b484f289089794cda6ffc344615e13ea25673c2e108a936abd418314283452333c28ab31f6f27fb2ce493f28b9d44005c1c8bfd28a518eeba4e5576a2765af33bce3f1d3d7ea5756a5339edbfbf7a710cf2ca54e86095c0e1207b52a4d91c17e77e9d611f96242b73374859d353c0cae9ebe9d7598edaff865812e2b0f1329abebd68bf9d42c42bf92144e07b63ad33f40b5924cb7c35d379bf4daf1c4f50ee817e85135e29aa97ffc7773e2ef4d2e93b8e9dff0e4a74850f7ee2b601feed8bb6c73a4111f720a9a8b812e02f6642e7e88bd229c11dfe6a4c88321eef6e1aff8df77be8ad698dfb34489e76d44f20a253fac530ddcb4f2bb8461b1ead33f025eade019e37e7a48696092acc43772bea0cd71d74d3e44081544847d7b7a11cf730a34a75488fb45b1d01924c09a1c09fbaa4ffe04617e15de445d1dd106eda831033cf3eb71939f534b88933667ca366fadfcf4b5c6d9605da9394406fda78be98a25ddce71b20df5c448f6e8697cafc26f416530f0c7f6d4eeefbb3df9e6791349f67d23df048a436ccc16f18129e73e7f8699a4a713da738357248c049422ffbcbea849ac504cfcf9d38b9ac0f859857750aabcdbf06d98b5e825d02ea8cf53668ff9a54c504fa6ad59b19e0f2750dc699eaa2d36e6152a869a209f20b1c2015a825c77b711755145c6094a934123dc039ac6fdf9d7dd068e95399e213bd283c1ca6448f7c46228fd737f1d9543c35bb7d4f17a60964a4773d67ee43c0918d949cb868c79d2e53dec004ad9ec8de358ac465135f57b6f9674eea5fb2172f5169ba0d174e34f79cfed4f20b3208a837a688ac85e2fc55c1bb90482976919f17fc732a65f483da4aad0d1923a38492e99045d8a04d0ea13f29bc6deb5d59d4327f61d0232b549468867f758b2f1fb7126ff95d5e4fcb0fa69459a73a3f78a76c4154dd5a48692804dea00ad126e1947fe8535c7ff3a94143de1f64cc29564637bd550f920f3b1b81067bb8a9a81e7aaa91f4722d11ee6862e7a76937f9ccb0813aa39f7db4137d1d58a22d18cc970d026c408b8f81c3969da7d425952bbf3b71cc6fc0b87144dbf922f604c56ebf8c617bb722697f95feb2478b0c9d077c0bdcdae7dcd35d9f018b1f483887438af46a3beae199cfbf478e6f7de2de9c18f78e19caa002ee883cbe4f2254abc8ed6232d3ef6abb5bf8f02e1818ba6580dfab9e7b68a6ff66b61ec59e547be017bd69b44399c3a52efc656093f798d95e06324d60a492295475b4b91f28285e73b9370b8b4f0feb2f20bdcb405b52d2c2778ca78b7a846dc9578039140b46160c4e13b647e4e2e20a361bc9d91b2e6bb95905f362f0d161686c63df43e225f3bbf723397a2d60b083954b0efb9048bee8a90562e5065b7d65e3aa0a1a4c94c3de63667b3e9169dcc260660c4210dee65273db38850befaaf4413cd2e4b306ba1ba20d65ab092f10d58f78e1c2d7d1b5eb9d6e8d8e853212a844e3e4fcfe8e9227fea55616adf700d2299c1e3fdb0acd57d974d3b32855ad2ca7fee9f6dc129c6001124492cbe15956039bf8aa78c04d91337657de39e1f22d96da6e470f40e07fe259adad5e8ab2adde058777396efc5d71f27d4ec9901cf17acbcc9c16a9969689e7d06961b15aa6caa9d9c764a575af08c9edfff028770baf1d2c85e0beea389afb48a8ae8ff5b5ddbe5ac48b5a5ca0e564bdd153a9e188469c86e908ba15fae7d82b22d2d36c7502a01eb12f2bac3b64fa08ddd89389535de9dd0bcdba669114345cf5b03e999191115b2b4d845426922c99f9c1924801589992305729b75fa0e3e3d5e3950a11c2fe86e4436e49221d4a904d6a929579f04ec00763a47913b3b148dd0e54af57cb97656450f1da70da3ed3d33042ef7c907877f3f8b8bc666b240db597477d33768fd04facec3fa72a941da13b15b820e94a652b8e736c1a9248c1e949811096df30ebd596327f285cdb5f555e28894ffd605728919cd9b8596e00d8eba9a16a692719e32e2a766d32bb7afda53a9f495c21c57858a92e60a38a8cdde642efe36ceda39683469a24160fc674f0489fcbeca4d09a4ccfdefd92a697ec8d5908185a6e81139761467401cbec7721f2dff38bf9f319bda112bda3845f7d788e107bee196d4181e6d1389ec2739bb30a41b76a826b310c1b31de8dc253d7c7a1e0a9e0be68930628d731dfb52f9dd00355f097a1917a6ec9c38f6ffa70fd31d9c6b17007582c72d3f7be39c42309f96ac477c9ed2c51731f91b125e7ab5dcc84cb13a79c880106feaa1913c74632aa6865aa64c60231e28812ae28727cfa99d1992559cdb2884cc21d593651fc0a7ac1bfecb98368cc8abba65053db81c46eaeb6b9a97e77120e85a1bc47ba1851b82f11282d6649375958f6247cefdec229cc092847eb785f48d15d2dcf686563e81cad3fc5ca3a8b9924beddef6c266802213a3879ca23dab1e2ef4f20655a5a6d76be754dc954ffb72202c4f7f1620b66cfd5f35ab9428f8a1b1352050788667effc4c59e2bad4175c0a2bd05121df41b03786abdee9674b7e7d49ed3b14f63930f1ee3681f4ebfb5b54ae7a402b23cd49926eccc78ba4ced24f59e102bb4b43fce88dcf13e879dba4c0b00625841e5cff0eed45347ee267efef198c0e70539e4a9212d47d4f1404ac98807bfb66118cec96bab85abd3c72b67e297039b322f0ceaddbfc25fc9d318623ed3355b29a4d63cb8f988e4e04da89a68b0e54c42d046ea17ca8b0b17f7abb5b73af9eb61168097d08eec1aeab47a24e987230128ab78ce3d611b2195e902885829b5d32773711dd1ce80e5f9f476cd1b380ddc2807d822e80a13f838a2a65ae47de327db2ffcc7d8c24750bd634c19a9f30235c5f9939439c5958f6bcb29d9e6e54e344eb43bd78a569d4f2fadd87628249bad8bac371da048aa923de19d2c594418a4802a8003f3d1070158630a265575192bce30f18872de910f0cb34d25e04d6b22be3f36ac8b9253d550a4cae0b297760425134b64459ee13ce6ef93b5d23c7b61ec4494231304e42fcfc93f2972b7a1e1b88b0c4bb284171a6c4f815f65476347f718fea588e60e7dc719242f8df7754a984a3cb59b392205de49fc8dddd8a5ec7921bee4849c40496f7a65f7a24f07db5facb8e5233fd95fdaf444d2962745dac280020e07db97a2d6d65549f9bef64f2ce74c3935929217e2e3bbf7d34b1b1c73b2af388f155881141aeb8d812b5bcd30897f0faf291cd4b408763e21c20a360f80b7dec3877ad30553445a3f16c0677f9bbf4412caa340d2bbae6401077bff8afa1b31fb10e14f82053dfc3f5e551b485b2a0a2079c368c38cadcb65291687db052b9d4ff24be5cf35747ae20601c15e47867d2129bc2726e95f2ef3ce4641e398a110cc3a995294b7b808cb2f4ea8c567cf7bcfd9e8dca412664f1ec25cb65d950f22c9e1c0beb379a22c0cfa14b82558136d6817b5aa48aa80aa3ba9a738568748405ca1b10a8c6ee332de2d2f19658ce4f195ea9434141af5230bb132dc8d303de31ef7dad09d8d89f95968f80317a4a6ce6a2e7b5b280534f971adee9e56ba872bb239abf7af387b5407ea682f68f71850bfeb911ba3bee2a9283690e9701e11e67101b77be5294a840ea697f6e7e703b4c53bd19e872b3e216a92ca1b597f7187b7cccaa27236442ae347efdd78f390df9d929b945de4bca322c40f59a181b022ac191ca9e85fc4bfdf4e5378e854fe61c767f0fa687ab9113c0b95d74362775b97de6383bae4a52104a1081530f9cf74b95cd6191fe7e8533b0eb5c92ba63e5164a361df795e8e5ebcf6fbbec0963a783c1c2e1a6448cf5819296d6eaf3062afe4e16408a4f9c8d0c3d01c75ffccfff60708655cf78596d7fe222c45e99144ceca841ba12041339f8d0f30e1d6104d8dac22acb7109289168bb4deb35bd8a70be2afdfbedf5b0f85c576a0f3fe07dad3156c3004ced5b67c1c8e2714a490f773e03dd288c3d2099f51c8b2af3b626cd31bbf543caf9078a9568f79701dc8d5792847636367316d31a6badad7c64d46a4ce600ac86a39af24f111657a28bcb5633f622913e01fc95189a8d6b6c13a18aa2d2050ccde0ecfad4b640b92d4d7d1b1f74019037733078c975ecbf0d49a912c5ff5cc129fe16398da6272e761e946654698000bc8ac5ea44a7dbc588ca51803b7cf2dc49840c0a830b785fa9ee49779e62cb1dd2dbc9cc730ba532c5e35d811e00bf0793bc715fe10f2c79f9d98f3756d0928c8043cf638469e527fe99b4e73cfa53008b23670a4f5b71791e91a03bf19e20932ecc6b0e20f9fe81194182b834ad85b5f0104bcd366cccf8f7e3b4e7500ad72fd6961e453311a24583082e1529158f0ab7eb0fedabfcae1d44201c86a8dd66e8228b20533baaad44b98b977fae24492b1465c5409d0bff2824cf8eb5ed4d2fb5324df3987f0bd075709635fdce1c76480324f8bd8d8342e3d50136492428f96763b06b443e2e374b8248002d0ee7e663e2a06f060b0730acbf95c04be7a646916564d7672f0e51dfe63f7a45c89bfcc645495872e46da9ad0c46b98ffd7f2bb34432f2df4ef9cfd90311dcb79be355d19b85720d722a1d85bd34444766e9b106d3aee9d3363a904283e2b44f8fd448812a76b414175ff88d38938635e5f6618f42c92ad092d85e1a58643873bd8c1951595da4050fdcb7cd28dd745bd7916b912d72114276b4c561a41a01d864e56f1607e15eedb6240e70fc624f7f590f013c9d295e75302acbdc9caee59533651755d6d174fb4f23f842a817c3153635b6d74a537654b35c2097e561858500f983d4d68b32c7c4c0d752bb430c61fb91debbf5ca25075d6ef3c9a82d7a7ac2d0782288b6c9aabd028142ef58f3fae6d4de69d4a38bd17756476c8fe48a918695d71525271a151764680a91e7c22d8c86fb5a28954a6349969912e5eea6e0566e292f682ca4d3b3fdfed03dd9983a530e139201284f5f9a69409695b554101d4b158efad92652c722281d7f2861d3a02559d26e8a5c52cc132f8a614a04367a09c5766059648052bb1292903671e1a2b08001a8f474bb6d4b9fa0fb13e7ce1c799e2256d4b70db8ce0c15bdce3054df53ef644faca119c29ae070ce70bb7a34061e901238906b874213f44e8b7785211de71632c6f28ff8973cf607d261395b68223ebd151b429bf0c4753a300ec1b3da5aeddfee73c987d14a86fc269318ea97235a3fad0149d1a75142766f3863440f9424444d5a7e97255539c2f9a2fe5e8f5956af8a7b418853dc193e43c8a91222238e6a3460efb47efa1485b9b7ec92110831cb96745d624ea40a50987f02a223bceebc1ca9cc8de05fb41166adf5839c164293454d184cb11eaab20903226ef1e14db4419d35ad2b597a522b53b853ad11aaab6c907039cd3e210a85ca404a8d985d1efe6a3c64fb19f7add5f08c84bbec106dfd0b2b704558c038f4eefa5bd32d9a88b649b44736a261686bb41683056bb03f4b185b7d260e8201b6de56a164957bbda5e272dc314dd97f0fa88826e975f2f8d9cb82f8cb56064aee03506e8209cdb68f82e821272b859231a37c4fce173ba2e602b6a346c7c3775b9164baa5623a372926e8d96169f1e989f8e20b51e6c078316784cfc45232d526a5cdf6d52c4e37550731588cdf82959f7024f95bdcf9fd8ce15fdbebb8246484dbccdbdb0854f57c9a9fd29d21921940269eb6f19262e37ecf6fabba1471ef49eadf86e02c555b5d4504f9c43b7ce8f402c28ada7de5630b16e3515481be75c0d9a2f2faf8e457a0a38e4b2f0fcc5e547467155a6d02ce2228e8b36b40c1a473576614b42503cf1175d182dd90f9bc91a9edb1eaf4888b551898713126d4d79a451e544948bae9fc5462083254a44631ccadb54224609ced0c740354a89fdea4965b97653fdc28684e16b8fd45dd977bc7d3b52a107d85327fdef40dc36947db076d68bbfb4a00d2aa3690c345eff6230877b26ea691037e9d7be18d6248abba38a15b772e724514c27df217496d499876eb21412683e696aae12ac86ece47d63ff708a99ea88d85c84a2622fafb4ef69ada8e9ecc5204faa0f186b1be69c1a90179e1ae5a327896807c00bdfa29a512f65b84bbb0a96341712093b89fdc44d0cc5a5e814c0ea982c1d25b9800a3ba2f25a0751e04b9df39d160eb9fee6ded7b99ee14ef550636eab1152e280e072403fc50da7abb93e3cc3903539e360ba0d6d0155d8ecbd4eac8ce61e1c316b3d4e6e00bbd997f76499364aa710af722026d8d05bd35858876174b8a3e3a7ced0b7715e23debbd4f725494f534efc26ed5a06a5b0cfd78db20577bae214843a900e8ec931fbbca6ff826f7e3b0bf01aac895b4048b7ce6b6fe97bde8b7ba75ff972e8212275849837d5c2370f058bee6e91e1c7b8b9d7a3869e30ed42e3f440a5b4145c8ae7083382996bb491344c69f33a6aaee3546948a95aa911d1cdcc1d1be19af2e26d075e4f73e1d90bf985eb10624532177ee4cd686efe47f41f5ca250e7f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"55a4e190c92789cfdb14768d8d79f456"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
