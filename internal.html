<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d90bc203cbb1327a42e792f15e3e22d3c35cb36c4c2d53755fc7729fe0b68bff30a06db8b0b46fdc0d94ff300ee8e2bc16c2d8851751d6954e271aad51fa39e2e23b58252a02cc5b7795db3057bd6d62aa7d7a5d1f586161d6dc3f0a2c0c0683c863a7ed9db8073aea07971e27c281019dc861529e7a61f29a6c0f6e672afcc0835f751d7d05660d0647fb83a093460e0d572aac627dd31da647332b11bf583aef869683048e65731b67c451bd2c045ef08bb098d8531a2eda76e851608d4dddfe1cdeb76f6b3e1b8b55e3856d6268cc97879304d19dadeb7058039a002b0f1d74348c76b026486fc3591b39c369e9ca334d870b45e69677f289936f9a8a31750c9666daf8dc75520aa7f8d43e48b4376b810fc4d5035a7868ac963e7a220c817f673604860ce5a82aa7330ff1749feacae62dac45c59808326cc57774fd8aa187df15badfc28c7331efab8433834658ee1a99b9ac645055bb265de2d20e3fc1f2564516b14903b4986f6088419aca7e717c1c87a8787fb814bc1a8fb9579e3fd519a881cabaca92b855cce6d823ad5041f0b92840dee0947dea445ae7baa76c8809dd6e7b9532d244720f671514e31cea6cbce06587df28056b0e75fae3adb0f03ec74915a48ff829074ce87dd3d9f8c3457520c10c70353d5c1b6e5d8eb6bed23c7f539384e1213c9bef3e050012aaa0a716bcfc8c691d475a4300e5670b80cf3e280481d96f990044d71ea90595ea62f2a1110ef765c0033ff11dc07abac224aeff0feee146d7df5a85a8a3875760630d385c9d21afe3b08d2df75885ee12da77dac4218c2d59b844416c42185e0219e2602a5b3e812aa5b7bd443eab5fb6222b2cc4d593087608c99ec19ba2b26d1e0f6d9a7a4cf89d6925851769a53fe4bc5beee3325408346c7ce3e797ddba9df65e5b46ba00d0322003d1f157bc5ee3759f1846cccc9ff246c7f3f93ca66cac1cfbcc92e3b49847c5666e1f092770b658c91b2d6b0aabd81f73a29493d6004596141f987334a0945d08d169fa521577884e7b0a17b9c68d4423c9c60358af88dab7aa9ffb15196b0ca0558c2704f35b7e941d20a90ad5907a26e6c7495b88281be05810dd7c69e2d4642a78a385b7a6521a01704f61db56b96324210c23ad8943a93eca453b6b93a6cada0796acf81cc33ea886b098e2ba81daff8606d3aa08b5b35df0d1448c1946af41188eb887bf7540ab54fe756410d79df670865365ada4060b0a65b651ce6443fcca5d377c2b4189f3912654f40a4d146d30130c25fca8949f3dcac5e369624c1bdce09e2b8fed47ebdf0798f370db96350f91adc8aec3d6741f8d48eafad9ed8e536b2e47e14750fa5aaf5ec4efbad5d4e6e72eb5892290451cf98cf381cf109f138f7d142c95ce3a2b11b8a23eb040c9ccc8ecc6eea72257f78be5fc495722e1886dc013a70845ac70c1b8d12d3aea0c2e619f78f8c027ada94f462431948c6131093444f390ec611dcb89fae0f493af79b1ad1e6ae97ac41338b3420d86db3dc48de7cce79de675b2e4a06e27320a47077d8b02e95ad234bab8e714d33c35e27b641c8343b1bb328f44048490cb2f2521abbed424e233f16d99f344e059a4e3a120cebc27bab7b954d6fe835f5d2d2840435a3cc924295fbbbcb14970d0e41ad0a87e59e52c8aea942f04546ddbe8e017aaeb4d9843d474e8bcb6f8fdc08f318a25f00fff38a1479aec5a508e1f47684c965858f4b1c13c6a9bed4436924d2245b6b7cd34f2a1e4979acbb83a5b0d7a9a8657565f50463fe4895999ae79c86207c094b4d3fb167318aed198e3cb3e866a66cf3775501cc9eb94320ebed62e45fb75038e07ff1adb90e87d7f12de85a70b4a42680a526a49ff85c6c1d8be6772c415dcaacc5b9cfacfe3e6cc34c3bb595045c56bcc1ed0152abe25c043c562e815a972624f87b2ace5814b7a03d61db45a231f8e4eb3188580f2f533bbe858c6ba92c58866274dc56e44adb4c3149ed930ddd11ffc1d4ae50a26b8294485cd04f9c373a6b0b0291ba164073909f63e9bdb55217c38a252b79f263c371c8af3f44de30dd8b864def2ef67df3453a2548add3b026bc196eeeaa5bc0e09db6ee3267f711d86fe45adc04589cd51eb5972dd95b926afe529c5f13b15da16e27747b1854c068d77b794fccff355852622871de2c6cd6226169d2af146fa84e3776b52c1f0fa8cd082fb1cd2ffaf542d6ed270e93b36e0f3e35b60f4aa3a29c688600ef74c4eba995a01f70e153a52d8c4afb12c0b4e3f6df7beef1b0cbf843f2c319b81e50cf633d0c73527dda4b084c4e14cd7e462f1e2b56c2a8e88e3af8ea815f8c35fc32ae3535b6787d305f864558a8a331762cbb801fd30c7345ac7aadce6b1e13f8ede53d25de80d73ec80134c9e97803aae28c8213d6ef014c6bedc80d89978b4ec68cf6b35d12389fcb5d6822e7813a53415319713ef14a84491c8971efcadc5b26246ab7924faf3f125beb06bdb3b2a60708c24d5e81a7bcce4bfd0c5d3cee20cce53f8b2209dc179559ce084bb427360c4689977f3cdbe57ba2dc4dae606ff93c9ad89171cf48d622a36e13945089b95a2548fa696cdac4a8401b51aae691621065b17a15ff10e44374e4f7799f65f9c4aa5c8f1438774df93a92e0be5171502e023fd4a0d84849294e4df4729b609f48a3453ec7a6a42215656ee26fa1e3bd353cbe851881c905bd968e25eefc69b34ebe2868a7916160edad0f794dc6c7d44565830169f45c0935df8352c5bbfdd6b9735b72772bd875fa1ddf351596ffd91159c7ab4efdcb94ff9908898f64e315ea996b55e9359e443c91a3225c4b6be158cacb3d9cc447a7f125cd054763b421a7dab917faca39277ea6f2101a8c2796200a57a9234a52bfcc34695055b08ee4b7d55c373c7fadca595c8d66e9969d62b9844a4b6284b025d756a55e74b17e1a13a199a41cf1df72316eea46841a359272b0d388e0239efd66c3fcb1bb981e2ceac6bbf0b22086735e9736fc6031719ff54220ef6b94a8983ead8a3446369db9dc7aaf0d28058cc2cfc68324f0dd36adc3503da7340ab38ce385511d8cf03d4a6662401fae9aa83e33d80499bf5ceb79a121de9c411d84e2efcc818d81285217e28340f001e92df6e57f5d5073fdce694e0972759c9f8182553c22ac4732fe4902394e7a15037fa41dcd55d788fe7001654dc9cf650caef02a7d8f5340a5afe86ccb26ffff69b821d675fd501d17bd0722d8bb1d88fa630e578ea99bf29400420c592dfd1d70e63b72525f22432f6b1cbd443fc191fdc180da6d663d5f3b5833464215b6df44acbdb5e3b0eff83f6f23818eb8a59e9d8e13f962ba38f731838bf9a318fbc1dda54558f6d4a12079442f2f9fd1da4e049cdfdc7c48cb09a8491f94e42a28aae851ef88209c769f9158451e186a3bf51b1baa27032a2654c82be93168d4ff47ec49133497ba74b220cad438c31f62e559620cba958f976756e68ea39aa07ddd323d66de7c1faabc020dc64e8bfb1f4604184b725802cac66d999cc1ec7d31ef554a8a04b77d16ecfd67a935ddb88440808ef3273cb12f3a5b1787b149ece38b4b10421b3cac81fe839cf6f67e8919f9327ae8c78b701698f15175a87e2abc52d4332eaa8da3ee75ed1303332376e90838f57bf6e89ddee89a1c4a11b0ff8f21ca166b219bc5dc3eef4df22caf9cb26c2d43328b36cc07d0ddd8a940aaf781f425f105a993aca486307b735afd02491664098a4423c6d0965e0ebfb4362bc536c7b3c91a7f01cbfcf7be750b02d1fa28f8e18f8a1a597b401fbca5f241688e5a940e2864868acad2ce6a35ce4fc94a5a4820090185cc20ba5af5bebbf22b2947ae6cf796b1671d748cf3b3576f259fc0c320fa3a46985c64e59e95a16daee37b49e3b8d7ced016dbc9a4584d7d5533a58c75d5999d664a9d2ab3ca680cfb1d5c74752f8e1e274768679af3574b189ee3e7af435085d8111c7f8deb57a8cd90e363ac4aed2c62cf5d6eb10dac1011103e62872843cf65aa02783f63f5f31804c96892857484c45b5f20950793206f3bcbb14715fafbcb3f19eee3ac7057791756315b5e25ef530f9c14189a528eea3704b8c647c60beadc8e9567e4ae98163cb4df13a3bcf37b8674dc9f1dfca8bbe5777eaf841fc02f6d15936e3f7464cba8a7bd959cfb0259e147b08fb1c135d0cf7faa93cc315a8a8297c671c9db91e594a51bb74157b81992082ac8270b0be95c62618473c3c540c2359028d3563df03ee6f7fc11c2b023170e52403ae56bb397c1c4eef6a2a0ce63a90ced464964d4cee6eec5755d47b2e733003983de3679abcd8606e5606755460b6a40c22423d8b8b58637471cb0e373c31d21dd26a8142bcc22ac8a491dee7f5145ed204db5f0deed698481f8ffa9f7e19ea6ce5d81025697f759e6ee35027caa0508f5c9ce3a7636dc8325931b7371fc1a6ecf4f266ed39b54d0869b30f7d8c4be3ddfb58350d2eac22ba1ccf9e561daf376d229d04bfe082b6d9c9b4e8c15f7c817be46fe45761410e62715ca798bdbdae16c09b3cc66d46995a6cc7b8f578b94a90971a5ddcbf709db3753bea95404b299fc9723e47a3a4854f2ef8d4f76201b4d02a939b72577c09dce46014abcb0c4478649ef1cc4b60c117c94d3a387bf4f82a9461611f2545ce890869df36e6d05b43cd4775938b0688ea8b5ed09a9d7f21ebfdc70d4faf6c5179950c19470eeb6df9714d22b9830f4561ab92fe6db6a6d6ff0a58f9b9027c026d1cc91dc6325e581a3a8889afe8f2d3d97c11f30a8b075d1421bb0fa7de1f740602bc0e9cafb5f3d1c7a7ea5f0bbcd1a1a6580b69d18479aa465d05c6c9fce31921879c439425a43724328bbf6d015cdb0e1b697fb62db6c7ddcb4343a45ecdcae7d68305fa9d22e6f00a5a563d6a998b17b401fb082913df6816e3c903f8973fec4fdd1f0fc1b42cac5ff84388db2045b406a17c854f177da7ab7cb13c5f3eec07893fe378721dba3abbaf4356c8c5e378334c51cb5f8231aef847e6f5a053410885b0ce66eef18afb92d13b4ad5203fcefc73bfe82971cb601ca687acb8f7fd924831ec9ed72a3f748e1ed9ec1d5561941d53958ab6798fdba10e45c31a18aeebb9c928bd395c45733f92604d1203c930e0b82817c152649ea4135f79345d25a9b99c3bdad0cc0a0cccd52156b38a3bcc1a0339fe1965caaf7c20a9646759f4027cf073d463c0a3f995abdd29335515da001ed9493d0422512947c48ac17aafee085f45afc4f5e2f3381f4c17e19ab494ac9e30f1371fa6ec197bb38b313a5a174c4e05e883785168b90cba133de1c9ce8f9e20f59256b50ca350e4690d5b291e94f6b00d84d6c57a45136e33d5ec972b04a18a5566cb2dfe35a93a16d1be6cb8acb3b555fe25a379514d815c158851a59b7b32d8b264504562923b0028e9bd72a721c632c1a0dfb9d649a889997812e236a0a419e3455b4ed686f756a2190bfd5e95c137a308c0cb25f3ed48958f903500ab5bcb883a0b950de36f815a89c00379df12dcc85e4a1d4981de195325a7b3049cd98c7550690b643974ea5fc6d9cc4e8cfc1aba07a5bc02334681a3b64a0b8ac98b0cc507751f90b1e64d00ac76f2ffe837ba129ff230351d64d0bbe3b6ced7ce34b1742080a5e2e6a1f44270a2de39a8cb969ae7c632631c6444e3e43ff6fdf34130c85bb9fdb7ebef272249cd8302dbc59a0f50a0ae3f16abdaa1f79b8099d9ded135b4b2488fb267099236dc3f909eaacb4e6c198da4ace6b6570c5476cf81e8e69166cc12008db5068337f3294b7b8e6828ca3c791e30b5435fc5308aaef03de6270246340a3009103d73ae9ec904ff37d1f60e07772b9d589eb662ba7b78d5cf31bed82c6ec03ec077cfc8cec1b1b9ee916c79ad44762b48bd58ae487d3cd041de2888b1695724bd4455aea2c495ca3af004403b57727066237298db7d4a1b59526b20107107ab796cf74aeccc27c25557302ab66182a20c48df4b2a683d15ba591b8bb0178224617825d7b5c9eaeb0d700c7d69aa45e6a97719e9246b20c9e0f48034d0b8b9194580ff3309c89aa0b6e6a1ba184ff68b80c69124b6111c74e252d9606cbb5211b17d8185aab39f206c35a781474abce00e98788b147a1f917fa582ec158d827ec91b3792fdaa53fc8e6c7ed87dfc6ffdd3662ed4761dffbf5f42c772d59ca263673cc61131deb9a8d4431603d8cc2ff0319f1478809b82c472f6027c7136182a5ec57ab638dbaf771f2259e539b1be3390a2c18b13f722cfbf7f8325711cef3d0dc8c4648cc8475097b1a074eac207dd2acc911735c3fcf1ad2ba5ee6b0290847d0f66336bbad37eda08ad4a50cb6a0ff2315e08123df0ca087ed3863e4b6c741e7ca01559bd8fe0350b284cdf19036006a7d7af5246db9c0f2ba949e1e606a8a12aac8113e4d46dc570b22b58bddf5c4ab5f5420c8a01103febc8c8390cbf17c9b3d0ec4a18b8d29925274884187fd958ba2d4a5da855c9d31bf4c1a717bad2682043ee5709e9e2af4d5430b44d63cf2e15a20b21ecf697e8989d492a6b25dc0c46c6d1010f8ec2ec8fef58338bfc85590b528d3fb43c6b567646fe6307da87e77e7b543e75f88a79f2cd01d4ad857f1f1f7244ef3dd662e0a6e53fd9d00d935b67195faa7588a177e877dcd81ea0f7b874ac222bba87ab553aa4f45ba245aaf373b567db4ad314f0f5399f00f46a4e5011e0f1834610152a9230e4b246c7024b60adfa86035fcffb7ceb3e6d1e24f49da38e9b0fea3db3d475171068320bb4c6a500e63c13faff351baf31f36f3a0cbee5b033f56d5765b186fd84f9928835f38296be36aaaa07f2d5288327b91415a0626de10c563520d09a49547664dcd19024a701b6926cdb366257a97db55282d535d7f0bdf7d39c1b5ea33e7ea022308aab509928c939e06bf51fe745898307311d7703081885168291fe8472ed77d73d04c20f33ba73fc858824712f90698ded87c5c22eb49cbc40474e9e038bbc56330cfc6677824ab1c4e9f834923f32d601d8d4b50877774db4d3ab0ce7152e49d5aac7c4e2ec61df697fe4610dab175698e65210204a003063425e21b712af1a02512ce1cffe0d70bdb182647f501cf2e26f4422c7da2e94ba666573a11f8e9059ae1bb5e6afbb44f81dba6cb44dc9c3ee797c8b4fe6630e5f54677aba80b378c34a9265b017d7c4ab6bfe0f01cbe40bd470f03c1f92e5cb3724e1fd843df5633fc5c1f970e46011ee1a2c7ff44535d89abf030136a5d3154edb75f7e5bb668ef1ade85f936bdec7249041ea5e8b44af34924decc5bb2cea9628df2f6aaa6f17d95eb96481a4b1068fcfce02de60134b34fdc453c45aee143d2fb449b44fdb10c1dbd5c2a260556264edf3328dab860f7eaa115fdad35514670bbc03034f4f5e5bd0db2e97e20549c05dd336877b165b8db7d89227cc426d596e13c88b8395b28b3d4e8340bd80e37489d839062a67c4a5dcac49e9feeb7b54645688e52131103a0180a292d91f7c7f8f478e34acecddc5656e1e6d58ce205a2876877357999185de07059980a1f6c023cbf0d84b172770936fc613e7c7b0d9a553e9985f89272aa06c6606a2622efc82107f0cb75bdf5febb077b0454150fcd0d620b4a0cd119359152b62309154f2fd5d3e80127a6e549b667cfb197ecdc00cb025ede8792534c31c01d59f9c5356a686fdeb0bd631b04e0be52c24eb45a870ca7d5308c18d2265d9618f7218d6e93ece928321f75ada08742eec88355e566b452f9c33ba5604a499f653f6b701cbaa6d7f11c36e41c8fd871aa4d9105bc22933500ba17ef7e6662eb3655f3d8ef7232222f2cbd69b9eb954d114a0d90a7d74ee47702af5e46674d1227447b3f7b9d1e1e8201c83d486d8ec2b2c9318948a1da7e2cd1878247b8ba261bb92cc0b2562ca7e62e269d8e0430c4e6b2786c570fd444074c5d310bf8cb2937d6854ae256448cc76ffa354621878bfdb99f563e80306f56e2a97936e42448d52382f7e67b3063b20ab291e9046f50ef39182d82227f780ece5a73ea92c6258bde0c68aae90d29a856d308ea313aa49a8b829a996e07df352441dcef9e58e199462e1979f1fefc1d8528ef52acee2a84966e105ed6c80f516574b3555fbcbf6a7e67715a099124c26930177f8d739b4d63664d2728141ae116c7eccc9f4acd8200fabd33a73749a0f9140fb4fce5a7d2ad59e24f6554db58d6c81d635b429b890bce52fb939b591e88d1fe0b22aee9c58c2a3a59e666c824cc799d5fd3b0125ac8bfae8bc9206c0e813c55799451fefc111600b8ebd2c25913cececcd0af8de3ebc641b1a01a68b7412a48fa59fe9369af72554e9a4a57c7a6e3a583a7df4715639d64a79133646d6d5a18b38eb93c70740f7e6cfbb8294708d223214f529c037650fba0769be50500601d75a45833a39ba4bf5b5e44b74ce83bcfbfe661504ff7c5e0bd3f2d41eac1cd09c3d64637c92c62bbef5211f46c07030626a391d960ddbe0d5142ba2f5f8d3e62efa2b9ac4e09f1aebf4b22697fc382282246979da03b863a93367e2dc29f7800c44cef3518a6c6e4ac5f47c37705be4f53f3f7440acbbfcfc265d86d9d2bfefc62754fdab66608efc41ef00d0bdd25c3dfed4f5a7b8d19b83b2c2c8a6fd1952c6268024ed13ebcca45c8dd519bd5d2371b965d2696cb57c373afa418f6c2f4d350444b1cceae33a5df485a6af3c404271f5495690a4ee29231687abe0367c1ad545744ab882175048406b1855130d54c5f93af38311d99d9e87305102442cfa90abd9a5622601b20a800dd220efd03ddf977626daf2a7c62267d618cf5e38d4288308ceec287ae6911fd97160313d544be03cf2b6b96f92300dfd65b27fa7195235bda10c4a4172a4d4f9eabbf136bbd243e285a29f6275711138e8887b59af5fb0ba0100185fe602f37390bb7ba9c674f8bb864e131f6d7b908dcc28c15709f1977df6a6528ec3c1b5197e1d8208ce5e9240ab5021686075f0e631ecdbc733a5ada3dea291fb9c7dbbf7728c46c8329e8afc855773b14705fec06d2e2b4f93e943a3cc92ddb4de72a10073bc3d610775a7e257f43935a89be957ae808aa42db088117f4eccbc11b9da73366ed17c51ab9e4d3a93866428d0e8dcebc701918c5245783e0501bf18774571ccfa069dbcdda9baa43321b16fcf475e9760e686433290d1416ccb42037122442b2ef52e1704455f7a7ed2ac3cd16ce76ad3f338a79fb66e2d239bfb44f1b27d1f08cc781e180d3f0e689112abd062a44d410f3d565db87c98b05b46ab92a882256966fc64cac77f8324da26ed0160ab4a23df1a7f389d0f0d79f8c38009b9aab473225cf9117c2e2e472d4d059e167075774b7e719378b6b69cdbac8ff4834806f6dcd5fb3c587c2694e2b8f491e49fa8d65dd86d172d9fadcc1b8a479703054a70ce2bc434d375a3c7a61a67fe730f95ca28d1ade3671d3dc4bf2a3c03aaf68aca31b4f6a4e61159df76441fb6cc3bd062e4154c73682cffdbd7d125cfa68ead039b829a38888f7bcfb9253aab874aebe5e6ff0f15972d699cc5acf793ec12f44c2dd8c826612a41df75ac01ccdcc80e6a2405c175782d3584cc0d664504c37b10ab78aa2aff20b5d267b23bf16d622a256553f2e1241c42315ac9b4527d4eeae3f7f88628b2e3192f2be23a579ead8501c3aa1e43a160d6c4e989ae652ab45fcf01bd6ee0b0abb5e991e21909750811f56e3dc3861ba1f430c4c973198fbd12e2387909eb0a857e6d0aa711c3eb87d6580dddb8e799e36d7207faa27d3de41c51d2eb066081d1b490ad7ff7b93cce62c0d46f98839b133f0339cc6963be115345b77d5079e8d663e4e1734fab27eacb665ab24db279f852770e24c32bcb9246bbbacef92c2e57ec101a5a108f5483951a1ee4d230081357f5d5de7d9b6210c95bc206df180d4d676b12ecfd26696e93b5dab2b0795355a2cb63f373696b2ad1ac8a33c13da357e35be01e3f4f8edeeaf1ae79f25becde193557da57791d65fb9d3dfc40e931c44b5b40b53e115bb847e5b815919445b8c4d5d9bd78c3c64d8b31a38e4eec02d16839445e554af4c370b116cb48fc11e9672b72019eb19b877b7290dfb4e7235bbbfca20ac6e4a3789b938f3bfd281750a246fbbc4419e607896ee1c9c5d08da0c336e84ff1a31df21c9ad3c8bfca60689e637fed3c7de734916ab469d7e7da708e779d8e156d1dcfee9082fb5208f8ed6ece5c866725eb4386aef37d39ef60c46f782b794213972bff09003b6b56b86fe84a1fe9754fbcf12746ba922e38f8afd89bd6499b047c1624bca447a8b76588166406cde77dbb08185bd9717261d16e6aad14aa8c15f43254a5173bab2ae00cfa01907585f9eae8818168d50a0ba72be0c6c9b2d6236189a79e4b6f6f8176d5615017202166bb39ecfc972416ee7074678f1c6bbd7fda04a47d14c2fef1ae6e851970de48db6fb6b7c6502c21266a28e109d980366b8cee3e08e8aab85235f8f0af7a86164111968bc7f2b6336841a8e1a9a4d4bb23bad4b90b4f6a041a9193273ff85fbce72912dd7069daa76562e96170dfc2b4d5b93cffa28fa93a5bfc614a6e5a193b019ff44704ac9aa9f39a969d411d3706ac4b6775fdbdca514a296f05e17751d50a93971fd0f206320dd26b80722042a5da5abd57a7b1aee113571da17c965fc09b93bcd6878e07f226ec70e2b295ec4c545c3bd6b5abe74467b152246e931b0f0e84e7d728949f769267aae04ed344f29012c93fe0a0d443a153da0823b78a85676caeda2d0d485716b47ab72fe5b1e50c6f6337d448185a5dfd2436eb11a30927515be7ca91073e39d93bfbcff0bdc20c3f8fcbb92f7169e9ef5d93d04aa735228d1d7bdaac373f586333f8f8f3e20a6bc5db0ced83f04301e28acb77d96ec53ad0ff5b1c9af7887323ca3b8909976a38b272bec39c7b2748dee4890034731e53bd172bf8a446b825beb61b19d796d8c4b4106497e1253dd8457c9e738a37a963c406627d6bfb717bc7cae990fb82cea36b2df79be8dc94d734f7b30c10eaf1968c02da637f5a957772bd4772db49d96cfd41aa5ca31f6a726de1e1e7fd14259b3855194f345183fd026c8abc661255e4f945941e3d8c95d8cb4c8f373756579a7fe73e6543f9164d824e36c5c385adeb6ec108a7128377ca44778da5d0b59ad2ed8a8d09fa998a01992baccc709c9b0722bb2ba4827638854c931a1d27cb61cb1ad34ba15424994ad0b1d002641c586f8fa2cb0b3cab7a8da45ba5c844cda345dc2c0443ba0f9d080785991950003b6da2a92b6ab14fab039047a0a3b6b5cffeabbcda74eb0788e93ac8d9d741c9e549a46b15c7780a3b3b3c1ed9b914972926ff169823dca3a61f2adaad13c5fb3641ec5c5a4ff00400ec53563c24f93cb491eb75e7918be6ba58d1a97db0f1ac3f9c08a8da9eac34589f1828f65222d17216d0a0c0afff61014f98d4fee6f4ee2cd8f887ab963ffc41771eba49811dd3ed456414c9f2a1da3a69953d827d16ec408a3212755299786ae17028009fb56924f33c42de059a12dfce66e1c9d2390b3da602d577bff29638185b627a99d8cb24b35090461f2b4365331b696b71ddc7c4af6e9739687a2f1706c7ef4cccd331cf9f304734b26bd02e904d7d56f6d5680513ed82cfed470b06ea79c34c351182159bd6a724013d78634a0bed63592ed0a6199ddd64db93b5be40a4bc5a7abb2979e7e3e98f120d5c8615343a9fcb4ac9dcef92dc865a8c3d8cc003be231f5f3111322f0b8b95c49c9face4ce2b07067c76450e05b8ef40d527f80a001b8723b3ad9dabf248a38779fd67e915bbdb1f666d1602a18cb88d37c067a1af0f4a27b8e7087308dd68f9a9489c0233bac9cd7880d807eae7e26ae097ae0b331e3d17bc0acd9d390caa7ffd823f46f422a7aecf18eb8b168f00bc4db5f07b4e0e1ca4e77406d86f4e0de1667167d5e5f3e634d50a91887b8bbadfb57159c04d00b544d9e8d8ea891f094dd4388c7562588c33603ca614239b10e7dd54cce0ee3fb0a257082bee411e4973fa4fe95bab40fc6f5617acb1a00bc9ab29b21e3e14f390cd1c4ab254a80d6a2893d1a38498deeb97d57f75f4777fd259aaf4e27f4a44055e10eed5fc82aeb1918ff7737211eedfb9bd97a6be71fe74858f8546f26a2994c8f1c5b6cb6a5f5f31653cb583b0334fb87c06cd778270a42d945860aaf4dc34ab86df9d6eb9e95377b22cfa7e160fc325bb0f7e778f6387e086ec4f5ec69305b079f40e2f98617d0d7551b2f80770814d1b4fda7f36db19be31dcc0bdf5bb8f41a236ea95266c2588229c1b0f1f71731d779db850d883204a26e96b512dde1b8fc7f3d7decfcd4b97de76bd7030a2409215761e9d6db2abc2f9b488ecdef0c0636208313878e124fe6719933c65f095cfbaec2fd240b2ac0033791458f2ae8a855c6b8d1608cb40bceaa49ee4760cb40aae281f24e76aa9713ea7db65147d4820929086ab1209c297d245e80901b760fdb867d9307c7aa7b6946ebf57b16da6fb70031a19eacd3620ea7ec74136455f00a7a4b1ffcef3d02fcf11b34f97860fb258aceb91c29f781fa5b02963b03cbd227c9d8f1dfb3c521123c879008cae612e1841533b4fd1334af11c57b5612ce6f490f2522ff0c54cb0be6bfba54fb8e4eb1c5cf872c05d86b701cbfb06f0ddeb31cd2b637741975c954d27e7efa89ca1bd291bf3136edabfbf68cf46b16aaa65e3f52827796cde5d079d178d0e4d7378df9e19d0be35745b176a442b15e4ec55bb12017518da2a0c73842d14c04877626a0ea8e15f5722b1eafe58b151873a9fe3d2a221530a38c484435738f8260bae2b6862045c2d5ffd1eddf60b58ef7bf44eabab2449a7a94da236952a5c773b186f75f5f1de897d77f5ec7bb414b026f7371e1d7f2512ec8ac6e82bede47fe5fc38c08ecaff75b3ad408e3d1ae8dbc8601f03fc5aac5e8a28f6ab66223486c5cc4346cdaed543803d2840abb020e2324e9ff1b77d354d441b1e9390aa9ea40af95362f21654ef7227966db0ade46cd3bd30f9ec7cb9b8e88f8f39c94828973196cd45c2b4e21c93e589fc9e56dd0b057115a407a1094c495f63512d83f2c04cc086a3587873104f9916309828093ba2bfd2fe2fac2ae6631777ee63bf67a177941c9f8ea90dd4ce2bdb5dc3564f4d9dc5e514860b548384c2b04b32fcc33a10270796345080356f3621032e4bf794f4d4597f7293886a1dfa8a2f932f81cf488f35729cf523aa77aa22371abef639fad9a063749d9f4010d1507cf1cee9e205f2122e63df2aad48d74ebe2d273a7520ff20619810fdd9fdbe484b0df562fde681afa6a390688b6038962d89da4c6318190eef820552f089d63184c9f7342f0b0b3f0cc338fb6a9028d9f6d8b67c79e828e2e00a87015dd6c569d7ded1b17f863c76416f7a7ceacdcb5f7f1f3ecd965b2a23ef0f2f53ea1571b142390226c8b780032b5d0ef845fe501eac3e86b91396cdfc583d92410259b7de23c16dba87c21462b02bcd7b0179f03b9744a8c6f1236714880ade69939030c6eec906ad83f03bf4eb6d5c77bb795995a0d176ef5088f6f4ef900692fb8c82c2aad346c5e44071d6dd0b85e9ee4d5a4b46011dd6bdbf563fdc242d388f15df2aa5159c2ddaef177928319ad57632bfb37466c62aa46bb9e29e060631c075546a0ec4fb05b907fcdf8de5cc5bdc5556567e2136767451755368a659248e397b99198c3b0e88b31056522cd4773c9883ef7e14f99685bc3d4791be91f263e863ad4295e1bd63e3b809b6b4c7e74f6ce19a95f6da5a5aea9030955e53d5d049c3bfa2d3986cfd8210a4ad5ec2c5b11023b61fc17f4d6459117eac737d2cca4ebb1c8275154871257ae9f7ce38cb85aad346a8c89aae60fa326bc8bb2f936e2fcf09bbca3e72eeb029b3171fb6db9011c968f3a85f506b1af5c54639c989b888aaaf8f5972db8af0c0e5acebbef224b9e53de97f07a70c30bf2cd91f8620c19fab511fc7b32d0a49f8cf19e5c7fad16af3665627caeecc1e70c6873fee889a6e036ed9acddc68deb81ca23db91f399891aec07d6a50a4fbdf6da57c4e1b6c0fde45cb4254bab33e4971f94059bb7bf244b47e5aa89e81e5a4472c0511da7b1eddd151e1cab464672eb940c23726c5f52ba736a55e516e86ed4fc3c7e742440c90f7c21868f01e5342ca6413823b9c7be22ce14208b87b8d1f2993f3f992a64c8d083189edbca6be4428cc85f773c0c7237499924db7da1cbde852e960682e67f4da3b7b1dd300b9abc520cf4d9622e8beb21faf65d3b5a208e094365990a106b642e10329bf48bea3c2ddf9dfaeab87745b44e327ce9dcca117bb47ac1bf367210489bca4100adba12e8d75fd9ec4bc29a86f8e60dd43d3ec4b5dd2be94534d760946e10036a09cb3975bd60cfff9fc7daa72aaa4cdbbc57a05e4613ec7774bb61177db21e0c0cb97344b40a97e76ce3fae74344a59cf05b938e66354e87b90d188347d42284fe543336ff40c4c44b094c311b36f3dee298378e74bd6187bdec8dd42b295341b95f2cc5fb1721a2bce0426e98b95dc0fd21317b8199a5a428f8f44b0471da6d5a5514d00ef4431d0a052656de6ac1d830c1daa1fe806b37b8534154027d036c4bf2a17c215779b566f9d7a177ad9727f8fc8c37144014b15e1faf838e0d53148c4d8fafee959b980b883a5b111561062086044bff797c427791edd43ed19eea0cc2f017450849c82a91c485049b8c1a46f3b0f1fcb512bfe7b0ca9dabb2a44f425f2e6c91e1c89b301065cd1ac001dfb4c62009d88cf7496aa9a82221474bb77e96177ba815f9e26bd42cb7396a12b2231c5daf305117e0c7f7d34f38e340fde386ce4aad9c83854edd24adecb242a1a2c022246a069e7e5e04b7c527bc43137c85bf7bbce406fe99815913aaf9929da7b429c9a4cc9cbf98103fcb1a1de769ebbc8545ff84556e830cec42935ebe1191dc0a51097dcd5b05e7bbda246cdea322719bf9e98f2973547eff48aa4650766ecfc10069038f427e8d0c8a6c90b8440b708e962bde687bf65ca0993fe5394dfbbb36f5b4949c23bd67c6d94fa1cb5255de256123d8ddaff0865630fe56bb5d0e4cd582bee773377dadb475e34213ded6ac87162b4e9d67f072fd3ac1929f9706fd0ae296fa3a4cbe592e3ec502281193bcb36dee934d8013a910c4e8aa45efab382b3812237c6cced2b79a0e21fee924cb65f7c3bd98384c3d2c2132e0a3b219ebac572422b50c81682d7f3197a2b6e019f993f0e78cb770e7ad3464e5f4893582828de6d13652aeecf542febc67a472f8431ea6fc221efa4edecb7c662c37db62095fb80c0d992a03c632f91b14b9c467223e128b1c4698a4302240614e74aece97dc62278f63e3c32049eb0032b216f7b9b5092b7c96f748aedbd4b0b0e012a978b8e1de4be6ba15bbaeb9f70b04eb24c02ce8c103b7cb72fba738c8e75f9ad8457b36e9ee0c771b9a7580827ffb804648cf9340fda751da5d6cca32667b548ab2a0d6d6895904f9b36a4400f73f373b1fac68c984b31954c6118466b946f31b3503988cceb5f62e188564fa30057dcbd87177625eeba56e8cb40d6e653a92c6902bae514cd40b6627d4c1c578497ffeebd745c606761beff9a3231329de94277a5778c643194070c5ec5273cb55b9c3e56b9096b673c16602d59014ceafbfc1dd3cbe2b264cd68f7d33d4d70a651e48df6c3096521d7e1cde22a6b6c44f64159008a19a0386cf146fa32ab222015781f51cf1aac188f9c307bd939f9e28a3e9f9fe018861c0afee858e4017dc2f894581dc1e8dfd248717693b712b6c11ae437edb3bcd4c142db59a90a137969033f1241793ab18f546a54d0f5f0ae2b6227d96344e9de10215404273c66b8cd7b5d827c72bf5272cfd67b92f6d69d326cd46ebc5fc58dcd3619468665502efd8953d2780854a7803d6a7c583f242752ec999f0adbb6343ac2ad2b3c671756ace8f2e341298017bc754fca07afaddb3f3cfdceb3661cd6a6a89a40fd14d8585e7dcd2475903d83d6accf5ce51f4ef2ba30684a56c4124fb5816bc045576af38b1a026656aaf94666ad6e208bdbb1f209da280d34020b3bd285867fc67c5ef7e4636c73e266f096f6da768a833462bc97bb006212fe8318b6174ca9a5fe139b34301a7ced66e8cc949c671e57c9f713c578e3be3f6d90843337744142e31187463e04792605749e3275a49a5c004d095c80d86b018018319e615f7adb73d0c15d8c24f2ed40a081569d3306ca3d41ebad269eb232f654e14b2f8b5a7c31969e5287e75e10501007527f902cbff00ab6e6a046ab5de1b420dec7b8caaa885a92b98b9e4a613520a2dd1c09a7ed96de20fc8b4e5b57fefa5bd1e1eb590954757bd23e359516f5f502482f96221068c4b8830b90a060801101d237c105a6f6601b6de7e9145e7be1a9b03610e650c5b850c7db94c52eedccbe85754dec18f8ab9bd6295ccb81eae240dedbe920d1669fa530a0d81aab56e982cf295dabf041b42ecdecaa2fe824689cc69e38f95d7304818e4286c3f3bf62c688fd6c7aa2f4b9258f3925bc3d27a4537aa2af4994da1a509d43a44a97e6acb4db24b62895377a0a54311c61ab68c941f6898e47fb2768365ca227745d4b1607dd62cb0062ef70638c0a93cccaee673a2c73792daad512209f2564b1c907a70e9eb087e3d17a5205f4ae244acba54e25cb98eb35f27e2a1d3e70a381a07ecbf62c9ad0d96ed4531e40c0e0bf54a5dc87fd861de815145bdf871de7321923c08550175dc0af82a36ccc0b5477413e4b92144b6c341c696658024668f43f1591e9692e91ddc4e7173f580649d135d3fd8e8cee2a9080a6e198638a59e02d4c2e5cfbe7da156112bd79a6e46ce20034d4ee07ef8e68377d3a64e185ab8535aaab3e971b501b346313bcd871b18e42a912953763309320199d3197de8dc64fd1bd47e8b5ce5fe4cd101626a2de37570b659fe0b67a7fba0030966bec179e22a5387891756a773181b3736728c26b2d0815d7ee552c2b0f69455d78589c677a15aca1e393ec021bcc54e2b74f9ab8d60d6f7632460ba22fab30632029b0c29f2a5a1726ce0ad73e1ec069723fc5e486b2f3bb112f33dee446c5c5e3178907b90dae2838d84d8039e73161eec99cb887df8578c2cc398c5a4d7be8b58c1a8874ae70dc9cee2c40c5684a845fbb84288a1f2b76cc9f3babc86bcf8956f31bd7008fe6007ac599504bc331a81ca5b7f9b08397d8cbe18110e916bfbabe51d0b2b355c2253c23a38f4492e7f62ed0057ca38036b140f754424132fb8ac1dadee3bb15a21a3fe22ff66ba73227a1eabd08d623b26c26fba467f5cdcc7d4cd81dffb20e5e6df62ea3ec7bb4b6537c3680b02fd48bcc6cc3b405849acab17a95ad5bc522810bd2cdda7a7c344bca8872779d05ab7e60a5021432f71b8b5a6d84ee40de8c8824834416121fc7554163bc31a206a58c1a7ea94691f993c4635ad7e9ac8424f7293a6a0c5650f96e19f7c1a08e3440776b2afadef79e26702518ce4950f0aa67d2d3e21b4ca9cdf8fec07e251f1629c60231e8ded762596d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ef366434c4c8d5b5f0c593a6ee9a18df"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
