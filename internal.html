<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc414b190a309746fa2dac3e006d86939ccd57b17e5f6bf0ef037da98762397b07016b92d132214edf7d40f3a19509b8d9529eb9d30e3c80e27dd2553105eff61226a6b110da72906e83ae6aa698cf9601c81905dab0f6a85f5b9ba0b8f586c2c6662c2cd21dc010fba342b332b6791cb8f4b5b69d23ec2cd0684897a71c7b19414e612824b3b91f5497df8b348d47c7dd42e616650d484ef99c3cd4144d115eeccec6b0df8461d3f573e2434e0c9c09e8e9d310fd34bf248b2c014875b4c50fe0dfa00c0c552e262923f816cd9cd1de496a0fad56d5bfdf9bdf3c423a6f3a4d126189fa6cb642a0b0c7326c284c51e5188d0b02c755af61f7e56dbeb1ed00be98ebf33a90d522128a134055e12275093f026da20b993ae8528e85b51fcec75d025499af0e3090ec6131adb7112781982d76f43d775205534fb5593b617907e43fa51829a2463e54f39f7882861547a4f73792b36a624d7ac7ab5002b863a2872472a9535b72320641467cef40b06a6cd740830cb13bbf590826eac4451563a3e6a3945d7fbedeea3cabea218c20df7adc77069fa9dd85c0027353edbb5b87b913c8b14e14923dabdc33fedcb9fda36c0b7680cba5b0ea476219717973b4f72254c2d6ed628ed5f61da20a0558b8938bf792cbd100127e319f4d9f4150f3b73360048173743e70a9063b089958b33407829b7a8cb032d323c8bbc545e5c50adc1932b997b67e2890f2126b9f6fe54c31a66aa8617f270104ebacd44663ba8056a37bc87e9e58e82047eafd987a2a063e95261466f6fab0fad8729cf8d457e59c1a4ab38d785251f41b89c5c26bd82c0cbc72bce59c9e6a1f227c3064fc1640f2bae5d15647ee7a82653597bbd3551cdd93d7ac2ded685aa6f9c89b499e54b51ff2371a001758bedb173e126e0d576752bbd5de9371ee4d6e51a63607c244411dfe3030157d24966d7d1a8eaba96590d18d2cef0206432163f4c95353f5daa3901a8ad5a4de8e127aad75cb19050f6055600e8fcd1cfab404e7d3ad8e513ed96aa900dd6d9b3678787c1abae201265c20e154334c0b62717f591ec4b58f86e9ead7a2cdab364d51202ee03f1004eca04171bddabdee281bbbb5a34d45856cce5d52bf638730fe1de3166c62667162e8b58501e94235db2d45c90a634dd0313250b7f29b26198a6be6d66a84acc802fe41a0f22b8811ecb9ee71ced863ab12ca304e58a77bd1be4c2e7324258b5463a9d81d7c50b2fea730981573777503f6d6b90686e80186ac80222f66490c76d8e9caa9836f487e66d4c3c50f6f491d6718f1096b1cd1880e3f09ac26b0fa7a2e32b6db21881de8f2d157af82c5130c8a8d0bd5a276728391896908b486edd487715b0b15a61776909a9f4adf4d3a211d0d4a93c0d25cb672251fd5f7213289c130da55602d614d07d7fa9c0ae716045d4ce3e0ac92414b123bf265537c3a7c7817eea6cd0ac965926b1d3564c4aec348e69f63d67efa5620a5e6b952174f89f1e328800d16274baa2fe106f12bff3dfde742cf94209f080af3a295a27811fe66dd260605ea302eac9c6a1733e0dc6026dc489c46a3dd5fbd1ba53731a06e6ed6ecbce352e1dada3e3c6baa9e376ce5f8cc7c54ac3f9496b5e26afb9764551a64e5ff15e77ca4d91c0ec0f508c6a82b018ba367af9b527907a497b87aaaedfced3cb3753fccb21b4f8a5ea13ef712749a48d8caedbfdcd1367d826521b9ca858119464e31ba71c46ba0278e86aae42fb11c57ece60863be6160cdf91796560cce72d9d0728fa93cab52e5afb2978fe9f8f06aa1ab46b1e7d35936d11f2bfa9fbdc2440ef6c5dc0e3da173b607f1038c314b062f061bfa90e545cf506c5d3846a527b97ae25d41083c7c8c2876e751b7b42e888081f7905bd7c26630ad68d958002d2bcb16a0a45ad4ba627743a367113d16835c83dc1a9aef8b4f6d04129d1cb8eecb5c4fb5cfe31009a84a41a21e048f09c8720b1d1a1f19bcac2aba74e2073666d93ce76356726ec0fc4b09a52d39f2e6c4001bc4365987876c4f1f429bce6c94252f5caca3aaa7eec071408a451edebb224c97687c52929c1dfb8b576993050c7073c92f72a875a04a49b2565df4b2a6660d15b8a4f230a9092d5e9a1c8dc967050074925c68f1bad9bcd451da97bb38715e7374f229367f65a49908cbe8d727871946d59353ba60c4c0891d143710ef6e387b89a508da1be6b08c0eeba758128b74f673de513de44e0b65a5964469e7393ac1f28a0a8d240ceab284fa4cfc89179cc7099774e3c7843802608e76bc85c84dde3ff028544ccbe5c43dd0fafa7a9b24ba8af200741b71f7a0e93eb30c68025ba1305a1d2f3aea45800ad5ffe4609de9af7e04530746d090c4edbfb1592113fd3c9c81f9db339185725e13319947e15da7a424a21190c9be0b04370dc128ec97b8063451a1c063df3e6b64adb2cc2e38cec398832b6b1faf4e7dd8ab5039edffcc7062bedc84f9e105d7aedeb49835c69e94fbf132b7d0bae1489783255db68feffdcb9254a133f8ffa95d0e1aeb8380ff5c37ea4c19a555ac4b9afb6f14ea6f3a6329e88aefb197c662f143603829407e170d51709438bfbf91c79562e96aee42ce019a77cfd21a3d48667860cb401c37127ca5601d41583cb9ff79b558ee6628bb445147e84407b59348235a2fd01547d03ef6e730401e07ec262d3c8317e17c9693cd0b993beae0e6018938fd6e19f33496bf31933ccafd3be7c59e0d075d0061c76a4bb39c4d1549e18ac6d1bb63bbd5dd348a60f9a3629edd0cae1e3f50a6d72800679bb2ece4ec4c3f305d988067e7d9d75275ab3472d5cf7e6bb0ccf96d78339a6a7f3951aeda6dc0d4e479da138e72f42e4e34c8eaff0a89f0be0fdaa313200f3549bedba44c2aa9c2931217e995939c38267434bee34a752f77d7a0c483a341cf40430e4b58a2ba8005d6c15082eb512c8aac2095fed4d7f213ba97845aa240a51266abca2cae4c0e06b10747161d9704d3a50e04f8a4941488c3a7c1683475d5ff7cfb87331e6a8ee9754032f3f56bd1ed2bc4acb63dfd609a92e9fa72ad59be60c5440529890bced8aa579a747a2244ee4a562df5bd6aeda14033f335b991f3cacf81369777a0713272b63d483aa8910025803e2a0aa37116fcdcb378526faaf23903e00dbdac6b85b60c3b86781fb1189faced907b7663405cf948d18195e8eb4adb0fe1351e6705ae04cc2a8dde27e6e784e0dd55d01ef27bd288405196434d47af484d143fb6c0b5f36b66a5a2961fecd6f2e87b09149d1fe183aebdd4b453d468fad1c4e0d033942e16ba8e62de84ae041c8abc3f4ee241bbf954d98ea87d7b192ee4148f7a06cfe5dfbeefdfd613f7c7625045cb56e01c19674e9661e1fdcacad518bdf42da595e41680b464e2b309062ab87ea62c6845cc71f0d4ab78f2e0100938d6e927237b4e0ba381d9582e0b6f1794fd4e827560571283fde1607cacb1e4995498f95ec044fcccedd462db2d5debb87cf8e18c1e3b9dd9b881918776fd545dea712722bdd07a88b0a0ee258e5244673abd8639d55954c63a4c1cf570cd0ccd5bba277d9507f800e7cd5b4543ea98d0d959bc6d5a1f1f0c9e5de454c8cc6a8284c4a46ddd37a6150630a328f2abd2e512fb0c54887739acc5546ccceb745ce9ad27147a682346b6e2bbe3b7b18a7ae03375409d9224c74120c826f8977e231ef5cfeba13b88cd9e7b2115ece1db737b008a3ee466de74388ee867914ab476e4d6a0f5276bc9cd8412c157ffc3d640cf1581e782f6bb1fc61a2dc9e8ae09045e9db21467606a111ecb5e7ffc5a47d5a8b9df3eabf8d9eee8a04eb2effc535ef72cf965710a5170304433abb1c7b3ad859c6968d5fbe4f8feb421d4ca1ee675b03d987ae4013127cf024f33c2ab52e320733ca8f9595e47a94aacda42666c346932171e132094736f40ab692b0fa2b6cd7bd0712b9e217be5c078f63228587fbf2b47c4a226062ddc63d51564a56f1536d5104227ae3101a4158fb3a39b2b92bc2d779a52bf67d953ef87eae5b76296dc5a91fcac829ead080e32b0738f9b73a64e3da7a70fafe78a58d784751d1117afcac67fda0ba0e3485f70d5fea2453e3f54604a4366a489421f878583fed6183eb60a29b8347b2f65f016306e3793e5193ed24b4c5d547ae91291b342e2a7f464904b599a41dac2e72ad1ee9aa343ca34646100b304998e01dcec58f14d0d4ca08179eb6586d697e8d4533454e07e1a5374e009bb8478e1f478dbe908aa4d84e996702f80871568d4e26197eed9c53a5010b6ba2959522af1f49a66a8253acaa338f8ae83089dcc567f5692fda4174d3e8061ab75338711959dc262a89f9b03922dbb19b6193baaa9994a01a4890bf86756c5376b8eee3a583679b078f2865499b9eb9d3a0a5d7dcaefca2d4d133af0b2804989a666e7123342c33560c7c7c6f1cd86999a115224e3a231b4eaed33624046ffce2732d4e5c8320dd4007e21c5444f4c18b3a62f538a344543d2d438e35d3290b06e22bafef78e374f3e7cc4aabfec913945b8de41200565d07b66dc557f0684f368b0d2c91ed50703c6122b78ad78b2eb81fc5c23d95dc1a86ee96549abbcda31e4b33875761ba8fe902a98a325ea4f2f1fe464f8aad562d0c3999264d94de4c483a7fb06ff8819f8a298072dae07e305e2c7430daa54fdbd60866d79dfa87d3bf9868f9b1fdfae185b1ce361b0cf8b7e1418307b3758f1f54d2809a30f267c6db250df33ddce99358b3a1d4d6da9c8b20195d98f30cae203b8ea7653728034c3dd37a39b6455435e358b0d6d79f65286ef25e52452856721b6e6d45125118c3f70d4467b2ff3154bb15c50da6471c985b80164598cad4055dbeab4e5369fca49e5be9577372a3edfee95abf31f14efbc249b7f62408a64c33fe770fd163cee0b6dfd3a665e93ca5efe2619f6098108b72f1c8b67513a8b09141a35744eb4019dd7af1749bebd0fe3349dfb87f1ec90c4e6bc0c5a3b35aa37984e83cf3c1136e08178afc12dcca4f8a87d5e1a27d4f477b8dcaf9b05b9ed3e2ef7825040b4dae6a98743b9773a59cbe9b0f5c6b55b219dc3cf61bdcb714a2c1f0b96bfed90b0a8fa5d48e240f0b59f55f8a329d41b06c251ed3bdba69b8bdca2bda83405b9f42397730eea4c1545c6ac79f96992636dd2bd9d9cd617705dfc9de5331ed41e92d02324a86c4ba5d5e0e3d1cdcfee31bd31a001cd8636a69ebee3b7e48e1547544e8c91619e19b032a0739329849fa82d4abddd1607c3f7ae54b6a2ec5ef75b79849aa2b917b7ccf9e1aac105b688191f5079ca808960bbf4500003c9f372ff628fb9aa295198de5b6f1e215a243083e591eb9649c32bda15e17df05a7066355524cf4af5321d9bc04644ea22931739e0b968f533207f3335feb0895d8ba6ee518a1efa9c1d878dbd2468e4423740cc4126d154915ee3911b9ccde3e62eb87f9911205185da57cdc325e50de60e0a6a77538d95e57eabda60a58bc1919262d54a390fdf8b4bef47bdcb9ce20078ab648d87d4c7745b22575d6200d8c5c5f31518f535af9a8b11383070bbdfdab203bd432128387c170ada957c22ca88d85c0205b1d618e93063023a9f71431db77ec0c94537ec095bfb7b809a0a7150c821cd4b6789e55a1fe692003c9d6f6b3c45aed2cc63852de87b5cbf4bc235753918046003bfea4b994bf6334d7b01f53a40779a7921f16c60f9b9be68acfe1d830c9cc66b2c3e527ae917b3431cb1eff05b92e92c07f62ac99cad7a95a5a544c54ba9a538de0909f9a91ff2df1b39c1a5ee7b3b2131e839221055505991a82177a4b1648ae5df93b8f377f1a39e3b738db4a6b6bc5f92deeca0a4be748ac763407fe129befb353d370a239e411f979a8c3c350a811408d3b5fbcb7e2cb2b7fa1707fdec302bf5bb8bd7fe9a03f0f2d00421091b85c1a492e2af40a9946bff3179824ef43449efbff288d1f7f3f88a69edac9294cf9171284781034efa1ffe359cf4c68d20c0d9bd2c3f05eb1d809e694577175eb62ba18516f6f0cac6bdd86f7537bdc73601690cf1ec89a9ca9206e831eea5acc4eb88ffbb8bfe0f6b935eda8e44080d43f2a799e42fca608438a1330b328c9d7d6e9ca46edefe33ef8ec67817c74f7d1a2f79d5934e54ef78264c81a6b6fb65bda7af50960e521068625f1449b4e6d8e387903097801ddb741de5c4cf66e69032942869a822241c01de22dafad4d9b911aabc3efc054bd42c73baa3ae68a73a07bb2b277860778ee0bb6c058d57d1eb7b0ebf04b58308aeee3a2eaceb902a419b114537b10808d0fa0366ac2601c17b119c79961e43009ca4718c399434f1f1ac990eb5212224cfb75350976e19b956da675f0ac6e3f4ef6b5fa2f5d8cf0c3e84c037380ce5a6c1a2b80943c968f04eef7425050d5ddf1890e808e05d47a02e323063d37fa7109e973b93be63172f7e9f69bba6c2478a4d931a8a5a5bbf2e903e40aca576b040272d93a87fb1d5375820d03e7dfcbad36b761b9854b5db54d3a95ef508abed0cf6bef87f4a093ed20ecafd83b933e42fb4e548a3886afc5d7968bc1b26e95a953a123814921d7eb37fd3a9ce4d7bd680aee1599e64a69a388a770755d5ce3be0873263d4ecfb311fcc444bfe043a3c565b3bf49f92030087fe0dd203302ff15f78ce6c63949cd0e19440d4ffd3109e2d9f756dfa8be3dcca5bf2c3334814aab55239538ebeade9d7f03adac10d3e6e11401c64a578400ee011f371a6e39011a5594e2dfcf9c2580a07753cdb229bfae1301e9fc2933c69f2cfbbbaacfb5d2d0b64e255104a1ba26c88b09d26c223d0ac7ae741c75bdde4783babeb8520133aaa3be87fd66d87af70fd60eeb608ef9a6bed6f9d2ea19935b117fde6e67327503b8e228d1bea29fac583230ed6eed846ae23684c7c174c0dcc427023f5c8f2a09cb227ed423772a78306d9654475a78014c69207947f642b1ce1e7995878b62abe5121a247fe007e59e61d29c4a3e6c0ebdd982d5e7dcc7cfa477c3ae23ed1d6efd2c52d93f033b52f9ce7ba1660a68c4310f04921bb05f1103974c4fc5a3651c036f1207d7c37f838f4ec150488636e85519ffa657f4e806b677af4fe545430276ea26c0cf6d3e60b06e6085e8710885e1f8bc29fe9fc73b555967a8a649da93b8ced7b10747598b78f7703e66dad54244d8973d6fee68416ea2a45646851dc260956f52a45d6ebe009d9b9f3cd748a8ae74355edab97aea783982e2c0e06d9b36938b148c0ef9b2a33c8e8e59bb28f036de9e57a53b0d523266f459aa28b02423ae0d507de2b155f4e6a050dff5af7a580aa3d3b2f92727542830ed739aefbd578bb8577194619e87182c2331225565fed1be8b9ed78c04b56612d337ef93c70d72ce0b4c1bb114a4464acece200827b8153b3f0db59582ea1f35a9936e9469e90f1bee7bf018e80a964cf66cbd6efc642909be7c8cb45e7f490a0d37030ddd7d2618255f66a24c57096650bda8a8ec339b87cc681ca77f951cf35d2da09542efc38b714d39f1f2a94d17a50710277d3053ef15af71160fadab8b3c36ff4aed323c3c6ad01d17d4678ae881ab5df23a19c24ab1a83a962f2d8102405119d9a291ea78e6df0a59e8f763565bae8211cc5eec42e194a894b9e58686ab5c78e0d0b174a554d4e8645ec9a06d38b131ed337e2d158d512188cc946e9da152266dd2bdf1458082554947ac856c2a66e8992b426e6464388aa97de8befe12f84c57b4141ce576e77407aa12420a1c7eb5fb86cfe385b17049527f5dde6d2415980e68ecae603e1e388c0c81c30af9ebcdd327ad918203e9c07fc4046b64b8efd3e9a795a1899f4ece3f746472f4fb8c3e0715a8f1d2883cc625a41995631b64e720a884af555cc6a5fe1c02c1586d2f99b1907f79557b4a24451cc336b2aae5c964c3c904ca829f451eb51bef6fe09a4878df9663c756448a8bd56930e10e7aa17e143dfcab20995331b789620b1685cce1f118315f541cab5c9af7c397e8080bbfd7492b345df61429580e2f56ed7ff3e92b735d0ae9232d3803e9b3af1f936d5067aa8b676e892f6f2740b574323c32dcef7941652c71b882ca77924575dc236ae1862d7cd0a67771ceaf9936648fcc4c69b18cd86a007ee74c932e8bcc2b0604c410cba87c04f74445d192a793c746698470ba0d3ee701bb86f43d33e1404942b0024b94f397cd45deda36fa644f900456bef1fd502ea58ad2a9960ea297613280624915fec6e7a6486e6b6c4cdcaaad0edc1101ce4322e0d4be08c9178746d4ece5ce84a466cf4455f05ed05c781057565844940843eb4e85b85dd5c43a3ab62063fd8cae2c807617d5b798bfd2c78bd76c0a51e2d06137df7c03965bf92d597a2f816fbc69962af04d5992ccee908cfb56bf6148edd31532c66194c0921862b1306dcb0f3076377db969c01ae633c5a424aff26b1c2d66feb4522377bf60072ae9361db9999b4614810329a3ee4da32e0a5e44256a83bf77073e546d5f98fd65823c8901bb23770e6494dd994346ca0ed6ddaacf845d6c60226267c7810f2b0eba47d3348bbaf5c8f7e0c2b396647e7ff3fb772b7cec1eec0ca958afb397104126f38a40a4b8dc1dc0a4b1df24443e8998c7e1685401282107dfe7dc857a660d7c38cc2b96c1b85f92de8769e447955fd8fb4e3478eba30c3f11c1b0cf2f63fb93e627b34701ae4dede556f43321998ee751d324c1a43b8317f1d328853dd516c04ac3677340de7aa070d504d7b810a8a33d8e4ffab9caba3fd21a2d151c847f98c30e9bfd6e04e85fe340105f72d0b306fd6eab3269db0782c99c8040513e931fc78955a7616f4d6187219e87338b55c7a5cec4c1b384acd0ac894771b502e2a629cdc49a9c1ef59988ba25ea114ff943b445b136eb94baa64d03b31cbbaa545887e88836c7612b32298a3c48acb8035f649f3929f021380718474a51a17f9a5798cc917626dffac6d56e2987d244090c32e0b50532d183b291ce1cf3733f9ac4ece7fe0434276653ff7a0fc085d25590a6408f828d20deb4597509d29ab80e2f291ade73be8e40a57310c164cc9665f21fef1d4023b41248951f6105cd586dcc737a11572140afdde890696e65ea7f91fc8f107cb54bcdd2f921b280ea298d969c5a14a10964c9c09c5cb2aa83e709188f77df5a6951ec0fa982e999d2e9e37d332496c8fc95d37b1fd4d0164585a3380dd1426d54b8d661e0fe5e0963dd6318fe632ea28e53849959e185de42550e1ffaa7cad2e521a54727b6270feea98f8759a96873e7a0db0ae5234e4cde166b90d3a1f8d90b1ffd67784eb70e99a032377f01f15354a3f29d6dd94cf7f151b04a4bf26db1b2073cf7ae1bac7be892fbf611fab3fc87720503580202511822464aa869b59600cc8864f96cda3663942b8b509513718f13fd1c1e2381746c3c89f62b38621f205f37743e9441c7d7c60fc9a5c0cfe186d3eeba0dd379dc38b7ca1f348422b2c308bf738d084803b6597b3d214f933489db16adea6229adbe3447777759ecb315be4b4a60e1e71c1a4e2d4b0d9e46fd8d007d1085ac3a8e4cc8b7fb83d9f60fdde3b7a8b2a44e0cab8043229ed8d8b54ecba4376277eb8c3a285be02c6e9e04b0ea2b8ccb10a72261263da7918049cf193f9e0b142d921afadee06f804ee26208bc779c10653940d69ec637ce852b22893c382a172cf43f786a91a7c605e91d8f4037209e825baadd8ba53bfe1e328730511f6f862343a158dc89285dc5106efe01b373e5a2f913eb7cea4c063bb3454b58dbd1edf6841ad5c949a09e080e0a09eb08365991e0fe96d25d32c501b29505c52a714c1f114df710c00c304112864c7dba2cdf9bd68752ebc2f282d0ba02f4f8a23363bc00af90499abc3181bca547d0b2ab1d316af7652680787a6ebd115c981a21b675bdceae25c14bf694f5f07f55868050430eeeab9964dc33c04caf7f9254ec71401c8abf8215b8c496e287ebc37d49251fb758e78917e3c39cb62d6bde405493f1c911618afcbf0adf98665a6b8cc26a12403f555e4395c5c50fea6d34a29acf62b6c1e2938840fe2f3858e30cef6e6f83816ba0dde3cfacd3f937d71ade6f9a45efd98cbb04c09f3f22e3a8210f0856f41e330cbbb239aa45662a06bbf484958de6c73e1ab0d4221f4f21c421d56a8b302ac9f7774a05247c6be781f52043e50e4965513a70d82f807ebcd7ad1d6e38e8cc0577ab6eb0938ee0739ccddabf607c9a68e14217b9d0431ad6f2eaa2d51a06e0476b0676e8e899ea8b796839aa2bde67eaa080aaa212ca90d208842a64ac682f48bee26255d86bb76289100a57e4dab8ea5dacca1ac77e4d5f3894f2f0cc783efd87e2ac24f47b7980760dbf3288d7e545d8fe66c773a60b0ebf7c349a33275878ff9ad0acd726802120060ba0afd77a768fb6744ba2d44518232f13c079b89a85711ff3c13fb84cad6fb5940555f6d957fcde3d2b1400f6469cdb83d1beeeb77e67dc967cb47e4eced2e4f2d50499067b3037eef01945130785eec182e8394142bc3db1bdbf4a4ac7480d5a2250aa19e00e14ae9479342197c98f5e2ed82794672ace7db1d274dbea643692eed08be532ef320235d8ef00bfcbf96734592bcc55299dffb82cdeb9931cf2af2337a1c46ea356ba9c6edbf8a4da9be6a13c7a4982070d57d1e6e7f92a03bebb7447523532b163ced6ea683a32fb54f89a0de74361ff07b9dbcfebccc1ecc88357f5a6173ecffd2ae89f56c6467a524f0b90bebe2b6f3812a269ebc5c998fcbfa52a64097a4d3a1c2109ee948ffaba6daf64a989d57d72d469787476528ea7d2c44f777104bd11e0166338c271178fbd3be5863a5a3484b27bc7f94f70d8bb80672fdbb81f617100bdb7518be6175d5ad018fe9f8cec8127aee0d4922e65ae12b749899e8adeacfe863b3364a4e3f3867e10de7711183cfeda5cd5dae2f6683b5fc8ca0eda16e784d26094dac97e74ef675ac1acfff2dea196a85bfe047736d26d7507170471c9df9aff4716b9ca7b8ab07df50758ece12e9c9a5cd2a764671f209dee450c6900f42a50154757746c52b5386e86e725659e08d71d1b56014a2a581050f989f083efc91624dd2b96be3c0f98d8899e1d603bf53961e73372919d6fa9be6efad657016feadb5a1b1eee179c83ecd1f7a6e20ede6616405bb50e2a38e250ea1776f06e1b0685da5ac87f947d62f45dc1b241e48dba7ff254e525d5a52357fc673754acd4b005f327ec021fbda630ed210f29e91ba9a16b5fedbee689b214b7ebd8151747a7276dbb06370ccc04e82444ab83fff1f7fd6abd26b188c9340607793710820c09efbb19bdd235b65b93bf99d861259086bd35d45e44e74c6c11960f9e5e31b6e7ef0b2dbd1e5040a87458c529d07f57059c85f1cff5459b7a435ffec068a8cb8363efcbd6a7f0358995f06bdb17e1b4751046639fd24b340fe0cb6dc33f584ff92435c016bc0177aabecb68fd749be99df20b513b951cc34d4723ac2d43dfd9698fc9969a8e78c3bc9dff7aa0d1aa58255ccc9918cd857a6d9f221c738ab6180a2cb6a6d2ae46423cd4c9c264f70299368ba8956b736d709353e3060b3d583ef09007aaf448167bcca8984627f2c04a0b0960d86c88c4487f9c27593f5848a527805a3c929d67d3686c45de75a23d0c2590e64d3ae6394b4fe54e20df50223ab922653323b61773d856049a934be35d131d2102744a8a3a0361cd3d927071a1029be98f87f45f30da6f8353c78a7734f893f9b1d51671317cc778b5308bc1c616474e7752a480981c9e4c08aac10b8a25e2be3e0550791c4e1c2dd359533008b8da2bf98bd67a57760698b49cd6c53b992e8678c1d3c1fd18aa8b5a8136b5bf64cad428d573cd49d94ff625e41f66262434dae1adcb49038ffdc8cdd617330a213ddc87b6d911cd5a03960d546ed9b4d051d15c5aa212db3667e29ec204359304e8a4fa481d1e1fdffd782244650fbcb5d3c003e32be0c301e2601ba42c35345bd7f193253175919e00a96d3e0da0dbb96aefa040de7b32223f341cdc4b3ce820535521d71e5efb812ccadb353e9bcdc86e48d49ab91cb237b9878b1a863f790de10ba42140e889fdf596e684c6193909693db017ce0b1e4c3a2b2a6b0113cc80b7c29ee8613ad2d63c9647904254c387d77cda2986eea4a8dc99c32af0eb919528e11ebbed8596efa5ce9b80b2594e6ce6c153c65c73cf501897656c744b51f9062376d0fdad98df4432b37961cd0b0df99b2f91ce030eaa5c0f3d91448810345e04d18a5d9d8db92fc9278161c79d7fdd48c64b59139875508d3b890dc72de95a580aee2b77aa67ed0003a9a6c147ea7de0c88242cfe0e367fa472c56bb05d2faabc0d8a693fe044fb971a644ab0f8241ccd289a743d5410c71836e9ff8a0331da2fa4aacc21358c525f25f2ee8c94d3e08d4194702983a64525d409a63ebbd587430f638c2c8e11c5b9b51624312dc9cd9acd35d95870dbc281dcd79b22c24b04be1dee524c25c598b244ad2d81188b330623d6f4fb004c2b338b429f2e2f08c4a7ba713988bfb4cd660283f6a57a865a8b4ae222eec1fc825e1a51dc8b8b92c07cf0a5252f960d78332c9ead07a2a43b2db7f489cc6e97f3c94f83c80b075868a5c314ef9074ddb0d8a13e676b5745302b79dc7a089b631ebed4690d94c88a0c99481effe463ef7695b1e929d9e29e28f30e5a45287dc89b958a77e78e740b88a16bedba7f35013b17f1febf06136985df3ec9b11a1fd527ca9ddb6f4b2b72206035d9759e6566cecd208ba84ba60247f72fdb5b0cd648d9d1be3a80238c6a24f6d9b9b93af230842903576fbcc0f9efccb8ecd998a8c160f3cecbe80465686d625a0d98004990a7bf4b21d173b60dbdd64344359c1bf9e29ec55a7b1e933662849c545fc278dfe593be3b8d74b27cd5ef1ae4354d21e1df665fc967b9594ec8037b2e25ed26de81da3cb1acce18156a79c3459dca272f1d95d97a5fbef3a69013a40aaef2774f50b866bd2789a76f6d0508ba5b02381aecee696cab4c5bc0c0e27705eccd91cf054f9a1a82ef968f87f9952c172b32cc9069e370561afb211fffe878e7fab288671d74415d1ce23dbf2689e14f7d21bc1b61d6c52f8389e65d3137d3cdc4c66f2d97534cb49ccca748fae8ebadfe223a138d710e67dc8d4b5d48ca75badbd552871ec0c366498b906f497910cd17ad8fec2d78ce00473679c894cc864715d0bde2ccf0902343d1cd6dd1d6a8d3695e91aafee3d92790c8a1604e42793617670d9f303ec43a26cdce489937a6a3f164808e535d7fa7b769ee476e3e414d9f9e954e443927a73febe349d21de9698daa169f00a05cdc51fe5f67dabe65941a49388289676a5c3496cc99e2b251bc75bbed3d59de28bdd28fe66a37899345ebe2f165b737eb4281e4fac6ad6627baf22e10ce46c2caf9d51442cbcfdd7846f2b48c5d23910a8dca232548b60b852e3cee68dd410150be9a52952cf5b7062dc9feacd8256c88da208fb67ce8811f8a67878fd448053737b17e7fa161784ab0aa2d42c8049fce3c7c6633f4b7f48ab6b110cb29393b06a3b3f37796649e5c639859b7090a40d68643cc38ed4ffb049c428e3ac92c24b9463c43dbfb682a73bdf5f0adcbbe9c2611006e6795c7c4296c49b9f3745b45525b61c93aca916b56cda1f73d37a86754a0315b05a43a408dc31b648689f80d54d4f03e2518a36ddaa6fec078400fc58c32159aa7e2ea9fcbe203c233bcd9df0b01c6a4802cf5b31b4e9e08197e35607488c0d99c8b011d0040eb69532052eacd451adbc6e44d70a27ea85b40775bae3c6efff3f088717ab56b2418dd107c4e059425e7e659d93cce8773d53dbdffd9c4820f5e2891093bbe287e6906ead39bdaa0da3840a2e0101769a903c4ea818afd534a817db05e06c1ff094fb073b6e75bd26ee499052c347404111a48c18070e1ad796b56628551556dc5059f5681c9a827bb629bb1bea0a9f0133955174658443450fd72411c67f7ddde447671b2d60e5b4a2be08f30d8db849284cbdcecde388b6e752a5c697829a159a761dbe111f45de69d2792d042ccd70ae6db37720350bb068462d231b9f9f840c4232471c2c4645847d31fe0b214c718c5c9ae219f2f31a86f4c34717ac1e467b61d1d0a6faa72db10d3200189a087b50f22bb5c13f41810a86139dbf1a0ac63f641572044c5418b7264c96e9dff3d3ac136473fc0d8d7fd9fcc00a308ef628957f5040093a38370de1a451760a12bcc4df56250b90084df11834a9a62b8a2ca7d77a87f4d63b6f1f7f2a8ec6be7a263125e8d0e87d41bfc181bb391046808aacd1ba0facc3c3315e799ce75d12b253ea4b520b6b335d7b0473d6cf30835f1f48e8aa26b8964ca6610b65d02afecefadcd17e6a2b59dc0637ba350050aa129c17fce175c6e3af6993914681fa290fb89fdfc4d535dfb8cd2d23cb4eb17e8e52da0a32ddd5c555b8ef81481e4f2d015bcef1967b167fcd0c864a664091892230b042924458b0cbbca36068e4c5c71d86dd0be57ed7c3c98feac44057b52e653ac3eb95e1932e8963f2237b3f89e17ee5b457f95a2e945b13b4bcb97b3d31cd6e7f5d3756c118c55319d56dafd11ae1a3728f9a223d938faeff08fc0eeb6e743a5bf3760ae8af46658d4ff980fb6f6aa74488b0b0fc7615176b83ed1e1827d238020ef5844e4057cdcf336afdc3b1bb485acf2d01cb3ef72e7464015caa8eb3260c33f2314461f791ec74e7d2492a3dbbb7265d549d9b024049e861b73fda33132db71dbc5219c5f01300395cddcddf622492e9a79e8fda2328883054035c0cd64262dcfc0a20a6cd70e0d516690a500c8d6c3744e451849bb0f9f124d658413293131a392ee41a5ba04654c5e23c04832f1bc24d5b3c9c3b4c2ecb5e8fac75db57f7f5e4fb5a1dc130d9638b643672762de0c307cbf90d03564d735adb0a3a4dcb20f5618a8408bcc3e80eefc74ab8d2eb27569d761b59b793ec73f287a8b615032e8f07872f098ba0a97c0d7c093c03b67b5113a67401865c60582b27d5379455cca910efe113860fd8b52085a75b22c835368817b542fe90ee8bea88bf1576fa5909a3f52922ace58d73f26726600554d0c2b5769799de98e9341257454024ae176fc66c28ddc20abe0f2d00f7857ade630e2a9522de56ece724976df806343b25091455bceacd2a692aa0e5231295556f4138a8b7ac97d3f888d73add99b4b04939a92121a03a45a825a613f678b3c021836f5dd89e130c19143913ed41a329e187348edac896cc4d8479a97907b5c93f04e2d15b9794e55be12f4babfdd254da8e855b81195dc4a6982904160c4a4e7edc47d6e79f62bfe75424b5060313ba909be3c54ac1731ca61f28d45c5ddc63a95066ccb7405ec42cdaca2e3ddffe35fe01e2e516e264ff14c691b522296eb9dc3e77e778739fba11ccd68ade8f593fd4a609dd270f22af59121bfb13789a73b2b6c4fd90a6fdb34ecb3fa65276f4a775340941a49262ec568a09adc1c54b12fb74cc6bb7c7cf98776be1a0788c6ad69b83cd85ac6c320e4f949c3722ba32d2f453514f17244057dcbbe558f8b3d9dbfe03a0bb41e86a1771218d936fe2b47d962c9f09040c79e98f6787f74023936861af7aa6019ab84d7aefbe3fdfb9aef76197ef83a9c87b93fe10956f138af732c62f4d3ed0b5cf095fb2ed6702a3c4805807cfe9924c4336d6af45816abd8a65f88a10fd617fd2eee2dba70f61417d805a6d49c5f7de67145256aa74c8a731b1b218102d10d43e062663d745bd2054c5cb0f1e967543c317adf7f03875db72ec6e09f8c37dcf875d78d0d9785ed4d05cd42a0047e1dabbb0a601da232a6c9f09575eaad49f9672563d0b835d625414cb6448f95a35f5bda71f60e98766df506c21e6794fff996a2c90e0030d5cb0afe58b02b0df941d56bd597997aa2750be80048fd179d50faa85f118a1bb2b0160156be724cc2d63371591b1b2cb60cfb09ec9f020bd671940a2f52d8680ad157b00be3790ddebf4c404c596bdb70dbcbff17506b5d832ce68ca63da948be8996df985ab7a2038fd525eac4333e827aa9d0b6f0e4caa833bfa0334b34d0a54ed96eef9eee41e571d6033882e23fc7e7aa0c12939900ac67dfe9dbf67c4debc83101ca606be0ed6e43adbec9a611a128178c605133a196bb5b10d534b2cbb9a462907d96363455232e712b96b95f6f1ca92ae6edfc9a83801d4fcf1bb008972a0e137022be2d6cba98874388469466c7d9b441e700a5df25947a87f01cc5a3b1d6cea5f10a2dced3fdf43e88b7d807f728156f26bd7ef31ed9a35c22fc9406381714d6fd36c924d57cdd7ba7bf4d387dfb316675bc514e761ddec6c4791003386925861697649fc5581f498e988141c575e9355800667942cbf7eb75653b3610dfb7adf037f057b26f6a8cd3779d13867764149131b5178a4f64be038a18a9ec9635ea7bbc2283a925c83cf94ec2c32582cf91d9c772c1cf8e56d1961bcacd05ecbaf4911b9af0559091e9e23b9142ab56097be962dc9b6eeb6750a9a775af94a8575e205d304d40bbc21eba7d8ea956a49650c60ecd5d54720d900f82ea9180cebf451cc78e3319b4f90f49f86fdb75cf75fe6577411acee799519f981ab688854385a172047b2238320082e12682e8f263e275265fe129cb1503d927192e6f47a5992c3c7b352b18bddb2a26b8a273afc0a8dc24abb3b9b1dfc5034ee5eca278d71bdccf1c91ff92ecef12d506120a0534706bc1a1cfedfa882d882a24c4eaa9942813edce4a83b807630ebc90112819e2d13a276508f06e5831c3507a6fae4266cedbec6bd221dbd33689021ea18894b86381455972186a045ae4b8755ac8aefa617f69bc3948845548c56d96908929b709ec01b3c7c16dcc0582e913e547a67ba13bebf672281534e34d83e75b2ab89ce5592e69c8647cc5113aa24ef1cccf952afa4d8b2c4828cdd942b7579354a04396eed9e631ea115794ccd6b93ffe9c41b376c2b70fb2712207c5166579794d216a6fa57223ca1dc494f9ee28b7a569641035ea28632bc08ba9d93845ae61aa3020a5ac41693e6e1a714af60f9e332bc4628b5d87badf29bfd389b421d9cf8fc29e88f3e563732cca1c8a4b06ac8a782bb62496e5f7f041121f737de61d13e89d920a5b2f82dc9033fcf462d27f812d771580d5c0cb94b7b950c27fa0304d71191c75be49d6ab7ee4942f8681302cd92e1f2227bae59f8cc90278f289e9631a73f36e70bea59277e712ec50ef7e5c305e49d6842b2a9b6612f6c10cba8cb2fda7a5fd01f6fb4e1359b7107e1844a94b907671e4c308e84bacc95f9b780715c7d49e68d406b1f35733af11c3d4533dd0d4239fd98faab4a8e223cd4a9883c3bcb4ef9df6717322f0cf8db55cc80974d40855e891befcfd38efe7688bfeceaca603f1f3f03494b97cc31f57061480aa789bbbfa252ea75ea0ee20432d1042f3a640ca8b257c04067e5c6e8c6ad3b5954b83d9f396166af93c5daf6dc2c7a0586199a88238a65d08d4259051d9262816c6bff02faecbe8553550d2d0dcca5ddcfe6701b11ba2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9a40e9e4524951bb860428e1b12b0998"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
