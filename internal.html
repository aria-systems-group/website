<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"166570dbb324090ce3ad78f87fa9d1abc851a7a0acc13e3ab5d786e9acc3c7dcfba875fbe8d2c558c96e9a69ffe506fde08d02cfeb02a984d19eccec2e0dd122bf4f5a951ce9112f501075bb0a4ba4448aca478db7434c5af2eedc2dae67dd6fafbcbef74ba5d366008778fe297f432492b5e4e127304589ddf5f84e1b898de37c5d6fb6cb714d5e01631c7154caecd0d5e7ad36d498414e6ca53c15a72843155dd1490d1d0015945228ea57cdb28d00cfe8c0bb039d46e9d4e9bd87089db4e21d41aab99e701c7184f8130862d6307a53c3d808a458e6005095fec4b3d7b8f62cd264c46fa95a9c39ee4ad393f89ddee32c759512a0c08675f8e1dd27ff1918a6fe1f4c1f2faf0855406b01370507a1d38bd80472c58ce9cd0ed23ae2567b37376fafbaa8782a4283a69f7f8cc354dfad52f5cd20ab515d6a04d72de4ece1e14cb5a37fe93806a20e13cd32a259d39669267a4f409056e327363ca7cb0280cf86c97df4f3cfa56053ba3ffa88054a60078645a7217ebfad72869bf869fb5f5474c7702dcb36f0e03c94457893d3032ce6f9b926128a5c84c4624f54802dc97168dd37315caefc756ac98c6adbfdee534159f2d700e8d8c2b470eac4e4035727f448020d0bcffeeaa73bfc2e30ff871aeba4a39d5af835b733bb001761fb5720c0aff58a4f78c74f17eb7131788ce5ec538574cf73a7b04eed369f02141802cc6afd6a10f7bbce44a0cd0964508c7a1a0595aa207964abcfc510879e798ba5eb7bfa8191eb98ff235b15deedf953c80e85050c4f81ed12a70733a711fd161ce6e004de7f7826b2c79771dd52741f58be33ff100542c769588a5ac98b85c5ae8bc0c33fb0b41b5a15885a9f06f29723eeaccd53c52b5add14790861e33a21dd98ab943c19a01183321037d7ddf5b1e5b9fa084289a208068ff071ae3e50616304256a9a5470161f398e2f2f7d5097b6ca2f050f26570b47074e6ae29a1ce9528e0346dafd4fc3e462b2771c708cdf6bcc300bfbf5a4e070694d22eb50db50518204ad7ee423c8bc912d20c8685ff5db2b4bf2d01ff33c83b614fe51316f3e07024abffa3e3a670dd3d2132efd768e6389f22559250f3dbf9854d1def6ed36ab75627719a9df9ce106ce3890dc8f591d1ecd9a083c92928868e63926670d192b92055a1eb2ac4767a4f11d77ae393c8038425bbb01b891d0a4842e65d28cd161c613a79733bc396775292eae03466f6cc86b1427984f76b63491af658064548e7fae1ec93b39208997eacadff4384ba2be1495166bd54a59cb38040698770eea7644915ce82cc7306f213379538c81e2340ade7dffcf08679c1c426d5407dd34a1ff59601415a3fad4b0e56881995fac7d9e23dc1bded8edd0377bacb50c232a3fd91de19a75347dfbb1131433dd91438a2e41845360d6f7a20b9b72ae17f664d0e872e1d9f322aa153fadddb13fe06101b9279fed49c620c24e111ace65ff4401cc0a5e5c99b40a1bf6f561de5e0192eff56c7aab130daf7cf782290bc6678c9f10ffebf343a81e26fe38838ff52b096cd04876c3db7bd0b8db4e4a33bb75231eb8bf0cfaf8e4e8f7e7ceecf76e77babc462670e52f4f8531f7b29edac62e4a52e019b595ae0c9299336704f423a12680a2f2a664fb21a2e86e77fc467af856724e3a33ebf8610f915add0c7fb15104bac2ce3a3720f3e9bf85cc3f8863c15795aecc7d6852e613c15947b395cfd3d564d7cc429a84aed14ac3772aec7ccf6579410a6322d899d26f80435229bd96323aefe84c7d994e590790716dc9ac6410508ae88aa0458a55543f237db3bbc0860816389bb2e48106d8c46c726b00f64aa524c8b0c00b7e16094d49ea5f7bc3d17d150f8ba32e35ddf24a347923f11771100f969344d8bf94aa1b67086cf85bb2c421949e9913187ed79934c3616449dc5ed8753f03784f762d04ed3b2882a5e9682e5f8c17e6f99f195b8a361aa3d37dde64dd734ec083648e82068027698adae2c80e839315dc0f3358ed608f5e52b8553f3e44532666728206e125870e7eff68cd2c433c8008494186ce87919ec8cd140d41a8524b5ae1a0812fd22ab9e8a5341e3dba2b6a0869c063821d58b6a57cbc0eb599f42249afc0fbcda18e391ee0f2d2cc7b7d9b470e134c3c691ecd8f6376eadf96ccfa779c3c1acd9ef1f5463aea6ee9ec0e9c740a43504e371943e2e4195d36f1376e8af431b8573f6add3f5c719adb7ac65a887ee8abbb750bfc64f6b27fd621b47512b2398eb00c3e5ac6873857987ae6b9bdf785cfb74812d2a96fb41c08b45bd0c90c1250c4ab1d6edfa1d0a3d714e284ff11886a7ed5e3cf194307bf891908b5944be93b9be64026546c452b9214047f1ebba985a39a80eb958d1f6624a0d8d53276579b8fdab0bfb79b3f49e5be0eb715b67841cbf84656af758473a898236c03ab5dbe5e47c99bb415d23ecd172485f6dba498c56d63e514b81e91cc67090ee9b7d461e5ceb3eb37d547e1f33569e0e36c6b179447ccea42f2ea22e93689088b729cbecba1cb401bc37743492a2aa78a49d25a2b1dd3f5fd5fd68b2217939009ace0476e79a0405b9b13111f13a6a9907bf0e1e28a236e5a54e8aabc47cea752708dbbf27ee0339eef81ae703936d52cdcc0b7ac9c4f86fcc153dbd882735dbebda68002b1feddd348db64490d08beed44aca7ea37a59c1d633327722e3e76e74352c33a0c77975fad71aad55b258d99bfe71f567adc3417bb0e4a1bb00bcae0daa249aa654318f47c663912277831cbeb18123275c4f3cb9cb375600dedbc68af98eed3bdfa1a13230464afa9f7fe5b535d61c30b0174871222406e201a7106b6d4ddd3b29eca7ab9f8c34974a313d5cf9cb0e1e45ef0b45e6d4809e7a51c33064b04f3898c7172721513216b9beb9b3dfe704d25d7981052ce1abee6e1e750365655d7ac69d23ddb7c9d3e23f7bc0322d0c07cda6574496680756f723cd6e8e53978882eaa2f2450077e766f10b6fcd5d65ab8aca0adb9126305842801c48cedea4d50b0f691f9a797422d9b8862c0a207666462f8c4a0eebcd5cc58403879f44b4c8a750c4de973ec7bddd983bfa331dc777ef8bb7068c9387acac200ecd7a2f48bc52038a7fcbeb5218b38d1e2981c14defaf4b356218be6e1a7d6a86a03389ed190c24f9fa9eb8b3e39b23c14803f299c91788f7eb59720df9440e669ece467ff4736b146c56eb8c54534fb0144f7a96ab9ed8a548b2d0626be3eb64b8571641deaa5c1cf60cdde67b58cb54ccbcb0b594cccc00e0b957944e439f5d99a80f69b1a37ef549ae6af6b17b7d7422abbc1d03b96efd212ce07724020e6d0ec3b2fbf720bc812b138c30163ca7b7d1079ac4b60ec35e2ebc7de2065808f8f4c75cd585d5d727464376c9ee56c3614969a059a1e94ea331cc227df7d883c6d77f6385e5f50ed0d566d034365034cd577ebb7d73f25cc6db3cda09d99d0e2fcdee879ec8a32d7e5166fe770153f476324dd1d13efb896d2e585bcb32427a8ee96722a2768fa06db428319ef8b69c637a8c9e24eb85176645db290786c5bf82f75af5bcde8c7edb6b1456d0428f6cadfd9c063965e02c5fc1464fd4037f23ed954693c0523a439d087a7bc0edb1bd30a74671cbcb830f735c4a97757410a68b0b5d911ae0497172848b4bb78073d98f9ef88d51ee46c646c856a2248de41e0579436319163f7dc62a385c3d3cbd6850ba670a4c0639efde811d706737edb22c12c2db98f1bd73d4f17a531876a74130b49d5d614859298bdf608ffd1d119232c7593169acd630899423c184865c0c759cb6f6855800f40d042114adaee1e8ea3f29fe6fd25e5dde5a599f34ffae88bec06a8084d87130d889cf622ea3e52e4d270f4ad3b06bf1f44b3c4dd9d585ac2b57e73774038d697a37b4419867ce4b139973a2ee54736f60b4e5c2a80f253baa64d4abe75743556242a539831d17e95c81fc0da390081a25403e9ba5d46d522da74ab4a3b51993161a0ff4ddbc24cb8403465b0ca36a3a7b0d54b64fb932eade8201172eaf4b8e5ed7d09d06ae17c2ecc2011d014ed5c397b556a145a922792f6ef58c2ffcc8a44e2fc372b71b7f77480c8081366e4ad587a3713e978188f186bdc5232c15d02f2d6fd768954da696b5214fcc037510835a399d65ebb9e13ba814bf8aa7fc50c12f9d6dbb972603735f3cf720db071779d07843dc69cfa1246d996c4d1c8e51b1901eb4d6cb5453348a89270051f2a3fb2dcad29f08996bd27569be69810f3b3f250d37df250168673aaeb34dafa9d2743d12e8e4db273fe8bd8c0001cfe7212ab028a6e92d078e0c5c07df0caec7283c50d643062dc0a365f03b4a9d6ef150eb4473d741e7c602bc59cafb6886751bd6f7b1a019377f7bfecde3fb6d98708e76c3ad26b94b48340bbb216897f0ddc3e266f0a39ed461834122148aea605641f959a752dc44f8b4fb9e6c39dfe42e16baad43496ba2851453f63c134600741dfb9ee0da1d7ac8f1098bcc56aeb3fe0c670e2153f720ce928f8c97feffbb5d6cd3a9f7dd09312c45dff6c53086af3d5f591bb92a96590051849bd89ce66521f151fa34c4a8c39841ac2ab78b289aff661f9f13e4f7c45639a15de839eb232785c8d6d3f7ccae86411d26b108e4e7ca0eb277ff28bf2db7c35d4725913ecc849bddcc7a0a9e3608dacc81476a8a8b530c2a2ac84839bef41f17c7cb26076d4824869cb9b5a6d379c11713b3e11b5c38804c5983a56be5135cba908361d8df71dd4959cef69766f7361c57d75b18fdd77f1a35e413b38d3349997f064096d4ed1903ddd408ad86af3a5811c5fc79d61991aa7b5ca2ced97dc3166902792866f63ec16cd8de23bbf510767dcc6a2d96ae5034b655ef2f97329e1c6cc00195e6a4e88ad1d8c2bec1d2a0722b5ab6414cf59dc4941dcb679f379935b6a13c86fe58c560125e69cfae8a807d60b5446945c45aca09a3a17727a119dafcf3ae3060db7e225ce50780ab9260de5558a01dc0d89b84e1926599cfb8424458a56c8343fd00fabefcef3c94fa1e13d7f7d1c404668ebb806ce3f4fbbc32e25150151a0f49d2bfb135dd755122b3d48e89bff98f1a0d5d76a2cc5c5def2af3fa1532c157b3b6c947ab1f675b3d5351ccdb76184ee210430de4298ef62f530620f7d9f1623615d1aa4aab18b447ba4fa828109b0997ceee9f1fa9b24d95d5899d379762f3a44514e560e51c2d14eb5692010bae5619cbdcf41681e0fb6d5b6196f6e88c806c74c3a844cab9927f7eeeecfaac92e5ba08c33320c91fafccf751c37d8936c088de60cac6fa9e85b0a7ce85a62420f408d0a13f135d99b10f60090ffabcc35365a5c9efd7a026e1af247db10050f906ebf8ea00d442af7886c639811fa66c283e1eecd44288aacb2b63993c583b9d692aded6ead3de435da16087d625e591e25524e2bb0b486b9b3cb1df42b33f8d4e24feca416c9fc7ca17a6eb19d0e8e76391c1eee16a3664d2c53d35387f8182388fbcf9f74209ef78f511e37205077577d2c6d56bd31703fe70e99bd5a7ba1ca19bff0f4b515b23e4cd5968197de6bc8bc506debaa24ce4294c130e8617a56c41532055c7304ea63a7349f2796a29c208a6a349c45dc4eb5d198d98f850bb19cf19d471b410563fdc006b70943079e443ea4f334667d0d53472e405ccb995c09d2fae63937406d8750af094da72350d4f510a1df7518276ebcce66d7ae7ce82bbfd8ec9abcb9bbf177bc7693d0942193a646323ec9d68a6564f2e16ff7cdb8b529aa830babf61298cafbd6dfe9578b2c7e09cdfaf7613aa5c1e18e6e0bccbd6fb88a51a941de375b5760b867ada63ef4f2d2768be94d96f25bf2cb9c2ef6d8046c4acfc80de66b92e200802c09e17118c137265282296cfe920052bebd080bb27a55fc27d5c5a740d45bcd652cefa1d8843afba73d95e1211a9ba626a059cf71c990e55f668bf79d034f9049bbdf6fb78710c0a6734fe7889c603ed6b98451506e0ca47ca50847400178413906a7f4e9cafa029ca821d29173ffea95f31ac37a3d9db9a10ae7014a25b089687fba2703cdac63fa14ace52846e47a8d67c7e0f5de1094610091c5c25a5c1ac0dc6168c5bc23f1042167d7e680eadfeac61e97d8970ebfa4528789afaaa33088f5e647994a0ff0d2a775a9d5d61f73d94a5fd103ccf01c507b4a9f54c314b90440b99388e130d76ec43e48e9f650472ea67fa0879251e1e06b1c3741594368dd6061539709b13d5ded8ebeab39aa888e52e829efd63629c1c4545e1228887a31bdc74344d88bb3a9287d156e0a419d569742814b40d929ef7accf5beddcaa4756bbced7814dc1f3de5eda57f1ae277ce3e587d9f6eb6a7a8360dff574a5187cccd3d3d187c762b387c2ff7cee1d87526024c06b2d4963842ecc330464b002adbadc55f7f4de1b2b3b44ad07a29538796e48ee69e314f96d731c69766a77560d94f9c506194bd5288e1cf4a236f686c70be5aa7442a88f5a00a4191b7188f2645c39077ca183b4b6c2fa394b1b7345ed888f64413031a8c2ceaa95db91af9d60c3ccc644c37be3b8a93271cf6fbac73408b3ffd6199fa7011782318490b102f54ba556e3e907b0f9dd1b11fe6801d12541624b8a24dcd81cd44e7921ff650b8021d46b44eb4aa6be204be4f94532c70248ebc171a14008a59b65e1fa5edf328edc55b1b0dd01603fb22ef88d9cef280f3cb832d6a4f30572204c1498d79323fc47920abeff33bcd9c562a439762fae78d34fddadbf9415f93e51e853dbd69acd718793540e20dfc3bbe1b0a931afade6ac6ae20be2039d341e8792d3d10ef3e11e301c743241dc4fac9e836729a63e9e80981a17bbdbd28dc666b383024efef0932e76dd46503cf3ef293fd53b03ace0a0636c5f37d1841a57702d89c3777d9ab1f0485e9bc128aafd298d04c7332b9a4e538701a782681559133c6a3c356202b64cfd0e4da5b2acb7d96de3cc48528bb4c9096a0c19a75d2412288ca3de74c1922ef0d0d89a75f5fc1f7ebece5688d875711a24515248474322bd52ffa9edb861d3a1bb32e78934fd6e31595a35ec003768b4051e052a6058d7115303a66b165c806074c6757b08aefd5e529d7c5797055599d1540f005e3c9d05f52a9b77302ee9c844b4b2db8c30e4bf6dc4fcab44def142b254f3e90a924aa6f58fc44690c69f41395b146d4d9000e56580d5938ce870a39f83719fa72d9aaf365cdbcde19a7245d7d5c979329fe5a3b44a37c94b1633b7e1ed6804ecea6bcd03dab0cb443fcc1a0e55b17031dd0ed5fcfc7ae6fa983ae30503e104776bbacb7395923ab01aacd7372d330997f6f82d924f10c2ea9da65ede00e2d2060b6ade5556ec6df6db19de7dcdebc582d5692633a613c703f65ea847cc9430756a37665d3bb61a9b463ca87042415205318da4e41804fc082dbc0df6433962fe0e9de30e239bcc0061424dc18a30fb31517c1358358d4ed2c883f57e3e8ad2d515b1f065a4f01f4dc5fc71d31a7da0d46b65aa0975a2360a0ce4d149fb1961c5f272d948e669c6b5cfe50be4469685bddb6f51cd26e0e2928ffb26ee1df51d4ae696551d42a2afdfb1b7057aa7d3c08ca604f6c3c4ffcd89c2b24da78788b3f937d9e670e7149104f2d82281a54e9e9fdb094ecb4e37dc4fa3153feb18487487da69d93d33b64a0e4a08b22b9068e35b967810d31eb93a4ee08706aeecbaa64f9c8ba5b948bd7eda7efd87dbf283f0e5b7b0b1e34f33b49a9c55c1cb0f6944da97fe8f1cc0e32f7a4c41bce95935c6c633e8a2386e07c59af0704e512ce38851cd2ca5d28ce980f18c709fb97172d8bea88db2c884ffffaa4362eabb84f2538bafe56f051765e8b27fbdb000c8611b54a51424cd219eda42a5565357b76fd0d77ab28de599c5f1789f01e182ca8e3f8c6c6bc46634e9cfa21ac9de021f51683770b4f841eb4b227c7efcba20261d82a593d00535e107b6dc32f795aede903bb2efae0760ac02d1507691df17597ac686bfbd8d74c9afb4b1a5f5ae5a0d3270e8e481ba279f625ad33b66d112456a73f50ca1e0ce0bc74403847b88e10c220ba977a083bdf4def135614353d92d5f80e41319270d68eae9cf60d1076737c8f4fd9a679a6f9a37890237353d316d1649b101ac3ff625a34e5bbf768ccd6a04bb952f012639a9129a48dfaa444accaa787626ee0e6a0e648eb70c3c8f08770ab1b43ca975a139db773ee5aed01799a67d02c2ef374dc8413525a65df0a5eee7cf212b3441dd59f1e97e015f2fc6b612c4e6b3b5fe291825aff753f9cf055644531b0c8afe9566490a84fa520bed987d817d60e6e49385cbb3f580add674131d8d2370a42f5b0c37c59d6f55cde76987560925b36efe0b22a6ad2c9ecd3c003f12c588291f4d125e64042c787f440bbd7c08ee45414050f572f1c03b7bb12d7e65f8bbd43c26e8e478c66c99e3bbe9bc8910618a677b1420d91bd325bbfc1af1a5c5eaad9416732b7e75a53a756d7f93f6df16f365a6ab9c20104cc52f0e0b7cd97c11150f467e8125ec09f08031ee073cee4663c540ce9da2aacb0b82540f9b77c6a724cde930f44f99809e6670d217700fe8ffc7e5f2a04f2c197a6d5de1376980e2e0fa0ac3d81892dde2472ca7e9b613884a0706fd3ba82b0a7d860e04f4cbfe8a6326250e971900fa4a7850159df2e8dfd7b73ef4a9a9f3bafc5419093fbf7f17063b2b34a3f5c024d07a28847307673db33657b3c46c38481083b50889eadcb84020a60da1ffbb3e32e239a1af0c4bf70d8cd05c846866ef28cf8713017c1dc886a501231fb229a93c11724bd1cd860c98ee4707b26148e58bf617329068fa5c83fcb8546e7dbbd062b31167505618fa5f6376e8dd17bf2d9d5cfd3c76de2c76b5eac62e794ef9c308571bc416bd73cb9e20edaffa93531410be20fe4376aa31d91c10e9b733f53693fd0d7e6b0bf5b86a567ff377360267a35721021e88317025853eeffd247706c0e49e9d388a8dff92cb2ed0139b1241f75e26762f1e300d03f9879797b51aaee66a8ff6d7f75a4612c4befa10b97edb181f590cdd5d3ca1659b78f66a612fcc4a027479a496922e3eeffb690ee287ba5d2467522ba0bdf8762fd8ca6a83f212939ec9d89033cecd3f04ea57eb34f309375cfce0a0c04f0c7c48c9fe1be278e17e60f803d430e451d7f56c98949706932a3bad8c063f46f23d6525cb56c5ec870c757d2490c389d345610f6d7ae0ccab92c9de1b5cd5380fa0cb9e0bc31b6f8f9cd07182c5bd7d07032d7a6e9110e51594e5e2d43185800b86ba7e8d35d816669f9e2e410b532aaf6f4c991f9cc9ae7f385a39874ccfb26a4d318ea3fc5224fd5e9b2314d429a21cd17c9315c2af6cb9742db5c383ae83ef75c013bfeb8c01cb2293ad990acb59107582fce6a94b3e711c9631d53e7f615fecd519b650b43ab6249d85d273fe74ef8f621cc70c67a12c4e2a7512e09a259305db82ce29dbccc77cedac1d2a58e1c9621776810b5e1b011645949e029b93da0240b92ca60213a71cfad90bd1ef59d6f999444ed610bc570b19af001e5e762e439be605d67049076eef074e1486c1e16b3c806d46cc2ddcdf4720c07022570ef5231a03427da71d283eb93e4582b9a5d1c2d4ee9470afe370941d67c441ea36e790f7aaf9e27132364bcaeca3dfde69b4a382d515434a2ae2d43a1551caf10ac8f4bdcd4a9795ac414ec4a32fb15a2861bdf81fb1a16df56870cbe14c35fac24bff8a047932fe2e6c380d1d68ea65382bf6b8d06d58b0e7173d4ac3c432676ad3032a8d09600e40c848cad9bef6b7734aaae381bacc5eb4bea02c43edfa70e1ff2d8f040a48dac53fab284f61e2318ba7855d40a2ab8c734075909294221d68605593bcc01b602ab8d290b9585683f9170fe8f371406852de09fe9e08b6d6cae6ee65acabc6e848d471a9d51e29f4d23d70d3d34a9104593de5440e2eedb1f75e46555d3aaa875cf3cb6743401bdb51b97d9200ce9eba895d2451b8d28129a8918df23e7a8a2e8dc57237783c8fc0f68a98b4d59e2363de120c22fe8dcba3d2b6d86ea3e2250564ced166b84f65bdb99e9ba7e20b221ce70a468c993b685e5d8dfabc93523a5a704b09edd9dab548f64dd634f850f7716e7cd73d217e3b6dc1e3c8fc4a1b174a16a751d61cb6591fd6121834deca03af8a8cbefeff657496a693c8182131a29a89a84688ef90c06889a10b919356a5b5d86aee56b50e68fde0cb2cfb89151d2cbc2dc5c0c4efb2dc3ec8335d5342559fc1ef1c3f6d674b301fe33aaf967901a35b908720559d2e6837ade603851d8c543bcf3273cd5c05610b5e5a7e802ec157b3810886febce0a46a7b77066560b07aafc34414352c29498198e8b3d2556258450fe49d6fc5c35a423328b082467690a70f3cc8679f27befde8aac81ffe574b8f050fadc7c8275fa087dedf03d330854b190b63711922671e3393a0f14a8b7407d8bb8c51ac93a3ae436e3affa3803bf8056badc1f015859baa260da0b749b77638b37ce34b722eb19761322e1fe72fb79cefe7a4910988221203679a30aaf4a7fdaae678b140924e8039344b257318163ad0c7a90262d59d536c3e4f3927734e9b1022d406a70ee577e6493f28ae10d3f115f8f0ea608eeeaf35b6633ae5c3ce3d79fc64ca423f8394fb75f4ec83dd513b862c66d8a2986adbac3e4f8f1a747f1f439ccf52f63fd96b0e99317db7bebc1f2691ac88a456c150d2acc3b8b0d9d2eb4a6879bc5b09c9cda4defd38deba7a41891053d7db2755d47ca9b6b75438516118729e5c34639dc37287aaac99dfaf3e1ac30544cbb3e4d3b40c61c7e7c427f98d50a34eac6a35bdae3756658d4f454af5b223487af70db897c330b5e71b33885289f4770900ad45077d062f89a42afd090047de68405a37540d8fb37beac6076227cbc72f5d93f519075432f314c2f35edb4091b5d099bd6a1972e432ea600d186270406960dc7cfaa84ac63d8f2960776860767f4faa8f751b44e8dea0a6b6067f151bfc0ca5b53e570f9ddc8529ae5a791502fb3cada52ed51a6084bdd5170bd8f8458935ef445fa2387a35915c1f055bd38bc78dcc3b320b2244fd972a2119626989459e33615000746200f8def1b4882a7023ffa80d1c48cd80ccc169554f7f0b8165463e4ac25741f9f3195a01be00ea134ef979cfd404a76d94e2e85b97f81a9477354bba4c7930ab40971c395053046e9dfb01c6ce214fe13bfae1e15e32d21a7b3a7af10983ed2dda499b8a3159a8c677b243f435564946c21c3f2b709a3c94ca1e87ed8e7fee8e70a20bbbee31aa5a27ab964ef9763f40a54747012a4a87e37732af31d0324401e6b6e070b54eea0ba3bd62e4907d23f7f05e12e0bd5db5d1b7659fa908cb9ab4c2720ba102b0eb2614c66a385211a73f9f09c85df89462a51bc282dee6e0b3ec43944cbc78de4e1b30d7442a30e0724352516756bd5692dfb1938a0519dd4fefdc7eef32804fbc8fc5cb53801035dd8f98257467af5703c77e98ada57725b071fdc6b1fb1e72a94daa4f2544342fc73a92377fecb8bf5337eac094de5034011bedbf40630c5da947c468bb179351b80ec60658804c9068cab59b03797a2d94b970581d9be99affa590f87842c527a6ffa5511952df6d53e48a9db2a6ed77520d1c2584680f70de35bdb2fa71bf2d1ce0cc4e942749c3e3716fe87b7bc1ed48ce028a67e3d0004e9ceb3de1efec9715583fd024f2a3e07b29a5d0c70cb502579fcb1b4005a9eed80704dc796697db03120feb722393869f69109d172cc8d9725694680084cd4543bec4540c808e705eb8e254d0ca9689fa6ffa0b374c6e3c95ff10aadd95895b125d1de7c9d0cd0bf503af899ea6ea912f906f68cb116b4bd70a1aa61f1c3f9a1c79eb0bad18e2e3740284f99a51ffd47ac99bcac4a5769ff68cf792d83597f31aeb2ede7daeb98e16e8dc83b0a03cf4f343c8212b431543f763c0afdabd6d81a6daa13a8840bed0318c13182591546dd98a3ae59eadde552c930de2e44353f538ad77d6014ed0ef787f7960562e80c000e8be469061ddb82923b89f3bffa6b540960ffb712e4f0d26358e002eee76b70a5dc369ca06c893b994b4286b7c562cd06c1fa87b2fcc1638bdd382cac57541c836b19c158e5fe98d0ebd097b1c4df2d85562240caffc284d7e2d8bd26916f44ceb1732bd20ec3307b84251adaad37086780e76621691294f908243041d91e10d9ffdc328d9cd4c310797fb42be14fe2e2b6de000b18730aef901497b372be14a5fde7228a50b47535e2ee9bd0c9d635d4cb34ad88174f40d782dd481ca69f805629cbcdc776f6d9d5a624d825ba4ed58960a90ba14393456882c12489c36d9e8ef1bc51a04285019b0c8b7b3f29f8ae20dad6ec1f444db5fc99709f9d9ee54ab85060030285a2f4dc9a3862f32d65d86c468f35dcf7d128972cfc3dd16896366ab28641e98b65f16ad239f08ec045cbc5a3a58ea62735dfa433d94112ed6a9ab0df30816bf5cfaf3bb5f30a6adebfba61e18c4f7e9da64abc0d9eb6b78fbca4f6cc6bef06acccc684323c93ad1d38ac38b4eff60f190c4b67276e033be492a6abad850a2950c251d729b8b9e52bf8fee105c4976c1cf17ec39ca91f30862cb6549b7f26d7d1d0111fefff59b2f25fa13882b8057575da3aa05c526a1849e27bc773cd1c200b25b5819645e6c8a7f29ef5216e0109d8905a19fb0bcf92d97cbe6e23de825bdb8cdf2bb99761a91456c0fa6319b446277e3edc9a4a9d2747d8b55dc879cec83e111412f7404ba228ebdf3749488e3c716f895e9b03acdca5240756c4c4e6940a349a4567c76369be3af9b5c7fce144d5ed49b11a809687104a3da94fe2b07c8976c4839ea919f341399800b80ef420d34516f239455ef6cac0607b019348d86437708a0e19d20f610d6ebcd18a3d23a055c9d5bdad7a44d6e1b9ce772c2a2e1c6439086040df8cb2b34f7dc704e839a9f2c84a9aec1ad075d11edb1cf67695ae5d28999f839eefac2fe161337116cee6caecda0073382faeaaf6a654c85a815bac60c47f492fd2bf237f41cea686616e4119a54549ef80305cde059777cf0b404f4f4b64355368d6b126f32c2c4b790b9a473e0a83d652cf277ce8475ac5e07d0feccfe40b52ffb3c7dca4bf5ef19a7b96cd8995ea8a53ee27512174a14e62343895a43ba6bb5f308da61083f90d2fdbc92866af4fb78f5640609610521acefa4ce4ec4224329f8b77f2b9bcbbbc7eb0770f6158f8b6ddef59d16dcfa3ac56fb1c895f1c9cdfebbbbe2d3556fac42c3a1acfa33d462e10fc477dc24265b7bb965daec58345da071fe5e195cf5c3bd7074a1fb3237a8ea7bc4fe4ef11355b9352bdd52692ad3ccfdf5b0a311535a3ff4dbff6c451d7a72723c5223a1ba35eb30cf7941fda705c22b8c38ca129eb7e94b9cf115ba18d6c4ac47b19a322c805af8435f390e75a6c7ecd3716ead014fba624ab25f79b4410a3b0e27e0ebc1c905799570b104a5022ee5411b847c1e945e7c3e6a8ab14a05b2f109c54e2c9547166a803d21da90d231fdc65d98ef30c1c9a7c0b5170c3c53e0407edf1f71fe9e08e30c5026db6a769fecad7950655a49c1a580a1e82f32aca992298ad8a6e34957c64b0975425bc2f6cd9753da47684f443c77b597597b7ca0907643d1eb8c643f0b5328e46adf81ec22e43fcfddcf64df0287b1569d58f02b94c18753e62519a4ccef75eae8639e14258c440ea930ad0881dfe1dfa666fdf6b9fa06c20d6ac0d9bd2e477195d53e0eac85bc785cfd0d4f4f2187fa572d44d5bdb2d5604ff3ecf718a8f5948a9d6e9cec418fe9275f877ed4248338f50654bced65a67cd428bf6375e56332bbd6c28719fcf119792c68ec80ebec527390540931977022f23aed5fadbee4e7eb5348567ad7c40b024138bde647395f793d3fbfab9cf79ac7985a357277759942dcdad5082757f52229563f5d9251306488b02cb1e120b0de984afbc08b823f5d68b2ffbc26486a9a86d7e1150006fcb1cfb789efba6630acddeaa82bd419ef24c8413507e3d600e1de16fd12503dbe080fdeaae63720b1feb03432547ba05fb75caf065ca4f2c867bae5e07bc7a76d24da6a9ae5b8764bc97cd8f537aa320f043b6084c608f4552dd24e54d76f5b31414b6285705997d718c710eee18c796abf26df324ba0c52286f005109ce5a4d4178436f0811c02e943fab5a3e22676f5398e9911cabc449b6c903b791c060820d3692636ac28333aecf23725464dbdfca585a24f7c7db83fe5b69c8bb3bedd1d61709455b3afebfa24662f99ea59b2a9aad07e1ae9e1b5efbc080f0a006158fe7c25cc2f25343e7a975b8224fa6e9bedfc7f46afc9867b99a35716440f6fba119d26587a96150a0a22942f1f55f7bbba00b6bfbadb4db68888ad8aed4ae9a293634e9028c754999f3fc2f1c36009b57d2ed1373104d62b548d4994a7669c614c7d5caf70196966e715001c37046c5146fcc950d920d12981d4a997280bbf5d4c5a4de4685f5a719982f52de368b0099092d7af2ee20e0fe5f1b312f3296008c6be9a74133dcc5246a2779daa0a04ef0b71447e4135750b0ffba81986e723d87763efa5526d4abb5f90ff3c78aa57ef9e6ee461e621f90f646bb9b32beb9887e58ee1426b7196fad8038acb1e47bcd03b8ccaa61cb6fe71f629dde6519dcd54f6d64e7cb711c99844d8f3d14803b2c915682d60266dc2b27fc613e4e3841ea0a20d6e3390414c19c3671a9179a0a2cb8dd50f2c2402f0255ba9cc059af3d7f228ff6eac73ebea53865ccf01ddb8b4bd72ddad3d29c9cf53209145556623f67a3b41e18d58cd9a8f10144e449df3b8d8d8c7f3db368c983c8e418ebc46ef09a75dd9ccca7d2b10a764581bef925f05ca0958686f31b0721da72f4b9bba8d905db6136679bf08beec83f6d18280ef4d8bc9fed61b5dab9732871e747caeefe64bceac7816679a775f5fb3b7e44b0bac19696feec6fd43b864b5c89de778b8b6b2d2bd9da68aaf0bc714bb09c37dc110a08635a3424079710ce1dd2d32ff1f6590c40b8ac6e406908f147b333b34e1a73dde86a4fc6c4d9c1ee64cb23cfe89f389e7395169be6c3421b036593b1f92bfb0a3159170c5200e3ca64556243a86e01bca4b4cbef8dd7ab1f53fd562cf02df97fcd3c7b3e81fbc886cce2833510b0e12addd6bb751c5819226138a6b934474047a4790b0afb4079faefdaede6d5fc1920edac3072f49f4ec433c5eaca94c42e04d57a646c7e4db0ed80390b759b9bc6bfe1a2ebb2e5694a9eb3e01ccf040049cce3fff9bf4adb3eb418a61084973c842d38416949a71a186abc08217c21e1e59e3a6bd5e28a0c9fdbae53e90822cbd1c74664da24a6adfb96f2f1148f7185433b6a911b9829f2e9f3397214a5712de000641d30eddd6f1c7ef3f0e66f9c1fdad6959f7f48302a8877dfe331e5c25178f6758ed8b958d5d0ee7622e45b008299178288d49514aaf4f3a7e46dd63f981536a9b1f9de0234c395cfb3363de178b1e54b9546295fa4a144bd6ae3b093649feb94b05cba39dd69dd5510ba0f97a41e4798a9000d264b261db17b4c20c7c0d0b911a4a8924f2da88fd8a8116a1f030097ade91c2409cf6ee63dc4f01468ea1bead21305b0cb5f77f2f2c7d1b6179a4a208d01c3bb37efa6d84893986d876b643a31b0b2488aaf25b145cf02017fb9a0c2d75305f77f07804fae9ac3bb4cfed7e33be77a7ba2bc48a6ba7076630204ba0f3cad3894eb54d24220b9e1b78ce28aa2c65a6d0652d9dde3ab7235bdd93941c9ee0dd53c61807fffb23a9500dd0fc77ab2a2206a97f1c4fbca419deda95294fd1bfe9d3d423dfb367ddb52bbd393f7da9ace928e66136c624904946f9358ee4017b83cb7e418341f1da971f053c363965ea1e0b172c0fdaefb4d6d7602e72c4da55bf5a90991a11ccbb52a82bb812cf9d96cd4ac5d943fb02ebc7b802c3bd66865e44a851388ada87594178c48dee16acc55b9fa8780934ce1a5e921a9d2e5090b7b4c043e540242261a29e6f520ca85a723211bfacf6b57120f341faa34254c3e4e3d2ab939f55ff638476db2c15c8719a21c0cfe6abb6e3442a4a296c32297cf9dec051f2b1d7911158e351400c829024d12be0518c51dc5c2d1e69c1edaf983b8d2e3390396b8de0b22c9b5269ba0aceb8f17271dc85062550db73689cf8ffcbdfee9e7d93bb5ecd69a17d8d50122e11a7819ca00fc5fe74fdb1ed91b715bea8ba1ad9d385e8be6c18081da81254668e453df3b5ee28d77b5967a35194830c7bf34df78f5f44c787ac53f43a21775f450f97b58f3fe4b2758ffebe451d87a76c15502989f19cb90584b4e2b3515b0708f8e4129eb35d92d2a119cf82671038a0990afa99a4ce5419d46907933c93470cea02479c474a2a36cf15fc6b600783df8bbee3d091b4e4e32a3d38d2187c9ddd2ddcd4e36453827f852c14483d4d05defdf023d4e47c99cfc243ea1accade30892702110844bf4b7693a8f5d379513e72b2f3961948a428182132e8231bfb0a0040e7de3cd40dd699a724177d8b17806b93504f829bea43eb7b623a527c29c5dc24490585fa7ef6e5abbda647b2ec72dc6877e74e919413e85f766fcc449d2fcd96c7f1cc7027707002a673e52391f80311af298cfbc266b730468d01518398610cf08ce5dbb0323c4fc9c7481e498ac4a5203b5c5915808a8e43100ce0266d2770b6fc487339153eff66540e034c0509bd50f275e24d578671cb380d736588736faa4990723c55a5a1ad9ae069c55416e5f659db6b74a849b6d566728606b3d74e74da7ca8c5a3e2485144d83b02dcf6ba50335fcd765ac98be5e700ec671815c84b869a144e040c686899e8c7b8940d011b4da825e15a10580ff6d8fcd66275150a280cc8bb6a8429762e0b69099697c0a493dddc07009e270a1c364f87047a5d9e7a3672cdb31ae67bef4a48c821db1376823d418c42dd39aa37001f3f2f3bbe9b5d3ef3565d62d4f2e354b3805ab1bcd81bd63a63389ff5aeebc5879f8a0cbf934dc6d490b3a65955ca4f8460ac98c47770fcd33df4fede1f7e7d9ce97ba68b7025e98a34776b6452f66e20585f66f235caf14b03a2eeb2551e0097b7291f51aac05c62892982a427c9dbe96807f4af792aa6dd81cbdb11c29db14c2db0e02fedcd32c83233cc1be12d36e2f509305da127af3b6512ca20a64bdd91485adc4f08251cb895330aceb38ed749a88eacdf5b02862b00e06a0a9b41711e1e224c09c6a7daf0a2b01e32f026749db660aef583291d65132d0e99d9444f68dded5f0a10c8f5aebb1e4ceaa067015d5f66787fe6642fff47717f80e1d7a2cc78b88e54f9db08175f96fbfa732ebc609347de01f534f6bd8e33f563f16792cffdb4b987f7f7c0abaeea848c93da34c36e516d36f70a6d45cafdf3dc3fa875a3e2038acd184258972e0044499413b7fbc3b11ec0607c7b9513a8e991849f3e4e9723f7a60b1a8e86475b36a78a4c723e08d19c9168458cd43232379feedebfc358643afe938d86d7376df2c102168f540db48b23ca90b60882316bc16c846e728c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5baea5607469f4613a7c6224a0375453"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
