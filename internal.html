<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"817efb2094852c4a3233510f055118afe10c674eb5fb210fceefb996cff6074527ac802d31f5c0808c3f1140acacae3051aedbda6c2eb232af7beab495fa4acb6a2c87c680d9cc78062d5f3d2c6265e4f1b794ecce2e86a984c336c127400a45f7207c4baa76d1f018e8e99d0145f4e2d1f618da2bf9567dc8af48dc13b92c46bf4744e463465f2fa4185a8d817fc34c324b5bf7d74f520ef7d82ebb4723d41e46edcc1c7bb3e2ed8618ae2aaa8f79f578b087e0416caf16c7068a70f781d9b063bdcd6f7a82a46121f9f406d4c4d9d8ffc6457c2a98576806535afca6a58770b4c30fb69b25bc392e95a45388d6f0759138a3f50784ad7e8b3213620e0b95471933b9ecf0d4b75047732954b86fc61fa66f8364303545b941b767786ecd60c78377099ddd2559d8a5ab76119dd1b64740d028a1586e0e13c495b5176369cb3cc9029c0abf7c3947c9bdfacefc54579b853b8ef8e27d10d51898098227d3e5869d98b1d96fb99517d0d48620459a4b84cdebc078b4392b3c3e6281fe4103deb33070b1e8dfb9b534ecbbf8c83c8e6c9a9611b68fc438310ba89867200d4428f2302dcdea1e486aff4b5eed75582e0857f191aa1a479f24925b58ba530340f4b8a1809d473d89fb09a98acab7d28937cb005eb3936ce1cf6370d83f4c599e7c0335c362d1dbaf6fda991183a51f782d5fd53f6345b8fd7f72ae41a57dc86b18902a3b67fdc02416550b4d3e1a370e6450343ede13800b17cd7426cd7a28afad4086200e9975faeadb7013a92af280f7227273172cad13a6d2158a1d5747cfed31eba0348a30d706fd764e26750936110ead68d45bc94a032ae83dd85d91ca2df64b0d9f346707f693819401778a36087df91bb8f8979ce46aee2a3ed3d373e7df11eee76e1f80b6b4f37f4ed9cf3dda4426f4b9c1c2f90f9f016d56bc6ed7568e6311f744af6127952f639dd114806eb3b09682d196f5be3dbb677b1e49271bd5a702cdaa696be2f377178d2b0a869f3f6ae23f229ddc7788cfce2bc604a0e7d83503d30650272f62c68d12c13b9003f904330c2d00525a1833b4624b3e7c5ef4064296e6463aac69dfc26dbf709df2de7107263e54eddb07ee04c7b898f11117644e1d3cb22d75a6cbee02b20807a45bdc6d4306bf89033967f0d3b2db238ea44cfa7654f49fbc7338e5ffaa13175267ee95781b5ec84df562f3ce141f0df2906e1e9b19e6b71a090f598d75df03e02a2d42a7ac37a84bb520242623a466b7416aed5cf580e0a39b90babd029db4eacc477f05ddf506760587dc5b338c10823a3e493e6c0a228c9f4f301f37a83a65894fae8f166984e890b333c00ca9012d01d829d5f580c000e32e5bb56b3fa8f360466bca002609153119c5a0e0e1f24e2ede3d3dcd45d54ce5e7090250decf100926fed33a1e98ff9dc52a490b2d5e5d6ef1afc444e3789d97a7d9a1c696bba94cdfb40b2ac45c2d3e8e49f9ef4ec0f67a4565291142ba5483daec17c6fab4ba54c04070bcbb355aa56770b61194f14ee91ef4314b116454e9a40188558de986db06d11d65d24293891141edf91f21eb246a105e1c3f5db611df06b5c4f4c7ac9851769abee0100909161b181f07b3eca1c298dc13a81b663c7e3362551cdf40df14d27032dcd71692e8c733290d582b77696d0e85ffa1219471d24216a9413e67911bdc103451c8f38204875c06facef8f42095450a75f1a0ed6ba36eb404d0535352474d05a0e6b82b858c2f54e18d0817ab569066e844a35426630291b9b5870a898e7c4416efb078d15585ecd4b181ec7ed00980d20c0d8d0b334743b9ea4c88fdc73ac71e7bd10bfd0fc8002606b7fa08b2c0755f97a077905d617d6d6d2ccb88eb2ca7f2a3a5ffbeee6d307fe76e171309c0d53605d9d996fed41cce9b2987c97b75b43f5357cb13d5cc81a71c6191f9def5d3bf92aa572264a901a3b029527acca1c4c1b669dc1b3c7ea2b5a3db76bca32258a15461a68cb886029201f671b6b70922c3dd1dcc8b986373d3e0b3f39525213787cf60c785554aa7b8edbf4d6170ed68f7b7bf896e1fb7586fadf7b1203c0544211c1f2a1027f251b29b83ade611ba14b0588b7c635afe6b708f9f22618ba946aee11f7ceab2aa22499227b8ae7ca1289e136fe3b2550aeac98e2ae13b3369e197abc0d8ac58725c0781edbdf9679a2bd5291da1d557e84472f18d4332af85da999b4205f0a7e1d81e6a5b647225a36f8679cd3f225fb3f144258e17b44b5ab9ac646138f3fbbd7750565fa9cc974f0531d1e8aa2c9015d39f9ac245b8e6a5047bce13c917051749222e01994f1949e03189311bcbeb3afa52b71b43f4c184a5b04f3d05bb60b119cfccd574355dc690585ded01c40be52ae1a5cbc41398cf29c6265964b88a9f7e6093d386e8b9869f2e4fae5577a6fa4cda8edad465dda9bdd24756914abe16b97aa9c136a13805d0fbf5bce0a17b7834b5a9e1d9f661c1aa553c33ff0dbd6e7b47781456a3b441f40d9ceb707f90feab73b02f4934c2014ea62b2117e25a1e8de6811f079e571e7b95d7949ceba38efe225320ce14ac71c02d1f7f4e2e205f7e9f1ef4003a195fce003d378e0989ef2a8df26320453038f918eb471557b72ab59e36ca903eb8f0a4a1935f2c9d11d5f9b8b9b4031a72f50b6c47fb8f59f77c71de3af7bb223f65394af86f9390b71745386916d9a6e64ec2c340dbbcecdd7643d613f8980c6608a5917bad391c32c914b38adba6e03818c221d5c17d200b57fbc4869936db78439b9817638ff570f1c7032f8e69e61c8414e89569b870173fd1283c37b94a24fefdce10ae2b7a82fc09ce0b9e4d6f05fec281f17f4d82b1661a1383330dd31ac85cf1a889ba0a2632e92369de6006cc70616677f2274d7f99f77c769889646887a78b1c7a3bab9c4a13718666dc39b65fca2c8a7b90231a281b6c0a9d316ef78a9f8a1bfae4228e05c4388eca149c7c8d7ad63aad350add6dbdf37f8bd973a0ec0c8ff5203686e920699156a4465267bed075d79248631758503ca8df57e1d5192ea5690edffc5f0bf8ba4c16745500bbf806e15909c4f6cf23dd23ba227057fe55bb039aa420535d93cd7a65095b81c53a329364acac60eab8d01e04db35e3d453c6a7ae26ff6e2b3978b68281afc034a3e85c11e504cc6c3a922f4486a045a3070d6ddb2592f9e19c02d5cc13df17e8fb2d202c46002ea5d8b34b3ca76f1e3f98add85d528ade2bf0c1cff76c6938b834fcd3abd066b7fad627abe913e823623523e2c498d8a405bb5af0a0f2685b0ebef88890a2791463ae179b8b521d42629b8bd9149419c56c58485d7af819ca371a5331c80cab0d1764027299bd94f448de7c000a05a2292d36225e673dbb75badaad00d42c82c201a0717fecabe60235ce4d2ae1fa28c8ad48a9055669b880d2fb2f8c7a7583cc3af81f1a46b0db8d194d36401fc8a560d768aeebd42aafa58cfdcdb304ec7001857c15c967debf4a07487ea578c7f138d23ff6d1f97539029b4554136c4e65fe73bc8a0577cfc2752ec425197c1156b5eebcd9284db4de3b75808fc44e595ebe83bb1585063846429dffdb9464ac2da60801257cd5a7f119cdc4f2b83b3f8f203c04c920ceaa563673501cb7a2f2a22278e135a6f86ac2bee70ed53d6f2e467fc00e199179d00de91e9f30811d7e777698dc81e55bcdd0d6037d41f55e10bcb7244af1e5bf4b5b01586679b465a72bbcf2a9c9635b1d7aa5f9f37d13d565cced05a14521920185b3acab8e87e31e291f56176ea603d4ece4fb8da7499e9e195e0dc724a13247831ea8d94ac122e5a7f30f5d7bfd8e3042202c5f383290387b0001b38aea2359b22d064816d80888e84ce100ba75f1cf221c9bb316c7522b9ae1e392572476cbafc697a75f5e7784722f160c3bbd04f9963a625d408faf063c77536086e7b9d7e2df5f95024ab3a169c986c14eb5910e18d425e28c7d59d76fd45463581a28d6cc82a20855d5038113896e2268bf4fac69766fb695a812ed940330b6d91480fe88b1247f296e792ff5fd0dc2543a3bdc565bb30ff780ab2b053d632a3a0aa2eda6b51c1edf4dcb23046d16af2f93d0d05501579117e4366c2b0b7c27da9f8e615ecb792cd63e20f78050e8773c555c96d6018ad5518e893a0aed274ae4a57c0db8e17efccdf1f865e2fb6bec079f97b78652b3657eb8ed85ba7ef4da8264db68d8185230ea71e6d851c319c60ffadba11dee334ce76ac4fdd351fdcd4d4dd09ce0cfe7bfcba14838018667db9f2f86984860bcf24984b548bf466f36732fcf31ecdff7788235cbfab51bfcaed365d0e702d5f3539f92c1f855f39b6cb316d2245621cd24f5532001812f2c86689517ed94b77f422b5979e312ae6df19a381fae79a86209e871cb6b3abadb135b4dfa3eb4eac9c315693b93fa7e408cb0ad43b27ee5a15b36a18b24dd97cb4001f3898ac41125cb7333b34bdefd8d2caf42da8ae7decd3807b650c4dc797b4e9b5f8b81131570e84304a9c5a98bce295183005757f0eb3261ab3f302ca278d79e283188fdde71711b28e5acbd3d2e37b7400504ed8bdfc32d8218eaaf0548a22824bedeeb6aa2faa3ae027234a17c43cb56e2274ac941f2b8420549069ed041f5a6c6236b3122ea34abf263c74ebe9e480d4b9543262dcb771eb7ead79e972aa52508fe9de34599bbe43adc1e2380828977067404fdffe372931396cb6b0f1ac1512db4371dec313c8bfe108696694a9c71b53b9988dd919e84078fff22515f6028971680aa8d766be21ef0e73ea442dc74a8b43234c5622ed78726fdda6c7e4e24095ce69e35fcd4e7752e607d66987eb17d8c8dc8245600b1ec1fe7f3c521af9facfa3beeebf3aa3562718a42f545b2e8b85b4e1a31fc5391e9b37e56fe745ba3fd371aae24e105f8b666dc364106971a9093a0e516ccdd8122bd94b88e2bfa823bbcf260ff80f0dced61fa4dfc4d4f2009383940c440b7b734447bc09e8260542bededb669f53f5b276fb83879c34b8658ba1dcbb15f29ebf3562cf15ddde57617dec5d32e6dba384a1b7d2235b4168e41398db944b45945ab52224e3a76fb888da94e7066aaf494ce045e21d4453aaa2c93a9c898b61e2a8a5b561d0bca4153a8d855f483d70c76bcf46384028e08e8321339bb76f4db7c0deee6ac4e0d07959c8b0cae40d1320f52e5a98d124458c71c44e1ee6b4295305af1e5c68f0bb4427d9a6fca3009e452a0dcf0f17ee72c42b1b2477cbf519cf3145f72a17943d300b18e39ab4126de6865d876ae485aa878ad4def14ee160ca3397f28ae0427bd48079e90c341d0c4d9efb123a29304c4aad27d97432656e7d62784851b11168edbaaef316bf20308f9cb7064833745cd6365d21f0b79fb754278e37f0cacf41b902052fc513fc47b82c6b0391afaba10ea95d6e2567b690b2394eb0c9f28563f004e3837f6cc2370b95bf8630dc64ec27bbb70a5115eb01cd35cce460bcb578d5f063b331440f2976594635431383312a0d567a31c23ee54123d502eb3c60f078bd5beb4ef0ca47c7794b274fdb01fa73d7ab63adb6d0af194bc5a779746a26e0d42477067321933f16adad6b0ecb99c67d0c5848bbec2866d812d6855ceaf12b38ce6b176fba909a03c3c4dfe050e8bbcee898810044900652c778a3fbf0b488b37559b2b2237694f71ceb8ad9b5f1e5e80cf0518332aea5746168102cadd37bb65b96715d9a6faa5018a6bfd21a01009386a716be6ee85e9b76006aade0f81059dbc025c0de5450e0583f9252f0d270455b05e6727fcc61eb688fbe82903b4f12a7c1e65ec05f6fb984e38f00a6619b54fbf9db2c144c3af2e0700352558edb397c4175890e42302cdc651b685b5dcde625ae84e511fa9cde8929af2bc7b2795181cf797efd8bd709e603e2ea40473db517be3ff15e3d82c3243139983420da28021fff0cb20f3dab128fe24be9f7cdd00e3d1c20093ec46ebb092b46d9b5fd3fac5880654a6cb1f09395920e7bdfe9af8821c3f4d2091fbea0b1d57b235fe97991607c236c19105fd07c89c6dbe10ef944927351dd78e19ab7f844bb054b0d396199e74a57ad36e907a3d7c7fc3fe2a0bb3460b11b1c76d8c1f26c96c2c78dc9ab4d1690153de7337f6589caa8f881b25bc8d8e336774bd46337613fe5dd49ca06fc094e9c5284a882290aebc5b55d8f1680e5e508bb9c5639202403b12990b0900a428751301bd2ac26264bb25542440e4ecc08b96a65987ebd1bc0cdffe62e87b2a37df8794fe92bad5caa10d8a48877191da6e979ca522fa906dba68c5654d0d3a394eaabdaf06548f122b73ba9824baebce5be8d0276f930fcb6575493ab70cd4967af768ae618a503bcbc9551951447354644dff92f188f5f6f48aeb17df7d96da338745027f68a9d11e249f3b8e382a30e59ea284a88be84e387f90d647f435341acc52bfa125b6fcfa6f3bd42b5a41cdd50ec05decada00489cc49f7ee6e2a75cad90d2553cbb054f6a4b767cf808392457d17c378f4137acf9f530b1c7c8c81d7241f38cf590ed0e31cf0b89466f509b9adc7494bab9184d3a701ac6b01c00c8b437131521e95ed1dc065928378117d44792bc23352e2dca8cc1379fa06904f6e5778f73fe4e22bb40ca66a92fcfe9e206b4d29f4e5c628f11c6b61953a8dfd36bf1fd9f48458b06bb5fb4a4a879ed4c6755ee2d4b7f27d7dcc52f3da77311f6f63b0be81f0b961c66b53b3dd015b179b2c1e227c5d8592f3ec2b58813b18d794c903657ec6677ac1eff5049709d078318e6f0fe42ba5871c8f061eea137ee0a808faadaaef8a79b51dcfe188df7a9dba0a4572972970bec68a6a8502668b944cd0aa94d312ae3101f4c5dd7c11e90154d8a0aaf5d62e53711295b3766b83c4bf0cc0c75795e1680292f497ff9109d0caf6ba855527169e9e780a8f87d16b8c95939953288e491ac65a583be8df6a589a791d4905750d9139f8b6605cd4c67385b28047a7a2286b1437fa1df7b92935cffdd4056ef7dfce0225bf843772e9d786b683159da4e491ffcfdb2d0a248f7714e976069e39a998a29ccbb85f04b1fedea0f4ed0823a0aa236af8e6ec1f5b8a05caef4873956c8de4e316facf913cd5496cbc91bd34343c5a771cbd955df4dc858eae38330480bf714cf41779c1a09185f84abc780189148a493f98593edef52d1f4e86bf9eb683a41e205bc285c0ad6240d9685e9bbe5b35e59a0863d650fcc0ce2fca2e29814bb012d50bf96d8aa0c43769435603c1cbfb124184fdd571188dd87e1c27cff0343cac8e65d8b02f4718736c8111030f19d869d4914d51bbb08bfae28a40aa8cc61f592a7224678a8f8bdf2ded3ba6f58ad92625556f9d928f2ebceb1c19a355b28aff1c25deb3ba56cf375451ba1e8406b403cbffa90c91f392681329b9b4938ffcd53d7291c756eb6cc0d710db8827be88b6524af3865d84fe78793ee04b74aaab77a89650436219d441e3e4bcba107db2035e3afb5f7f5def2a9a6718cc08502b5f55dcfe0521e0a61d0f31382a395dbbd1707fb9efedafecfe85b4f64ab4971091e218ee227e78a1df0592b2bd3e74a08f5fe9a2959fdad426b0307d723ceadec03d73dd2dc16d9a844f90601076b53f50f57e52c536da79426856a1b9305f56fa5479006abb877cfa60f44abf8d7e841efc621cc04272a0e299c3a13a8d715a4d0fb2a6c8f80bcdeda04f8742dbec7aee51c7b247eed4c5afabf22d6ac1550e37a9d9bf2e07911ac479aeb3622ec38c60e6baa6d66472373a3e87d0fc218d1766951269ca240cfc97322366be69d3e6865f2b724ac7817438ec6f54eec488f21b5504865f996e78ce063ef1c26fbaf33432c39f0fee19f34a87ad479a16ef02d5db75550162fe9f8606bb56a6065b6db68b070242a70d3b9e1514f96ed7f19cfbf3b4ff79efa131c9c3a6386a27124b2575d1d083eb38f0c5bef97379d84c315f920c8b08ce44e4a9678cd352e6a77e5d042cd640a85a4521db9449b603bdd880995257ae6c5965d391f0f548fdde3203ce99ed86e6c76f13dbaef67fb0e64060e38928d3f8458b056204a9dd3e6325a024eab102d855bb9f55ba70e1596b5b615e99cfa89abd081c55048b3f00f89ccbc0924e0ed5f71393a8e9ac6111d75678ddb298908ef7ed0ed216fb15a64f999445d1a841decb4e8bcfe4d222798bfd3a4c1fa35573e222731acd5bae1ebb9808a5889e8409c54dd7813de4ecf3c313835877ff4b046432fef98530fba610cebc32a76ac704a44c04aa41bdfc937bccd8456f0ba26201deb7796d761dc32a8a2e56f7332d2e6359b13fb9dbdeba228362e98e60e6192b65c74a396a32d9bca18f8b097c34a4758ce52323446df81d1f3c6dff8243400075b75300e1801df8b8bc3cf53093da6c15cceee15f76f26792a0fb26e360c07638bae95467380d9c01221e498775b58fcbedb4e58d800d0a63084c4dd48c8cba25575d7020419820d2faa627f23296c5c20f410e8f5fde13a3cbfcb60324c3047e46aa9ff50ac01e00bd97f25e3bf0f67508b64705ca33325ea35806d32cfe0d1b7a03a92a00108d96786055383a3ec0b8a792cbb99cc6cd820b30161fdb4483d19d41e9fa1ac68fbac635ae92daeccebae625ce508ec2db9ef3bd8665c0e09a9da67a05673b97440c6c291d4ba1633700e0bf3980bdd35d8b29e0dfef29b2182ffc4552d404eef16c59c3ce99fbbf5d65e4c3e68908c772b7d649fef4acbec36f3dfcb683e9ad6adb30bae7a3ffd6b767124112a5be59a2f7a252a416eb454a7f8607bb9500090e322ce41caafdfff162a1776149de61f65cb85f4aae893dce083765ef5cfff664c4cbe6164d26c411f732ba492141e943873bceca039bb90b9380d655800c3defaf306e69390a0040074b279d3083b4a229c6a34f9727c41c05b9a914825d4a17e7f15dcf825cce5f10a461fd823020fb1229a86fae0d03a199bf65b717e0c397d1f9603f2ce9e7a7bbcccb522e843806fdb0d567f97b04b8da3cb19a948166cf62379f2c98b6ddeb66d56734ed7fd7cf326363bc93cbb01d41a154cfbaca7938f4be6bb1d4b15fa2eb6324d5b3d531138d22c536e074aeb97deece11ba477f5c0b1eb2aacd60f67f02216778a37fd96c44d1b0a186332edaf4121cb1c36785d325eb42f470bda4e27fd4aae8dc66ac9523b21b28b0d856dd87be32aacd37b3b7c6adfbf5ba4db65c82430ae19d377e863ca443cc29f6114b24e231b8c7fb24b2c03e6d36be79ad23ffda073dce988ce8435bd40e7452266320670e3370949fb3cbee295868ddabddd97f3ff2c6812a07a7d50d3291a2243a544c51e32e31facf65cd9a61aeea7085b6022699b02a284df257e10c92fcb26f22aeaedff6d09a5fc454cc5f5f91c651de4f6f162f23c21b669b0a8ee0eea4c14abd92e6709f66d0eaa035b6ae182f52fc24768d6b2137c54d308051b11bcbfa638726e663964d75bd229649c6ec0ca7e92ac28df2f6a454400653c52acbf56a1b215612095ef7e22ee30498949fa9693923631bf919408dab7d20eb78707c01ac6569cafbb8a1200e68cc59fd3226acaec152da6dfdb8e80d1b4ca8cf2792a2b7907619e9776edd9cd77d29c3f4be0c86acaae1f4d51fd1948c0a8eef09817d8c5a912e771a1983424790c3389bb9dbc79ec245ab60560f42b26f4dafa631b10aa79bdc325b19e66f3d7247ed482d36507573e06a989d2bf0d9430359064023fd2b7e80a82327f224fcb073ecc1b69869355194c9f71997df2b64fe3a7c98058211cdb6f148999179ec96cc4e5d1cdbb3aea6634c34895e9f1ad5d2c3af46cd63bb382c8edbbbeac92b500edfec568dff37024593eff262507a637ecf57724dfb242b47f50eb8fbe5805b15178f0b1b435c76c006beedf9ebc3bc2205ee8c68b12600a9ab7bcc1fec50895f56c322292248060604db765ec11ecd26d3611415c9139599c4d2dacaff20d4fba4454e43f780e07e93e30e862f5a2481794393f5bbdeb8fd2c0fada71299b63b6c5ab75e45ced3be4c431f6050028bd580cb735778f1cab9ba917a3eb20d5850ef43ffa4fa5c5cfa04fd717d9d7eed4844abfab641fe49141cf0ce82ab15bacce6355d4a36568c950e2a02d7eaa815f55a97552d7ee099d340e5e450e8f01bb0a1177b16057e3dfd74e9db4fdfd19b352e11a7289b477f129fb4bc6f3f00be2cc32cf7dff630a8f9f044c26055681a92339169f69658e33e409d1be4ae4a274c544de4450d2149af36a46879a661fd229e88ea93f2138f1284432db2b95a2f38ebcb9238b8dc732342ff01d087372945d45b9ddea21a405ed4b67bb38be4d58d6e6e51a1196e83d507fb71b36b8a5cbb3ffeaee4f6d4ec9fb89fa38fddc394edb0acebfcccf90b09c16c5d19176c7a2a4512cc5de17bc5fd8f656396b3c19ce145ef3f4296bf78496b4b55b21ff6b64609a1b626ee26ae6cb7fdcf14038ada10b98472e385bf6b2aea356b2d99061ba1f3a59a2749a1c2e81c6ff17d972a654e24608ac20bbb85ec84f080fc5d4d2c06322618948bf085db538763b188de1a68ca0eb59a4e84d6f12975f5f7c547918915d95ef7f139cb6ca6cf8194a7c5eb0b1a4389ff0475c15e2551ec623631df93e3b631a7bb69b9e37edd38babefa2300f2c846af3ce2dcfe270d890b119c1369945f5634048ef3d6498ced011d0f9e9801caa4c3e85cb560bb5d219f05c6dfe92d4951ba30e323ecd4ed8231653710120c8cfc4520e890d12c874482047232b482ac7b06c91e9f9d1735936aa173a3a089811d0c2da04d336989909536c6946f43b46100f946daf4cd4ffb9f102d07c1e61d4e1b8d7165164744d723c4c54f8ff239d1fc9efa37c28d69f45b192ba7b614d9cc39607c9323f9b4546090e83e562cc127148f9d0b3bf40b64bf2a138dbe07ef31cbf6460d4089685f738fe854a68c9d31271fcb77673c33b1fc54ea7afde33f92580ef5dba723db4f2ac0a9839de24c72dcb7c65bcf3834f6fa1624e671229b1cab6fce305c0c9f57574e01f525eb404f2ca994935e9f264a3c25a11056924581ec28ae3985f256f9139e5e61cd9011f5a64e4a718f41f6f668d5887d5909fb473506baffc985d9b6c8016ec54bf2542de912335fa1353765b7d81f371142a9afe75580087fe02f5babc0d02237724c15dd21153085841a1e60871636739d5e9859175d02428ed35158c4ff547aedfe7bce7d930975bd2414107825c2f0fbdc89d37030ef6e358d0f4e4b198b709c1d75c6d583a4476b9a18af1cc2ff5fd3bf98382dee1bbc4950be8fb838ed45dd7ac52ef697ff45dc949fad63b92fe4cffc406394937f01ed4f33bd33481647de4a1a612bdad6b35f8e4d6bc0b5998f5ce3d98c2a2fcdab29c4148f4860ec81155312aa1c650208daa421ffd82670152f48647aad0d4d4b23b443570998e5ae332b3b1b05245c2ad960001e38a2b5901ab10b7c86ad18ff95bafad8e7468ed1f1f93dabf4913944de858456ca0d6c9503838af34b78332042a4892bdb4e9b22b0720f14eb785b7ea63cf4505cb47b4b691d8858f176b354ccf8fa04b5b5e4d4a727320e37b8f3a98b18e6cde7c0890ca5952442f2f756681e53ed924e7c396764f56d00c5857686a8bbb4c2c774f3eb10fa9aea4ec1bfa53226c72799c519a0e1783b63851df80d1e213ede8bab4d080c5c1159d900592c404576258384c15de7ab108b3cb8759007dcd08283bc5eab9365e988000fb8970878a1d486e81b249ec65e0f1e3dcbe9638240862e2c829b86378484276537eb70eb81ef1cb990110110ab681a545cc68b3066fe0eb5d79bd67c93945811e3a6f6ccc34bb846ef8db85c9f0a04309751dc8ec0b026bfd2b457078eb4bb003e8f582525390db4ececdcebefa8b0ad2483dec76f9c1e79bdb65077f74f9f265c14e3331a22d1f632a102fb11bab8a9620b39a5346277a07ef0bdd028a5f2c6f35ba474657f7543b8891704dd49c2555e0f430b36f9ea4a1fff64c4c613660bb7336e1e89205ae2368748940c8d0fd7863712c9721d7577a21f23d95d9d351009f3867dd571af1e5185bf814b35dc38e2597da525b6205795e6810131ba34782fff5581998dc78dbf990149451904bf766bcc820bbe7a1afd078692381998c52342c43f3d8a18656c284fbd57d25b204561c692fd3c30da0287d9bc568aab8c041fabaae8842f17ecb8d71b678b723eeee56b478c9e076b809b9712a336eb18df81905ca71fef6d38788b8f1d7f9946e9d85035b3df385299cf79ec0c79975c0766ed169abaac19fb4a3ae97bae45aa1238953d2679c5f953e656de949fa6e65a527dbb3119ac7b2f1e52d594d6f736475af86e56776531bf242749d2d906218a3693ae71eed2024603df1bfed25c37571fe37119f5a96350886b4d6a8cff7747bf262aaf5870546f5a139980d85de212f4a076002e86dfa617c0378d556045a5d2e46d9cbb29c226f47a9df441ea9f246645f09e10b84aeba660d8b30fb31baf5bbc905065a6cdaa2e3669a5ab292efbec0e8cc363287f2561324b6e07d50c6c36a2c719c733904f8d553a74bebe283920c7046848b87658beb3461cf9c4f1851c5499d17146fbfdb9b51a894c71b5d75a958b23a59fd5cbf55b85d9e1800ab0416a5ffdb007dc6c7de8fe14e3ef946333197d1faad20f44644e755902b9d5a91ab1146185b63ebb436f27fc7fdd7db654f523da603dd016d767c58e6b6d8f7d6d54b1c035440fe216629c3f5c7285a7c84dc3690f3d4356bb74d9c09329214c212f82aae4320f21c96cd140c8e2b9ed13113b5428c0449d3ac9327a8e23e6a827b590ab046d7924480460fbd44ab25d5920d95e1afeae13318ff50ded38c5395b1c53a17f48b7e86d01b6845fde1b4f6e1d7648c6083a07f1761a42ba1ecda7a5f3a908a9ecf748efbe1fc4c119d0c31ce7e2eb2c798daae1ee647be2e2c54d2999ac557707bef9961448247594e4044197888dd79e2fc6c59d5a39856b42f9f6c7e03254a9cb6e809cef84911910671474d1c7efd211e16b6ac6b4cdf861b3bb9a3a8c01a6272d47e51243a7bd262660eec4f9397c5d2bb8b97fc0884396e5ca91611990776473bbe56765397d046b343179c243319a13070681c78f1f93d815ed0361adb588478dfdefed440d8e4d98962c8d488e8ff9d92df67c2bea78f7ead47dec871f761ce97a2839ffd124c6817ce037a37abea8553e7b2f1a8fd36f4623de86c31ba387bef480548e996df6f86747a4580f07c0512abcbb67d59950ab6270ebaf6d38ff7b4948838eea2643d7474ce584466209aea0d3694e5c7953f5ee8a8973e911928fd659595449204cc046ccea98e3ff53e24d725718374068a1ec3ce1c7d11b0395d6614b415ebe154f21865a3adeca1f229b227447c774d9b4b37b375e6319ecc44f1d9061794dc9fe448aca3f830721789d7e5f25194b079e895daf5bf73431c43a4de04cf08672b0a4ec702402594398de45d729ebde675751a4c6ce9e48fec856df5e5ddae4545f8285c3892b0e3c088ac39f9ce5fe057340e1cc415a0662945dd858d4b7d7f380fbc52ee92b1d212fbd4ece3890c447da73598dc3d747140794a969bdcb292ffd2fee773b31ae6cb881344ac38e39fc7a0163410682fd3728f689c037ed2dd00c412d66a47d10eb946b6c71aafddb2c17413cbbd2643f8b4615ce86b775c50b1c9ed91079ba9f5893a946b42c769ba299236bdd1db262594d4c14c42bf1ec70c10ff3c1db4e471bbc79b2e7c84cb10d7e1c5350f9d011c401669d9c03c8f9e4b3eb2a3f537c2b9dae15e23942cf48d1e5236a7de53481d7e613bc0672f0ca2e43cd691efbee83b871d737dd2638a6e05ba0291d1c79de1c540b0d91e8243c16237a2a811d2ca9075ce08ee1d52428f524b83f6970350bfa1d5f0e83e7f1437236408f862645a9e1c015684d3b7a9f39898e16ebe955e66c6e5750cbf7213c81271d2fbffb297ce1e9f83a30edb53790dfbc3f8c14d1991cd3ee0dfc32437f44aba8f6dbd803c3c8a69fbfe46f6c2d4cbd1c6daf5f70d30431a1a09ed312c43fe38a642a46a1214bb1260b8a596ea82c10d1aa0d4d1c85e2e5e110b9e3eafd2c14aa3aef8f6df0aecfe0084cb3113e3f2fa0d94f982347f5a7ac910e264d51e31f4459c39ad9479fc7cd52631dba0045fd216031d4ac37c6f43e3cbecf633cdbdf8ed8b49e426fcdca6c6ddcdcec03ab707e84378179800b91c62717e4c7e5725a04e3d4d915efefb179a3cb76452811b39fb7bde050f377a067f943aa02db170a5995aad52be4757973bbb7259fbf079ecbe4c1a75c2c2cd05bf3319aed75eaaf5a0a4fe9540379f58fa2c9e1351501650b573d22c80d404e1bf16743a0cdaa7ece03e9ee83b5bcf9d6c0b281681d4bf80d706c3a79152486f7e558d80bffcd2707be3c4e78d88b150c9e8fe8b21b8384f4a28acc2aa151c5daacfcd1707d5aa05e0eadefb9da1069fcce238153abb42f67e680403fdebb95c73dd2b73a7b3a25e4724e60bf10a5f645d5c12bcd00f9c25320e9cbaefc8fcb33830e6fd8b5cd9674f51c5fe819c46a0e9b9c74918230a6ba5decb6ce96ff20a05a5b79dc96677324d061e274634f5e70e914006f0f816f085e5f3175b6f9f64b88b42262642ae1c382dd0677e30a6146af54d1b389ecb95a4e58076a90bc5be5d3af04f539c698d1a64962888f9afb144e1495ff631327e521985ce19dd8a96a9270bf3eeae63bfbb74a95e3f86ef8fa4f6913aa03c7357c58521acdb8d3f5d6907a700cd244f83376a7447c0c910b5d7fbe40f493095f20994a17a8680e9dd9d76522520b948701e8da4b6b166f4f64eec9bf75071f94f578cbc780191e0df54cb6b36605b3b1787776300d57d130a3ff534883fe6d1f2c09e52cd96a8226f7d8b48783d0fc44f68a4ed501eb4f225e60e7c5945aa4c522dd219cc6b04edfd7844a5a5a6cdb8145beb12981851a2f981f6af0912f2d1abe649cc51ca4f7b707b4490871f3134c7574c09812b1669949eeebb0c9cee935ba788781eddf91349beecfb37c82fe7894dd22671edcf9d55bcf67e4ce222e4bfcd34bceab5da901823ff58e09e4a1468ae353d62e35ca0aff1d82ef81cc01ea772478456eadb82ca2fbea40d9673f825d9ac1fed843b0379d21c01894d6e4365d98bcd7968d32fa47af8c047c5597538b86a16601f605166693cbcf00718a31161cfa73b9a2f948d1ead017528946e81c5dc9d16e2e8ab303245b8ec6c720bbc35f7c6e2017053812fd78d15e82ed1318c0aff7d74d256248d7e52247e1d3003582ec4609626d27dd567b9a397f34bf1b036228db4322bc5fe0c8be7dc37a26aaad30127c670255e91a5a491d9bf4ca625d7050bcb5fe1564f02b599a4dada1aec88b962de25fd3730ba549abe325c70fd8a2182017612b7a3c2891dacb2a79201fdce218034a691a52ad220131fd2456de9e96621ebacb5003364a4e7fc001bf8941c2a381624c879ba539e35d8290bf147646e99fcb462580fdf0cc745cf6eb773845304b5d8381960274d3c7d316ec1d7888cb3f808c213105b4d12bffc97209ea97e43bcd7d36d5006931d75ce258d14c8f6d0c0bb0210adc5ac81418c5c4f65d97d4068f30e0fdd1078fc33118ddcb92e6163cb875a3f6398dfe511b6e2767a145be675ed5a0c8242b76ad7d5d4b0ddf03213de3b969d92ce4c6382b3d5d2fe967dc7527319f9301f96e0ab3c65483741c2d7be9650ebdf91f6e216b20c15952c3cde9e37994ffb0eac635bad73febead6e14e2eaf7a317556bfeabba620844ce68de1612b4889ef44bebedc5ac3424488cb96bfc840a86ab6746a13b8af965fe64404108e0214c83c84dc1cb15d33cee5bde1d22bde7992a0efe1823a9704bde25b85c0afaae841770e7331001e97e1ea5b81b1f3928213f3de1e30ae5e5ba95606a31cf865de31728b15840005a6eb574b2b356b5c689f59b6cb827668b11c9fcfc83e38020e432bfb13e4e1fcbef426591694cec808c223cdbaa9baa7b8400b90c2b43824e11fc033da438d37a293181344d06b0849303d72ace329dbd772b59beaef8b2b61b7bdec245596c262b00e58b94c028cf08a13a344e23e63ba0b34edfc786666e8be6a39ddd883763dd244985eb9f4505774963375b776f7149b37c944e8e82ede719cb5e19fd9182f1c5d3f5202e5581c8ad2dee09c0c1cbf164d8a440371222fa895d152747ebaec63838cc2b8f53074f09cd41b69f679f6a93bb1dc8dec4dc9513414b87af80f20a370e4ec01fd03fbe87a665394862e4c9f177b3bb08bd871ad7966ebcde5e1b57a21dc6a22bdfb59434bf289494a3df0cb94969ac964e027427369f97587cc26b51a8fd335f0f683547dab29701f46d92c1b45892d13f897903672da4cf2892ac16d9fb9472e3609361aa157262c6724f909235d8c0c536def3c0b5fa6978784606d67af868ca6cfd3c509b71cc9f96b5db45931deae6aae19b38908c1dcdfa9a9842a68260ed5c2f023c30f50d790d14482686f218ead9ede449ff8ada4fe7c1c194291f12ec542b700f052a3f2db5fc6836a21a9a95f69f1f4a4ac5c0592a261a6d1ceae1d0203be47fdf9f4f80499b7b859e6431f8f862955e20cfac4806ee33e706f8b30cee30d5c3bb807b2046d0f5acb934cc30905e6ede2ded024004a368fb2cb8a1589433b903fb3a8763d5334d3f88b3233674c90f91cd9c0f0536898041f604e5629c37dddc57571110303615a8668f6cf0215142de3dbe4176c142d2f4917b871e281b366212b0f7cd772ed51a5544d7856f8ca9c97d1db0906b9e2180f708b84933234976250533ca0769b7f50f85d152f41ada306fb9deda2e7dd64062f2d914745a158e4b28bbef56d1bf9cd9ba3696c397feb57b161caf7c0746543a3200417d78c8f22a9bb92e1461d3a96785a59fc2598e32b518c458470abbdb5a7d810a2aa16fb297073747f7fa88c172a2a0d779fb5f6b924f54cfee1338352ee7bd917aa1cd802f03ef7d3200cddc97a00781112ee18daf39487b54fa8493e9f7a7775880cb6a70dca0a2fa91a98d8b69b5af71c295d43b99ccea13ed28a828267dc1f950dcd4823bc39494d1dfe3a82254503e02beda1d4c550ed8bbf6012a5ac4da12768e6089af4540758dabfa37ecba7f2b8318ee79016081f2891d06321fce6fc6345151bae40392038f3894ae7685b63270d317663f04e2817b44cb17c8094ba18ad6d426cab26da29eb54c173c1feda32c59834de49b0c0733ea7d77dff9b33db6253e08c707fad77a77fe9954ad0f6b71b4a55d0031d1460eaf89d6c9fdea64580f014584b241ad54e1009962878ce2e726f8b6b0bfa99d3be278a10d7be82264dc5a5602566e6a0ea904ec21ba5edbbf1fbddafa9b323bb7c799327da0185070a77a501a7c03807c8fa7baa6c06a6e0632ddec26f697cfa2982b4e6568929a41e1efd623b2bf7a31fe857c7b34fa1d72aa6f677484f099d659f248200606ea393969f04d234cf897134b414bb2093d94e0291a6d93985f91419d59c32b9af6efbed7a6e67fc8f26a024738f822e4cf88f5685247dff8438d58176a8a78547","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"944a0acb4b21cf3f078b90cef0e80b7d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
