<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"475666720e8f1d84a8795003d3ab6f3a064f6bf4efe8b7e481fae2d52d8802b438ac9b01ccf8611daee66335d8fffed83f5351f5fe5a7bf1ca430c9ccd22b1202263e763c90fbfcba2e91e62dd1ec7bc5a05bb21e239134d5a72dc39dfae549ec10f843ec6bb9e9b15a76f79e731ed6195f4b85f063b1b7f564223cb0dec89fae54fa2979c4eb0b4b64908dda656a7d71c83ede129d8ecd86037ca2b1cb312c1d6e40288f83e24a1baafee1c4bb35a4bbb37cf33531347a043c6595ebe8a5fd5e3877a73a6fe7cdd33af4baca25ad1291fff5b94fc5f40091f9195448beae096980b0bd92200f8eea25060ac527048ba859fb4057292641516f3638048432b3c29d2c85491909c18b1f2ae9889a7c677c8a74969c99995c9688c51ac7d6706cb8fcdfde028f90521b49013da0362d04315b071003c198af0198769b087f24adb00cf98578a5f9ec3892b0159415476f9b9aba51af3f7f22a73b31a947ca847494bd4c4f9bc171765a11670db4ca75261e6fb1c984847e5d1dbd5dd3462a1a7d7e2e6cf8ca09d938647452df56784aa60b42d415451d04bdb0f36a7156d33ae46961eb3ea0e51d2f47a7a1bbc844ece4f4d379fcc9980446befb9b85d9435bee9319df9d3b96e2f52267890396a332e90f1b89c4e27243ab0657f2ae225c85392e6727d38ee9348050a762408bd07f75e9cc95382d23dad4fa314c5456a1802111e675c2524bc2e128ce806a0f7187eb184f457b7544046b7b51dcd2d84d109ec2b3c421887c5e64a643dcf1232e18d8fbe745182c08d3e5a2533ba60c0748b5b649314958bfb99126a01eb7b75745910c48e2cbac8e89cf200ecac742ff188827881cf5ad9b36929d4e725781d500af5caedb107609e9f67117f8d4aca3026c5c6f8087e0eccba1905c3ab14e8e56ba9a024dd06a69a6e0381b27ce5da89bb0ff6b90decde071e8049f1f20faa8f72dce241c7590670c04be0c59d3ac33e78c2f25042ecfbef17735ed60aaf37a3a88acd6fb3c33cb17478985b15807df9d7a76e63cafcae1b52e6261cc8eca6cbc85a4da39bce3f0338c6a065bd27c425fb8267e0ea4bc581cc1ec74fef01d39ec58f626b5b89108a9145be4960f0d3d5e2a52fc31944a372a59f70a848a4cf427697b719b33484775561cf2e54a7041a6ed563c9e83104b3c4b4ff54580f33d2bb280e75978cad2fe3537d549d8d90fc1cd212df5b53aaf4b95886f4014ce3ef0a8cedbdd2349695e99b67df68ab2aae7e3110b1fcaca02a1797488e6dca1931a0c98732ac315ff16be37e8a08bfcad92803f3a27c7e9e9b8b84a9dbefb5122d09aa54bcaeeb6ea6fa6795430e4f0de1b45dc4eb868567716cad6c381e6b8a650f3334210f7f690d605e9e72b33aad8b638455f14f71460650762fe7f58cd8ec8e0220e4aabc9d72264ddd53d24f678430d3643187e140babcc3546b952358ab4b8b93dd786c9a9ebfb3fa7410273cc93f067d6dbf3a08d6c35dde1b89f303df45d08ad119034333943124e89aa3d4251a6b4e0ac96cde3038cb0f5b89a772aae8dd41ab7153ca72599501c9468c925efaec7623e530b3533ec8770b81708072b8d487f24ecb2a4280dabfcff7ef61a4a1e7659bd366bde1c9acf92e0598534822df8dd13f7fa2858eab9cd8f45739c6a92614c99361fdf7a7f3323bd82101baed20029fcc18f8299817dcc50d88744dab6137eda8b9af2b40f1b9f88aa75d983805ea50bc430ffecc0b18a3346aa866cffbbbfd83756eafe7c65e98a80b2505c0010401edd8fe8ed411ce4bd033725de8f091c25478286374aca12831aa5a84c0e3eb293f3e65da238846f260821f72c7c9c9bd4e27b3b5eaa7fe4a22be3eafe1424d4d62468bccb7722b137d764888d719e0e829216e525ebde358ebd34ca94c62a1ace01f5f68f2019dea78136d03ae67fe8a8fc960f2bc961975494521c4d2ad6cb429ab7a787e1c1eeeedfd5335cb4d8378fb6ad2be6055ea637adcbd108715ff224e0c357b2ba077a71df7f683cff665b8d932e8381e36986a9ef087784760692c7528f1de620a36e58da5057f0f4aa6b5b831238aabc8a921e02b22aaa0f4e22d887250eac273f0b1d4d2a1bf695de1e9dc72c67af9bec2d3be7b91f9fc8d123f65f53d96b0c5d8842efba43ad436a27ac017f78b49312a19e35431deadaecd6494bd7bda9a667b0f864908845c6df000f0cd466f393763ac99ccb160fc9eee9888221078f545ee68bd34849d8edf89c870a9b8b359867e6bf3e9f55d4abb6f7f2417dfd0e2c324bcbf7ee217c7b5d11849582e2281f84f5c757feb7a4cdce1aba2bed73cc5cbc89cfbeb3a75e7e4108cb48a6e3815deee729450f88fab0489dbc683ab79509066225bd38eb3bf0d87a77df10aa93534505a096ac1e1797e956b73a58cdc3e53e6f4c04022889ebe2995010b94ee8957c4b76f86fca04a7d984e6c2497189fc640734e126568b0bea52af4ff0ad49bfdbac18a0addc4399a11491d7f51d4f6543d09c516cff48f3b24d1b6214553fc9f7541b6f6287dd52f13c7f15c040ca2dd3bdf5e53bfc44f03a381961c7ae5929d8da91460689ac6f4b266ffa7a64596453fa5e4e5f3e02e0cc0b6855ff6dc342501cb3bd0d29662d54ebe085412385ea08890c247b46c0952c61451dfc00b31ab59fe443995c8916a12f0310c39052107f7e1f37b61f0c885fc563819cc1c48eee5f3c80a1f89e560fcfecf4817c0bded8feb7af62f9e38bd9ae2ea095d657df6c89e43eaabe6b11be94485cfc3f3e651fc312efb3598e1278048d0c703377ed6c39434f97b1b16be7d5949177a65c3813b3aaad7604becd144b88beaf83ad9eba2d450d95c9debda3d8303a6a63af6dbf98b52be9563ac3d0a35f846ec346305da5badc3d393d7157fabcaa49abd328412493d7da35fd1e30ee828ad41fef6d5c1dfab5c33575c5251fd3fdef752c236ae1c2e3c9cac2c55b456175b338cee19b622ef008db4c1781159ba59cd15102b7b5d9084e45b8288d1de1abf6c36bc3d4ca96ce195673941dd868c54d17fa89ae8e457b69051f21a1953c4e0ac7926e36bb49bb6db081bbf12ab5b67bffb92681423a516c7b13844bd6e83b5a047d968ffe1af3b99909064214c2177f92dec085e227e93bf79ad0f8942354eab72c409b08dcac89a42f12c80b47442356aaf36bc2cc85c7e516a48d831655ff09f70f29874e984a64a0b0cac2ee4304ee93489bb92e03c836fe75fe3109310febfd10362b5dee0df8d46f40de7117bcb632f8d828b6da9b0c2c90d85a317639de8d8ac28e26e3025a5ff2bb3b2706bc31019cfa5dec8ce347f6bf875dde362cc255ec9816b831fa509b95d7de246d73af792b30c56758efbf0a7913dfa8d0f8620c611b505d00146bf8133cb66f81088c4b146de4fe4eb8789102cde6fbd035c9bd8743d02ac10fbfd6dff65277b3f5c2ee0708a442c64a8ed0258f45b2280f5e630cdfd959b4995b32f2701d57894dc713169d0617c9783d04ba12b327012a87343166d55b5ddc607315d8a5ffeb61768a33cea7d09aa485b45f072ba88928cb7758280da8a901683de4ae422a290a975ade712afd6de9e1e0dc35f38c48a118df210b6fe4f40695b2297eab725b797a1af0737235a4e87e9ae9933b9c0dbf0d979a3c38da703787121fe2c7fcfc73bbbaaf16bd161cdba63a9eefffd64ffa40560737043c10b9749aee741b38897b43d271fcdb273e4fbfe1b6615bd1e9511e6385b51384c6c0a5a19022694067604215c09a4678faa496712c4453c16357ca8e1db91527bb749f3e6473cf21ce7b8c29cc30617b09d30b23a6a11e9c954f8f1b922efb84910a9f2b03483ea3073eafe08d8be9b54cb39c5fab5b802135ee8d259a33446beef1d5825897860209aceb5c0513600e74849f87835c162003ddebbb54b6baba1a946657506bfff9073ea06f02c4bf4189851c36e9efedaad708f66735dfbeb41fc221c255a64052180048122b52478845b3fca88de4dac5a01c9c74bec63a09ba8decd93253a2c40df237c5ae9df3f4f0cfc9095ad62c4ca067776f0f7531828344f431d41d59ab2668670e576d73aed46b6da8e8a68fb04d37d14101d16e58904e961a46e684d638e0e85e298842a0ece1308432727dcce9a6336199992f7ea7fc400f88a4d6da77060cea4bb1b6cc29783d4bea942d7161af21b158fd7b2a276a49d293058151e1974fc6cecad90b320a805fe5860aeb0a754c24a7615b62f3955f253b56fd0a84117260972dc02d7de6e4a63107c44a1ea09524dfe7883fd436cf41e807c5869cd2a74f65057ed86f5f2d2c818aa2a6475c31b537fae70d8b7518b7336c4f6cb8dc98cecb17cdcd8da22d99f0af2172d97884d7ba2a7845cd6a82611a0593774e2c75f9a7c9dea394e8a2da91c774ec779ca9f07cabcd6250c4415da11005333098477bbe6e5a02431b38dcf227101e877575bf93ca8834c6a9a632a9e6ab6d9b8b0607ee102dbc15429552e29f0b623ed8a62919da06b3def41fcf08bad8f7b88bd0e6e7c9c8d47a44928b39b2e17fbccb97c243fb7d6b50f02dd12a90c583fd91a042bdae21ba1a4f7c5e9e07b898b790d87095f04e5a0d3b416448b06ff56fddcd79fdcb1e38a1266a92e1f56c0ed8d4c30a43dab0f03f4ccc1c28716f095faa4f9ae3ffe8d88c85a2f5c56eaf54d1dae25d06c4f094ba51c61c94b5f46d44222ad47230791044660eac9dade4dcb010c4bd85485a77207cd692b09b20e43ffc694251ff1284cec023d31e54d7ba30b419d86dc24c901369f732b7789a844e673a60431c92193079fb5c8044d911f2e17c7d3ac38d7bcc1666915a40502b311a8c3b612f97c5f548c7e726cf04fd974272394f2f66b7657ca63b76942d899161b9a947cbb775bbc571c6620ccb51224bd6f51e6d97319975b0482f90e5b320d55635a29c482313541ad513c5c819191f13a168c013d1635cfd8c011488985b15d7161d09ba9372c1773326c14bdb36aad669a3d0d9a22a9edaf6ede75eb6384f9729caa4bbf0752fd0e88a66269826effdf98f743bd359dbde2e384691fa44446cf6db5c8449605f7d62d2883097c352064f60e41b606b276b0b52295263a86307b895598779ab2259eec29e16bf75882ad9d17c2478d4ddb27322584af8ff9e1654f6e47afd193baeddb81f0cd2314175cdbf504ec20e9427439e6918dc9251c604c85f1242080678941f477ac6fc27771d74269c72ab46f2b6f78beb5630ba1a31b7443e4deed1ac8c3990b8e96dfda4d069b4d4460e90706d26bb1b5765056b9063dd0635fa01a35827adf44650fb7469faf2732e642eb5f606c83f54f73f73f1c130f806ca764acb10ab2049368dfe066c66fa5a80e57278a93d3e78954023bc76c69aa181c252ca70157e93b3c9fc80f8271437c2442a9ca31b46614bef396d2d7c367ba53726f894eb46169baf0084e2e42e94d5b7b830bafa51a5a80b7ec878f3cfd7916a9c08aac8ec0f7ee6ecc03aeab2f9206f4c2a9f835d1ef4b7e17ab732147bf21744ded109e0d3ab5bc71f6f1dcc5c390fe5f53f45843db1ecc4de6cb00dae0d370d6e1d5937f01dfd692523507bdfbe3e116cadf4bffc404452e0118d7aba89cd97b20d25eb1320dbe3c7db87b60686a2471af0fddeac7de301e1781b8322a3827d8fbd199766eed039b93474e40a5e7b8b57a7c0d98ee352f6c03b345a75a370fb78696812d0c00468177936dbbb5ddb6a63ecde9efc5ac400206af523d469c6f8a020176c5d7f308c4a16b9ecee7885da634d3750f925a696174b4377d54697cc71098898f4697666e7e656a420ffd4cc583b0f098fd74adceb36f5cbcac1479c1fbd03503df46869b81bbe61ee2da53b6c45f5a8ea2cb85da5a0fdc2213f3bb369d1691ef6a46cf56b9f159f669adc2c66081cb7538a5b8c3995fcc7d019ef2156cd32c55c683325be50c3d1dc795f22f7a65fa6ba6befa7953776e3f636914743e6d647a26f0cf20ff7618f0ad1eac86c0d494119546fd6a7b876465cce55e89b9bfc218206158fa9ce8863ce34dce61b7d9ef4a074a07847e955b1d9d25752b684c9264cbb3c64852fb8f4d12eb0a45e937dad673cb5bcb377d18678c923b4f78a78c77960eab157160f25f026432096b72b62c9c79ce95f2adb2ce7760cccea8c395b5efaade252053430532ccae2d14d9bafa9c8b2c631590c4bb200bc0479230594736d1fd831b89b3721bdafbf0df914bc348ea4045e2552319de27bd932b00bf7332b83e0bbd2c346142daad4e4772bd4ddeb810cd6d2a91afff583915ac02731c4aa7d4f217895521134a10a0e43483a61689d7d55dd7255f333d6a7392d564feb73753d4073a073f515ff18f153715c02e3dd17fbf3afaab1141a9355820c1df713d76c49448af1f3a9d93152c9f6aca0f49b00b9cdc6d7cadb70c232a3111b4e234113535dbd371fc8ea964f79f47249116015822d548f0e1004d8b82f2dc7a6bf8876bd13ae2b538d1ba858686254c5dbe5e1055d49c428840990c031a47874be1272cb6b978fd23b4177820ae217c0ff9631ce22a23da05e34f73c363cd798307ab7c5bdc91f70d1b0eba4a138025ab4c8ce007b4a109392724fdef6e5151031a15e01d244e2c200c65396322455d1bb7a36f6a99d540c6433b385a9285d923f64661128417e35feb068a8d7a764ff1ac229a87e7d131cda2fbbe74da798cb278651692c289c011768a1b52766dacc4f40ba7ad99c28b7d41a65435a893c57b88da0eb1c7dfaa9679ab82aeaa077be790e708a6edecf0ff6395c297f968d2159a630ef28c673f4029a3657a6e1bd13092e55af6ee3ebef6c66bedc953dcba5a65d03d0a3a84b97fe2fd0ed7c6ec866380e8aa6d673388051b49f251abfbcb656bf3e771b578c4d9bed0239b93c99903f5c64335c7245beed7525054cf2ff83ac2eeec5fd24d1977952d3648b3da829373b26c86e7bc7b930f81a46ed6699f0106e6c26782bb8bc4b05b316191683da62ca68585c6a3a2f77f5110ef60d57b7101e0349c549552969c5ac7f32d4a590689f66bb0b5a693083d44c3e58974a3d43da69d04fb725c457f6b1784c0e873869b570b4a58b08e404ef50876a4d26872db13f4c78b5f5bd2d9a829f78dc8026b3e5c72692566127e91694cfaba48bfb85d80c17b9ed328ff333e5263addda42573b5d71e909ffde6591da78d7aa500712a32152e3263c378891825abc2b1f5849d630732f2a5cb60d1fd30e55fc9958da4251c354e451e038f34d0e6a3dd55e0d86a6479d664d62a9344ec7ec16cd2442c8ac498b5efcf01fcd6e4e09bb18d313525a944584aaa3d02278b5d42d9911b71e28e07783e3d3cc89f6194c80f10bcf69eec48b405f64bfaf142c22c65f10fa56aac576585647fd6b4863e07dfe73b99aa96f8701edccbe16f948766390f43ce292180e3884bf7dbdd90f4c8b587a33eb1cda4a1b413702116c993241c59e4094d98f4d80c9458ea6ecf6e7dc2b2926b49a9261f8707ac3099f0e8cde14084e7f85fbc87535996cf46432e4fb76f25a375188a62269c289f267b71a11a75941061bf730f00c0b583a423d2de21abd2f8c1313f19f7847470603e58c56aae1e237fc9634a4dcebc968e17ed4c08116571e649cdd4b79a03b9f4df3c64fcd8cbf939fd34edca362b983c36ec2cc8c7e568b428c1d14b01dfe22fa10078c66052947955a6f3391aee1bf4f30e3f4af133a941fc915a69d61c9debb14282d36a9f33e35b62d2be86d288dfaa865c0702da0776a336a81966b96c54af61dae35d4a483a25a4754120ac0450e7dd857a6becca28e15f936c50f50697db6e3b49dc398de19888a0d8a1512b54f0809c6624f98187dabc8de6fd286d8b87da983762fca37180426acdaa83aa0a784ad3ce914a08cf55796e59fa52ba84ce8cf7fb861db80e658a5ebe4fa355cf63236fa7d890828192a01d8bec6edc03bac4b18f5812926c1a5107d5eef0eb0de6157a7c2949d43e871552d93b259e821a081552a75ac87da20dcfd171afd7529b791a735535289408861b54b75b9e18ab144642f8a53c7c5443c8fb8749c942f021aca843cf40825b61152dfa049f040520794a8276dc4a4b444f6a7a724d33e45082b940706fec47e1d9adf8522ce47e1ef5dbbee81c7d3bea91faa205304774f974b44b340e69b6e0ee60acb3336969ba687baa244782ffded0246e36080cec9f8faefbff1fc98f0498431d16382cb935392e7ba03cb572261df15dc62a7edd043b4164e5d23a84a8b59a6dc194ce84835a116c4c1e55bb98fcf98909e98226aa094f463f17df9e429f4cba3d31895ab2727d10b830abb7089a797ec9bd3231188f3c8fac52564f6b6adc74a7e177ab9880cd67e96772e2a79e59b40634a8b47d24aa97e967939b4bc24ef5c3b76d9c547329123fd1a83fcfaccd7f346f2c9d4dc68af3631b15bb1b1806b657c046e3fc925bf072900543b3c25d06995ed509e190cf96f43f2ee41315a8cc741ff208f5143b2ce665d3a5f46f5ecaeeb0a83f771c132e262b2941187f561e054191a39a530ae46541df05456d28c2cd2513ba91c522ec3be97c27dcc210b1dcb37a3c233e2de57d04030fed300974ebe3dba499514c323e7fe0fe32d1247c551e14dc0dc31cd21df402813c79e908aae31d0da71a0c08a7233e9cd360b73b5a69805ba5e0a607f2567cdf2db71740f51c773c8dab3f03c1a1050dc249bacd90ca74dfd6c3cbcb87ca04f98b339862800da6b9c5f0ac3a1198ac55860c6bd602844d0dc2b6a8b6a50f42524857190463c283020e3d7479cd4bdb0ee4e56cae29d62ec35f0e47b9126d4c4cc7c68dbda8d52953b8d6f2e7d5fbc4c4f1b34e8d217d8c970b2a0cfb537aecc3b30987c7e5dba143f915a086c5fa688df2dc129d7115966eb8455bfa87f1865b10dcb137e0d647c389f93f2657ebb837a36314911cd3bfb9159a0b4c6c53fd91922ecab878109b33bdbe57c4df288e3e6d01e3b50bdee650e2e880dfef55683498b40a74c0b7dd6e2ec82602e4b0beae967ea419d7be1ac089b114227f790770d6d2013eb006890567cda219b19c50b4a75627ae20f3fc9fa17b3151afacfac4be0da6475c5b1c53636f80764cf10e1b2458fc2f3e59294f8d69a4fd5f514a65b2e17d8493c9f51497cb49cadef23ec6a961d1772ba7052ccc5477d80fc9ea0891369bbb02f9c2cc00d2f8ab3fe03e17a7b5602023404144c356bd6bb0a27ad615730a24689167823a0033077956b7977657e8e4cb895ab177df20a56a9279bae56a459b6e65387093d0a2622b16a60ec3bd7ad93b1e064b5411653d2bf93a6e1a590b33665e8b63bac56a385b14e0e5b952ae48c0d66b7ab6943d3673c83ed79d7d5a731abbb4bd1f1bd460741b2f5262673db363f495ed216c38fb823b841ccf32d0770710c67296fdfb839943c66613d0c7d2c3a016df20925bd00cd85fa5af6ee18cc92cfb0aa52ee3ed2dc7560c5434cf8c425d049e396353cefb7b4c9ebcefc1508a7e41ff36a9e090eab2319ad7ab6d5d5d87fd32465a8e9191e8d85dc3af1f2811026d044bc0d3f69428b9684fbba50477a1cf56a6739658d18e0867014336688c4cfd6fc5d73dfadfde0730ea2b9e958ff3975d71101027bb9ef8ef09a19922741132e15bee0c7d8f9640e79cc0ac52c714ba9951b563f275b4e5f693aa976e21d58819358cd8dcedb8f9e62cbcffb32b588403bd74ef15a39bbb877d4929348df8c243927eb2473b609c4bcf0ab0dfd48b3868cd5fffbfdcc1379633c5390cdc4876415f4eb87423597c94abf883ca587f4763560ef5d2f6ac162b661d3855ccc7ecc97ed3c70deb64742685857a43449d2a23400c30e4975baeabcb78986e807160e04ddd79d3b87e8458a25b66a9a3d9988b8cf7cd10c78ba01154e5c883a4e35edebfe043ca477459c4dd22127c9cc77327d2b7c97d464653e87b72037fd22c9ed115a7b5314d231c8d9201a382f2f801aa0bb42d2696ce24e1ab8858ad8b76ef96c87a10db18eca9de7fe9b86ab7b39a11ccc3ccf2fe42d3a3e47bf2bc6222de264fc6cf5d193d4d79de9e3eb84ec2b67bb6bfff824de608818cc6e4a3deeb8f6074a22d9d6143dd646c667259705cea0c0593ad414622d03a593f09109c507eeb1f66a4d7b38a26d4861b491f7ef013f32f6b608964c8b80e1057f0a989ac6177c2e6c137654c8abe0f4b601859a406ba296520c4f11fdadc0dd90e6ac98e746c0be29ef0b2e8fd8648b6b1f2791d79f5016495dc582001360dcc8fac37269bf9a5002fc16f4b886bee50054e1b3a277c2769561918e7017331abf4a6d0170f55e772119dc76700cadd104fb2445c3526cdde85021ce0edafe21d5dadb85c16a4cd20831bc42db18482d38de6bb0a99b6218d86dbde5e1129ed21813923f141fd682eecd6a9e5fc8a23d2c4c110393d79ba4768d587c7ad0729bbceac32c3784eb07162c21a37eefcde3cfe6c1d0cfe766931bad43b89bcde9f383e24a17dcf30613cc5af327da20a1510fe80574931659f3bcc47b9f8bf70aca9d840d91ab714a8f00d684cef73db11b15e233a1b520f7ca8f47cc60e9e57ffe07259001b79b8cf6dfbe33a45d7278ad2bb446ef9399cc11389c48cf32f91ee41950baa4452f0dc1eca4633dc4ee247313f6e62844575aac57efa79f69a8df87b2f7749f777d832796c67d5f65514a72a0053c2148bcf4c5a45f2209da6f67515499dfff59eb389617914390b13ca964d35f055a129ab5c1723c9d2658393fbada31258d1ec890779143a759dca43dbaa3f0e73d03e5ce239fba4d70026955f0e5d9cc88de4f915f37f761f354090a01d2f18a92786416a8fd0823b17e474ecae88dab405d784246dfe3fc975050c881008330ba3141520cf36ca2467dcb1fdc26dd5eda4f30c4a2d223b62066a9bfe953eecb3a99ccb21b9c44ffd570b216a59e12a870c73c989089088729e69254ec31c2efd9ef9fba76cb224da8ae8e45ccfaff957d626df014b68073cb9b929f42fb5ec45dfbded633a0dcf2f45a3f46a3975d63b66969e41cc224e006340ee004bb52479680b6f393d11e819d6d4391b0d6ca1ca509041af330150f87f8e1bb7f7572ae3e2946583225a4166382f7cc626b7522716538d4f0e5afbf38a574bcff73097a80212ff795698175dd106c4a0711b1029700b32d378c97c385bc3baaad2af7ad42fd65fc7e61c62f5e9de54550791f2c08b406de6b0541e1ee00e19044709fdac261275ad348679f9ec7988367e6b8f61690bfb156dd3c9640bbc2359e1a36877bc1fa296732d0b1edeb353535a1b1e727bd96b55444ed5ac8d3f9bd9dae11aaaa8d622dc6402bebedbc33b08a2c1ce311571404b6cb950782fb03fdf139f318b97a05dd23a6f3964694860b2a247285e3b5344d419e024b11f6b6dd3fb61effb051dc6472ec33924cdf810bd924e7526c79ec743d841e7b63d13778cc2841bc843b04a71ac4c86f284e9859a7a0dd0c2d51eec9bb5607581ffdff39fdfb5a0a455eb876241e1ab37ee73d0e92ad6bdd18a733a4644b9533f0c453f1dfdbf9536d53545d00ec39c7ab6c6bc25404fefa20fc720e28f8509e31d333d3fdc25b6820ccb6f38ee1133571240cb7192a10dd89db3b4a0c7a2a40350e96a8280bc4da2af55b4061fd1d40bc33b984b52009357b20ffca5521b70f769efc863b026c030d416ce61c70c5b85df7be6f147bde2d240e85c7bf0345516dc9b48f286609a5859a2fa72718d9fedeb426e89afb5ca4fd86f6314b081fd18eb35937c277b1caae7cc03373c5a7522b8549896b9eb20149444a7f41be5e91d54403930cade786aa674c6fdf338ac81f51701513007f54ccafc01d45163dff1f60fb80ceddd6b6bf5f90e3d66ff5b2437dd61156f75ed52460aff5218b8f721542327b7422b4003aa07fca1774eca71ebb134fd2b398772e01196c4fda037aeb0972bf3f2b6e7924eb05d1d7037ee377f982be1f28b49de8825a8f64c1012e71b17b8b01bfb8974046693291f057bb7c291c8bca1b029b44c997c834ca7c50e657ce7f59aa0c042a66a131ab00f4751c85c08fbcb084fcd209d5ad4c97a23f32a503cea856d439ef698f98fb87069231c75cc603447824939369662fad04a1a4060826e98ab7f02d3d86baa594f23c8742c79a4eed72e77ce340bc56400454e683635db56759c12579f1a81f92276bbde1687251ab2dbd32fd9dbdb215db375b26383bb149c45b94e61088640d8e94629ab0e2f01536c595566571f35fc90009e179a03eb4e491aac48ef9de2abe901159912b067b318c6077f73995ad40abd46c5b7a40769523e99e0c5b844eb71e6fc2f732a5378e9c4a182db36563c8f79320635235a9b3b5147a143e26336afeca520b9627804f20561dd42f4c7f950a372dbe80177eaa89947e69bbe25d2bef8d8b3cf5ad5a78078be3eca00645770d92f63bd5a82af9a282dc47f3b1768eb09d628257415d054d8cc4437b920e900622c9197aeafb35de2fc34703af8b44b7c939b9ddac70c8fcd74aec446b2bc5ebfb92a3307208d318d3794762c74b49a36201a6c18bac5e433508bbe5c62ab615745ffad2935f20adaf8f203ee35930c60bceaf1aad492da986ee8207c71e30c17f387bfeead537112206b570ea5b834ce02b82718143643e15aaabe875b03d81a5a4be1cc255af8fec38550312974df72c27141be22486f65c8cb955632122bc5cc79103b8656d02d5790ab005b50f6aa0ddc6fc06e9ce4f271d66b2cf96c231d5614eb78a969f521d103678970ca05b3cb84eed5e50d4f54dfd59da1bb141033d8501bc86ba77646d000cf501ddbe7c79a9af9a8447ebbc894d8d96cd6a113b87e908ab66e4ac3569039574184aa63ff5ef43accbcb6ae8e7a1d918255f6628c30ac489597aed98df32a008d580d4af8ef0c99859b8bb7b4224292a5ef79804deae9d254f148ad8fe72b9e54e596337760244f539f41059b73a0bbca8a9499d300225fad52552d1cdebb89bec207ccc7252ff285a4cc225f41883c8f35006ec0361aa566e92a3b867238de1d5cc27bab6055430e64fab0b8b9f99931ba1fae95d85ecdef140c732effa8a7e46e038d9a310b6d9a7d6e3ce928111bba85f5e2814ec2aaafe34b609b022611919f7c7c6c145f0dd4312477e921e16f88498fd400f76786fbfd5133a43db6cb5fcbd1b4a9eb6b5becbf25477d4a9368ad140eaf3c66818a226fa877d0cd16570532ad93c16d7ed29baab8bc6883c1be2a731fed1a2aaaa117b43b897c0afe6e4c4e9ee31c27f7d66c463c724ba28ca1fdc836666953f404d3cf43df59ba00c78e24b2e9edc1f8696ebd61273db4eb9bc6b71fad2e49e53644215e3be3b8f74eef3dfae622c8cbca5e73782cfaaafe053ae5844f2645de6e03269733873f3fdee4ead3b276cbdbb2062f63b57672a56d845515f67ecc526fe0959811c6bb3bc6e65f32921c9fa8d76c19b34dd6c3471cf5260ae8cb7ee53c50466b5ef8e5f10ba7479b7d63bbfa60ea400b470989c7ca44eef21898dd63377cb32bf816b2cd18d763a057c975c53fd50928ce4ed76d2ab1dbe0e927cbcbddb2ba57574e24582f72462574ddba23e242cec05fdded683dd7e66e40ffe370d7ad8ba6c9018186b255478fb3f0e619ed1802395bb33822599f5c63f2613776f8e058e4087b85531c9ed84448b741b35ec3cc46a2f3b555308e056f0515b41acb409c366fca7583f10c34eedd08a910b2e53c68d771fe6160b58ebc18fe682949f8984c54e7d703491f7cd2fce2fb82247eeea63443f50a19279e384cac0bcc157a48aaf3b62218aed482734f87697f28628796e7b5801885a4675c9eaa1f9cfb06c3e95a82fe06b9f5ab1005463c79839e732ff54a3f1f9cec745e6a514602f036bb4da593706c41cd401e6aa9eb830d9143280085ecc84d9c254ade1d4f2223b94c8a1a47b0ecdd01cc6ed32f140b6025b905bac6347816532608908e87b767d0c3c749bf61dbc0eae836c34bfac3fb79bda8f7547e8263137b28fc80de655d382f6c42b80d9ee1335cbb38003c6c6e520594aebb9c881412c33c9e1eb5082492688c902c67611e6b7eb16c3e1e8314c1d788a296faf2181434db441296602762cf8ae9b2e973f8a57f094cd462a64ad60ef1e0884fb6f3ccc3f5c5fed88b4c4ee55db5cfe625fa52bf003bdabfae6c10653846288e7e3f054eb64664aa1e5ccfd6041b679fb2d834596400b767bcc2b1b1eed1d79813f96724a07fee481914f89cfaffb11ddd725915db2408248604784cbc1f74accf92832d9dcaaf2c534caa5c97c065f367afa781f76d48932fffd7c3ff53e0d09993ff3d27d7a6edb1244a6926e274c50c2069161423c9f53c2c044acbca7558bfa63ff77a3e58c7d7c6348114cea9871036c766d1cfce27c465f876c9cdcbe57bca1c22be12938be3900bdc95c8a91ec6bc00aa216fdb90067e9e33a23444b6e963a614b160123ba7ea5f8ee28d629c10b8dbde4d2cf533769d36b266b11be996eeee8528507b755cab76a9e74e90298e95a0e0002fc639aabb4c6c17977745f8210a80a075e35b339f348960dbade56e498a5805db8b04ae03c6a622e43a5d491bfb4263401a213e4eec4dfb130243665c5e26fd797b79bf6554182c46bbacff287bb66abcef225eff9e425836ac1275495d045e7cbcd5c3d52835b29d2850155f86e339788ff52c08b08f0c89a83d4646ab0cf2895832e4d1d29b69647cff1cecd96cf1f24dbff1a538477c63eb944c587783e33296fa0d2d307c651fd4f1edbbb821a4eca38144c74625b5a02df726dfc15a2921bc46d2c422d2b848c1536bf644a0ef72579dca0ddd1c0f72b64beb930149cd3b525d71f20e2d25ddcc30c929d7794d045f371767501fb07654e97406bc4bf7b3df7bc8320d982eba720189a7b6847c48af3c1807cb424679811406c495f61509ba9bb72ed8879adc253fd530f7fdb2e7208ffdb0f327f1f5bd6912dc2131152b70528d1b0a1a9d401e68db258d418a64fb0ae9f2b3a23ef78ff2f17846f556b784d0a435f5c8cb8535321ce2a7ded9f8ad89395f813ddcb37fa3f29b1aed9022c86cbd050d7043d0825949ecc37626d71a171f268d288580ce8946545e2dc7e3a83671c49c154d1d91ced5e49301e9de93bd5f13fdb98e5d07b2e02cc4c25f12892340d5036033a2c457397df310b4b6a2124dd97960d6bfa9ff00af0e1b4ee14db7db42775185c426647fbac8024b7f2e7c39633b87c0ac11414d5acb4295e1174167eeb3b02214d1b2c9b17160bedb6da12a94fee4753c1360cacfbaa2836c58f09c79874cf0d473a614c742ad0b29bd62f8a9d6725629e7b808a03a263a13c8e1e7747ff93953e5b124aae4ed3e8e85306a3dcd8c804cf839b2e56394cead634fa52ddd1cd9bf1495afc3e46b4396c5582f14f249b7c10b9f68b9d24d4cd85e87cac781f7af923f1ee88ac4d1be68b14446e67f5cd7407780d17275cc4b50f60ba102fa7211bfcdd3c2bee8620bacb511d4475a70eaee6615a6174b7b301a7055c090f06f08154958396173b8cd6f1ed547fa4b59a27bb6c4c564fd0a3f1aeb77a6b8f505d554b61c77d1ad7c8df97e3f8c42a22905f409324b9cebf03af649dca39d7df4bc7642ef48ec226ebcab5eb2af6190bad843d9102200fe2ebe1c78fbd8ca9dd1e2065bc0952bfd185a4dfb12ac5a27c47cc214713b30afb0df709ae5f38c65cbeb94cb4d14cf4819f17be7a86008ed8bd934487a97cca233bc5fdc038f6e53d4998263d1249a211d1fb3df70b73a37a37480a4dc66a3a4cb441efdbb604eac8e546c716f6b770636d4f3bd37502e027017a27c27c384d1aa1a2a3cecb5f64a57c20027d414283075766c14dc56af804d615ab897851e232e01c61dff6496d6632815e8e76c46515fd325f39dd2f7c9536359b646cfea03027ecd86be2e9c7ec2ab6df5f728c0c615f7b7ff11a1c1db72835a205999fcd33fa3dc014c992fce37574a6ba358d33d0eee5020001dd4df4dd906d064a2627ca49a1a7f98be5671aeaa6a108efb18ad99cc46d7bed3b35820e43ac1c3a9decfbf68d0ff61eb9da34e1acf2697061ee4f9fd5ee12426b43ace7ae7ce6949ce3d42999e0410e6d721e01b0490058ea9c9f3d287a7d97db9ef6bc943249cb0e05ec8907977adae8914777ed36df64cf8a78d2d0c056d6363bf6492f6432ba90bef2a4904e5eb18976b9057e3a857be5b5b110ad5dac4fb7ddf002c517b7da4a441125ef79b61f9d1f6dc399c1f1e017996809b853cb15fd992a078b63918c5a78fa92230332d39cb7e9c10fcf12b804a9dd7514089c0d7317ed9f38e571fdfc7237aa8153628c7d681c810150967cc87dc24f5d767c2f91830880b09f6aa50efc2cf23ad84883d743b9062139e4afccbe8c4bc6a48e9b80b7b06de508292b0ff31633530cce4de2ce8df11cfdb61f17f5400f6c6e484cd7d01e9b3a748d40c09a07f0905edb0059b35311909b5266eb6d71c0630bafb214e8522058820cc45be90ed1a045d0c68e24721d8d11c7eeebdd90840c14b45673202557839a686e0167122b50400f59c597f6e9af085a2a6f2483e314ba23a2b27270f1ce4ff7a657be731bfb759f43ebe99f74be3e8da16c1ea1e08d17981280bf5661a243a35d603824643d27cf0754b7d16c11928f2c153c2deaf6c81b14cec8266bcf6b1c37c24dd7132faf6053e692bba88a043fe40cb026a2f76fe16fb8faeba3ee572115c8796d7e7dbecd7433e9876f079e5a4c91a6b4720756571d92f8a8e85871d352faa2fd870b9c0a528b6af8d93fa336793a1f7267a1a109a861f0f9368442972a4dc880818be0a328221cb39e8af4db2ae57f06cac3d9e767a277236535f6ee904b8b3d70d90dd47a74899f4176bb86881b88e1f7c4428f63e106e88f5752c2251da416603de46a7d4a2ab67d06c9c1e363d82debad1d804e52d6b8fe0d7db00a29dcd6c7da3af3bfa53e0da9e2ef5c6dbcd5b6df4cce320283a98542e13151e300b01f531d5b2d0edf0cc547d249c39906aa41fd6a0ff3784d6725ddb793d20448b77f07a1b1ad9815069bd470a5a26a1250b9cf89b7ea3208816a96c50e64087df69a576ca07864b812b04e87d76585ae5e6e1bb7f6ca486531d45a609bf19c60ae3efd3bcc32a3bd98d5c5b178f3b772c61263ba8be99a29a61b3b01846cfff7937625626486f7e9787ebd0e6103562863268c4178cb22e1fab076298833e5a855423c76a7cf0b179bdf41357feea84ab8eee96d65a75c44e1e1379203eb9d9e63517fa1afaee95df4e8f329180bf1df246e5fe40f162d50d311f487d865634fd7d0264e18c146d974e166f4418e233c006f201cd560d16943638eb20488fe9158479e05c100e9f00104c0c957b56a3444eae467cb0fad78a00d0de23114d1e589612c59cc0b65bad811686614440e905089a5756c99dfd98fec005c7f3707cf2f6d3a2c70447c9efc6b5f337c6b2a6aa0314de124e05962584b1c222f2c4b2b43fc2d68ab75500bf53add8a4c0ba234a272cb64ba06a199ddcec0a8991d8a18f0ef3671b00de544b32965d5819ba89c7c4d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"603b4a45c797abce485155bc54902b35"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
