<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"731f1fc6ace7f00db12f715155704b8b35cee2033341036b16d94789c71f90cb2e5e7c3be328c4d23a2a64e9eefc0a3d30fa5971c1f8803c9b85dee7924f2ceae37cd6e942036b8239ad90ee67f8eb813ca26014a753d0407ffdf4dba64fdc1d06527913b8514df419c48bd48b4a7e99763b03c760f870c0aebfa574571130f3f26a8a2f15b43333ae3eeb1e2a147846dfea2b0e422d054522a0ccc12a332f9586db5b61925ee8cc6a0bdd72d293b17258fce2cafd86f4193ca3e500319a1e9369af382358f5541f6db0a0a2a8e19d4ddd0a154059db9fa319cdefa88f7c78166db5826924e387f741fa83122dd8a88edadeeef6dff925433ba9a661d6bd252f0d66caca806e65bd8a76c898ea2feb54eb4c5ba702a9a742c91e7cfbc493128479779a504d4627681916cf6050550ec44d06a6c697b8fe76c5dbb8a168f81fca02800be6dc8b11ccde9b9ce7955d88cee676d51ecaabcfda76c240076aa37bbafd6d367efa4063ca2018ea6c99a93613ba7dc1f3589278947a0028317ee15364cf7d1b1f62e7dc205999d514178235f87dc16ac8c20dc9f9d61e03566f753edc717a794999daf842e82760aff36a18e1b3f9096378a1c5be872f9b1a4044539d06180f39bd49acd06c94b34cd76db0889ab1b7c27ba458b94f6ba67e8f16e5485f51080ac70c3519f03aa56e9446cb503847c17223a69eef1a8b77eec61e27bad191a816ac9c3d3c31deffec0b56b73a488b9a9883deff70293153ac7002f55205e8d20303d6cc14a72e2b441fd42e382c63ae02e45b022eaec6a6a6ad9f926774ef3e99a0266f9383210f10e67e295c4246ce3e3773614503c61ca4772326604baba3a8979d7465f688d3cb3bb2f7208bf8a8c1eb12ca97142e90f032dbc31417849dea80546186605432b5e8a648c0ad6ca7246b89eba157552ef7cee6db07e14a4ddc2821b089dc2568362db7f268bf377ed6c45184b89ee0f37982c262c92603d73776e186b7199c0d8acce9f272fb152975e4ecdaea792830ee3f532a42f8b8f0f3560ef15e0913d9e52f5072410c0d7a99dddf339d935d44a91e8c93f78a3b4426670aaa980131cb00408834bc9dd15cc051a53cef19b946a19e096a20cd6e2e2ee4c4804df114fd685c08370f89c0f74f20f04cae0f149cf8a7789fd1b89c64a2bbe6c410739d9df22a76f3fb96fe17df04719b062251a046585ea06e64a608f182fba99235b30ed2c0fc798e494f3741c60300cd5985ad371be3f1b7887f2a605008a9184d28e055b7a0c06ae21aef434b5a09b6989ef08658aa3f91be9b1121c81b22f5ed6d018ae383c5e3fc2154f67ad843326745873180ff4557f8134e0e580130d8ca13b702f8355adebea32d327425e5dc8731fc85f79dfdba76e0d0c8d7c412beba23b0273d5c87ea03fada74d2d450cf54b123c3007fa53b9bc3861c2213de4744851d20f7272da26052d2ca5479811b65e51737b767ed005dd1e5414ccd557aed5c114ca80d8f1d53f69dfb6556c5da7596cbb4866ae6e1468af0be4a324cda1ff9648ebea2c22c3f54ee451bbc89ce24d63ac38aff8ac131f6e4c8428f31cfbddaacb387a47b386d90dff00b22dc7c5ae79358e5eaa99edcb27c9ddbf4a08e79d9ad4edf364597d9e3b20e03a0b7b37e008b62fcfd37d40cb6caae70a4ede6cd46de4bf962a5452d576dadb1d3cd2c4e5956347f20bd6fdf659c6ff77ad8a3114756705d0f0d2d991e4464cdb20eec0536a0270816186f5e51d756512ded3f8063a1eee3999ccb51b8a96c3f05febec3e4fc60e4576db8319e7b04d590e4d894a8bba6736d2971e75eb6038e59a954161682abd5decfed7873b98ebd4148f770fb753dfb515a909cf7ea3c9ce8d906f4109e4348e7f0546be0c5d905367e6f41f6df1d3ecd991a17e96895169beb3085d0745bed4c8783d748813dacf4808b066ea1c5cb5bd87605125a7d1a251aa4ffd8e297321dcafe9e1707dbeba235c9dc2eb6cd5429bc73530ec117467fb79eed9a7609fd4a31489c6c0b9d55501851118714f14104ba81f81fd9c2efa2fdcf6607bf6b9b346c8fc2793c93281a9fd8f365802f04e60ca2ab2a4b1bfb7993e7ba707140384f4f8404bff919e522de706ed1cc45302963c093bc2cf68940723dfb0d5aca9c15d1257e80df18f2f044fd0cb2617e3901bf8f08a36261d9e3b2818a291b6e28cc5af7cf45b4d913dafeec16972c652084900391b2efc258bf64dae0033958b535180186715de927a0dd16650d178e8234e16c8899dbdc96614456c08029dd5882a54a4409908d01c9654740bf0858646d4314baa6c53a7bd2ebec6b7c069bf31fd3f54db7c672108e94ae003bc64699f71a2ec14a3362e6d7a0dc464c8e39af0aec50cc59a5e4ddbaa911330041baadf917925f3f1e729d711076fdb9e00cbd6b8335c5cdc78ff5f5e36a1b317a36655160a7dda45d4cced209790581d67d946bf16b4b55ba5d1fa9b7ea0e031e1a83863fda6040fb1d8b83796bb00e60f070e19182257690e26d00956f41bf46be24d81c4bcab5ceda85ff8895d6e6fc43d82467c291548df60cc0383d3009549fa1dd742b7f96d0059bb70a099b3990fd48fe1e21927a2a2d9859d03cb1d269ad70e143a2f98d64f68b3f952d3caadcc82166c1d7fff5f939d8cd8833bbfa9411eb5117e659399596dcf309cb554f9de757b81a02a5143bba453753c102c4bda8bf2dc2c851d4ff00e79524935ea4212da9c7221aadc69d17e065068f4a9ffc964202cf054f0e4cf7351fcc1cf36e617589b1034a264e3b98aea701f0f20d03232313e00e1e1dcdf14c2a496da4556656a9e874934d74c2f7f7397ded7d6ff554b0a6c333e00ce79f2158d37ffcd04338eb7ab9a2a4bb493b2e7a5f09061719ff611aef54d2ea0f7fdcb2d76532cf764ef0d12b3bffa88b2fdd9bd8b07df28c6adeb4d0c98ae0994dc7fdad9ba7182f014222beb31c321eaab42071cc9237e5c5bc75120d1b365d4bd75622c02018b78740d23f588e3f63cb3c6a8051e51d3dd98597f7d1b123294d77e139b62a45cf65a96d2f2200596301d50f6d8c9a3eb981e3134ee59b45a18af9c80d8ed2ffea2fbee13a4f29febb9de3c8b901792eb60e1e2e3e8452f86a2144a00cd01f17e79ce1e2f5e1eadfda69f827ed7ceb8b6cd8001be075ee75f28d482c7ca402570999c919f22e1e534d4c1463c95af6b7eb492793f37e110d5f5435b30d89c80620334a186b728469bb19afced33ba62ae23a833d4bf34100c7c8a87b6592fd0a7e91cbdab881042c1a33aa83fb92270f0ca6beb009deece64328a72c5aab62aae7c1697935e41165e5681d28255d6caa740e42662bbc80cc6986d376b4052c55433eddc1c39afd0c0f2a7eb939475d4dd26f3834c7fe7672ac15c86d104374227cb100daffd568b68440541cec791c050d68d0c9c0d36651d8abbf4141e0be0ebf8e02081fca67a12c0fc6a043a61e7f44fb69c746cdeddfdbdb4ad504d881f17f96dbcc94a3856408de84559b7240e41dc066b83c2154e6deccfc40b60c4c8f3cfb21d549010558bd2c63040447644bd03022b9f8010803aa37624a1585428a48e664e48f8c725c8180ebe305b575b29b8108aad087d069e0a6f358f1ab65da7c06e524272384cde3e79fb6811f495a8f7ffafaf9637312f07907011d3cbb60b53bdfdae02b37eaabd42f5a783d1491fdf6153520a23670c46e71f54c15ca802baef5828a5f76e49fbb52a5f0bd16826b36846c69cec4e8c495d9277cf543384e63e53355346b5875716e3dda1340cdc6139cc145b5d5fcd357f5c782b9147687b03ffc67f18458c5cf8a00039f31e3986671fb8be06336af95175f9c3966b2381c4e12d292f7424eba6e60ba46a82066ac9451afc29c5b567c0b34ff50410376cffb52cbb46199f9aaf37d76d0d3e568fbe02685a85054362f1ded35558842d25422f57f533309637357a7e9421cc68eb16394d549e31d86c88b860a17a40e3d7e4ee73938172283ced4b2a44c5c9bf12c3f44dbeede6ceda84b8a9fbe36c043c1293b3806773b148d5629f5315df3bd62b211ec8226827f256710a202445ccb64babeca53c44ed719c23311cdd7f918dc03afff8d13c3312397c65e9882594a8077fb1b3f387c0c1d9101f0610a6255ad84479ee8a17f5d27984e6521809b08fbb7662aa975f6e7c28c36784e2eee2b81bb027d36de00e259925e61ef05ca7e0757aca970fd1a5632f69ac080d4dac9238731e2a72ff520a9d4d93d9839abc6924403699a8622ad48f5bf0e82b2c6765835f37b3d1bbc26c6d1b3fb9d78302bc1feecaeaf55b58ee71f50373dee276557dab44994415856f800c4ce27e7eee274716377392525535ff6fc29b94c1264cda8bd7802601e9add58bb25b91b3d7e54346e3ca2df894014c2ef98018a08734654329f809d8ce8eb56a6657244988c4c440383a8911575a1b878e7bc7c3b9e8d9718a53a3a2c55529e17531d1b7668ca5f156d88ff4cc5c666fb9999f3c6cbbd7c2f9e46e76fca8a94f360530212269bf17fcf66e7402d9684689f97f5518b275a7426182ead9ab0f1eb8824d2ed6a60024b3a249ac902d44733da6ea7a33514d7968ef39ca3de197fe8fdfe514f75aa7cb7f1735d21df5f620016aa2ee145d9001e689fddf4483edb6ec5fce19374c9b73b7dbf2349b949ed7ea1a16dbb288199aaff05a7d71d635b489cb56fb83f22c282baa1b18a4744979842d1b1a096c593919ee78e17e40010eefc66ed093552fce6ff1cc05ef5af38525e42d07a6fcc660b8f147248da6179d1bc16a40093123778f404ea359b383fea02c4719375baeb96b09c3307195d976157046d627fac698a800089dbcc82711b6c91478098d45894d058812860f1b9f83110a3d43ee758b42bd980c65f9547c4466b0ac1fb31c2c13a854310393ecf609e7d74feeff091def9a9382844ba4fed9efd6b1edc34aa92a6a9dd95faffeff9d24bab308c60bd18f09d754fd815c2a94d5f9aa471640cbb3da1e2db9fe5856bb602a2b0f6d85d985b7fcae234527918bd3d6fddf9907097c13fb8b2a221bb77e93a853267611aada7db7ff05310211c323aa945da39d982c5dbda3555fbf5eea44d0d6d54ab40f06acd1033f84d7ca6f2c45c62acd4f1892a58b8cd38ca5d4f335ddd261693ab3db7000f3cce617124a06df66abdc58e652f8bde8e6f0f329b0294263e57e76cf3995c45f87db0aef06406ae7b8a106cb7c29eb5560ed8045c4b6317032ff20e5784b79644a17d54d6fe4f81c8357293d1cdc374e98343118a67c5c1c002b8e6de8dfd0cd57f42ecfa321e85a6f74018f24c80887692ae3efaec95beaf8b9ed5c79e3fa908fb5c3031be40df27bf54d7102a7066d87e20994377730ed01d7aec255935a53bc49d3e80649a566caf44aa110167fdb61a48c45b177f0b20669125235c1cdb89e321b5b733f83a14968c23c27b172f918679996c25594836e8edf0564865027c7bc8f18e85acdc4eaa4c2d8f4a58fba47a781b7708e05748659b374379f6248a6566523d8de794b5a053dfac9a0d66b6838f3e3dce9e4ebf428c5af3ce1b8f67874cdd5c1df45c98f8859bc14ee00e8fd4d30fadd6db7b110a48f0e3df22e229768f6d773f9716bc321911315890979e1baee2ce57e20d62897a987046013d759d90c7a760abb8360cdcd8941f75afa3881b86e64d4251ccdd1d5b647e78817aa5e8d8caa61ef6b10cf1d4d9bb6b6cbba8b00e589ee928365db49cae2d4c4e5ba5a5956c0970b51fa1898efead169f4190737814fe10e34325e4d5dc02b7c66f6e3e516b6075805c0445d2dbef41bec367f79e00cbde391f28726ae97eb54ff9a703332d60545b4ea804eed3da0ba98680384eee9f7a6305646a38dec7112412a0da31c817da17b7c33fc6e7302c8e1040c50beb0cf9230ef54e7e2198017132c59d60d65f0f4c3b6d1dc40806595481537accf2bed74904318564a127d7904346c7eb198755aa8294d8d15f7703e0927c03881e0a1e6a1da1e68c9ed1a9f417ceee16d2f42f42a674f51ff60a8930c34548d99fa668d16ef6b68cdeafc12111ca75f293f5fc4eb8caea8db724d9a24ecbde8f3446b57f990cb85a6c51cc7648520ef6e782bf02387d580d4b6d8a5157f90a2c7ef73c4801152ef6fea91eb6bc91fd117e041c3a0a03fc591477aaea4db8e43008a4eacc7f838bce6ed602b295ee966d1c5693658d7fc10db39ac3f45e0b1148f2802de54e192fbfb344259b62f6b729a9c0d3b0758f529502dbf235047edf82d5061371f93c93630d9052af6dbc646d3e32c68b38a3a6bb8033a0bfe17cce7eb3f7c688258e7d05cc1cff065b52c0d6ab2e8efa63a39fe4b56b368b09173d757794db5b30c4c2504c7d0f77c6764a56de1606f564131fe1c609749b370b560c2cebbc2aead85a4260ce35a327926108968c182abce55f6bcc0be310afd9bbc9b1592f466085efcbf5069ac69e8a12d8207b92ea56d381eea9f17b966f113175a27cc7c8f9e0b3eab29277e9f1d866340d84052469bfe8337eecf05b842977179c10a131b99539c93b00f9035c0be2df8089beb9f24359927326a00210bb7c78475306766fa1d8274d772a6e1667807e9656195c6b1465f9dbd1be850e8623304d761a64f31f656ebf0c250442cffd71c1012666e0cf189ef5c8b2f20bafd27df524c62d4f915c949f08aec841afe0be4d9316f9fdcb39e4a3164b1151b4ecbe995ea2e8176698361f8996dfbb4f96a0429ca2c583ce284c47171add8d6b1c5d57a5089f3248aefb93f046e8967c9481b0e446d4c017251c35cc9c719b707909a775c05bf3655141c4b1e04b1a6e6751815cd00f0cd939b7a9af125d39b38577f070144b363d5e3255acfc774b054956acc8d5864e4e9b01cb39489d18bf7d342e545b4aca257cb4f322936f62baeb2d7ff4bc73560353000043a165ad22ff69505e33372aecd6c0e6f01f24f648c9ed9dc8022454d8569de52ef8e261ca3670a1660c3f7dd662afb6d1d1fe0b1fa86b4bfc1aacde4bfd215f00352a8516b9e01248096eeff87d0fad57793ebc2cde16682f84f3af8f28a7386b8acf7684b7d10a87b460dc4cbfeab4a6916f0442ed1aefce969d5b7bc18e758a492b88bb58118b4d4b5f4d7655cbf1625fc734457730885791468fbbf717c5e4acb0352e46b1dc15601494ffa4a1f954e6f5cbaad821a97baa475ff66e79bc3a314cd64ad66c9cf88d7bb9d7a22e8c3d54aa957556e7475a04f7c48892086becdc32c0634ef1c3b62079ffdd78498196798b77ccaa1a6ce669c427b97a9e25233aee38f23f979ab41624e11a5bc4ee2af94396a965104380038b56f1dc6f0ead8087d5e8a8d09a394175e80b9bb7a4ef3f78ed2adaa96ab3e9d95244d8c5c092b6f99e57225a15bd3f1c90d8a3da7767b61034f088aa751c7b7a03b0137bb55b3069d84674fed7463d8fbf909b8766a609cc80c29f8d080cf797f6b36aec524157972f97884105629c5c10c531692951d5d42e0e0973f0d985d0887b0a5514e40d615a46300a20e3221be65951311f68c9e9f5a350104a042e58194fd86143f9fe68377fcc8423bbf0d15059b41fdff027be779f7d7abf2750f52a0b18606be2e049ff01a857cb44dd029b573de7d30d020872bd10553abb78c1cad6621c9685b19b06674a2502514268557227f4adee579e06318be2665b81a2de8013c3ea6009b7ec56c0c39f7a4ca4263345b99e4d54de399b995c073ab40be7158825a4c92386c4ce40325b7c43102fc5ef8b0a0ad488b64f997b0294e7c8de817882d2f4c929878f3f24c78a3553b0fb76308e97f7bf4307f83c81562fbdedd5715f4f4976c7fbe87d20db024b4251cc0efc50bc061ece64c89ad9cad23286937fcd16f998701d1c500359157b960d15aeaa4fdbffac7c1e88d09d1706b6a56b4d9b3636f255a24639a9f81641f77ca85e9b099645674ec990c95fc4df7a63c882b707bb6ea101e5c85d53a7b2562c44c77113452965f0d09dd12285caf83c92413f06956c00ff1b62fb66d889699b66c20ba1d241710f4f9b681defeed80c44b50f35e9f0403faa9280c9477e065fcd3b396f5872a435cc18c39d0e46640e60d56bbc44f23174c87184bedb43112e0f2c1c20ca31dff6b6394a72ea946587262e4dcdb900025f94a95227149a219b005f28add434d842634d5ee87ebeefb9641392ec7256c58b34876ab968703a55756ed8d2ad005062667c58b2cb0c0b1e1ebeeca6f6eb6cc32ed8d3174be799a9012378d727629b7711376ce9b20144caf1e02c73ba169ff33a6c044261d498aafea1cc2a8fd840a6890f4256551887b1dadba66b2f537744d95fb6c527d505f3b1c18027828d08147d7f36c3ab6e27afbcae3d7ca4e191e7b4c954ed294ad214267f77819ceb11d3883927e7a8098e596b46fe3e0ce3b91a38f665dbaeff6c3e79c0974e6fabd69f51b6faf9712957ec37406cf73bc4a3d0347904e5f298bb585700bba7831904f09d55136a0802bfc5b57cbee6caf60ce6583d684999a7dfc6a729ff35990abaace4818b5eea7311a16ec37e152a595df3c3194809046c96cc6f24b4688271bc83db3831c14b1ec305c4e0fc5ff8595549dafb4b2896e2762a47e936d7dbfcf50e841bc5bbb6165db1997ff669d5732a1e970ff4c3e47f4baefbb7dc6cc313e7698147c842a431df809e8f94a6225de4f5f56fb405b330e5251e642b932825b032eb12bb9c4d44ca24e3b0b2d99264e4ffb65e305f3c2c1760d81aefdaa7c87f68c03a1f5898ce3c7c3cd7ff6754d3c440e771060b2b03aa81487d469a5f9cac3371a8e3bd5f7909f2ad5a6ce40d53e6b30bab3a14d44a496ab46504c239f23c7abcc7f91bd8eee2e4424785a77395147e7208318a3c90ed7e49e3d54ac08a79d62afa3ed6788d55a77a661ef124f1a4e9f536aea7e077c50827e2cd035fa365ab0c024e886efab13089bfddb3b57538e46fb39d75e20addeddf8801c45135a6c8a27b9e4433422843e292bb614634b90bb547daf53eac6e445b0284d98c8605dea77e3e5c4948a5da8710216b650b6ba536b0be328f6261737c8298ffa670db4ff9f9e7af92e37218e579c977c1f419af7fe2294cd8474a1d5b37c80d2dd9b3a9576e3bd2c5946793f085c54631dfd3325657b7eb7499b49e7dd0bcf103ab401cd200e15c04c83826e1c94f994086190931a7712255dbaea6be122a126982d6bfd46aa2b841527fb6ddb30066b024b21ecfbf7f961324a7b6414342a22d8d89d6ce2c7dfd1f710b3d3c6da70933cebdb6ee1f4120f8fded64bf201ed53e8e066a99eb4727c24ceff3fa014c202b82f8c347629de87acb28fa69e0253c3caac370f0e72c7d9aaaa6eb89385d2db550ecd782a43fb8d8a705bcb5bf8979420a7d404e32d87cfb78ae6618f4791e82b963f22f1c49ca712b62934788413e1fb741d6e70139bc84775ccb35a31ceb10a5b4f69bd413187c9ca175de29420417e6ebd9c4acc18e39218af091fa835473c49aa103f100b4ddae076be07c91ec4fe68606543c22c1f06cdc283cbe487a0e542aa92c479255b034aa4c547b7a14d572268000dfad4609ff5cbd0f04bbf050f72a7f3a92e5fd0c97b16e88d0c726b84dc875e4b3747fa49b57971b49fea74a2c60fa47cbe2cf914e79e72ba547eb7046ec2c8784294acf9c48b62c276584103f4cebbe9586fc23294813fcc82eeb80a905a21904ed36705d0b0e36108468d6881fd16809863ea7e7d47b289233d5a8a78ddfbf959895780e4e9d20c080a56514fd5f3c6d58b58528ea3d95b246663aeca59e8c81b068064490602c6ea57275507967eb296ec6cb9cb73255e625e2942ef4d178e41873daa717a8c9d4361be695b57e5ead1610538fae20cf151ef08fe115a1a9693b5308f516374b69a224d18e68ca75d8aca55ee4e2d9b381a6c90e282223e71574b5953e34bd3a25bea40c6f2cce7ac8b6d62888d43126c3ee08c166b839f0b8b93eae78473b9580c01ac6a85986c51339e20e1605ec064b7ba68f9e6661ef782d25f57c3b26a27ffb428618182fd46f01d88e0ca33aede8b06088302407e7046e0f6d2c0c4d543683dc7e2c2e152afa8839283672598df7a01962ca19b9fca8535cb8d7fd25ed7bb145d29e37d549a1d7901c5eee42e337bf7b306e54cda2cf3ab6c127b67dcc20215bafeb010863464faa4d8507fd0bb46105de0888a7b3238b06c74041eb34432d2506d99085355df30ec217b54a4a4739be2c6e5219ea7c91105dbe53f322459fd3b09733fe0c61bd1f604828698f49df9998b6b232dfdab4a56f88225911bf6061bd30198e664fce8ff889e3f69e3fac87c38cd0b9bc9371316356c751b0c139cbef7f90761e3e56c6f46d974c48f6de1e2c2a0cb614e521cbc24f4cd886c096fbfb2416d33f2fdf62131d68f40c23acddea8c5ba58ab3e239a13b7ddf88ca0a07e332478442a9026a4e31badd39ed1e0a128d2481a50b6f8e7162702d3b114b75a8a643fc07be1d83dd7e46856278e188614c5c2838784596d5ec339f899583e335ba66aed2c07d6b88d6711f1d6b996488eea203edfc349baad2d206e4df147f1bbc5b4d6038240599a9f1138d87a0d4332aef37401fff3a706187426af06897397dc77e57962e10139cd57da1209304b2379dbc368db27658b378a1f1467119ad650ff919232b0525470f7703e2e079bcaf7829abbcb0556fce90ae41fc858c036d36371f3b31e6aa301ea2b65d01b76cb790595852408873670f6fc2781adaedd9f76324c8cec98ef31aac31b7c680499b6569385dd5d28292b0249d966169ba14575425b4b2365c0e50761e2aa3861a5e7214a6644f366c33018d81e7bd682f396b372d3f48f33d53487e14bdbe4b9c2775752ed3c8734c595fee582bb20af4964f7327cb52e2916ec8bea5567b2d9342142227960c7837ec5da2a22a5e26876e0c4e1629e26d59ed74dbb522f0097f9f3da878941f267e0322837260d8c263652f23cbae00c04ad6ec3270e118a2c88cf328647b23ed7dceb494c2429ff20328cf7e9f512df92308809e37ec343f3b57cfec1fa11022c13b449b2db9efe22be1777f35b482ebc8d0e27fb944b9ff92d3ae8204915fa58b102378d93a0a04060cdf75e9d444f28a8dcb00c07ada93782ef216e4fe0780c45f38173adeb7bcad91b2b0bd959308d4e59b2a120ff7dd016ff9aa4735550d9e67c35fd7d36a6ef1dbd3416c3e07c755619a3ca30fd41ff281450f802203e5d641725edbc053f72ca8e2b0860f24590066b5fe750675271d66ae5636adc1379c5a8425485a47d348eed0ba251ab619cbd9792d54fad736481b8493918bad759f700a28eb2a4e853b74a95f4ed5ed192dccaf69300873cd7ca56989b389f4a34406d4244c0f40c902a6c9bc6a7a4edcb06246d1a088fcf4e4084e2770f3a45c69fb74d34c039f8fd5ef6b36679461a18474d9b41c234416257eba4833012efc39e5fb3e63ed8710b3783c9b27894d9fdada1e6370bd66957174999110429a53b4ee6b10f206f5b78532fe6b6a4f9e69b84182b97c310ef3cdd88eaa15cd18a94dbc642ec163b5b27f543bfef708de63c7d607692b720e572563893db01e96ea2d96a8238e2ded4ecffdd19e72a4430ae84ada6a3d65a3646fa30c78a2b1c7594a667f7e579dae5f5f7447f3ce99280070e8ad806770f3c32531832ceb1b9410f463524f66b4c85c9e9050540baa72f0e4825afaa977590e4fe4747d4f6bc839963df9a75645fb2a7661ef0aa63d593625de81ea1b3e5a70fa6f9150b845067efbf17e1fdfc0192abef6edf7cbcb866e86ec3c4fe5e8e73b59259f52135536a774c36d2112ffc8e30bc7164f27a6183c120e825d585795c3fc4ee1019cb449f23c7ab62e9883b7e46ffa0f8d0e4bf6190e3c7c55b24551c4f47219d7dfac504f648deb156f55ae602c0edc10d660bab3f43aaccbf8c7ffc31e7802c250193c71707d00bbe937833131c816467a1c55f0c233654c67e452661bd136cfb1a79b8b2184d53fab4dab16b74ddfc747f26330a55abfed55ccd22a2a60135dd07d42b3230ae2f6ca5246f0084258e05153255944a8dd9dc3da0333185ae91f38668ab44cfa1873daf4be11910d9d648cb3aa827b22586e16251ea5bb4267ed79b94ce46cb5545d1e3b1d2bf02401e5e2f40451e98a4b8c4517d41e5f1fa0b928e8529274ee9f8ba25df1558dd34aa37e3b7b024778305b9368c22ec0850ca5171c02af72411224198a7494a94ca104a9c6783dbdf7bc29c2e0e982d243963839049dc6d2257a07b8b2fad7a8108eb81774fcd6298e5ae4d1839cc5e009b1a30d379e0991a8393441b1dcb47a38da7a6e8ecd47c9daf63cbe4a1345a8d7c33eb12368dbe310d40a37213f68191e3b49a5d06e5dbf31276b2ab4bd6f141729443058a0317c7032694989a695991e76f9fd1cb54b65406dcf8f0844d487a36b8fda6cb8bc77516f719a2727126dc47d67c41774191bd2aaf6eecde39285b5d1be30814b21ae75953fc5f7232a05cd5b2379a6bf7bde190e0b22052a209cbf3295e91f9046d6716b689b953138ed7f9277fee165c90ca8faae5f7222515fba1a1ebb488e52e1408505f2bd493ccb7e47f8e0981ae92c04d36ecb357d8c166d7c535d4c7799475b1820ecec1f4c34afd4cc749b1c03e94cb7ad1efc80ba88677e5494c0b1b854e690f5f581fe1e40f749791ee76d20e3181e92490e8fe931a5f758240892474cdd54d80ab86d4992d3d1ba8d34deced90fd5394536a3229cde7e29b9b7736a771873b48001eba641b37abfeeb13d438445908e7fd840815aabb9b257e08986fa467f396b1b8a1704d9d1206e1ae528b780a788cd2473286fbbf8b60c19632e3bc8eb01b4011ceddee101a6ca6f6d240a52687ddd92f647c03ab91758139d5c0a05e339795e9278ecb51f85e8ca0a1437f2164ee9d23651e013df13f1a5b3e66103caa78ef82da2542c63e51f76487a1b2eb71369f43eb04a9c9789c5c8bd19d0163feeffc7d22efe37b93635bc8792d23a557cbe02241d538c84bae01f479bb797e54721477ecb51f5751e00f5b5836e3ee424d36193b3886123206e206a93873ba142e11221b748081bc4d5c41294c379f39d6145679e723b184b22a386c68c5e26763b37a380213b18ad9ac5a0c6587f3df53afcff4646311a779eab5e759f93f50b4fecf20b3a9def09b0a35be1f408d4084bce758b9805cc56b56c830ed66efed66bc5263c445a33a00437ad542f2055803c013c4f5838d15fb1dc950d893b737a3ca004b8876b3313aadc3a9f32e311cedee409526f8a483f2a724de799163d1fdb1cf1a33ba394d84fa28082dc51c6e20d07e97a2932d86f0b3c9d7ca7a7eb5c38156382283b8b752a79106ee05279f4f1820e5ee34ef98ea50e3f5390b448904856746e4f881313a710d7955f985dea466a5077c78f4e8e245f739c537d7866d5740259527692e85bb0fc897cc88a3e828e3def169e0e7507f0655b34f7f8c46bc6e74047ff9bfb2d6162ab7f3a0064c793c8c42cc177cf1a1bb7a6e2da552a4280cf6470072f692461883635815d5b1bf96d66a6366af69f9f67acb9a132b221568c89e1f01a061f779d17fa76c037115156a3299fc3bd5f0afa9e58372b9cd31f0e6ba1a73f7e9331ab080a48c59a1f8bfe93804d069d6e75c04d7b83e0e0a00ac131464b9e9b251acc6133510f068a74aa6bc66a7688e4fc6fa24293c68096baf4be987e863b6b1f58ee963c33d31dce73bda3f785f4b2530c13899bc71254533b77d3ce12b950aeb68bc3a53e0ae8a1a4e0414248124dceaa29d7f888c8c0921dd93a4b9fc7be0805f4922ec79e8e6cf333af75d495f8f8b3857992b4a3fc25f5dc65ea4d661819a5e7fc0975763301a208758a4a871ea2bbffa5c2ca6e1862be97d7eb82544de419b23e6df6ca4e8934cccbd39df31c83dbc0e37c757f6d6544622b1f924ff611832e4b1847338bb191bc9d40de8342dcdb358ac2df68e1a72ddac66027a6022f52619c7ce70643e4173a49edb89f9b904d5acd1f77493ada4748547af1334788aa02aa6871f0984235ecd116c14c7a81a2f998a3b52ae3ba26108f2d8b1c354f6c0e927f4741580ff5799a65279692d9f97c8c5a57ea39dcd93623c84081207bc5873f1abe3cb7d7dc94e66ed35c8d9c5753aa03ddf62136a78504a863a8708963af86605a14b949d3ac8a211cab80bcaa4ee6de8c895dc50eacee5300006742d0c4bbeec0811e5e210493abc5bb36679ab26e4aa66664db4e6ec060cf8e7fa79848bf8ec1fc9cb0219ba845fb3f23219f6190e0cc55c083c1177aa4e42b06463fc9dcb938f43382506a8e7532b9a147adb40155e63379273197331d09e49abf42deeb685674ec5ca09d66987cc2eadb367049ed17d7265c92db1a750d95b928b36053a5e5b7f85d77c4892e6c2e5373868ba2f8e7368cb4514eee3775e2c4d026a995f5e7c34a9250aa9211d219c7ae1cb9a184d58ffdaaeffdba706c0f8885b2a5767feea51eb901350aaa8425111bbf34b0cb150a96f1c2003c1f1d3767ee7d94840fbfeaea142f58ae26bd57c5240b2fa5499c45bf4050c94dcf2e78513a41ced509db4402dbe381947c2b2ab45faf8550409d797f4850abb22666328398cd5baeb57c55364aa5ecf445ae7ba7bd8aa04e18b77a5674259510c5652cfadeb40113c7525b42060dab621a1a519f0c284355b0228380c29b25b1379a42961ef72bcfee58afc0dd43473478aa2141c257d07b38b2fb845c7cf391075e931684840949858fbbcf7caf1c126a81189da3671f0376928e3f1e0b2f51169ee7fd1ade3d0d687fb2227768ca3600809b49f1b28de5e6564b221a2d09cf6a0a42a3ab43f2d6cccecdd396e2815a5cb2fc726532fa8553b390805dcfbfc78bb6982d888d39d324ec279882f3071f837297a8c1c5fdf6e5982696d748b4c904fa193754c99687c9e9de7eab99b8e124f6db429ceeb287c48c077a784dbc9c11e573f27c5130efb947edaf6332ff1957930bc194502cd38a68e608f03c5af8e1ae102e229c9a0b6872f047d2bd6e344c303e4ae2a4fb86dfe78a3c184e4c0e92d7ce9c47b2adf8b4b8b1164c3fe5e6f09fb37ec794fb58e3b34fc3b96fdc8692c0debae1e4e12ea2bdaba2390bf4a246c6f8d1f9312806991db600d65ca79b1d1660f73a4ae0494c79c7a64e6b188c910cd9b1325e548459940ce3354e27c6ae81e3b819d30c4fdcc65a4fc8cc44b29f399ed145964f1845a9937fbdda6ba1b31a0dcd2f48e44fc30a0e790dab2ca4df58cf439d30519aa7676bd0c98b96135c70df05e17b38f0e21559fd934abb2cf9f34866a56a424d1de355e9f0dd858dbee0b6a166e6da2510628cdb5af632b14abf4faec64820e68592e41d975fd6b4bc9821a19b94cadd2efcc749fe7bf4e310b0946af33c1f7a8b377eba6c318ef3d1f63d53e6c9c74d2331d68df59a23f0d36d64898bac7f035185273cad949e5c46e2d3357724d695089dcf8e475602aa2ab685c9ec8f36ab602fb89b0208da0adb24b368c4e5d2453d3313a9240ac600d716ab9e1e3abea7018a90b61dddfcc4609329e54b88121ed1df13d7c495f62dd2c478a18f4ce10bd8b51b1008fb323d01ef784752a3a862b5b359cd63bc00a5257842e21244797ddaca1a53c2eb6601600815edad91bb19e3c2d581cd9b7dde1006344ee543e1bbdc5ec2086136aa726ea662574fc2e8269962a91d7b31b7fdcafd79bf3bba6dfd4f41659f360b76e518600e570f086840492bd2f8a3867a4af4565baca97d54382979b56bb1773aff70d7f1244482dbaca4960d049be539f1cb30c97908d49d1a7bccb1ec24c3b3f378be7bc0ad123934c942851002068911fd91ce44e9a763cf7347052cc12bdba2b625b61413bfb0f857f13448763478ce621e39626c0575cba6e38e0bec976c9e3e1a85f2cd4ddd6a0452a1474a4baff42883df149838c756a1d1144ddc139d6ab0dc79a342a6adb61288103f346427b7884a935f6100fe19667d6bdcd1142889cea1cbcea0ef611828f93d1964305850110f060a2c24474d7669cfddbe1d612279a63741a8f6671a07cd09ce31fd3df9ae7058d4a91291eaaface86268e980aa6cefd707d0ec2e49db7271f3b7d05124c311de82e666b2931834f113e88bae030443ec66866789e136c06fc32e3fb558e8ad2a7ee021309315bdcef454c157159b555698aa31fcbfe1d7421b06269912ebf31ad76860f681987188c6658967d3aa8c25e67f15a0b4b9cff2ea4e69a45c4e0bb0e24d4a22310b51242bb305d0ab2f5f76551e405d383ae204431cd3f760cd9d83c53d01c93ffd1ec41aeeef4c06453aac484e185f957bd5c00087aecaa736ed6afdd651c1a467e70367035230d6f4ca28f061b5f7a1a05c24ed0c0ca7ee7ddcd3196240f5b6ed74b4dd21bfcd6128e9b87cd52f263eb24f53e2248aba2106a22d0a24fcadb6e434713978608284d2378ef65967249850002212b5475716f2f074ee4b11ff01f83dd62d7c11ba2ff57cadfa7b93d9b563a47ff96fcdf4bff8935319689fdf1a08a6a0c2bbcb9f48c6ee3606ac20fc7c3644e862ec0bdaea82a66b90eeef8a7b0ada0e23185396d19a9a4f31a0f0c2af5f4cb96cb65cc84a079e3f3369d726d70c63fcdddafd55d8ff39af226d33d0df0761ad812bbe75b8947383bedc4a90ebc4e5c39f6be5b2c31775df9c098dff5f017bd9c82d9b9e5eff172db14897fefa7ad6bbffab83ce2c9660177d202234ea719e54df1bcb08163530d37d829d768ec67f3439b5069a4b546208b94bbc353d9d65ab425885fd823e5cfe2278dae56d1f8d837e56f27cd9be87e5743434ec4ece4a34e174020d22f85d4ca4ce42f89d712155d3e4aff9fb875dea09b32393f33efa02ee1858c89ee3188f8583426bfaf453ca53e40bbe913807939b5dd0a7c87b26bf43cc71d8851cf44a0f102d8fbb605630c8f15e087fef7698e6aa78697339c069f060a34bf24a1d65a23c4786ac3e3e422ebb3cb6f81b570294713a306eb2cd378d58fd391d30271f706a82fa0ed123eda7378328f2e50bfc3f513a5ca28198adb1010f13c55056c2afc04f8a3571f0ab41a82472287c74e9e6157b31890726cfd570b7512aa43648ed4a8cc9d7119d603febf2ba6072967702a011e5c447acc711e3336e3cd037930ba10c02cbcc3e1a3e318ab33880a83d94e0eca10170528f58f2fd49d0b2ce2bfdacce87d030f328eb86d837de2719e0554fbb2bad7baafbf66d57f1d49e70ea9a1e5c49279d77c5d4abda4189268866ae36e600267b19e2f7c09038f058587923cb0cafb9ab6403b5f9b9e8c738dc7edc745aa74b64db950c6f652b95b0de7326f09d02bd1aea314939f6ae4e6a230e24f63dac8b8bc6dc5bff923459e93d532117cc8c63c0e26eea85e07d63cfbc6e1505b8275087aae9e618a6e8945780a92c290499faa5c69720e459052002691efb4b433d1d515c7778f8a2fdd5a11482bdd579a494eedbbbfc67be75131cbe477ee7ff29a89fa1b2bcc8de4c7655a2c721dfe91576cdd6e1650fec2ffe70","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1d460795c5824b127ef91adbd2ab1239"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
