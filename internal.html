<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e3cdf2cbac5a91c11b1d0db5f773677dc7df136be58ba879ff8772d703d1b934058dd0187c194cd7d311e0216ce775d5825769e0c91c5bc4c2227c14e00b94a146c1b94f2ac85c84f79cb30ad72a773a676d310aa0d85143ad01677d2d61694f5daa7756648f107b84a906f8c7905c14d3c73bbeec68310971cc64c4d1122ad60425c490b0ca3ba8e1a8f5a845f61d6b8f4b12e54e81927edc39bedbc9c3fb4f397036971bf7ab2d95f164154eb3fdb21516081858aa10f757995b9fa693eae59081e5cceb1f7b4c3b4083d0017b6416b5ac9055d8d9fd500be11db20f2f9714214f12afa605e8e14dba3f1e9300c4f3756ecc986c4dbbf6c3d6e8b7e76e4bb80b70dd27c1f28c5e6ddac0bc632e5e5e9555eecec004d4bc0ef6a56f89ad517a2bb7890099f962a5be81d87bf30a4bfcfd6e78f05fb2f6845358361919285e780c43e9e4979a7f321e6fe6e4334cfe7434f8b67dd81c9bc1fb88443af03ecaea0b2b90249dc652cb369f45fc086358805d802f46282bb6d3802253395daaecca82ad1b16b12172da9966f78c0ad985a4ac5f31622fa3a31737a05f3e0e7cdc84ca9114dcd24f05696ba83f6be29c097c4dc7bec32ec85319f468fe13580fab874cfd3bf65cafab1e27771dfd128644cec4ef74e9522f7113fedb507551647c27d6c99ea1eacb052d41a54ad30079ec45bba12054d4dc45a420a89808203d5419727f67a089b2e1f865a6f5147c747007e1cb3af9ec462a01e46680b24ee8921675465ab616b80646785c3e26e9eb40e7e95ba0008b86ce059a32aac7d2d160828f2038cc3378c194b2df493d8b1bd9dbf596d4013d33a1b28c75d55f6c27e57db277d27e89c458c68e198b33038c3a149b2e00f61fc649aabc022046e024f0aa6a32abc0fa8a53bd852e7f8137ef58fb0b3ca3cd938e58841db54a4f84b8aaecfd2b9e26a822c5ed981d80d383f6c5f75a5664800e5eda3c3a83df6d16ccf0f7791a8da299c89adcf51f921a854c1ca14dd600caa4b9f14109320d4d5cc2dbcaaeb2c32941222c256f0b112e681cd2185fc2bdae0f4828f55087dceacd5e0cd72ceaf7e68cbee35feb3adfb9dcaa6eb6e1f3c5d18876117c94f45347e507517b1b360fa236217ed11544c9c9693f193741d735f19c0a3615e63b268b4a41f966f1a824d0eaeef15b11fcd05994e9f77c235b5f05354798e9cd676fe17af0fa50190e4bc89f9e8e06efa4cfe2ba890180436a2873c39f044c9acbd653223d4d0cd9a1e3c14250a646f95724b5b48cee9e60b4899805841a9dfb86bba2943d826578367b77f3a37f77b06e1165167660a437cf6e6b9533a0b6873dfca3c60cc47a391c291bf1ad4e96b2b32e4d4029f07c94f6f73b9b4a24e6a577b9ae040a3684306eec0ca8a9e94668f59fd5cdeb5f29f1079228d55b5a8401ac128cdb8ac2255c9282a5abff8962927e887d21e6db2bcf25cce79f68acda202598bcd21f648de42df448bf5914a2c565a9286c3aa3badf75f4270be3cad712f4a616bc68552f25205ec8560fb6e4fd7db77f475f3b69883779068fcf0b4f88dfff1c8d4bc1046a47c137f0d0276d5ff24077aeeb072f9eacbe6ae5922351fafd6900836cbb9739b17d67e8831f155545d78581c498476abe693018cbf783b75e88a2b422d917311a22854d0654b0f3d2a53d412c91f6f264f724e7f121851dbb0538adcf21abd3361db294d2ed02a3ba60a43c1bf227c1193d54fe41801736101d9cac559de249bc870efe6ad972ffbd1d6aa0d22d04012631cca132de921ff4ed44c83a6799fa99c6832f70c96541fa95165e1ff6578abd41c2134e12a6c761a53a5b09a2b8cde808a5c2d159415b6fdb17d167bde756f1067261c3e8b5eafdc1fe6eb87c2dbca41844ba7806056fbb89197adec73265cf8be2079016df5ca11426ca473e3219159cc29b6c54dacb3e846a23a4fd3572c3cf83332ef853478a73a304344ec6904a1780a0f2828c8213834c91fcaa7186f8a962120f044bdefd739e47e817bda30fc2b18c7560dfe4f94d90d9c821de62b342b4940249313b18ccae1256cc28ea59b110b8a4264e3a8084cdbb2de9f6ccec4d7371cb5fdda4b9915970378accadbfceb4adef19eb9a70be29e15f1fbb841f1b8effee75a30476d96eb2a2ec9134aec700948321ae9352cc11ef404074289257284881f418933bb3c6d2ee4bcfa97b0afde130fc3608f3860bde3f7641ebf8e61c6f4f98b7a682180be8d851ddabe9f7c6fac9966e8d2f0bcf59ae00cfa0e0c06b027a29ace35c5b4d3a170c3251a74b6b7b4af180720e85468aa0e72d263fa2a8bbdbdf4e5868fe27f9613d181c9be8c16317b239a126c63122159cfc8d27f368cb6dc4f1c8672b867029c2405d9972551ae58cf0bdb31fb1543edf0c958d169f2208f4879d00e4e353864dd22b7576e36e8a165f84826a13960e65d152f59a561e43a5aa4af01b94850224f3bedf7eb66df9d2aabd25fb5833bba72c0ae7aa41e326ae1d0c49d828c25e7e525f067420a63db537a5330cde290d4b5d3c9b69a9ab3ca58efccb447cadbc2de4b7640d66381703bbafc1d1bef0c19c25a2d43168a1702be8da1cdba176b26e63b98c7dce78eb3a291c749471f5c756d5170797c86b42e375f6abd9988dc413d41ee7cb1fcd410c1a71973bbc3bed6bdbca03842c987c59e9d29572095337b05fea1d483b01e4a19dfc1c05019a018f5cd89ea2188c8e6581297ef123c29e83a8a5c8c7ec5c1ddf08b6c11901285035639ef11f5edcd75194387a5ee669868e8731bf6df3af0086131887f7ca66dfb26df09521ddd676055b27f31fff8b25f6c27436443d1f4b740ad8ecaba6a0389c2a8ca3fbd6d81f13fc0fdd8a06381fa20c6fa8f51383eba74cacb6f9d69167fdb2219d963a24d314e98e00966abe8311f1168c23e62a63b63eb1a40ecafd0805c891f07460fbfd7e61fea6ee2573d182dc4f123686b06f89971627a1bbe2b059af1bce85686c427023afde93f6dcb2bfa465ccd5d387488482de11f5d50fdd0da4bd44acaa6c38d9c7b689953142538526763fa74a003c573f879a6284390750716e258ce3e7d2bf36dc6f37b379e4ddc2dab561075329dbcbdbce2ea7fdefd4791e13e78765b74a0204183e5fcf31cbad570de28bebb7e34ee3508592c4109ca59f896768e47cd051c1dec3066baf32cbeb07c95593f150e72a235b8e8f9d3e38d79429c6b5994cf128c9bdfa4760ac4602cab44049cb5f28199f1b870e0b8c76beb1a5c17182f3fbc8f39842ff6400533e28a78dd54420b35dc1d728cddc5d6e7cb7e2011edda5844496ae77ebdf3b1978267f570f22084f33d3a03a49fc71c1cdf68a4210c44d75e0fced01344141451ef1aad3fc32199f203b513d9803e76df96b623457ccb44b1ee24d19f4bb6156d3744eb9029c0219fae1e23b0eed60d25473b9010f8a0b18af559ce1d78f1e86f1bf074fe17c1dd20cc37a6bf0fb09ea2f08b6ce5f1f6bcc4917752cb9187e3c12d92bf9df903846aa826d1e707a30c10d214cb407ff8c521dab1ba8864168667c2b03ba17c7445ba0f2d065ab633a6fb81673292eb0ad6d5194fb57bcc8624a6e8466af887dfdb58d5f861e8472f49159858ac7ccc41aa1b4d27a64ccf95170388183f23bc3e45c94e71ff00a7f304794cbf24a8aa8992125471c984a31fd91b407972c1c8f7f97c75d65d21d8364d38432d7e85999986b2db6b40ce7c69acee8856471bb0dd9ab62d28df7bd6195c60b0e017f78f3f4ef9066c1853affec2fd1aaf255b76858ce24184d835cf712d7218977d9af33d1eccd13767d1e1d6d64dc793e65ac7ea9009430ea18f23f2317bf2728fdcd76b6ead0e1e0656e4d0abb701a4fab5689930eeb93e16cc8fd881892dfdb119a3988eb7c25fbb1d07121571d60e63411914311dd9df2b9ee4ebf1d84f35ae941eeb5171a3601dcd4f32f91819c45e761dca900cdb36a5b9cbd33de8e00ff8e82c31f5904d358d7bd2f4a37938938b316445408634e6483c07fb6cd36ca520fa94322e61871807b6dc9881f744e44671eb614df4fc01622fdeacd6baad80765a122dd6ff30f6c97e6de4c3a3dcf7b59e224c82c8b7931c7b3690be71f5188b467ecc9031cefa95c370000ba021014079568f4f2de386db443e3dac6da48012df4a7fcd889726794cf8d5fdc3803a4bd5b1870bcb1355253d749f4a986210b0f1e68c02c44414cd8c9520de2d94a28b0f78dc6da6033ca4e4942149d55068bb4b3ea2fd19fe29f0bc6682ff518c8e15cb8ddc1a2b1b2b1db9698e69901fb1b1caeb6f0f19410baf4c1a3359dbcb0d60700632f448848087533a99421e5e8521f3b96fa2dfe9fe4447aacbccd8ea279f51e17ec5f886e76d0a1d2dba5699d8940c4b5cc5a33ebc73b51f135aba3f20c545a785006dcb8f9e93a58b0ba915067cb339df7d4407a2815bc11db3301735f0d8b35386d5dbddd74b902993addeda959aeb77672985a202887eff61e607e42f42e499b8817ac7de99302f6811c68fc3a2b11dd256ae419bd035f786ac9237b8bd388f4b15f92dfadaf558b21ece943e86eda954e275a789fb8a7200d5789039264c58f40e5dee8dcfb8a210e232c2480593f9a872aa259d4042dc1cced7002fa8de3f5352aa0d032b3cd9e0ddf2df267d06d7aa2b7e6613638e20440a5e65456b2e793c7d3367eda3bce4fa061cf1e54a6278a710ae9cbddbb726fc8e00381df943fa0176160ca5905a05fbc81472b5a81c0faa67ab929019bb317000b63330c9168992e2397f19d7fd84992d09c0de000cc30bc32dba8e42d177d27a80427f0d497245203308cb7f1b60c1335474acc1382cbd67e326893c19a98924ca0807cebb3d09a4703b60e85d6de9e87122d672dc3ea84fc2b7a283c37a21f0adcd5ea62f379893c69adffc0f22f25845ad7725c3e2eeddfd4c6b7657dd3a96373c1919812b463f87a9b6f3a2d08781149a4156913b475c80e47805d265f8d2fe4f3634e67f12a9f18160f48826b5bdf9b5cd7869fc260df21dc5e4997468d269b163615ab88b6fd6c5850a48b15e62afe4d38ef4b7009afd3c16f3dd4336b714b4269dbe329c614001694ecc3f9deb31be59293cd779f87af6dd9deeecbf6dace4a71599e7cfc335c1d51b7effff49b86c823e0e24acae1b7eb7f8152b7bc41a0179bb7407636017965b7fb7b6a6f1e9999aea406bd056ae97ea18940bfa7c3efcc0eb4ccc86b50f08b55e45666391c577a330dee5d2d1dbcea96e4d55edb77fa62260acacf7e95be640d954924eed49915d4a3b6c5d4076897a66e2804c7462665b639ab7ff04ebe535a861f41abb88934a7be4e5b13fc646124bb878651d9c6d0b1f2742fb78bacaff035318327c6f49c1d8c5a83efcbc7b0a457c1f80041d96906e8d06c717df514e9973cd84007e776d025e9db9df94f9937d4bef6112bacc177f01aaa63abe0dd5d1e5d5c52572929f1806afc61aed84f6965b5f4039826a28cc034958f34446c6ff12a999e82d849db2992937f827519163d9231fa9f929b6dc1c306d65dcb4477956279ef3748ffcce1b11872d54f92566195629407467ef7b507cdbe2e613cda8d98b0bc46c5e4502526e18ea35a710c21dcd0e0e10510d411fe12aa68dd27330672d1865f12c536ccce6cea5850874e8f8a31bb89445c3ad28617a6d42ac069d77346d9bc4fc63e9415637819e8ed505a21d1d2a18d1bb1db3b02955588a9ee921c6a9c463164e053d383fb534ded42d7c1181eb973134f89b34c03f91041cefdccd0152786ac561adcd7891dbd512028e70c34113b5c9563d01ca4fa5089d85b68565e1a2b1fb318c0809b22bdb1a5b988e4b27445528c57d471d35729b7dcb439aae3b3fd3cc76f8a89da6b1aad6fcba5845739455b2c702931e8bdef9ed67208c69d90947fc20f8530cd265e5492e19fa866650e3acccb09726753d3246d51e0a2a00f27c7a5bdb745aed1e8ff4d85dfcbdc97f961f63c4236845dbf819a3c2937466fc64e1003924f9749c6d9bc70f68dee7860076c453f20fd19ece0957c224ba94550414e451addb5f24a5b870db2942db56d92542eab7be13a7afe851353f76274ed872aa63eb53f560ebc0162094effe6f37dca31ebb630f6f927a2a6ecaa080769cfc2dc886daa367113f40fe9d361b916730a83cc163ab4957b42489d9239231c99e4158de327dca5c3faaf5bfe246a0139d3b33753179482e7fa4bdcae6a519611b670bc45f63605c42cef9b3d8e8e692ee9ceef95f7aaa0e75fc1d5a299061de629a766892078cb612b209d184e2cd31ca59eefb25c6486f82b26323991613e1cb7d53dad46c45431b2e4b854200793e3773e865acbb6a9068d9aacff68742c41b57c3b94545f481109246f561582df6d7f8c0ac7bdaa64b92b01a86e9d447fd68925e22627cf977b7b5fb42773a37a5f9d59eba529ff597f6b5e347d9bcf77838b784afdac0f881e3fa9a5973a4749c11feb63ea27cabf6f01419f6f125ec7aa6ccaf3dca2ef2feac5e2ee52f06362d11e25d530a8172673a4ef815965c5161d6b7450e4b9a7cd033bd3eb0510f2382900b7d4c269d648eb9b45293c4740f46b1d7c5d88e45f8306c29f85df7f68c53915137a4ff2ef7134e9c2cf9a2bf832d76b3b291da931f136f9f87662c54d377417bf9f74d3a16244d0797c1dcccc6a13342e976eeaf317cc0c117a9c12d304a964b3066733bcc0c1ebbbbd83c04c0b834fa8b977c80913a4720d82026f024a431e14f15bf6f97def8e2c072e3ddfaa3719b9ff0917e6cbfdd4541e16664c5f1afcc9bbbf6312a9cb671f66694fed8a6eaf8b323e2107bc7ab3432efe7f44225eb1cabe03bf058a2e0826708b298c0eab546e926493a430d795167ed1fd3aa19a148cc13bfc0bd07599f1918095ffd60d776cbecb29d459b2b598c5ab4d9624d07cd3dfe8cd66597f4d93cbff8bbe3a25986dd48d4bf2d81f00975a375b22cda70178b94ff4e88d6996cf5904f2ada5c856a93c9a9cd832a1c0f2eafc44a1a977ced482e4eaab5a6675b20e13fb7dd7e586d2ad50fc4a9c367f37ccacbc184f09e34ba439c11e5cd2909f489cd735f84a2dc2e4458de486e08d3b05ba430663c567ee543faefde18349de24261494dbbe580bde4b5108dbed90f3ed8ee36a6f66d16e7884778d9e4bd8ad3d67a2a417219768460d6020d20421c3fa6b8d29c8d7aefebb4b7fcbc91a64ca28e9362a9d6bf1fa71bb8f106ea9199f74102fe3318b98469307c562a6afeeb84a1c48db2d4aa2abda0b2cc3e5a4a223d8673d4ab03ec831bfa33c628f62dacf613d1a4de06474280330253eb9a4da9ca62c7e4393479c2ad4dc58dbbc64186d1c492f8b00e1dcbc6a214166dbc6e8b71b2dae93676acd41f2fdbe66873eb5be4c3b1e41c110fac7a72074bb0e8cf9ae1f9ee3d7fe7437387b49f6e944398f734aebfdd5934a43c2b0d301a04f5446f050a97af54f63350d183b2e511c0abb0dd41284d2986745a7b38903e2f47111d414b7a38678b21cb17d832f9db9adb0df679ef11ef20ecf0929b0c55cd85dcfa66bc3bb162b7aa77411424cab03bf01fd8ae462e865b7ea9daa94050ec5feb638cb0e207ff0abb747872d6c461ec666bd4925ec9429f18b6b8e3b61f9bdd301ddda4ed400539b7e7176438c36d292a4f438ee06a29b04735f2a26852841deabe34ccae902501edae9c579f61ae0b9621f875f799d255a2fdaa9457339627468961af615ae2aed444429ce453f2bb3c7a7a26aa6eff224e20ba5e3c1dcb9340202c765a39fb297c059f7df915298e1fcf828b63899b7c31eb7c0206ac8da1e6f86e22c5b20323928d7dcccf13b96d047237ede3d36717a3dd81dc55953a5de57efbfbabea71cdc465c6d73254aa4ddfe9f3f38ebc0a59c66337dc7e189e8fe55656a33ce0eb9324619d1032363000dbe91156539e1c11a961aef9c6fe4aa85c509d39c6843e4abc7f9e80971acd70457ca6064a11f1757599a6dd6a8b68501d1b737ddf3aca25f1afe5ce81ba453f5a39ea7cc368c51f6f392448f7365d1f18d85375ecddfdd7dacff31bf29d59ed78704ea211c7000cf0acd84d4a4f8522a039a38abce3abf683a282d38cdb1d9a0e2d2653c23ebe65cbe5e694786bac5871ff8b669dfc37b8c8288e99516106c050139b24842a22036574ca99f9cc9e815986087c713a0a5c2795c94a2972ae759173234df58f9c26185fa74dbad82597f09189787085d46c68ef268a0ab92460b8bb7ec438a13b832c6d267e444223d0e08bed5697b298ebb8290f270578e3eaaf729bf8d27ecdab0b906ae81a96b1ebaf34c7669e4a9b8f0561dab9c38fe1f1b3c026c3a1ffec0030f509888b5877ef6afa583082f1fe26db151c8abed7e572e5b5f9b55f146014f869d28c7c110ebcac96d130815266cdcd0132702642ad4c03af455e173e05b5a9cb46702b2cf0603a84cf74e7b263fc71d2d7ed437a533ef55214a2556925a0120ed12bd023f7fdd2eb8fbf3a161844ddacbc51dbb7b8c83394aec94ef6e7a008e8c040601ae1f7c163e257ec20fd43e0cb9b007bec5f1b71d48b68aa72c4cc1f16c953d3c7f3e1bc153af376859af48115bc860cf9d0b7b76e4c9210296452c3ad22cd991c902e0e635bcc737ca3f2959ada2388109609bf3b42806f08d8b41e464faea278fe53d51b5dbbe224c9dc231eb3a1d1e2087b9ae940064c2de30315e0d48aa267512f95aa0a94e453b68361c537317cd99cd4b936382991fadb49e492a5bcdb42a5af7d3a8d6f566a0093e83d6a7fb2b5df8f88b5af451b0625c669d6b41db5cc231d7b0bb3008740d45857acde17092521b3f48f16434b22da9444dfe6f94fd4a2fc88fff3925636c785168bb1a12ca01cbc4f6c7d0fd190392ec4229615ee6633c0916cc4e39944a2fec4cb926676e6fc883b22bf59cb5b782305ae9b3d58a38d5beaaef733fb1d2cf6a2147bad28d56f19c2a4624ade566b1b1203d82764b41c64d1f88b6db898a8243ed26f070b4c9bc2fbd7bd7ac720e5af434f7b9502ac7c82852b921ab811c3ea77b87888b7c0a1a44fc7fd7dc1c2425d112f905be1d80832190ba4e72b953ccbcdb16e52b96953728c829a58aadc9214fbd7bcb99afcf2d4cf26488e7e04fee4da2a4249c9a372c805269f90c9b11aeda31be11e175a39b80649a63927caa41f96032f8781aa3fac0cd5e758e7b44e1ad83c77c4cb7d67192e87aa439a8c9b00df186c70c7a65bb35ab2f49bb5cc8daf5b74b9479b1b11aba56ab9b44b4515f7b38f6f94ca4f0f0b8d847f811ac850fd47f18cc01981fa7312068d02109551a89ba88ee2813eb9e0ba94ed114f7b6179815032262685bda9cd8df3b8bfa3c141e102c8094defdb65c1513785dee6d2cec8cdd8f4d02066395f782ada5a30687b54d60ff7fe6314a836c6a4638a920b06613c0bd75f3d6b4294d13fcc6b09592e5111b4f18932fa5658902137b84ea110e04783b1e340e2e47fa2daaf86dbe4fabd112a1304455fddf0c9e0d4d5a865c9730b03eda4f5a92171f03033b0f97b9cc06c1ad6b05d163371c0f44fe30f80755b3448f34adb129bf7817a4ef74a62cf08809964767d4e2c7f1d904048c557cc8f4a3842c643f6daf6f5b7d2f61d23dc421e6f6b202c0ee78b1dda76097c0a7e03136b1b8e6fbaee3807694644af1002a8c037e3b9e5d2b63a5fbdae4018dab062c52e32208c86b9527b831b6b7cf2dc2c46efcb728b00aa5b3aea713b70c5eba168490271a8bf4ac24eaf112dd785bd8ce0a4bfa08c260bdbd1545562f5209d622401cfa5be18ad1e482dd370e827a0bc08cb84d80049d10944fa2b9c55320ba1fe2f2c87f61c56f1d625e3f59a07d6b8ff0250faad79b4e5a76a54db0c64dd1d5873d38300817a6230138e6ef9118044471b690eeba4b50cf39c54ffe4313cfedff343dba5bce7f4b6014d27e17c480203bec99943ff6ea9218f19dec0ed4ee4d0708cc7f68f1bab7f39449ae35b4a8b787d2ae8fbd3dbc6ab57e1bd0a11fba16d4203b5fbd7f936ae88fbe09b2da9de5b8d84716f7e60231971c81056ad135fbdd33fe6a2d500a244747fbcf718c58f4709fd4ba22a79c3a8b5958d45a5c121ec84a6a5867b459b0e1e9166a5a903c5db3f5bf18beda5937457ee9419c7ec406b6aeeb1b2d10693304f15a06bc3a74cb2e2b7889ae1319d0b1d1bda5d5c11738f3f4d7722c47a9799bd6cdca2e0c4bd7c2e891acb28809f5e870303fc2ffede979ea128c78ae5d0359e30658899596661a1638a5bf4809ce720043721ae7d3ace571d3484db088c52d2aec448bda6cde0c08da07aae8c2ffc3fde6b05a971fcfb130bf890a26432b9596bc4648dd07b3cc5eee3d6e99e5f5b23f3e1e3d2c02dfdcf490cda7febefeb4e41cfe39128294aed717e597f79fb47eb669cf056e74eef00a1d3c5f14a009f74b7ecbc655b6e8aff57f79406e03e52a0e04201ad3e18bdee790586671596f031825018d8f7d2e33e8723357ad0af2b52bf49c2435666036e69cec7f6826bc62c498e61da82d349d8b37ffc433312178123d2cf36c47267a45d963edf84121f6aaebaf330f55bded25d174d7c043f548f83054dc21521c5f5c5409de5cc0c5e5731ced8091e2aa3cd6b32d45c332c24c7f66d1942448a46b4c901c259405a42cbbfacd422a8f875d5aa979d45542b64d5ea22a1ce33353f8b138f0b1d5d99098bd3214cf81161f836c8430658de972f2ba90d81b09b80cfcdfc23dbe350acd80d850a1c7bb5ec94a551673d440bc10a13cfee218e8dc7648c9f11e5c69fc712cea42ef86e28fd1650a4257b655710509413bfadb17b10ed2330cd189fb9e2aec29c5b143c72bc2bd4169da946e3b2d153a53b2472f135b65ec033d6fbeb2551b4f6280cb6660e49a23cd0b52408e55752c460d35f0224bb23ef80e552be83a5341102f799b3697cc2fbb9491eb74cf9e6e352d67eae72e8e1fbfe9dd8712b5eb0137b1c8b104555e63f68b72854e2dc5d54111d3127f42867b04300e63e6250e56251dbee922ec55fca51a4e8925671f13822c9bb6e9376daadc03db03d975ab2f7f1cb2cb296e97d2fdbf299a7f1b6408b33cab919e98e0cda178ea90cc52f18e218be0b026bb3955f73c26a5bf567f8ee4721e229884cc4e3f912cb06a773354fa8fe421e3fc29779d1c9cb34da35ca81b6d958870617188a4bdd6ac7e48707415e1c3a0a14379bc602d742c096b78ef3d354d5999cd8aebcc1198c76ef79bf3f9d4d6bb41d0120fe3a00069f0399980b5b21187a1eba5319f313e5d0c72a314553b0a590bdae5d27a75fe4731a4e80969af2f5227d8c8dcaa5f9136a1e597a0e98c7bc8e1360e498d3dfbfb83ac2feeea38fef50a74084034649dfd8d6b64f1dacb1ec8c31e5bb1a97a20653e351aee25f1cca90c5991cfceaed6f7100ed43954f975ab67cfaf85544d60cd003df1886cecf90d8f5af115ba62fb601c9c46f998426d887a23320a40fb2f406298d2d154057a472f349f2163911775b6d567cdd2ffd5b5b5414deb0609df28fc89bdcc9da19361ce9ef803a8fa67581fbab40e742dd7a79c8f2947475f3ee5b377b1ff31e467dd9c2a170c9659d6cbb742dbcd7d28fcafe73217d433e3a99e4c8eb11bdffd3e5f05415d66a448b4e5ad548c10abb9c73ef2e47561a025d90a40fa7f0a78a8eb5267a2486627ada40a7118e2561fce7969fd99aaff9a77c0f0415061eea32e950cae41807cece41b2630629f1dc7a3f7568b48b004e9ce91dbcd05e672abd90abeed3aadecb3c8476440f87599ccbf52384efe395899eb479bea171db20ed62e03574b6aa305db0a2c955a252dcb91b1d20929ade2c8989e91facfb8c6ddf1ed088caff560f406858b2d8456f90c492c70cc96bf8ccd42801a29e17b24be74453f7dcb0920d9b2868b5fca294211312fccfffeaeb05ce71441d00fe16488c862a5e48cdbc0e7cfcf074ca5f8a84cbd09f501e720ce2b64e7fcc1f222ff7fcec77308b37e30a5e342846303549f91ef2a6e4a692d95fc57bf89092bb651bc6e1a5a9341b98f3ece7ecb6e9eea27a2e71a3648c23a2f59dedea71507e18fbe60245b6f32f89f662c36c2fce51314462faaec3fa703ec622801af2ce8c86621277bd29b2534a95a801384a6dc9f6c74bb5ee1001aff14e8353bc3b6ee71649cc2eebaded34d9488d3cc759b424dd8829ad02f74f53d5a855ad539d8c85f4713188d4b4682561e0d3d50cff336d204db8456fe38769e97378348cf020c4170d7c793f27e0020a40431085a9d905141f3599e4bb64cc413cd7896279d20db5586798b9eda4768c2f3aa3feda01d11abc7680a828c779a61a8b4212f63d87f8de37d5e735f7e6af1f3dc55a350a50def330ce399005e048428a58734b86e35e6b5c05bf76fb2887b503c21f01b0d374df7dce0d7bbcfb804303cdf22678e3c9fc069d6a542d60b3509dcbb3df6e181c4d2fa5b27e79f93f969f770d9345dd5ee4307857d64eee4fcaaf45efd8b45a668bf3be3dc6eb2dc3baed6a6b9dfb8c1b9ea0b448d37e7f9f91392ba666b4e230a2b82b4ba052d5585ded13610c28dd6acefc19a75ba43c4cd2531afbca4a86ddd73a51b8de5fbe3e0df258b38a03ec9c894319219f36099f6bb200a4a1676c6f0693855ee3e81ba85237bd38c1a5b7532b5a5e995a04252cdeaae7ca21b5e4ed903a7851ffd1dcc89bd09cc5fb55aeb0d0e29c443cc3e7cc71605978708f0cacdaa704bb71d2d7aa53f5a8c4c043eb39d6577bd145e6a1b94bf5d140bd8538d38e919bde7787543c4cf09eba138baa280d862666a962ecbc08715aa35357e33f079f05f8162ab9608192e2ec04b4017c8964e5268c3a0317cd95ec5f43efffdf5b7bce351bdc6d81537246f8f2d0ec0308d3a8d4fe6763e2d2872e2343755664d545c2f856ff146f6fe2422d772cbd07564acaade979b00870c502d882109ece6ec207cd8966f5ba930f2a814351ab73d2f08a7ccf91a12bafc8e5bca0859843ad9c6c2760513c1599f5a2e38cd774ac7600456913acb123b9c4c3767e9b4ff2ebccb04ed537b9819d6b1b817a5f412e509e96ccf3ab15f444f40f2e9b7b17ead206417354181a97965437c39902fc11327e87209505d48b2d9d497e135cae769deefdc014333280a83a6758ee06cfcbeef8cc64b1ff89e201fa5449092eaa7d0bcb8e688c997e51567d7387fde113731eef097c0844f6f625acf2b9a83957bfdc1ba25f910d14b54814c2362fbb0cdf21d88f75609d36a0d6772f323df81d38330471d9ab5001e2ea28e88fb787dae4e7a7db484cd9d9e2dd0f6901bfb36e71d58f244c83ed206595a0a6ccaffe4e42af24182da2b640a5dd24db49872f2f20ff3e01989915cc0867c33d50ba52bc446cd22b2cc42e0e49ca2d879af5c5af00de2b597639243a38b0dcc9f598433dcb23ca5d53655e33cf97bff84e2fd85569e325493d0cef3b18ae32c9385182e64097a523ed8d50c0cd1b98b9f42650c9d9e7407cbd09d0109640e66a009d34c491a8798ec3b4a4f8647badde717153f461f6e805f768c7dc1e53b1b7329139c1992462db5e7b957e1568bb10a29314e4cfb110b8dd5a3d39cdd49ea478a2b288b4e09d52d23a73518b5dc1f158a9c0a42d71ae2a7b91a0ab98c6f254480fa49a7b5b101c15b869afb700f8974f81db6893725f3eb14a48bda05054060aeebdc67297ebf5929535c5934cb075472ed7907c4771edccef2caec5cad8182ec0cc400f885047de4569c11204fc79ad464858b5863b7e5f2c350dbad4224fddb0251d733759a2ea5f7ee3f9552801041d355b191e576c650915ff8861c5e72708b046c4fd858c0297816cb04167f45f13ba7ab930bcbf0062f19f7c2f199d8755162bf0224891f94f220979f414fb3c45cd7c2b7b5ea0fea9291013968f6b3d2ef0b70bf4f29f7377808ace47d70176afedf526b15ea788d50086487ea3e8269c6dfd4fb3c05e038da09bc0499cb53cc7d99734460d96b060b13da04edbb0c4f560931828f397eec2f70ee09367deb4145eeb92b7ac48eef59fa2cbcfcb55187409dad0039b877ed290440e68895dbe1cabbd9f01abb2a05624951861e26d9a3af7f407fca221ec2839976951dad06d2bff65b59729c19cba19ace3cc9609ec8ea53557dd21ef8a5434ed1998bf3aead7e0bc19267c2f84fa7881278fd670a92215333775e782150f14ccb35324be1fda9418f9221787aac2d7eed7fb62c22112faa1c6bf35bc5e3107f2959192259eda5f1dffcebfaf63a6841c9109a12b6fa9ca36ec04a15b1632ae44e0754872ded84c77cd1a453ee7df3a7b2028f80e7b439077bd0d3b79630bf5371400bbd670c14e5a6819242c57054e8f82a2a3de388bef78728743932555137db694e0ea9daddb50b6aed64be298257be3864c782738034e28cc917bc92035e0ddc3650efacd0200a8984636eea75e8e317e4deeedabd8c85cd0eff8159e00aee17a8b45ea734c512ff979a0f584635b9a6f437801d779ee70a539510737f64f2c54b529df4cd83e6fd75fb7871e87ccb80cc61d846250a8a399dccf64e9a9c6dae81e4eaf162ea43b1b05f9a188078ec4173c0e6525afc54961949749256b1db9f914b29c96bfc14d7478f1892050ac56d717ff14c9b2bccee1211c891426ad49de2e634028b09279a9153c2c103e13a06a931a4bd033fe13c0791a214e1069c6afa052a02401d3927476d541aaf1be715f06b32599f9056c0c1cd8eb8210c96e06e541a2e595fa16c0c58e8642915d0e7803739a043a68273715729991c89f716fea069e9272d0ccc25690f5ccebbb578e23376462341cd8bb88283ca9dde3f7149da140f3783d1418a0c72dc31fcf276473433622e8414e65f174399aa1bedcc4d305374e9ed6b1c8c104cf02be1e1fdfccf23cfe6aa4463c4802b90a0104cf7ff9fbbab7fb842acf366da272c11786ba041d7bd34b6f6e61e4593274fd3c3dad39fc0c6af2d3fe4e2a2a40320795a141d0de0e85045dbe9f5a92ea90d3a4a1dd785b3ea701db2bdd23dc7a3b134aaae1ce0e54661f360ff0aa37f71ecfeb50035eafa59c6b8b0ba314edea6a2eed981c0636a9f6db1ecf294ededc330147dce36977b5673048a4f4de549e3be404898cd08e6757c61282be3a4602039b1fbf73f4b97dc610cd667a33010589a02a10d32d21e53a54879c138fdeb2ef3ce812e3b364357d69f9d18fc31fb9abeee56722abe667c4e4f584a4f911704ed876a2ef6ecf0b7988a8e1e5fae9280ed5c84a01d5900918d8ac4160b1b41ff04665fa47ec6b2283ed48a7d1678c79b1b2b08607314e993958e5fafb3e098364bacfa8d5cb942091f0464848d7bc5c3d3d646efb50c8394275e775cb3dc69ee59f4c160f85a29839570963e3f0d8aa67ca44b8831c819c1e961656f554529d3555d67479deb3501d17526b877b1976356485b95b2adcd644f5d906ce0feb79112cdb2a7e4b38427dbfaee6ca90959021a81dfcf682264116b7d3245ef63b7c6003ca89fba7beef1c0a9b8ae52383d748765959e85e523d1031f4d4bb5b8bde3ff9255cae1dd820a1118a41e72d40d49ca1df5ca4fd9ee100c58ea9fdfc2bdb44397ebc1c366588e401ae0363177d5c79846407fc9d8108bd0a9cc1b529902723413e6278741d54b18474ab5ac4cb55a2fd461b02d662d454c2874f9655c619e661664050f00cb7ca251afc8a1e784ed25f0063fad77266f0b67419045cc187184c8e77a9b66c1c5d6894b8cbd1a2b18cd6b6a5f7ae0573618914435e7b252b35abf94c16e470c950f7000f2fcdf8fbc99565ea8002f238290e160f3e58fc10aa84cf8942cc84755b1656072f35ecab0808bdbae78da89bd93b3fe64442c8b6aaf74f023a7bbc27e5d9b3363b196b41ed3e891a0b051868045a91b7ba3ecdb78fc970bb9973d4fd0481974ee9f4da4bd4ccaa76e132ccbd375cfa1e2986a1df3cf8d0082f8ba89869cb8024a778f9b9a34843c393329e025f7e7a534257bd1f8905ac3aec01a296202b642c47e2b09112aa75f69d0e8ed7be3766ded2b1f6b11ea1c40d59a1a77e2e42f889363966e95d372b368950ed406a091d115953cdaa81ea7450288c2b064724c008e9e2fed3eeed267da93b5dfad72b3f8996e8b9e1f4cad7dba8352a8e4d7386c7a895af58af754a6c810632b579e88dc9ee6b23e9a52511ce03837bff5c055c99bda3cf9460bd103bce7e198553e33c0ae32e845c638b389e7910cded56ffc19770608a15a75543a1ff8a96dce756916c47ab8256fc4105f6dbe855b9b08d3331f145eb6ea1c10adfab3c7abf764f04a2880576c28d46ddade2b9f916c88ef962e250833ae7123b30c91bce209281113fa111352f2fb7691c5466d259f84f6048dec0b2cd1fc5e84ff947dc38e00f4b2fa785092acae3e7396fe6b0b0f17cf03922a3ea552c4d8d9a3c0a20432a27e31b50ef20add535b95501066bda665321930e1d116a3c9a690e187489252f133dbc610e67fb84a2f7507e2c2850cbe658f3a09e8efcf5bb2b7ad70bd00fe88ed250cc825bf1f7e802cc17e0ade4d6b20020971852107218cd1f6da5d7bbf182a1bcadde3581abe64aad1c67a06b5a4c9e28bd0ffcabfa0b5ee1d32b777b04315f36ad1b2a6858e02f32cf4cd3cc34d39a5c9d787629806de2ce3dcb1ee3f6b14a632f98011f23b6db447b5338791dd006cec968ca8bc45eebf2c13c9915f5dc403ebc3bfa479b4f0960c6f271aea303b81df5f2ccb883ddf714b86d810efea872d2c8c43429f028d75b71ed059d6f5f3357ab4ed735d57eb13a3a368460990669656222011cf23f1881e4f48a9590297332cafd0dc2f4cb5b3077fbdc8c4b03beb1f74da0c6b7da81d58872f29b188730ab1d1c9903f90eb88976adf0ca6ab365ce87e87323def93abb13569b5f2f68d8b57603847a4b131815f980686c4f4b8ef3e72fb460af3e726b0af799cbab5fd635cda58da38d2231dc10eb53958365513f4c7205cc4d6845ae199aac03c6be3004fce5dd211c47bc8549db68a6f099fce82dba4a425f1fa680749c46622ca57bcce905ff0e75b4a46285ac465e5e3fea4ae8987dc776a93b44f07680d5e3c1059a657ef5ee0271a10f9144421c71f9445e098312b2d6e29c0655e2405f42ee21e8b215dfbe069d0fa5a3c0fd33f7ba561dd63cf6988a9debc61d8d7b9ff2fc58962ecfca86f2b1e9778639ea606de7dc5fe1624d23b8b0d57b9deb12d7d268d488a8df1c273db415a5774643c6c2eb8d8178b95268befaae2a13d23846d4c418362d1028eff27cfa6c81d82784d8c45d2b0a4c0973478ccd6ae205a9eb1dfa86f1ef3d0afcec9cd74253074c347bd0df34b65d5d6b42b9cd532ac0ba1e4f6f46fe99b7fa239e32b2fd089143e27f2269842dd0e019204e3138b6941f823f323ffbe262afee64c2a1183d08fbef4f6feb04057a190cce8316ae55031668141390adfa78a3fd797b7a6a1534e887a43a7acf3350dbe501870aa6546a17dac3b0376eb0b14fe249d99667803fbe0ff1b1bb471ac673ac8f32a1f176c3dfff78d999e5ef7bd8a8776944cb6021537da064a801fc4fbd02a57cf403be739d35b91b0361c0ab51e908367db29fb8c1a692c116f6320294e1c6a1b0556dfbbf3dc7d45bea792ca449e08c2a7b643f71015aac25b017d6ce6f6630513aa2c75f96cac403ce5d4d30cfe3b29efa1a3c0d1c790029f1f6f5e5df86efdad02b56d98f8648c34cecd550bfb6cc45fcb4e4ae5409c4c4f84f3af604e10ba8c7ffdf8cc556e2ea69ec12ca897594513506f356d62a6e20d07a02f97dc561849a7e611cdb3687f081e4a48bca18ab95b37661c66218800eae7f57d60b67540966476820c7a961ae47e16d039a3c179468fb289f1f7fa0e12656f238e500fcd3148a7e40a1999e24eee65a749fcc2a8a2eaf21ff4d2cbb5a585b4911b6c155cdca0997475b8428b6f6c8b0f35df06e736f33501010c37a5ec35b47be4aaba57ab3fcd9ad12c0c0af1e4d5962fc8d9cff7bcdc6da81f8b9e882e00a20de82b62f387febf6a6782636bc3043c86c1062ff1ef46dab34d8cbf23d0209d12dc8f2f91fcca6d0c6fc443c27131ec4691513cf3518b92b65751f5ca4f9c36db19aa1b6d7a151f69456c7a2de84642299ff1cd35d6bf74c6f0d91c616960363753d8883bdc9b6fdda61a7216b2eb1058fec8fc7eaef9f6058d7d5e88040cf1bad5085eb9aa6b48253394b6d29fa31ce7ce815eb1c5095f11d5d046fddcd3d95d432af078b33ffe1fc8bbe86e6d2ed172f2b659768f26b969894b0282e4bc9d8e702a6474f8e12f38cdb12162e643c5b1e8bd81ab4396d2b67a4ae69c933418ae8c7bd5f0018b749fdb4a802dd47734e93883ec466da1912078b3d83d01aa8f36a24ac759fe7f1ac5a05a3c50d4b25bbcc44a08df65d1eac79b8381e59312bab2e71769a9442a33c5e5c85e6797cb5ae860357862dba46bb4c7375ec5cd65347b5a9e0df04795db61cc16ff74c115b0623487d5de58a553f5d90f2f45cd8ec51e2d2797b16c268090021b326b009ff4fffc259bb1236dd37c3a68e7bc9122242470213431379eeecea3c5e50e1e151","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8fd3e9ee6034f56cf0da6bd88e14ab94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
