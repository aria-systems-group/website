<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e384a4e2427ab2ba4a248a10c4f41652ca6fac1436fc4644127295886ac294fe8689df5dcf633591817a4c67dc9a266f6eab1864ed12ba4df0db4b155207550cc13b79d139519e2ebafea3e94ca9aec6fbc2cb34ec1acf60e7604fadc2c79f5455071e1b8a19eb3f1fa47aa5de8e32657feb4c6bc8102567c07ec154e8b66f7ba39a740c8543d6b852a211f10c9c1f2da48ade6dd0e56d6617b3bf7c7e0f002b06f383b2a5bc617ed8a80e90b90f9c50e79a7c1805f2d6ac2156e6f7db1452b6f9cea016e2ef1f5c5e7fa5b9a96843bd716f23808d3083b9080767074bd0493f61d9a4b00cc95c1e42e51378c203f52b61f8cbd152134cfc20463b8019885a0104ab96a0e8a5fd38ecf26ff3adf5684f49a44387a264ea4c81ceb227c2dac60533ccf184bd05553b29ce34a8b3659520537afcd2c7479a95d1107a98468796971b8b0afd0fcd926a1a6d5e9c60bbe08b181f494a92bf98a8d281ad199bb95c3b9e248afbe8cc80c6ca81d6d5cdb3a035ac7f2d73bc688b29d1dc60224679fadf295def5899d4257c241195f073ab7c39cf1e2ef0a72661a26f0ac95c23143a9587dbf1d9d965b291b4868cb061022ac4a96ee2892839bdb6b177f9aa4c72b863dbb87acaf46d6169f93b732e236b1a292144a79c552d3b0108c43d593ce14264baae5f839dbc351a31756c4945fc3607f88d87979e8de5cfb60841f49961bf62b3e5b78fde7ca4a1fbfbbee2e149f43fd127f14eba3f843d9d9fcccb825e64656289e89da6cccd818583f8c5e0c087a557b36c4046b63f369a93eb04e869aad83a0e73cb03c919ee819c5fc29650061a6731ea8948101c85e1ce7644ee4f0ad76b23c4adbc58c64b2e8264b0558bcb127bae07e2fa38d0695ac5bc2b4bf81cf542d1ef115e92ec42d8cc29160abf73b1546163c07431f451c389a2345a264dd812b00cfa39137735b69a517e9e793359f24f3f930c15ce0b463f22df064bf30256417e5dc64849b4930a868346794fbeadf3321ee97f7ea77f7710e0523ed83dae4c59b4617ff3e75c667ddd2888abf4b50df62c0c78c75de250fa78f358943dc71f785e06b439cb895670359f8c3f6aa6261569908108de3e4cb95e1dfc8c9c318999c6644427e32d061822705df593dda5e94b0eadbf0d9e3ade002c6c380526de3e408b4a4a806b9b06d94973ac7697c713822b2c24dcd69f48ee54bfe9c86199297e6c95d52a79f34de071404bf0ad5e5138b9add5efde387edbcf274d7e626b60f7293a2bda30ae7eb55860ce5b7714ae5020997a88f354e042d0b5231ace51c4fe644a0952bfea684afc358787d5f76a44b7f62145cb620007e22847fce8e1c7aedf8d556447fb4a51e8937af2706833b58258c80c60ea1c19f383ef9a2245ba8f34c54c1c43d3d427c8f55bb1e9bcdf3b7ee86696259032dc21a0e696a3337d4eb1cdef0c89eb7654760f2109dbe46c5c155a9144fbaad28a0a80131a1338cc6cb4ab15a87d67d73f6eba9195bc7e0b0a55d79b9dad52876122b7ea92a8b075606eeb283ea34ffd04357ad412fa61bde2cfffc0517e894766144fa2a8e399e37c850bc02a902e50c4bddf007d7af7b746aadc1b6a9fc0bf7f20d3031c95e97ec6c6aa97e397f7e30bfc691e016cfb3c481ab1bf19a3c9182d8482d47edcf878ff7c5c0798a3f858831188f3cb89ab5165e5b8415daf58af7ee009ff6a88dcbe42dd304a7ac73029b605de6e73cee4e774bec6e016ff42a54197968815290db40d0b10ac81691b0c423145c5a6a22df8a2fe8f01ec9858ede2eb33671848d8a5adca565106384beea41805b1c088936fc459985e6fc127f9c9e7290ea01cc9e7a9d56ae50b4b47ffc3b60b791c4eef156a1c8213e6a14fae2bf03146981768a884f2713df4d20ba082478aeb0bec4c2f3a2892ea3da131f1eefcd861c26665e02dd657f4177183f7691d3764defedde54eb7d77ad3817190437864fc7753b495ddeaaa5d6fca1c9de62e7926a17ece92539331b9d47a86be622a3d4b5402d1c007311583ea36ffe763e47c5ff9b3cd2616eb3bcc972174ada82074958658487bf9e9397ae69412c5ed8b3bf9eb27b9580262e363b398c777e7a6203a2d462c889f22ea66b24f37d3870a2b15a2175e1ff581170ad6554e0128705e330912c96e5b2015e09c7beedfd765749716d116d075892d51e46e688b10e785d47e35760c25a67dd0922af221e9b568b4a9b6a0b6dacf4bdc6b521c8e9c653c544e03b58fe4c0e30a2734607123dc44f1ba700388a6e0427387df4cbf2903a910d680bdebccea07c881584dde8a41378c9dfc2e586ee5685b6244acc79471946c42e322993edd2fe4de2823275a0c7db5c48471e25953476a0bfb4df1c8e61b3e902bc17d6ee2a15a1193c54439e361b8a3b9b2d3bd12fc86480b2c5d9cc0af845aea3e961fb384df651a81bd8d5087ef81bd9ab55f1e2b831a27fff891ea052daff007bf1ed8275dbdac88c875433d55f840b54430680a1201ccb2dd89c3a0b0ce17a51bc18cf4dced9b879ca4e133a3fd90fe61e76c0480e75d42e65d06967d9c0f13f3be16bc4011e35a0e7392e1a8d1a2617fdc355cabe78be4f68ab865a3d046748c04a8fab15224cd5f91ff6583c0732e5e675b51b06749db38da6d63cc26e1176224a49a89c5c68cd906c932c89cc4204a4346910ac37a0d5ecdf2a0dfe6dcd1b1c57940d6d7cbe704be6c748724f798a6c11af1c3d7939bda97da6b7fb03922b73a6ad95a341802393b7ee84f83ab6e23627539a5b6ea8a9a1e2f35a20c83a338f97c7e32a7f7c5a22dca4fcb30d314af54048f3b5782e841a23449c815fd8d0173eeb976b21f120b89126ac081fbb8a581569f3ba4c28ad4108f64857b40fbcd0845c461db8eae102d8aad3c98940e71d8e52c1e792a0cf929ffaa3088f91827fd5a15b48e9bb1a70109ed3b53bd7b7d1aca053439c1909d3a40141dcc2349ce9d47989b4cfceb16eae02e33d4c11fa265aea0a5025e3968ef4e36ee262e0d9efa8d07bda9a56f3eeaa882462ebb9c361b75b42930dd6704efde96241e3cda5b6994b59d40c5867183e40ff169bdf0d6e5bf01f90abd0bf75c0c526dc131c67f5f8ffa0846c0e63e88ed62ea20e5dc38e5bea7fe271c41ea89ec9591cbba71b82eecb59aef3367affb97ee003c87d35b25f8782bd9a60e996c8169cc76bf91467dd10eeaaa612e83974dcc9db2dd5f1916c26f4b480d561881760215c6bdbadbd910577bf26db5bbc0f450f5490e106f72f70a7a82e977249244d525a863f3153be809cfbe8c57654af81ab2aad01bdded18ad60fc3a30690ff58834de6ecec8e28b241382f4d2e4e90d7cae45038e25925014932cb4668e0ceb8d5ff13320175dd4d4930368d2e532614811e683a7667d008ad5bfaed7b3b316f132b8ebbf32739ae119a3536ebc65b174f29c271d2683bc3aeb6ccaab1b0a4028e95a666574cc9ce1e4a09642c6ea207a2c825f0858e0961160a81f69298a4a7682aad4d3812d1dba6c20e853dfa33c2852b045015bd95002fbe3acee0451d8703de44be429f9eff489ede66348ad8d1db1060540897785b5b1a1630e851a575ca34c59d8ca23f1bf9792f96dfc27c6ae8721cdd891edbd919da7c41e9384978a10c7d3edfb65a7f45716280bd3f43f5d8939789080e98eedd72b6acda8cf5d6f5a125a3b9dad3ac15f5fa26b523b7f1315cf7cbcffef456b3efc780d79e61106d9ef13dd7e844789c0a3c68d325c1b427d33a1a506a08255ecc6e1e2330fd92e7a3e6aa7d29a80f282c11dd03402408870a0ec991d2da6a335b171b6d3199c91a280c35eaf8272234433248321a6d84107aaef9b429ffd351f34872b85f24c0c60ab78a386b213ba8d0d3a16635e7fd6e5bc7e91473e9d0f2080894d2e032fcd54c3e8c971b774f28ffb4bfd88fac89d81c25aa19166c73db8590078360579fc07c53d0bd8bffe277f27f79bb22790cd20ca70ef3b02083eb43e920769b00d1452beeb1bdf772b23343f844e9b9992de848bd0c75c470688917cd53f8c62b45eba43cea3490c7425d2aaa2c36746f5c70bfd035ccacfe6b4d6ffc03e5fb1b2bd4c570f31f7cd6241368ed3caf35753e292ab7f04107bde651df99ce866ee384e736699f928724531bf9c65e2ee99a5ae53fac88b68bee84f8461b285ddd5f3d9553bd458c488c82248a8a565d2628336e2f85d60db0b9d7a3695cd369b48cf90538917a2a9c52b9b6d69fe42f3e2345e114382ec476e76e34ac7b97c534d67a944ac5b8ae4f0db327345f0cdc4b9a4f9dd0e90cf564fa1e6564a7a35034ae34be862887d2203ae77387f4ec31856a63da93d2d4787151d50b05531287b015e0e31d7b6c9c75f8f5d4d4fb8460f770c01f4ea509de1cfac3e7532231d40b4337271900aece00e04eb8c03239df9ae2b995f93adfd4e3c064e3adb481668d12b9a0f7289826e74ac042fb83b69a29ba0d8febc040f8538f7df91a94d44bd8fb159371ed8d5b3b5ab8c81543d6947e342e15dd0468e9e4811b047574be9f656b43f4449b235acfb1a8ef1319f291ce08957ffddd6394176e2b827225890c21b1075698ae8d8d2961903c20761ab7523fda15378e6dcbbc8484de121029de5506229d343207a64956b5524f67e71d7abed3efa90968f6276408d19529ef956c3c8894425671de921c1f072541dc3776dfbda5083c93cecbb3256f24bfcae03facabed0e860e5b8920075408ef3d46fabcc7979f3df7ee24a1fc5a286ea9ca38f15e5a721b489694368c5fd4d46611091a478d9a676aac3c1942a2906cf686d0d43fb4b5bdb90f8a3ef6dc9c37414a18e65120dbecaf58040de4c41a214ef8e26e0455d9ad0dedc46e8edfb12715378652a8091e54e34bfbdde24e0cce169d58c9c1d859614ebe40e62f697f1460d6c954bf0dbb831261b5d8f7029ad988e603e6c06b957879c4a6d9a4f85d407bc59fca9c5f1b698dd9825003b19df9f651af35e81d8b7b38eda78f66582a51be2d43a9a58a170910947a6805e0a6d838508936b082a9ee8ddb4f0ca43888582b28cc1915923bcdeed05a1ed460fa3d9ad38c430b24161094ee5f599631566cb24a1d1c3b272106f84527142428dabf387fda2e76785005b2af8408157fad63ce4435f779068b8813a738eca1c9d8808fc1beedcd1d7422c2748013daeb3a7f2ec4fd48d69476a04a6a244b52204f8ae081a6a17370fdefc1878b0a6cb493ef4de300c89f4e6e9de3d2a7845f1a65b2a1fcb4dd65d2ade0b20e3ceb5350ca25d0945b3ef60014cbfa9573299e8ed7fb8207bfad142a4dee591fef4bbaaec586b38d837db88e41e659b348f77ede5540a2f6b271467a1307e81c9b2d151e8e2687c9109d2818564da26a1dfdfd24e0498340d3fd86c4e85ac79147598a88644689abb50c35657047c9183489d0414a89b4c4a48fb7f266850c2ad7e61838baf468baada25f0d9749d6225e11153998fa2fc645f43a311b1014fb80399abc625ef970a4b6edc62ef0134332f620b3144f5be72619b00a69a5437915cd2697670182de1a2bf692382bbb61a35846bf3d973a2af2d213da690f6bd8cff01f033592cbefba0daceb896649638fa0f747630dc3b29364f630bfea89f46bf762d8e913f6f7f3b5c0840488a9006aee46a805f3d2954536920e77c11e022aab1a441bbe49c9d16224d16287f10181e6f59c9866f978cc4dedf5120c3fba336607bf378484c1f32b3758c822afc5c444c0739d8d152ddce5c4a282d6e14814a26dfe65e8a8c6843fa65204940f2eb9fcea3fbfeffca30532e31f645137a85d558e7fe57fa452491fec8d43279e077b9f8049343fdb89250b0d779140410a3966751e4330d940d36f26d1a0d60b9836e8c17447d36dea1e4567ea2a5d31c7d799762253c2c571500db5df866608099a5b1f15dfa4e4d5c7d9bb29adaf6958fa6003e63132655cc294ccc7901fd607896564861a500eae0ff68a6ba2753a80c7353f47adf2e1e54e5c7234dd3684cca6d30fbf79c761b79e5d8c186c37c7128e713da969cba424495ec8aeb99a386c6c026dc583ae70272e1accaa9aabf7f19868e8b444abca91993fed131c0ded117e991b45621b05c1fc16b5575ce7841df05406e2844ff100d351cde7ad03ab41a3ff98dff08739a711bab6f0c6fbd4b2fa9e9fa91eba526070e9c91bbe23aeab28e9d8d82410872a5e4470e4f2a2b4a445b0bbe58baf0b7727bdf4139d7659443ebc704c1fdfc03bb4df43b9615a918ee493076a99edf2f2c728c11e3dd18f3bdc028dc475f643fbbf43f44e0194fb9271c962d2af7d859009215ae6a4536d841543012c1d889dc0a6f47b2ee63c017b27f6e389ef283761066a19a4d708ec423ba13c9a83e6915c4f8b60b424acb884d6e887e7b3bd185a750a7dc13a2479af01747f6af154e9c0425763e03de375334b1a8ae5f562613a820abf394a75abf9faed7fbdf34454340ae34bcd55de7df9deca18c24acff56037be42eba2ca5ee15e32a43a24a9ebd1e3b8ac83326ef5a69f13b806fa4b76bda399f58df61fc63048686a1f940af9916a199493383a781e4e8bb59be3c8329a72730b03c56fde8db5951ac661b0e8930a77f099ebe241495ad96720c182b25e8519e1100da7db1b87d627802f7d48e89ceb1655f88a37298744585e030f2451633b9c159fc2a70e65708cc6af75804b2d9e92e7530e82a1324be90daa8024d82f988cc98be7a16255433442e15ec6a829f34cdab9a9e9b26c8779a9e5e8af49bbf3c5db4866309ed8a296fe8ac51ed716ba33e47a6e24d9f1d6c8e943ce3b290fe55adf17fd69b5ffe100dfafd0cba975a1b59f4fb5765bbe06beeb3823593806efcaef074a31a195db884a96546944ebfd0e8e8df5f64c35c5ff1d4b4adb6eecbefe7815e127a9f2b01885c4cbeefac052385df8249c2ea94166dd3b4d3fc37d33b78e79a82978f8d4029bbec58541497e0fc4467a7a90c6eb1624cde1193f63b63c17ece3880ea4ca75c1328ec30c903e2f0597c4aa5761bc8e2d22c826ad4d8af8f8c40108920aa0001124fb5563f4e24f710ff040ced3fc7f5ddbf9581da966eb3cfbc14b4470e2672352ddc4f174104327ba575e82bd7e77b0fef598bc5bcf677e74e529accf3c3fd6edafbee49e203e03f269ffb071878dbdd90b516b3c28defb1137c23751208c8397586f896b49d70963bd2d101f20faa105306dd5cf48a99c740c4c1dbc0869ce1b3933d54afe8d09cd2ce9d5cb021aa9919618344451ddd91af7830900cc5be9d8b8c45d3fd41bd82f9adecb63103bc3ee8b2f4f8e1729942dbcf7afa1cf233a1ddc0f2f090474f1bad4381c09ea102d37a10406f278963d1c0393be6155b749d202931e56fe169ee3efa9b402f31b46ced78064af68a5876bbfaa78fd2fa7f88c07b6c702232a84eb8e0b658f685200d63594254bbdc0e425733b33801b3a8fc3c863c33b26579314a28f63cfa63ad9df8c5a524bc3799ef3aa6dae8423c3e0dacef59b5b1788f3d11cd749b3768707d90c04d868bc92881f67bca786b2c863fc5bedce4cf9967992e4fc919570798c1f6eb7c95416dde1c9a9bad56a0146cd58d667cb47d9d5b23ddfc335e619c0bc5aa3b44435e8798fd83805c36079159944db7f5369582e8fd457b49ac02c285b49de2200649e3502eaa2423a2da970a65da753d096cc53a7a5880cb3b5e6518cc245b2d6e986cd215056b9328d53f9d92f879aa694d710efa646026da5b69158f9f2eda0947e1f07abc9a49d911f579461cd52dac35dc15b2855945bf86566db7a2c2b2a05bfac20933c11a0994326fe3c497cdb9ab41fb4986f89c11dcba531314e1b969bbf61c3c437a30807b3793668e37d90995d5b7c0f77ef147fb4ed40587624d68f77a8f4cdd0f0bd78ca3799fd0e09afe61320d9f6c9e5a686e13ce8ed0b2451eec02d28e0768c8d42f4daa6d38befff3d0ba225b2858e37f1718a82a889a8b5c0e63576250142f7e44e9e1dafc116c03c4b2503e8e9ae36d0c30a7d328af59584c5bf718b040378265a78e07d5a0509685588570bdd940efcf95283b6a2060284c677d5bc1ac384c5dc8db57fa6943875de930773b40c81cad9b2c61bce7f974a480b3d279ecfe232a1f4f24fc143af6ed59efffafd171d26a2f8bbd4116ed7bb71c5687a733a176d1a647bf6cccb9956ea5d9574cf7402e31704d87228f8fafc66fd12b729ae7c345b458c92b7faf74f6a5ea2c3dc2129b16bf5f5cd2b6c7d7e7674f026984cd1b36c0d1ed7c6393e765331cfb3fb3f3fd8b4bfa3e9bae94569134d21e4874c105cec736d9e908d00a9e5194bb42592bed465658640cbc2baa9d1a30de2f2974e553f6e0b4e2314e46da302930e7f2fe16fdc095d0b9c3f82b31d6d0401d4742fb3ecc632b74505199a3f80ec399ea3fc9f29795ab4e1f87ee6a2ab53c3a4061315b6127d2bda7190562cf7f32b5609849610f1fdad6f0a9416552e60f753b6d7c16d82c73121db88a80a4f24cad48c80f2db042e5928d0392599758a099607d3e7bac14ef080fe2dd11b3fbbfb2b09a1992487e64937314663c570ff0d45529533a7250a071cd094232d33e922ff43ccdf1f25eee133bf4615ad86a71aa39734f6a2903574c9b9a1ed9492738fc09c73967abb38d09d01bf738c34a9f5441b8f0ec69529a5fc1d6badefa46ff2dff2dffb175495fe12e9c41ff2b32e449df73852df03a41b75c1cb9ba4866d88ad8aa7f22055e02444179095088d4c7f2f2e17d503f7c332e05feaba4b44b0f6ae5b7bfd96ee859e32e06d7cfef90d54488de125eba61d3a822e4b7234a28b27d7e9eea2cd40d9867b62d24a6f3606f090ae83785815a92cda94ee552955a2516e51c8e4baae7c0387cc226f9309e063c95276d86f07c373170c72d53bad5a6313438a47ab29444045ec18197c9b0367e39cefeef16797a3300cc77b40762b4d05b9a178ef6f803c375cd940e98f232bfc3b7f19f14bce3b13939412c8dacd653d040e4e5145f5a993fc1dc725720e227f9be476541727d2850b7334c42a37d25206ec1c235cea157a2ec40ec9819ae82ba9a86fc7ecbb0cb8018ef46d2f17c8cef59f24839a309e3e338f8c92885b083aa4d4f6d804ea1e7affa75edfa8fca469570cad6851ad1816385e5fab1d94a1a8f7edf2092c2d32dc544aeff4e6aa570812fe6d48990273a9113ac68d1ab241149041c734610cf6c5b9b7f44938268ad47324686c676af73ba08f74d00570708f34e528c65445051d6d4fd910ddace5ed66573c80bf5b17407b767ba5b070b53742c13e85bf22ae336aee1a2f84d652a96b2b3887643498f825f690ba3aace2ca96c9b1c846de4541d736a155c276b02eb8c133ae44e01c5c024c041e6d1edf808ac57f96665cb10bef850fe2f8e81d60f9e86d52ec85c425876ea3c0342da9e92749470d1ab071cbbf9a08f053f2d05eb736dc377e96744c559cd69815859622af44d258fa4eb14f03a06553d004084fa29fb7e3399816040cfb767447917ac9788917d98973a0fdd96bf76a6a4ecce42e3fbcaef66e45789376b667969adc8b82dc7f1c695cdb0c45c86f756c1d33564708b136506d05c8514813f27fcab92093ec7d8c16cfb07a67a469b99195fc76d9ab6e1298086a7248c6c0ad4276b4c90b3917cdd839fd617aab991fa1180ea17090a93372cb39e1d0c392cbc6f2376cb3212102e501100b9aca3f2ddd791e016930f614b0dafe400e3f0dac99314fb27feb1adb0915f789bdf91173aa6db253a8ea09f87a8618a2553fa2ec0f897f7fd9545f40a6fa436080d60ff8baa37bfc80508f05731fd3a06b019c6c542776c67d3d16d42b6ac05f40fff08182f95ba63b1795a79ae2461182ab32e2eda12423821ff23fa821bdbac8e4e202d831125b7a6181993d962da1e84e5df59beb89848694a1cbf830f4632f914e7b84db0c6a4234eaa2fb6536dd07d8080c9b431561c397278e98d5e2d45c8c17654f72408b3810db41a0802760b527f28900144a2a0fd3e329f1520b8bac22e1e343858c01a140db8988ac6f94531e1784b20c3d99ffa8321d283e016422811750f844c4598a0568b30caffb0cf1a92b508e76a2a6b5792d07b32ced931f17ff43ce641fbe950ba7689347149f977b245e7bd9af985a964276db105a6d197ba43a127f5fbe47463ae4b609e11dd63ff1f05fd1eb85ef448ba2fb1c025b61d27724a4d7e46341051e96d309595847260ce5d1bd99464379ffb080c89951634382732b78b44ff68541f3d91dad350a9c8b132c4356aea6059048916d8b7d3f2204f819f33a74df2f98ffdec86a5a418c4c32dd395af038295bcfebbd468f387f8a22065a6953682190e6abc15c5e17eefcdb1ef832e200f715628902872b27e7de0670cc29662280490ca72d21ca57f550d06cea365c6f4566c61853c1c40b2d709c4b5a269462cf8fdfa110de842e1119997f006303c66947b3c0270ee48306a08ae0a30efecbe3861e9b8f5c82d69b1eced04bdbe7253c1570639c18dec7bad8c4763fb342520cc2a0c1557d78fc5a051558eeeaa265b7151109bf60788f307b426fd15b70ebf84e67d2c408deb133ea1b4be6576de8d15abd796f2ae1ec06bb3b4ecd080eefa0483771dea3e391e48f4be6f2cf31d1ca5b28d3d0d76330380f3af221a1f2c0b44f62bc3b48c585f2c67bbb657b7819bbf960ce578d603cf21ac987a7af6a333ec2c5e6046e3677460abfaf7ef22e98a8ba2399c7e433613e4950811210f908e01aa6057a637e756a53412a4e0aba0ab39fc9db5e3ccaf05a76c02a597a2ec3107e3688f4972e6c89fa319219ed4ab77b9012b8a6634c3a34e674c84f439f8b462c726ac187214a14e565ed793381a0a22d37f2f7584f6b28fd3449644f1ed73607c88cf9a4954108bbf70e01acfa21be1d65725afda61dbf82a1f3a0af06d7a06fbc27a17d27d6143620d700bf518228903dce62d5ad7b6f4444fe7fe4f89f1954a809f47adbb904830933f297204bae40d689b069b7ff5c04b8c83f74b77611ec8497de2470fbe59937c20e6b6e63d812e832be4db4c9ac78928fde19edc0909f06622ad758449bf290a61c9edf165e30a30c49feea4a180d52b2de762c9126dd85d56c1f2bb7e1da8fd6e2e3467eac1117048dcf12c63d0ce3a6bacde0beeb7b29492df67c346c0aaf1c1a3f8c61cc08b7f3c92d5f841bd138bf204005ed2a8fbadbe3219cbba2fdc803ce27c0be3a2e7e9a43d0e490cfc9df6b7a1dee619169354b341d11217782647da09ef6175d01495f24df95cc3d136746c8302fe7057d85f3e822b9175e85a07e1644b46abb1e39327532d353f2027f592a6e05ef50db477a0a4723a1cbc1c3a1fe26bbca68d85a1fce454dbeba3f46338a33d6b40e239f2cfea0eb8c24dfd658552d821699606122d4131fdbc1a0b112fbe698f79bdb8ba1e8c195d15928b101c58f506e0d0bccdddbc1527ddf69dd7cbd1254fd0179cbb8af076e64724c1a9885c1c3fcdc91c8364be77c357feb3a4560a20bb61cfd52674b80d5f7286d7d75a9ec26aa6d51f10121f7c747076c44b1880cdc3e0206857ca8dcdcc90ead500a596e5b54d7c58f6f47c51913b052719cf6f2be05ec3085f9b9ef72fbd745d57dadb12e440e6520183acb1a9986a04f30060f5d55caa01132f9f0be613b315a66b8579686f301de900a9b16331a500b4dae5dcacdefa3ccc0d8d05345b097b7e74dabb57e3f38f522f7dcf9bfce245ec65aad2f9a5753252b2473e3676d20b1c35752ad0c52bb2c259104353c242cf41d638a5c69b3137f9a85a4613725c5334709414f929f9ee1c07b407ff229d9649f3a62c8a7d080bc1e10d867dceee1ad4187d719486e85181bf2e3a10f6f78de892676323d1d65080db1a81eb424257c12de380851f359e783ff28ff039d1df05747b80449b6222699397eea12e5c54cd51d1c5e6859cc5497e4967637d7738aa5397cd996168c9bea4de9f74e705656639428c698c40c67ef8bf2af34d8e542ea3dc188a0bc8b13b0abd3202843c191acdf386e15f00362d0dd8afe274ca048a913027a717f7c0cc752048e0ff37f77a7d908d02ed6908e59c22e9348bf87cd988d7e15edb7909826859c3d02785894e6cf3ec45612401ed326bb4735e179cd2ef2834b62d0f558643ca0420a0c81673460ece9fe0663fc1159852367254f10e98103a3a4fb2aa7d7cb4c481d616d04b9037168ab54e2540e20d37e1cdea7eead46b36307c77214f120c676b95002c3069a6c6d8a1b1cf6515ffa71375fb78544222d35e891c7cf2754fb7bcb07daab77228929eaea623d9ae2e5477f984d300132321e037ce9e0a49c5e51ac7af81d6afdc3ac72a588530841fa47118212e0a2f08bedd1e3f59c7c206de3635a9fa3c019d0a345c2c878bea2095af8fc3b2d7e581f843f246fee68ca4da58a2d1663535bc319dcfd93e354a81938663d16af72d99019f6b3e31fa947b35079b3f03f434db69d1269897cda6cd5d99885e470fc73a2f8dfcdafae6290576134169fa098818af0c114ddd40f3cf3a4ee40ce3ef7aec6ff5cdcf7ee1091831d36006e858ddef00e6a296d6cba07825386bf693bdeb39b73de8e26de13afe2f0b7fec09e9789dbcb86cd9b6235ead420b88fe16ccc96d56d5639906c802bcc4fd6b04d210bf065b4088c62fd8941e011908244754467c0be4383d0a34b2f96a451f260a51137d1bb457ddb88e2640160371ad93f04654ac6d2a29e2a38db6cf344fb482aa061c244db540b2ea7ee2de7d36bb5513e0b79ff326e178780d915509778ce82f61221d52882df3d50e1515cca6e0f4218e5d629449004b97e50e96870eb5a46032f6d52a04209b08fe7aa345ffc8b8aa9d0ebf1245c80d45d9f8f01d096d11965da1f414e41bd5ef2ecebc11ac78e546a93fb20794bde15aa797c7e8ae70a34cb18861a58873833568166c88236623d82ca04b6bf30cc8377237dc354bf178c9ee38c133cfcdcc1be972efc1553ece45c911d4af7cc0d4b07f09c5d0816e6a84e76c6cbb622b88d75734e436aff1949503d7f84d99b05b7fab2f86c91b5549d9509103203b7d54f0bceab26c25e13e67f109d46d79ec9a772701f92eb1957f52e85d64613f9cba949dc3e64308f81b2dbdbdfbfa5240343727a037ee1091e1f12914cb6649874c607b6f31b3cbff7fb83052bfb35daae6771d125a2db9c121830c5e20a0ef43e4e36c59ce5e81f3014dbd6b71b0beb116730630aee15e827a76b380d741a9c12f5f627c0c9683bb205a139357e110c44580fdaa0e8280d4a2d56d1832d6fcea06d2d38e34a9f15227e19c6f21d53a7c086c9bffb69dc0fbda41d279acf26778f5f0d5277d48d2d7bdb9edc74a403ef756055a55053848161ffd84c1876a4d737aa1ffe1a3dc9db085996f22800dec7caa43cb80513a11840cd9c64a0ef0a0041b8eb145ede61d43e60e2175a6ee282b134b4ae6b7e00e29bad09d95b14f63742a023e5cf6f32a825e5f931d3440f8907849b65de957ca594e75a02fbaca6d8e8215bf24665121e5b1ffd61d1e9d10a8ecba456423b19f1b933ab54f9b413807e27af41eaf2449586aad174499c4aa76d76834f0a0af89f955fc221677e63292cc1fcaef0ab15694b4554d34c1c6255429c6c55cc32d2a7731c81337564f1592d3fccaecd37b3a52583734a5485a4e5fd693beb21bac8d45bdc58f32479351ca25a790a6a07fbc69eee8b65a19aaeb337f7f4d60a3eac77956818e69c1c212b63eec7f7ef1d590424ee2fc44e58b52d1184f1988cf32a96fc60a7c99f5e57b331a8a5e0f30e5e2e02128e156114b10aa2aecec467bdf8145ea9964b1fd27e64d73ba3a2f51eb82db4273b747e6cba80a11e1280ba5efdca1f223fcd09fb302b88d690c5e0cb2d6f7e10aca4dd5bf64bad58f369954117db6c51a1d556ba94a5bebf6bf8f3cfc895dea9732a33f3413ded1589d134cb638253b98233c81bbbb94b8bab911df8931a1967eaa62a005771670999f97c1ed38c493583169e6c02ebab180130bf57162245fc24a34cc88c6a8304cbe70408a9210816dc5c970c5d8ce868c3f3cce94a2fa497cc8e368895aaf471a60ffaf89ce0a3c1ac35961593c76241bafcf8d658733e317b9a6b81dd55242cc0711f3aa929c6f008b543f038a072de8a4c7117f80b87c94990a5c6e40829339037a2d24dbc43b33033f3b4c51558eef2134bccb076006834569c6e790da2e9bc5f210f270173d257e8a176357965639c72f229a59f6f2ae930df025f7d1b61ed061f33ca88bec9aa3620f36e16eb16b98a5324cde50459966fc2e57c876c70fdcfc2332298b933377c719e1bf5edf9987fdd07b96f7bff329dcb427b4398483a8cc26662dd4f9aa18756f76d3f17531060cee19b984cf5c5f95b0f720d1930dcccfe660cd28a31592220e1050397883649ff53949e7fbcba0d277c165661bbc2babee304726ab402baf8aaad916ad1139ad5cedc8ac300294cf4e8deaf0abcafaf632ae28f40d7784a30ade576b2b5cde897fab696cd66c68c4872fe00b55b928c8b583c8770476926c14cb475954159b570aa192e8d70b42800fc9e77536ffc8c372a9e33c7c20dee14a543cbe3c7ca9286b4e3411ac2e121ec32993c32647b1f0f4d8e25bbe29bafab3294362e78950e520b1e46b3d86317efc326fe024f7b20b7414c9274445a460726fb8ad98c3450788b25d103dfd36741fb557412479654942382d36e4e688eda4b01ca4969e36112ede7dbf63b73ece6c5e03c986bbe3bf8b066d14ecb52cb24f31152f301a59d8d1682642183c39af4cdf31a9b50b7236f89c2f945d9e66ed25ee48d8fdbde2cce230c906197837e02f58cda6cac1637d630abc31fd118c317d184590ad2257469ef8dcc609ad3780182387877c4a5f0e0624e0eb354bdd105a978ad4cabd8b01505533aa6c2a7df98d92c57d4e3da52e44e29df4bffb2e086e71743b16808ad59c8e0623dbc10876e005d75c1ce3a9dbf4a9edd3fb2a6f71a41a466c307c0da8b10d85fdba79794fb5af44c8272fe8a28f0370c2795dad78b25c60a0009e5da91347e109c19b648aedf43ce56d6ef5eea6bb60d4045ce6f938472049a4f34b9053f4c50f15686c4248487663cc795dbdaddbdc0a795a9f374cb84097dea1755e7ffdb10255c7dec8fbba3619964813ed197cb763376df4b76a0c8ec4f3094ac4b7a3483a57cdce755f778786b6ce4c392acb50c57283b6f91cda2fe8e4dc73e63726b4b884eea67ab1205cd501835df8b72a0fd45032270770e4e17483add1d48b29249cd7cbeece8913212197a6aeb39281bcffd599cae98bdbc6ce4152db4e5fc6c99ba161fb3055eab8b23731cf639f4224ceefa7e37aeb8db4768e01af1df118d9d8e5e093aaae7387e7202b2a153465771eab1f864a8ae13cf01e26c8e1586b8ed3fc3326c8c499ad91ade4cc07bcc864bd76e0c6c3e55f96519b9a4295dd44567d9aeca45620e0af9d65942662cc6533f315e8067cb3613e10e5c79e7f95f9f144c518d2a3458e2d8a6b1995a10881abd8d7a0e7d8296d922ce61767875faf483bf9c2fdc5ce2c3b00cd19280659a07108244a75e3f966398d2cb8daadc761721044ed35b5f0dc94250005158783bc61748dd00e3b2be7bf1d1cb0376bda0a0555986500ca6be7dfec3aa64af13f6d550831d6b540276a99626e5b5cafb0bf8c7c1c99ee3dd9580be38b36856331624ce03e0b7e9b66a1d2286e5eed4f8266f87bc9591752c7a4b670bcb35a354a07246a27d1c0b6e0679581fec93b344a86d32bcd85403fd2b72fcd4d702d5b21de8ad43cec4487779644e01c6dca6c06b428afd8f1d568894a63adf61cbf999eba3fa58200957883294f490028e8942e5b201ff90af9d56f778adbe2803606e6c961169b2fa64e22f6af68fd98b3de1e8a183d56fc1e0a0253cce5b24fa4fc2a133714a4ed87d31a0ae281bf388921181def8b84c0dad61773683d7e15142177dfcb3b093bbf466bea12023c58f3f94beba7fd31e999cce8510357616153e697a7363552b3873375c242e4ceceeac57093097c3e0580d405d1f5bbef77fc9fdff78c01bfd779e4db6030a570cc8f115c294ddfc85d1dab1694352a82ff9597e91445bf645a61ababe38cc367863e78909917fbcceca19412b99a836137dc52b90691dcc469438fe9da7d27ebb92bcde0c798699f61f36764ebee13d96f691f2204e2fa811eb4b49c44da3f80b78765b0273db69aa84ae86bf458524fd3884eb60c400250d18126635ea0cf1587e7ce8489c41259097d100fcbfdc37bf6bde95ff36e65f1c04e7a6f017348dcbd2b0aabc70d1bc780d8765e9e5b9d942d3eeaf1623d4be382c5ceb8f53be9a02c0ec70900af75e5b5ffbb7f22af5d1cc2ab7b7e9c85b046c7366cc4f4521da3fff93140cf3f1b80bc17dee2c98ab0bebed0ee619139eb293efc0381345481890653bf6b5e08a4d5ce6742cf02564667f7f46fa379714e0ce7bf363e79651a3b2f0704b189b83ede5f6cec98212bc842e5d2525779a694e355189ac2038ecd6be5626d4290981d5c99031b940a2ade563527ec2ba529775f2ebcf68b812162d99d151689374fb779d07fdd0e048a221de564c6a80e4d03913f639815aa1a83e4368fce10cd7313ca31215c1a900ef95585d1a87f46df070bd1549ceabbaf041b3853c13ae9ca0acee66d6c2ce144ac8dc824aa1c03ff935f9419fd097d0f9e451ee6c06d330dd3cae1b284821bc365a91c53acec412af0e5af703a2c2c4e8d26a879559647503dbefc45911ae88a84ca248d1c354f60fea56e9925aeb32be22a56c799a5a015616be731142d83562b8aaebfd37820a18a30de527123cdf88d049bba5286a021b15ec852541cdbd72169fcf35206b98b477e5430ec75ec19677ae6f16225d71ee393d20e9b3344578ddba8a843b3cf84b0311421a745a4904c23c1449d4dd437a23163d1c5f15a32ce77825dab48afae7a002d30dc39a0e4d44bf432c92d39015f3da71a4a38ac12902e3fcf991a18d7c8326c1e48964096eeaeda3bfdd6988a949c755e2bafa7018cd8447c344cb8f51ee6b50d757053efe337839ed8e382280f200f5902d5ebc5eac9cd1cb04c52a0e0a6b710e9ce30cc16bab4a888303b8c504eb7b2e3181a5b68c531cb1a7fe5aad2029414e050597748bded6e3a124ef8aa4689dfa2bbf486651b6d937d5f85c1f57fee3dc908cf8ab249b5960d7bbacf9268489e3af0ef1255d532967f85b998755d682e798a7b8423b67c2d436f1c26fc9346216dac791d4603317f12b43025c9d95d3b178305a43a39d05418895a530387916c8f7e1714b2ebf3d77f63eecf2bed67eb3f2c1aeb7081cb413d1be6ba7adf0ffb185e6c18be3e4404b7f6db3a87370f5c09fd67224d822e7aeea2a923f075c726a2459f6c1906c82ed278079f5405a2c4991ed6122cef40d577ffd2dfbd6ca0024d7883480c2a9153f6a642e8dd235de208e16abe5fe5f8a0fe29f73a5f602ffd4f713b85e140e06f817b118385bdc83abc164faf5e553683a50017a10d25f4a54e06f173e725b7ad81646e97aa3ad40b35c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"37140fb3d93bb38054866ebc46665146"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
