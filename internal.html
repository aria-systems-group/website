<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60c0c50b7341feb9f9316d3e8e8c6d54ca7a97bd46ca10fff027be6e6de4a555a425051faac55336a622e05bcc08ebcec60f29037b8e2e88f9824769ba5e886752b9d7cbe2b799397a6bce8aadfc43d8afa59f527b2f41d1dd7a53e45f965b1ca812c3446c2504421035821cc1d631ee7cd787ac0a80bb8a6e60ffb8957f7ca89adfa7a8b79ee979b19add5150fa7a1f6244fde9be405fbc6d3f3b17884687131ffd55c0765dec348ca875392bfa62929f15ccfb46c551c6111b8f51493170a5014a11976a71617ddf85f6260e01cc3ca6e2e100ffe010ea57a48202fd823241fbb3a04f6c1ad09dfe2a35aeb60c708a9cea08f7ecb4aea83e4561aa21c206645c6ffeea653bfa97507ccfb84284622cabc33972c22f2100b6535893011d9c8f32c3cee33d3275001cdbac8f48fb148eb7ca203d3659143c6aa58638abc9e84cb9d2c47970df9998680e540b8f51773bdf013b0d06f6060501b42bdb49abafbdf9b1153b6b7055fff4a4730387834e81f6d080a82bb372c9aacb27211141480fa0c6f3e91f4ffbf535be29c6f569b00289bb9dbae34439e937c3ef4a59d2c106d7be39eaf9b15849a33a4fb9f7604f3e03042893cfd88821d2db3926c1905f89ead2b23c2e4c140fcd32b0f18b58ea07129c10a6350984ab77a14b884b400deaa34d5391e730d71d73fce3fabe6f6df778e0ca5f30ba75bbf620f4623f23bd85e4df990a4511a575cd9f2025708c9fc96da01eb3572d3f801e9842c188594d4f4a8206bd0d00a6ea95c9011577545362747303384c1587ad0bb64952203480adb5a3bba046929d81ee02bc77b51f5999b22888a24e6f1f933f83a521154dd590136fbd680a212b9c2db87e3992437c7f4d635f2a754b4fe895450a60007b0851e33146d69fee76f072a81aea4202a2efef6d4717b88b0fde8bfc8db06cc09c2bfe82d0971cc5c6bd06ecf1289572b19cbed12c6865e9875cffdc323e9d2f175f2b9d64d3ab1d3aa870cf4a179925eb0fc2ab2b6c08e73b51a9d6ef8a4250492d2ae5d0a2c94f02057846c0de1e31bed29f7f183c4d292fda736c9d143b45bbe082cad77af73e40c86923f27b622d35bece333a8e9e6c08f3a9db68075e4733af0d45d0d9d798252f188c3d8b2a2efad10a3bbb877e43da91dda671390bdfb12625e4ad431d60bf4245a65717199dfee90c2a74fb1c83e202916395b8d5f83714132ed7c5f512946750ae442f3cfc2f8248c85780cb0fec5cff71454f7f67e097d9f840ded8bac34460f7c944f1723def8bd978e0971001c532d268712cd23f072bf78f6430fa17dda2f937ac43a1c3fe94397924d357631b99e62fac90cfca4bc2d9ef7646be754a72fae02913f74f2817873ca0d01c922c24a638c0446d71f02acc8654b1533ebee26b540b04e27a6745d27b23838697da79c4e4995cc63cf5dc06fd20d6ffab20cc358b8f08cec31ab24f49be6036f171b6c0385ab598f3ef9c0e92a66ee885768c778b2384dfd34105aed251961fcb358c799d8a6930ab24959c7c8cb41a957279168dd044aad141ec3736fe08d2040c7dafbe8195d68744b70060f8394d46356abaae69d3a44762f12277622d225f1a9c85ece7ad2f503f1ded19a0cc63de7928c7c2127b6af888e8650a73324a9d6c197fc045bfc3c06be569b0354630044441d22d191374ba2fe299322492cd315cecd0c9e065f63bf7a7d4062b2df769553b4264ccbe233738e4bdb0c11eafdda075e3e662bee63025e0d2f59e48e1ccfe0c4f7538d2f77f1bb05ec8da86b0c28ea5f654b859b48fdd8f779938cd947aef4a9cb6b3aec39f9e04004e979a13dc43fd7e1d73fb18ca73af07ae68bc5a44d15252ddad8cdd7600a645642e3d138e9d57d421f7f2bd7c547e42d6e91b4d0601b63fd1289906ac79b36f27ddceb1afc90be8fca97442a0912931f6be90135840db26ce87673d355c216928b6d00b2ab3e96a49919fd6fe43e33cb848e898ae39bf4de10277d11d695792ecb71bb2cad2f876bb35489370ae4da4ebcebde80931cfedf352de553eb9c51f00b2cd5a1887777b85ca90e09bd49d959f5b30be36c0b65f716715befef3765ba858f8dcad143bd8b7fd55f58ceb5ef5573c828a9ee383c36678bd22249e2ad024cb95bf93d73a1e17bf90b0d6df1d1fbd0579bf3b1ede3179458a6078ef2341b2ce2d68e277e345db78c8d724c3b9a4eab9f0f6774932d7a9930ec95e382713719d3da08484f29cda120e1c78e8109124e24930f4159f21d3307e1ab4c214e71a9f4dd34434bd62f60966c985fccd366de25ca3163478a9d3193ddc49dff767a8498758e841b30191ec5780eac62d066735a82e7eefabc181a4ace32d8ed4c2b44894788eced80f27566f4df586b5fa63170c236d61a9a67f3383b8319f3eb9bc8649e07d6bc15351d991a7d7b31d07ec99084cbf10a015caf987f9e9c29f0bbbd8aec60d8fdf777a8e4366ade504bbf87acd3ce4d85794f746b642fb6359e15478056a54b5b0a3f9ec9940820b16de86eb82821a55e654094a5aac0aa2386e6f2a0fc48bc724139fbc3b20282f2e9ba36bbb07ae7be63c8981cf46dee1b0115aa56a433de0c2a738eacc9f0f7397b4405c6d863300b749a3254f75aa2dfaa7eae0be1cd96476004832583832ea38ad7790e872de671526e66ec2c3abfabc84044ad15e69d06ee3dfd14bcf79e429c4966cfc1d056a0239434a3530bf0f7997d3e84bb1659c47cff9af4e0c09e6e93bf79b4f1d710547b02d9fb90f211bf3257de2fb292b0cb03d3d364031aac1128fe0d4f8f01d60229235fdceca991108f7916abe4cb7ba80529f4320b291d9c5f867209d397fd24700ec228c4e1419e9982e68ae88cdce9444b1dbc16363e92f0337f5976b7e02861282080ebb66e6bb0257ff23458039b827fbb97fa80f6804ebee471b0905a4a8a6fad23268a59468d749176ed36a8fc91091b17ac667613b2ff7fc8ad2f96ebee7279436e90fbbf5d299a23970e716bf5c80046e7a998b3a07f5aa07271a69d138d16f456d881c953c236b22186ef3525f4c2b5490581afb4dd177dccaa06bc60ee105e1e7bd1a07a56a54be9221ce0b85d52085c16de8af1645508834e5f44cdc8bf77b84fd7f49c51bac5f02b43bcdce20e5a6ea1d63a514ba89096343b409f7e17eab15dc90f74552846e541fa09dd42348428eef9f6ff41ee804c5e92e3dfae5e11c4ebd02745da5497cda79be7f2ec6d02481e5c713bc0ddcb77c99123f2c92271bc3aaad431c459400cc188f0eb47f8a8f0929c5e02abf6de113189bbb9d81c82f8218d426bd6f251e52ef1b2379142d492ac783ba9821a0635a9d465158fada0f4d4fe94dd4887a7934bbe818f67a3f273c5fb31dd9580fbbbcee1f3f493817f270ff272036436c496cdb05c563a640a652122e92982b5aedef48206e1f3756124f2b75bca97f6ee5894695ffca0914f94d4a6e05d9d53588eb436037acc95d758c3410b7c29d027e0dca63e6ca9a7e60ac4af6a94c91af74b817828808b51966811255c2e04df11fd42cf5b7a283c40cb341b38656c9f179ac5bd894e885e69f731639d5fe3c83ecbc827db36b3674ab0898997e28081cd3e1bbfe4cdf93f929dc030915a60973aea9829701029982bf762190961c943d38a804dfa902a124154e9e74e29b4a77dfc84e212bb5b9283b7cda5d0a83fbf10390260c4d2edaccd5af784402956cb201f474229d938e625c89d0444ed4b75c443f8f44814250e8487d1fe164eda402d02ef70dbf6be243d8a3ac00c56e27fdd97cbbed3b65464ccfbe7d8ad6963de427b25d8711a0fcce3c892919d54712669d503d8d70b6ab8f355927f48ee294aaad9c24e0182ce6915e0d1e397f7004e46d5e342efa5319a969fe9bf41f3ae5e39d698bc33c011f5eb74c694cfcca160ec0155665fb7512281e7bbe32b4c1d3a739782f32c46c0c7d682d060506a89c45aed5a493c67a8f60a6b1580ea39b4d86f73091c5be13f504ece341206900d5f02ece3594917182ef8c128e84d593daf691e280d0776e31a689f41d9de1738a7104936cb287fd55eac1b19d893719f386b0e62797d1353163ffe16931423a864eaa336f8f63aa5ddcf4c22785113fb771c7cd413780398dbb4a1eeb0d938c03a807e4d442623e914d04baf9258dc02d1111fbc656c3664b7e4ed37474518119df32db20e8cfe624bec92964f45907416e180f8098b0a4f8df2582abe691b52842ed637620c9b3c825c0c68782746bb9fb59e750e5b7b5956e2f529d747ef06497339b73047f93b7edf44a926fd92f864b3bdf0095421925370d9d9b64781048f1da9c0ed88fe5073a179f506bbbf7fc616b238fbabb22cd556b3a46cd6d991fe390027544f098083c0bb00cbc4fac3701265e004b16e27e9e84789b32afaf6c341f2968fd0ca53ac06c86742e37c989b079e9ce29d2b461f843efbded5d03b8539c36db28dab31615860b2c557b67a4d1e027e0aec2c92dede0556830eaa827eacbcf843d692cd108cfab4229a16f858c3e6adb6e528c7d5a129b5f48b20b54e8b7f741617bf806d50205660a2a0c38179f2595105b68a1cb000269f42a460d796ed26d3ab29e1238a2637e56f9eb4b13d96a2b289ba192e4b55a91e10338590f68b21d115db96713d5f99c5ba81ec56e4b577e1736aef531014734f4722e494800a75a478923d184da439ed54cad76e761d52c0b6db408f345b74aff57f7fc4a08e24b083cae21ce5c90e671ff0e870ce8c3dfbfca8d15d396b35941f20e2971ccf3e202ed8c15063d071f2af36c1d8aeb29f0529d2fc21b398d7561d0b36545f527ae640538b267dbffb9113d189361c7d963ecac7ae3756ccc22204ebb5587c1afd8a443767edd700a065aec5572ab4115789cf1f0434c74f941de2d7f333f4a4b6e8c0180ebf9d2482e9be9603930269b3d7c79f9e5348cf461022f0100d1799c3c23c89a31dbd9c85984326216d12bf053752c88fa80a3499df373984885c7833b6aecfe83d6fe0d42346fae3e374f8a58a428cb26fa586735a63caa2ce7b4ff7dcf2fd7ae9b69f2587d447c548eb2db0ddcb00ffefbf24d0326fe0d8092b15957c40dbc237fc427f1886f0d9d2a0f24cbf62f89de7aadbba3da046d83a73c3f41802767694f27f703e09453f970a502358fefcaff4545df068debdc54e8124af7734273afa54404b40b543b987a7fd22aa8328f95f6b9444844c9e67162c3b6e6aaf8e9c42b32bf5156014049550651414f0eb104eb677942135909ebd8676dbd48fbba7ef7d8c2b2fde22bc7598359ed7b1a123ea53c5df8be7a469918b3734daef03f86f4b89c38459b9b9729fbbbe70393402ad2db980b2957101b40dae4e1e0655b0e67936c12a066d49b15fcae56aec470025cd2ab35d2cefab353cd92d960888c3fc87f678906901eebf7bf7d2c17df24051c78bd9f39641e9363817256de5c3309cc544755900386bef828d89dad08092594f191e09d5b26d0527e1b47fb59a1a0bc9c55bcc73be1c8dae956d0e53c171e49842cab5c1f6109be970ad2c0014325f71546a064c53fa1f96749a62c1daf364690f59500709d8f3f21c65f009951b2786a5808e3a1a1d6b4f2a47ead2ab1801ce65aa92c06a36a0a171a3b54e1251c7bab1b3304c0b589a5b61a396fa289827f1492e5653c2b2b98ac392ce6ab89e0182b941849bdf9bffbe8fa532b49d95c223bddd580ca1be15ca9ffcc590a96dff685976cdb2a848b8a3a02d89be9cc967def12f2ee0f1f9eaf574f8dac39d75153b95f02369b7905d669dc01c0271fbede42468527dfaa62d7a50cd34a543d3f68f394c3ee8256bde9b7c1280784c74e930dc7b0f0b7fc8af42ab05f764abef56168a42c1574df065db01d19f224ce88de698daab480ea99e89777a7d34b0d0f6e479155853c93dfd6899ed216203a54cd9759feb35b3f648c92867199632a32ad4d470b0c5fe9f2c0e2479f8f1f1e79673856c6199b95d6a43250dd4e9d54fa4204cbe969b86e55fc8567556b43cf48e573128fd37d4cd9990db06a7eb19628689ffd3d93e07f6562d5f17c7ce42992bdfd33fe3e0c64758bc9fee6af9ad53da5950386c4b61253af09267b0d1d2846c3498a9d95b5778eb9be7f98229520af4ebf729a5f2bd739650441a36bdba23f897a6a52d43c0eff231ab2a745cf504ca09b937721bc868a1bb1f5eb7bdbd9f590f24f80da7b469a5ab29ab086fa6680e3eb8ff2dc06077e9b822b230441a2ee943dfcc9573a029e05f7fca4950c0ab073d53a3c51ddea1245f0708d22297d7963f35af538d99fa9e40ee43917bd6e304cd21956e1be421b07d09bf4304c084b86d5f35d64434129bee2f448fc8f7f0c215053eef07c18d11af452c0a9f9d8c72055ccca6fcc9c1824cc2b8830a224bbf1adcec33164edab336c47697d554aa196448fea8446f2da6fe5345d4f92aac73565f1da91a47b80665bc8ba390ced864d63eab570609a4d4e5371c458921df36a1149fc25d6b0aa96720854d198179bcfb4f48f1ce0f3caa6cbb0b926b480603f37a094792e87b218d72093021e3db18fa7817afb1cdf4cb864b242b89665884d4002c822ea7bfb13d59eb8e298565d38a68ea2a5d5f5d3f19d23e87bf3acadd94377f32e3a8e414726e157c716ddbdb68734088aa12462b59cbb85d6ef6c218459ec5c0b7114c0fcf0e6d8d3d56b7440c0b00c20740f22d267a8d36675d046c8136c154b5ca1a7bc9003e6d5ff4d4c6e73af89d993326a213994e0e322c11cdb6fa7b0f39139b37ab57471d3bac0012c9141a0131671bcb199cb5c682a77a372a5acd642901e7e39c904844d32dd23072f0fe686981c50d847d554e384235cb2826ab723d4e9c1868a07954b62f80183c37967ede3dae90dff8c455eeb2149a1d6ecf10451b4751f456f3d79f70ca181a27b73e2dd504207249cf43a3170cf2b6652125efeedaecf2dcd5367ef826ccf6fcae5d49de928ff1bc5cdb8a27e757f4e1c074e969ecff42415c8554ead78dfa15ed01005b8f4e8cc9c71d5bf350e9ea882eb06f90b7d495cb7bf24218b0805b3d96a7ee21a7f0d2280415076a1f5c389551835f0457dc6789ebd583a3d28a9b7769897fa6586295ae52b2b0c8e3970b5c7843b2f307f0e072b77ac14192ec7ab21593edcfd14d9f71011752488a8ea373ec59b0277468a9a4bdcd902099e8502d726eed3f5310168b48f25e1c5e8d01454e84dd1fef6e86a4413f170c592b5836150ab98c704d1cb16c00a88518e8a232523ce475df64f4f82246719cfd3afefd94958b7b622c0e63f0317e2af9282a5b26aa67f8dd5ae00bb9df0984f7b275af321904ff146ea37ecebe1cc56cffc23a77707cdc14f31d255feb39c2508c0b350ac729d8df5454f1ba3d8b823001c3bf92a317afb4a8fa0ca821307a47c2a58f484652ac985ee7ce4e543edcc765b8a5f0b1b730082d247f2b9fa1c1a933d4753e7fef567df85f5d95d023b5e9700266cc40ac5e6792c3732a8858d4fee6d53edd0da4daddcf8b2dd1058058f0c41771d2e072bb8301896fed633ce667f51588679f40f604a47663faa7178b7ddb1691f6ed1e35f8eb4df444b6700d26fda3869a58bab66e93768e1926fca56cc3064b8e2e9196b7578af220e090368e94d20be8665bde5ddcf3c42aa3af98011d5f7f461709ffe0e6fae463de93534d0f83cb929cbaaa42bbbf774ffe0b7ec03f01334ae55c26d8745257d8a2d8a91fa8a19b3c0b9970a4f5040ce22382950e63fd9531b48af01ab0ae0210ae96e0edc8f07f43b5ede76ffcaabcdd08f27cae2f1174a579a8985cb10e94e4d00ae12781f2ec164e5e15d17f58c39ccb10e84658619f48995b57dcb173913cd4c8ef3a7aa4eaef855d3bb81874f8cf0cbcaa5c31c0827db76f96ae506dc4784c3240b7ec7085d5150f9bd452a34c94ecd9ab72a878ee1bc9fbab5d4f60ba9122a4fd29d2064bad7ac2ea691a3dcefa93d2f80e1e60f6b75fbfcb7815b30f4f2fe550dbdda0dc926a99a80769919384d391c7970aa87a565b4556c3f26168caa8ba33f94285323f3c8be7a9635ec8ca7071d3d5c3febb469b7c9c0676ef802514b345b23fe4c1c827728603f0bae56d721b2a7d2b05d768ae32fc7d8d7300cd21dcc286359cdca100e8497436ff344e721f6e1515b8347ef967d5a1095648dabacf83078b402fe11dd83b0509ece68d8677b471adcd2e05d027364b56d6d0f9c77c8e27e5b2c33e138cc0e1d22bea65421b335a0ebb79c8c3259090419b7bbb1a51c8c3f9a6e452360dbd039e32415cd162a861afff9bb50c6cae933974cdad5edf47608d9cf83583d549f97c30306b1fb618f11ff24f90bfc53d353194b1c6452ab5de93c632fcf6db491acd262d954a74f7a34182e5b7d66309630cc3775c02c6fc53d9f47a2f590354213d7eaae82e012688c98568b42c3898c4c892b55a331c5e9a326e1f4d4ae480bcd19bf4cb548c5bf4ea104cfa1e230e8974210620192b752d49fbc54e8bb56b27be6a3e520bb64790b70a4e869c73445f5fb3efa56f36ab5ae03dc951f4d7a676fc23c978e5c0f1f7c607e1a2e6bc31301fe685fa0e682520147d55fc25c6280c6d79aa5ae60315d4788be691640b907a5d4487a18e7b73a89fdee8c71a7fdb37b11c5ce2c96362825b053870b25e65a721c674b4411fd1116128974db568d6490b1661a37c1f41a634379f0be5fd3b8c173d1ffd5e39ecaeb05cbb912af035e085b04e7a29836b570b6aadafd62fffcdf1f7806ca5503967b4b0f90e7575bdf0fb32fb5a30d0637ad0da8aed3386d18c79864c42c96bde69eb73707a0be49f4fca6dedb439ae7c21e5ab0078346736b9b5e281014eb871b5a7c257fc1f91d7b1addadd445bb0336e9e65ee8ea99e4e83edf0003c73509cbd97cfe128ba817423a11cc61510ff226f44aec86f8d3fe31f7a119ebe1c8e7a38cef4e991d6f242004edb72e71e225e4ef6f7028459abfbe2d091c7c0329b8fa91e99b05368326e691ff084bda390d135f021893b35631e5d1987fd42d541e6597858710f90769afca0311d703cff7d5fef59aa00b68cc92d6a85ee71b943737407edcd875180e0be513eb17f9519a05e4f91160f04aafb8a62cde24f358b077599b9922cc08fb185b53133b8a2419c4692f3c38f41d9afd9eabe1c9bc30764fd56db2897552b79d0e628ef17ffea340b5124941263310416a69bd6e6aa0625adde2533134e0f17fc2f35bef25f0468b4b2bed017f16d3efa0a7f1a521cb62a94d57b70cb4001d945219e56ab49c4f23ea10a0ca9d97b8f166d9d82fb986026aea1f9acfe5cbb01c1319d625c12146c69e5c8eca389c084f744aa457d77b15a23c104161ab7cbc650f3a8d4354369bf831e34086c5ab107407648eb2cc4dfcdcb236343464886b9d037571d08c21d208bcf2461a96de04015a77511334ebe8375bb9731ef0b3d54d08807d9b6ad25f9344cf716347e4cc2c8e6246850bd4852c630b5e1bb45bb8ae00854bf35e809f5b547b73077d6991f8b16ab26215d0c2e2a892fdd016fa38d8d1f5cb27178706ab25215eb47dbf5b65e714bf2365ea69601c835e1fae6020d9e2dea44c11e55b45b8d0d4c80e63c22f31389df65ad68062e08aee9add3dfe76f6dee945e1e761861429d3d9fad261c9d1f6831a38b18560e8a4d64dcd5da23583b1a140a6e4044ccccc6cf7a62329887ac90e9e7ac9117d78e41bae342b714e79d8d6a7bff4d1e784b0b77ac3123971676ba9ec166448a83ccc0daa379eaa635b360a98e994a6d2434a5758f65ef11370c781491d21dd3da8ec79924baf22d25aad19b17149b7c848e9ff8fe942400d2df339eb7f6648cbf256b09c90c8de65f50c9bfde6ffe1ac295c79666329bc2bcff828bbe939705d3c92bbabec2e39aa9b66735cd226d18217197d2793f3ef638cd2ad1e92ecc9d1da9fe4185419fd63ee4508dec210410718fa08505d653af2187925ebb4797a8f1a520abcb22aeddfb8a92ecdce225c6dd5ff556b1139194f9dfe0c29a6c386ec6ec82bef0d0b0ec13e0e3823c79b5fbb2d8cf9fe53a1d22f876c71d19d864322f4a67310bc08a7af63abb687df2618818bf612b00124ccc6f11fc058a838da7162b4d228fe7b144cb62ce7e2ed67be352f0e31747fb4ca5c960f4cb53204b8d546534b23ee88271c91beee97f7a250dd17878a85bb1e627989e47d937a8cd8ac863f37a8709f4dc7024b4fafd6adb86589029cb1e0498c08021dcf1065b94cb65ca5d452403a34b2953b5b579180bbec496cbd21d0c1bd801d2a1c64d290a0ecaa057fa1dc1e05b61312aad927d240b0f600bdeed59e14598418f089f7f91324f7d340879da9f77243ffcad89fc8e44c96dd69adf9e0f2622f89c81561403a262cf89bf41e8f8d4a9370d57a6f1a4e35c609395d62825002fb635f22e10934de1966c7bcdd7cb873e986994c0027b20b2278f2a37b96304384c8e69f93875b904a565edad0625fcbcef1afecd8ee988d3234c79f8c78c50df8ee42bd0249925423fa0cf08b65e94e49b983487f1f0951480293d5611f18f7ab4cd05ffef7ef9741f4edab1ddcfc86feb973cce5a76926228bbdd59ae91c92f7b45aa1698ee07bb2a464e20270ba0f1fd3974d2c2a380e7d31d12e673538abb026e834b0a5c8d4e81c47c602eeb8774d1fcbe41a5eeb2313f6255c2ca218e95d5a322a7fbe246c23843d105b57d18beb82e6072825bd3b7c9b3c3ca711100277d02576ce669f0ca3079c8ebfc632fd2df9b572564fffe4d0e0625ab19f58e3f003318cee0889a686b34d92555ac9a6296b9a39f76f85c74b01ad46ec76cbfaea7493615bca3d7365ebe7164db49dd56da28bcf90c8fcd5e339591475766fe9847ed008f2cab8a37145c1236e882f9b3767b954dd90740bed4dbec15c784f4ee97ec8ebc863e54fc578b30c36d5fc3dcb6ccf1ab0f82b065283ebee8e8653c47d978a71e642662673b0065ece4fb6defc918496f415265661691bf559db3c259ebe91b645d7b30c236f9e19aa0625f7a2027f6f7999125abaf991b52ac5d28acb520d12c4e592c4dbf1896e937c8048a419a4668db04dfcb800287b0a528706115b5b31afe0d5bc141a126986e4b2bf6b99f4e92b879eaddf220fa3ef6f67e655dbbd1f6def0b8b4eb7ff886d84982f2041ef864f4bfe8c0933b6dc8242bc2e0327d65e7236d5a901b329999348c6a4fbb07aee982cfd3ab42cf2247b8864297d4af02e6814b766f941fae46ba36d98337d5c4b2b7f14a624a77e9d77a452320fd49a22dc7ef0329ba574ffcf11c3855eea3ca419bca0d0482a5e49980f76d44a0c9093d6b5632d82336e7b5f1ad56f76767ea706e73290814e4e62dd151bfed0814a7d72a31df722237c754683c408aeb12abc8aefc2ae5bade1bb3302d1f4824b6cc3ae253d8c688a3cecf32c180abe61a1b9efc15f5b811971441af2f9019798d115bbee53637ea0a08c8ed3ce95ac064f145645d3cb792e31214db98b3a3a852602876bebb3ebfc0ba009646539f7110bd3467c1564ce2227b2b559e459bf8b3790a4fd216bd917ac3725caee0ab87e06cc1194b3f8a69195328edd00b7da7740737877abec1a98949a1cb014b6f807100b699c73ec3f7ebf51aaa941942cc0a7177b563ad08a8afe19117ba516cc33300092dc14717496387713f5eb68ab55dbe003b0a541c2f240fd0d1113d3e576e0dde2478497a816c9e3f8e8518f1d0706da00979cc72832d1f01d83b856c3898e0de1a11ce284158f86dea4a35dd89e30c576c67e1dd868734fee8f19fb6054051bd9d57a0d71595a0742fe8b69997ff301984b8f1675e2ac5386e6b12964e4f8886da72a8316b3497b137b9cce93dd7324c1677dda2913c20c6b8bf9828f82205e088fad3830b4deab5eacffd4368b66bd3877f87d477f4cc6979fa6eef0ac0caab4cf4cac4aaeae1706af99aafbd9723e9eb3d0431b2f1306daf6fbe8edf3a4524a917f45e333f3db2aaf88d6d7ce872ec07f8079886fbfbe6d0358a91879d86cf75347d5634af2ecd4fa241b40f827c1696e4d4b326dd4ec038dadbeebd9851b417871615d260565b62094c62c62f8070764980e0c2003eceee2d0044a70b13691d0ea0985d8012f36d3fe9632c4b936f66186ea9fdca9291ab7456e788926eaf275ba5a2ce7aa8168ebf1b2ea63bf3facfeef3770b1defb836f01459cb6eb6bc2450ad1c4d1f6490ff10f9fb7edd290716d2c85dd404596d2f40cb7e26f9a37911e13ad5ea898dc8169d46429c50a75c1f2acc813c5dbe017181b7f49b07f65bb7066cde080012e88396302b5ceff7a2b30780512ec352659920f2a773329b27f2212a40e90f7f93e6d4853405d147177c3b526c4a20ea61fa6554e6936669a04bfb734abe1f081b842e825b8282d3a88688708ce20115885b4e9eea0f18b76fc9d2f7d0bb11cb2d0d60a14613e28f54656284fbfe19a79635ebe983bb4858e982555a46ed05deed1c979386f4b8b7c04f5681889f1642917e45ef0e5fc882b08f3f1c82acd20bbdf29db92d558ba8b5d7fd3548694ed1c0fee88389f2f0a67b3142f55b24667b54ee75b16e8584cd6f5320777f512f1db477b3fb6acfc77f16cb985d23d86c11f04848d57a5fcd14ee9304e9abd68c09abeb89c1ee9a5d04fc67e192aca43848bc8593b153f7970fc84b6d5d90c01f67f9a3b69c02cf27137dcd663c3cfb2ee23ae779f6e28a05e90767f51d06146d093acc421c3af3a7037446583c798bf248cda6ac5978546831106ed4cedf1f77424bb942e278c4b5c3f31abcdc468350b07957594a2809686ee02e8cb564e4a9a64160c9ad5089fdf3628b89e2cbbda6f5246733c5899abc30045ed23cec3f3f69c6aa24896f9b90256090885c3c81059b63703e749d9c37b1d5b0d536bc62c3838409e41de84b72dacb14095fcac4f95c8c94c7329768d38e5518ffaeb5c00e2ea9a215a8733855bdc8be884764bf78cda11df5dd3f38a0a9c00635d30bb77dda19a608471e2e062aa5c6ed89dbe028136b70ffa363f62e8bef32b2f5ee3c644ea96b2105ceb925afcfed0356d572ff877c77399be60f282ea7f850b838097ad898199257dd06b5942923a9a6afcec73e4e3f1bb31441e4735727db26d847e8580b5cd919012d1d94fe84bd06782aa9f6799dc6d36a095d7a446bd65e6b84ecbc84060725a3c4dfc7e805c5d0abb60109531c4acad6b86005ab8af956d3ff2d8a00abddd8d98f5c46aaa46278888719a1cbfc0e8a1ab68b5c45b284c68d97d862a3509866a56a436f3c48a8daa9e42e649cc472b6fca46a82d7ccbb5e48fbcfaf18a21782da51d2575dd76150c2c9faa1883f32275f8c2d66f37216e29d243be5aa87281342a208c5dae52ad38eefaa4ac76ff91b3d64d04703acbcd4ad05f0c05ca3f53bd3568c5c935c15e50dcb8336c7f162d7bd8badaa627abb368b9b99b4c18adca7a3a20f9666bfdb4489ad7ae53dd16fd6a6f8d17ce2e89e70284ee078586614012b05f7ff20595b5021fe72125ec090baf22764c8c3238d3bdab08e59548c648a58e6c76189dfbe3eb35912d39aeca54f2ba5faaab3bda94216e8e12de7ae6fa1770ba56bd281a88a74a442020effb1719dc363b73c35365c19084ef77fd3e5cb0a4883a90b06d7969fa8e49b89172636befd518b6e2c8497939dcfcbb5b689f5a4e08024097f642f0057b6eeccc7de304a3a72dd8719121ced31fcb5a417243e527f434b7dee35296db3db7620e3671af89438549171c94a25c204eb820d2381797c8033fdb8e7c5cfe9e88dcc880988c654729beff0c56e0a8214e721ddf9941e45c2d434f90003f5eb4e1e7650f1d92ac499bc074757650aa5410b5d2a8fc8b53b4ba25f85be43b64f6c1cd0c39ab70fe0bc84c99c14ef487f47c307b407f2ae8dc98aa49a6f40517603dde40d2f58d7162921b64056f0746da129b612ca80605531e42b0e55ef7918f782ecb311710082e4a071b4671c75d3fc264edae10ebc4d0d18d9c82108c0c5a7a520be3f9ec8fbedd52990865756d3837f86bcbba87a3554709037ebcb17a449eebc6b6ffe46028acbd5b77c83f07b9136361cd764c31ded60761488d9739b875de1ae1815f9ef4e82e4843588ea0b723f7148b65736466abd5de2ec1f3bccba12e5d285b49edd8699ff07d05b6ce710bbfefa2435291678efba2a64cca043a21b4251a56ebd40509399fbd5de86ac2c062ddab5dc06c0b4d254220b8c29628e1a385d4164cc9f5c68f304fdce81bf43b389cc151d1eb1273c3739773231ac066f75931a87cce19e4b57006a687fb17ecb8f4d9a45e2dfb567bce748ff39ed9f23667f80828cf020b05776d41c79bb793aa43c93516e47d1dfbb6232457d238c161b0bfb49fe6bd9528d1c962ade810a19e2642551bd5ca86ba3ad7d7890d6302cb41fc5172aeb03b7a5e3c917fca71307687871d908363d1ef984c5b2f53322fd07f3bafb08f4c5fbcd7ca6aec0abb7c806267ee6ff5c7bb126da1e469670f1b6909baa5a496fdc0dea990710f66083cd4dcac297e0e6c8445c798a62ffcb0830f9c09cb1582192ecfb922405c4040df88290581d7c5ddfc37026c5f26a1180f6c7e3808c5cbbee37d2f5140bfe57028cbb01c710453f8128a561ed2f78373f4fda34e437880564ede481243a5d9f7f12784267fc33afddc824dfda9f9f4ea268f117e367073ad6415881e175b6fdccfb140773562d65b5765df1c22222395ec9e0783862f398a06db516dd6f09156f210cd1d4c6c76afd5de1a62a9a55f268a7e31cf6a1324ae70884861f93cd7370a66670d2748c237e3d240b637d10040eff15751c937c90934b6a04a70946656feb159b1dc7ef282c13d8c6c1c0ebc9152bc4d1640a956ad040b06521158439a1f78de88137fb7183b7873f6cf129b935f4cff8691e73a27043c4001af411f0c3e2f57a64d98852a0eb00914de76a256b763604d86d4f7e25c1c1b1d11cbf0a3f889703a77d0974fa3178f4d1946d33f78950423e94f672e19dca1be8056d201102fed16347b132a3aa534431f22aaf73a8359f5464befaee50fa448a3f044129eb8c04d43d433e603aed88258d4ffa96092778ea6550b926bb7c8a8d927b53af25a55bf90e2cc93e415399db7ee64119ccb7ca31edc764c45c86ab44eeb168b09147a5f7fc06f5270d6457538d81c8e188d7af14acd2b5fa745f4de2c734fb0306ee50464b169ce4ea684023e3a672a14958114d789a26044ce18daff654ffaa53397321b6ba8f68f7a23896502f50618e031cf238ed6575179404a2b8ff94e2b8dcec8b35c62e0259a0cff5d78a81edc49d1bd3453e909928e55a009aa1ed701987467881f74323c28c2e48b807e6fb2fd9341d6eb35ad1ecd6999b201b00460e4ac1616fce43758a53625a5032655cb903227bc3a819cb5e2816c6729d4df4e7037ebe06dfd1842d5e71b353b0786b1ef0bfd068683aecb1d61440acadc9662d1e1f92c6933e97dc35ad6bd725bd24427a2e3ce73e9bb2af55627b883babd02efca3965291931c8a46845c304415a04b7e034fceb274b04dcd590b3ef2a837a39a23b66e6444b9d55fa5543a193f64d51d1e8b3974cca7d8678d7fc03273953a104195b2fd56c1070db3b010c23f9038eb0886b236bfee62abf91fc615359f8025bea7e7eef6c3df93135f1a25e277fd84a2eb4998eef8744ce436cae4778af56d824ac320019defeb8787a5add6271e6ea14089563ae450c62b3011338610f4276ed44b1f9a462bf319fb764ab065b9132e82e58dccf2e76805f1f5eade6b51b23375ef215fe516b3f689b2b9448e9ff638cf859d2e6adef0420f6735269b3691153497f0a0cbb52985734a5eae299fb715318d638e00c9ec95fb65c0db480f66cde3399671e3fc67dfe4bcc1713bdee4672ef94f9fe17b37d6a25825d0bc1ef878ecc276bb03085354de6aaa23a5a3b6fd7002a3674ec06bfc34935fae3e61af8c29c7a2f42797f24ac7d6f694935a8391da27d5ca4518a56aa2d29e49365239b698ab6e1b480681dff786907ab405ed3abf27a1f13f1e8c198dd13750e9977b4c838370863498787d101e707018e2408a814a510a603a9bca3457791c1a3353449e1dbbfa44c572c7517b53337d179494aeb631851b3bfb7722b9b604dbb8517b95d6c4d75f46431476c2be042b3210b9aacabdbade9f914755e08b70169b25bd60cdc474ff2d7109aa7b5cafd7c4132778a93609d6f80a65e75259ee177e08f23bcfd282c45f3da9d03364bfb2d0149d4e81e6ffc6d34394ecdab9d6210951e970aac8740100420ee72c1d26a4c5dd0380ad6820105267e56ffe6c225f6f30d8c84f8773eac0b5136607511690cc54af906a3c51714d286c0c5210a1e9a7e6945dd77005a8a7a150c64854963cfc7662f1f44b30496f8bf1388f62336a0db7ca800d378e20d6756d88e38bcd96d40374d97a42c6227fa98c0eeba6c0bcaf4a401f1549a32d713747387254744ec8b71c07c0a17137cd6623b5a09ca970ec8425adc8ac937f230000ad0c2b58eb5ae060aed581fcdd48bb2c4b9e63de3819632f7ecba984a350b5ff907f2f774a1f7f42bece8f9599d66b85a16fc2aad968c88ee4f6ba3fa1c21c44a497ce90439a29ab137433671e712da1d29d1310900df6a32d57e93c8e45187b43d471ba1254f90310e16718aed91d7708251c8d16ced0726b55912dca284706644b3be3e3169ff5b69dd6b8b650b6052a53eef6fa475851bb0861017f6f569a42ad980fb66d6229bad0eb2be3519d50e2f1daf94413cdb60b338810a945eed64e713f7128208d94852275032f29892dffcef22c47cba2b470102a3235323d8199069bb2e3eadf179744cee7f432e59693cf406b68f47775468871ef330b84d863a0733d48a913d5f4dd51013e3c19cb95de2f09b43a0091a2f1961662c65b9c6f4f1bdda6b58453019c687fa4aa5bfd5f1b6d91c0948c6734ef1fc7f5c0a813ef0e1ab72411e06c8cfbac112373abe8ceaef7def71ed639bbad20d5d900bec52c18c4a8578627146773a11431b859ac4993e4bc3408b5a750c25d1e195a1cd224725c53c935c93822eed949c4910e955aff652e75b26a278cbd1dfce6dde3476df0e92f4eeb795942a03076993d9abae2d19b1a50617387bf8622da3a11a3f1b61a7369d53d3049b5ee838b70014dd900768260ac38184cd9fb494b9af6f6b3ffc4a6bc9173cea89be6ddea140b52d6db6aa082c484372c5e2b134561535735dc12cdc38b5e1b9edb4b7c57d1f10329e593dc0a7dc4c23d1d8ef752f82050fceddcb9a0f6070b5ca665bc17e27cbee2920b689f74d9c398ca7f9aa323c62910abe62552265f949ff7f9c2edec7342dc9517f0e2ef97f12475a97125f496118237ad0694df21863bfc8478a6a5012d47e2e94dd214d6727bf91507e8425781d181aa6d6cef79fdbc779757a30e85c3ae7796a26dc8ab044d253f5059d63f4188089fc11967fb91c190bef8d88830a085a8e854e351f8d7152840547e1cef87efac07cb12adf870ead3baea1a7367fa9d88b377cafc2002d15c57d59f1d211e5d4fd9ed6a076322bec662fcc3b81338c86c2c60cc4a0dda92e87847441cd4192f000585b597a2c4707e289d6712169d87ccdab34ef30b1a9dd1e52669465b724cdb7aa93bc2279f1850d383f141d98ecc439dac11236352c2657aee38efeea7b511a3765176cba1d84a907910a583e5a958f2ffc6b491d95ad939944e97d257c1bc16ee59dba2dda28dc63b4a143d0912212bdc45f1b111db3317f8733050f88c949ce68a8d011e7e76e505260f1324b364819adf2572a91efbc5de40cafa271479c2c89d54ade36e87db72f846fbcfa48704fb8d4d962b10f681caf2cd3144d3d8ff1e15592924eb0474fb63903658b662cd4d893e44b90237422fcf4a0e709ac1723fa19befc7a7f6cbde48201330054103721cd6df0290290d1e22a6873a7af7b1b107e27606013a8c6ca205a3b7e07b4939cbe1891439159fb0535b33477f6cbb14365363c7a8c527a43f74e7d4d107699b96ea74a55ffab848d8104a087402493f77c49e616dfdd78e55bd2d2be0822a4cc58b9f1ddcbd37399727bcf5ee0d7fd0c6db979868e7be80bc232cf424d6ff42fa9d6b8bdc2b809c8d4d7b1fc6a76cb0c43ec6dd169e08f7b13caed101e29b272c2e65ccfb9776aada7d41772f9ffb63c043444c335e7962e807d4de3752030ef19c1d8f02f9928e54f7dbb734184ab2c79383b17ce17a05df3b73ee2dd189872005113ddbc4acf2a00ede7cec0810a9ceae95571c35081b05e94e9532f00eb9d3f564395207770f4aabc26ab1282e1e518ccf00517b09cb4ad7bfdbf6607b28015bb1805b5ff3b10a67a90a894e434f6f7bbef69e2770da84e04fac44741a4fd119acd10f98eb6483570c3fff486b4c62347846b163488aeedf1dd382c34c93fe7e28608bc29de521d99c319f32179e08d355f8eb15d5ee03b1831d5e250ce504fc5a08f9b8d4ad6a487971a75c4cf3f5c8e3afc7352b21a1b4529e058a1383d15c3ce03d29563060b7860b43405460a1fd7fe82e7d5d0a4850533428d1f7b03f2a7152b67","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8c66ce548f3b7b1ba0e5dca6a24f0010"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
