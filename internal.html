<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd2730fbbb3ec3f4515883538462e71317d912c3fc92d120812f93bbfd37da5a3ad966481dbb1f00da88c95e0263877514a44af5086c0cdf927776ffa2fd62cb6541c7141481564a1371b91fb7fb7c97489ad74b1e8b6cd059b7d79d559f5a63bbea5437d6f05b9b76e96f7aeb6fd299fadfac52f99fbabf24c704a704fcb7af117b87c131722749566528232eb97a15059ba23bc966aa12cfecf20bc7ecb25634951741ce55c42b9ba68e5141fc671c0fa1adf19863ec19fffbab0393e49e665061b269b17d1ff0196f8b23586d41d0e3fbf4100bdd0101f796b65bb45c7eaa0703bf8dd2ddc7ef6364f0491938bf34d368aa39c6ab5bd46e71419cf592c4ed8b6a69e8436d8bd12e9ba645fcd6c4f01c30288271d420881bd9d0f2554404ce4461a5afe9d806ef6a41ffef9978f51beace48895ef10081a3690a890d5322fef2e5b45b371e64a9d58cb2db733402a90b10b6f5923468d46e2533150741b1414f6077d72ce68d814c25a921f62337383040ca3cbaa2a91592eac12b685de585f9325c31d49d1d15dc7e4398daacbed855c53fa9c8ba76dd312458519ee39d25f5be1f5060364e277aef23791d0e570e82c0f610e11806ee9df1b0fac3e3b15ed187754a06dad29232dadeb14eaecd501ed544ce531151b9df63612a8768aa714e061fe23326494b34cf47bdca297eb006826093d0dfce157bff76eb0dea0afa42af2a93318eb4c059a535d89f3b16fc373fedcdeb9db80f1fb76b53655adfb06d0399f80669bf88009d29a02400b632c08531d07923864ca22c0eadf8a1c4f357404040ce0e6a3d9e661c8604a8fd1a0891fd24c484ac1d3da71ac56f3d1124e3f0a754550b21c7d9729f0ba765fc641d3a80ea82e4d340ec8c613eccd6d45d27b21fc5aca57652ffbbe328f2d1f18f1b1d14155592abc294d174061ca1d8950aef04e8a01bfe9ed787c7b74767a5efb7db8137e8ee445907b6eb4bac328729b365ae882cd2395d0a777bca193b2b210b864fdd7c19c16debd08c27fdc73be181b6b717385f93d5e1736bd5963353d25ebadb149ed221cba1507de10658315c0bad6fad894e95ffacff23af236e1ee596e5f8e0f2bda26cfe3576cc67aae2fb848233fd32619a615edf1e6ab3f605fae20034809b0dba38255494f6501fe525ac535e3115e3ce6c806216838e5a5657a46d3479db713faf1e7134f6633cae463bcf1a6b03690464159389fa626c990c7dce30c6417ee97c3417036a572928e888455bb928488685398addae524573b52f73d042808f8840ab93a25be0656cdf7617b4f7c63bbc5c74703d61b3ba15c6717f9432b8fa2bb87023a46a01fa93f05f5c48db2f645ce241b2b9dc5c30dd64393592f6c47b886f39c93746394a4512bfd397ef346f689cf01b171da4e5f263fe45438f465cdbc2e855e6d26c014a54df93cdec704dc9416e656bd335e3ac5001582414aaf987fcf7f0512a5ead1bca54ef09f25e6e5c715d9bf362ea214a337e0f918b71a33bbefcc43f4d6e752e3470363a155b41baad6438739acb6cb24b4db0da0393a2951243f446a2cc009dd1c44584de3c48ecbcec014ae52eea79f4ece312e75f3456d2039569cd40e8ae7e8b03e765e7d6b98f455d78eeaff0ccd68eaaf3b73231a1f177be6aea5b15bf704e98d2bb5a4d50f58d142c841c32f145e505215c1de4853d7fc838bdf2d8b52960eaf1970c467d8ddcb8da62f817469390d4a75e45e91e6bcedf9e4a160398f4272e8bf5ae67ab8b779b6b953d47aed3fae0dbaebb61858dd9bf149f0a6e081efb159c9ca3d244b31d2d3162f5bfdf9cc5ff8cf8fc2f116ff57195fe76f1eabd25dffa3f71de14635e803c6e82eb6c60c2c21bca7039648a8546460bb9c0ed768f48574e08e64dc46e387ef1e27c30fb64d65a0874b8dd11aad1d5d6c9b4dae853d32e12971756e28e2ba64d5ee5029b7bbba43b86f83247acf3885b765a79df4eb108dc4c6dfaac4f03abf8f00634445a4809c4fc747e506dddac1fa853a755646244e368e4360c46c50a3692c7c9113cec90d47e11f21ce64404546f8e719338b5cf22a063490274249475095cc120e7a6d73a0a36d628051b5ceb2284cec48fef10a5a7815a07e7f6257ed8f294853863e2b443d32d8cf556ce0d2f9b8852b97e4667d2b64442e0be6e22d6c9fe4301c8938d5118f680276c2674f581ecb7ad148492303ae1af0ff86ed45a5abe7c1dbed18cf36e7323075eb36713fa8644429c4ba7092b7522b4bdf57cdc95be7eae4ab469ba69fd7dec74fac8431ac551e33c7cc0925e5efcbe919c27b3740286713c95a3858b970290e20ca884720e1045316c18028f8d49e2aa4f8a3267bfb142d60cec70c96783f38b0c95a0c673f38e4d6642a78bcfa9e5fd9d7b92038daff7507b0a7174a7ae939ef5c4336da79818d0d72929bf31427d0a4044b9eb8242374e1b2e52c4810b5ec8c917933517018f1ceb7620e85bc486269515da462382ace183b67887ca6af835101d1ddc570a324632f81c4e66053661fe820b4aeed45b024a831a83081111f330264012e816da2c0a388fc87b607e532f54ff4d5c5a7f080538406b33f438de3ca568092b3567f46efca91c01efa50c45a4e56fab3ccf93ad635386c492cb79c6d10ecd973a7d7beb8e9710d01b4e8de4e73b1e87e8aa410e715a5c67321967fd811bbdf31422c89b429b31a53a06b414776ab9321cf8aabc7ccc2a31a72f9cfabc9114a0bcd9c1d4802c71f9672d18c0c0d8c6d7e69702097e66a8ec7e66044b5015dd3d3d195ca644f4d832c5a4bc655497dfa004a26a6506005d24d8bc2043e32eb09fa2220a62f4ff82acf27d2da9439a2a557d1f5417bb6f95682f79482c3e6d486502cc2c3352e985c679de49113ef14c29830a0b1329a30f6de2e7c99a5f3fbc3d469648c3b59b150c2e1912a336d934261d5e4608f1dbb3c379fbc705b010bb7ff9c7b89638f68ae6bc17c25288290d2e1ac517414f15db4e1eb2d358f646273c3bb1702d513bff7db397965e5077f943eaa9770837c5f5da9d53e16a87dc15950bd1c374a32b058bd4d6b1fa0da676da821f7f46edaa0919e836504ff5df3d7180dfa80ab02e5cb108e6df5313e9f3b5f2c7fa156146f44c230b2467fbd33ae95509c3c305752f91e4067afad5436d7da7d8990e2a5aedd97b828c51316176e8fa363c52257501a5e9521b73c57b55d1c01ae27b469dc6e1f9c9f25aab4977e7ac6ba30526dec022e56ef191aad799eb8deb3fd62674cbf685db9365ac2e17a1767bb78835984c809314fdf21a261aea7ebbd00b88b617c92c97a03bda95e7842bf64505ab16b99a24e8f77ca96913bed4e3beed206dde26f5a2bdb87e54cd3d8e7a15765218e01acb3d69098ff6101b5f45a28eb1b5013bf592fcaaaf64571a2dfa87e6ca1dd9c5274f46a6c6915886a784f5babbed080fcc6eebe58e0e0e057707952fe965bd9123624229ee750082d38be9f67ed01f61ac8a2c649f332c155ca2373944c70235dd2cbfdb66c892ee6200ce207efd16f261a8c86b7441df40149e7f257502327133c369833df02d3d4ac5b9cbbd0e8d14dab0d6752ea65e5eac90308e9e821ef8b28bb5febc66e65e37098d28db99d0d67e2da2d6d3041efdd977a839d36d7c6276611048e8097f53da322396c3e18113bf073e3411f3641e9535a0ce2ca7fb7b56480c3dcfcc7f8f5069e52e45aaff69a4fafbbe0522a131d16bb094e00871ca81388152eb5c26494333b51eb57aa44fddd3591b656937c47298782943ed5bc8027738ac2131e8c0f5203f9e9e6a033d60ef284f4d28d18057c0e3958d0f5990768ea5d35a78db44a27d923bcce4933f25e056ee2031c371e00d9092ecede0febfb35c7a29a1bca156567b6db36a1c52690b4e1817eb577adc0226d7fba63c6e6695f58410c34f42997c2ae7e70e1423494987979df0941b2131e3bc12639e909c2593ad5cbabbb09b64bd516317550968a7792f8d0bcb4ff294e4124a69da84aafcfd83d74a89d36ad53353f8a4c2b5949beb8e286366fe5581f852b2324a849b853ecccffd0153910ca3b2591d44218ffea75159139bf3646aa28d105358172996348d1afd9767b14c0ce45932c30e917ba4eb732d96b2ef500cd9a0840e445381a90554cee5ef5caa1d398c6662a0ef71a4e71a4433bc714d7b0572c93a3b30b6347f7a025e5f0b985ee0911f79fe8b9d3f819bbf7e28955efecb9ff5b6bb626b441d9f4a9f0cb5fe4b00fc73479ae997bd7574fc88f043869415eba4812f71bc1459860733319b011be08afa15fa37c49b4ca8b9a8c5a3b88760886b790675be1fe8f596cdc0380df164aa9943232f79401bad6cd9d1e0a8ea7ffc42d60c476323710e6b5bc3029e784ff3eb466b7a0a002d8d2c6753ae6175b50171306cf260e06ed390f51fee0dab0cec99f9b839451f7bc7af238e098509a9071e6b0e6d3523221ec51cae1588f097b57deab376020cfa6c10119c5611e333e8c1fe3500d85f1cfb2418f23b3f5712dd30d10a1bde75ee2e1c53da3620064f85d769c901f1fb5a9b177f7b26a14a4c960d26f65ce688a815daef160dfdd061161e42896887fa3feadcffbb367fa2543ce814b2eb3e80099c51fb6f38ab631ef8396c1b6ef8a4f3b7618cf6f4c65d96c6fa4e5e86a385a1b45bd2fc086ae0722d5ec5884e77ca34b085be4f4b41f1b533cdf1e950ff46ccc52732cfc2e05cfda825b1bec13cad351a85aed0138b140ae93594a0bf1e3c3b46276147bc3915362558c1317070ffe0896c327c4964fb7f246b97170618814e2fe502ec766d7c51e3027b1b4c0ba3711001c16753ce66dd2835867843a4237e1aea5579d70af5b6ba7879ee888806af38a88172b393297a538677c257e3a0d23b6fecf2f2931de136c35a3e8860d72a63478f412f4ed873efdcb60f2085cdd1b3ca76ba25dec83d1efac665cf8166279349d7ebbf456c55e8b43a596181dccffd9a32ff8431d65df08ece09f88eebde256c0d6c36a82c23bb57dce52a92411e68a9a57e2bb2e88eedba67ce0d69a9b078f454b533565ba3dc4a24d8ad271924b46012d9b67ad16fa6c5f4989917262d2ac1373b0201115ed35cd41c48326161ede4f3c98e305da5049bc0f928b4fce32e1ef2782d379bc462f3f8989f10293add9eba01f1f40b74aba0cdb1499e54fbec220475f537639190ce06c4afba0d363f1c8a96294c3fe59ea966bbe289535930e03d1be25480c455f3e367e257d4b14b3b48d2e4351224d79103043d8e31aa9233d07076f227ec90addf3ba853eeef4a83390e0311ae5e6b34c9490af97b6f43e5b86841af511a8889e8ff36b8b7bd5dcef3f93c8f73bcb7eeaf0b7815fc986878e52400da03bc3c5010d220e961c093e2c73f10ce067ea7f9793498cbeb2887ae65e0d593ac8591415434964c5d376df0ead4309f135e52954a096b025acf11c2ebbf126d1195874e88317bdf9df80325b1b6f456a5080ce97a02d77b26a04f554da6dfa51569719d3d443a6416820b356f1a299b85bcf099adcf9b460286f33cd0f9d0c897402fdc3096a69506a5a4def831c165e5b3d319f66de49ccf29f0149e2d5f8c391967c5ec2a8a24f8598d386b6aae8848a414f939fd2d248a145730fd06041b249a5b1d2eeede2cdc27621b4af210e6066a1d25b96d4a91ad6b0f192748a08dad067310f091db4a4857963e12c63694ea04e205a32db30622d4f5a95af751aa653f7fc9716e14b1e928b167742090183c4438525c8bccf2b09332b5f00c0f93f3add82cd25da643b3d01e6fade60c8d1e9e22d8ff0914eccdd4fc6a6700a17b16463f76feab9b3b0ad66a287cd1a47fea1b7bb7ee0b102f46359719027f57f54159ad0da40e1ec12d7e2a38d87574725209a0d4e860c0040d85dffceac689e838a4827e8408b9fdf0f50653f8130bf83a3762db1abd90813714f9c6378d7521323a0adedd56c20e0310ef8ef9ba43cba1bfab79ab26a99b0b6a9d462c80c6cf55fa45682d9984de8d955b52ef38ff53dc266050e15b022d9e53d8cf95ed64921553b93dbd780d91e968d9758267448d7bdf940d666d5ddac87052339f72bc5525d8ee39cb3503ecd018e23f86b02a191f061ed3dbfefd3e21192e87f191be1e1fa169c8db990387ea1f8b624980327856a0f8af33fbbec35aae3bbfa3d4c5198ced8855cb7a185947139f16098ad241c5bb218262600254fe88502a10a2cf2aa1f76d2a17c260ecd1703e8d839e5d4c1a56e6598bcddc5ffa845c9c3166dfec7e601479943807610aefbcb66d4027a217c33e4fffe41ca520ce2c69a864c15b22072d5f6ba9026eb7d83e0d1d7d829721c5359de686a45e24974a1179526d31f89c3f00309513962804aa60ba81962f86f472426b82306e0b44840ae8aa55ed2832134507ebe94f111bc83b554038a20ecc14a3e170dbe7c46263e983f279348c3d0b5fd448f4282941f8dff0c92d18a73a1c6fa0630cc918ef95cae5a20767c27f1fbffab1cd503ce96d81695ef24a81cf19d78adb5a14a8ce440b7d0ba861e822808d806895c9f3b0ba83a972718448fa7e026b42c24cc628e643945d0d023be9b6a10566384880504fde1e92f9fffc7f09b5082ff8820379534edfa2c4c527edb5616ab92b9d82152a3521fb9dbd38cb4ba545d4cdb994a0bd4302a1a5b776b8de6d47e7856d9536d2463559723bc056d8b71e5d475baa37a570227a93449b3abe5737a41c7a37f71312aa4c6d5a48945ac9c6a641d0b1f25bcae47a108de38c3ce9ab5b0a27be223ce88b00c8edc6a867914009515210bd153ad499a43881199eba9a3f7d0d9abc0311abb25864bf7c65dd43b34965b10ab2cdbad01c3fbba17a0afd84c4515d2fae1fb83b873b1d4390a7b79ff3f69494343e4968b90c439fb3730d1ce8520e8085382177c2f6e9d7402f4674497806ae798e02124c8858a7da75a12af00cbfb26ded692a9d599f8fd0a802975de009741a23e951dbbf7e0d09f538e8aa979d417cb1a914f6498410e33842ff6161dff511cc99e3f6f87c8866951e2ed14e03822a6fabfc7f4db1dcdf83a81758ca8585244daedd483f6a8cc834d4d584335a2db9a8d4b308215e2195dac2636f74569679bd1a230b3d7af5b011ca00910edcc4dcb44acbc6ca8ae25019398c02b7fa9e07fd5ebb67774d9c1d5f71be008731a094bcadd7a30240470e1e84d16cac3a150485930ac8c916d677210add55691ad47c33fd69276dbdfd508f443c00b6cf1fdd338283b91c28173cd26ca0e7cfdfb0e21822dc5ecfe4caf8ad4c1640deede34a002c6ca46f33b83112c81b31904aae63f238c11f4cca2245223642d572890ee840eb38e78b6f26a9950f10f1a28bfd08134ce600e4afc6796905cc5488387474bc91b02d7caee210e69d08833f074ec65d167d60a6669a2f4cf3d0774791eadd108005b7aac8f9be51d05c67b457167771fc85c9ed56aac5493fca78778763adc6a3e32effcfcc8c02218a0c7f37e79024ebfc07d48b0febf4bbdad29f9739fc8e3e4abea34961dd17ade723b04d3696438089d86941e28f53a5c62eea8c26d83fa979b8154927faf673b463958784af837e992bc7b0718268906fc56f23ef0aa02ce1323d961b2bf3189ea4bfd5dc5615417a1d5ea0aa31a08a0162edd31728aa052aeabdca04c81de2265a43c3adcc31789f6480e1a60790574b7ad2b825f6d05609a50602b5697f71bd4e3d60af69b30cf507cb13b8166782dc8d1014f703176111bfc4866a177cc34179d6ccae836a392ecb273425394c74a1c6f412870577fbf36faf295f951f3e11b3f59572ec1eccb242daa59a55ac0d0caa34000e70fea2d373401460f143de0ad7b569ce599413c0caca4a4eadbd4cf8e2ba25a8b1eaef8c16e4aa74e8662d54b5d9e60553aa5cc9437fb874fc42b716cc329c9716453df28cf7a803b9ad53a2461cf3aa22456300354d389ea308061cbe681f8224ec911a5a3d06828fc9c424aaea3ae6de0fc8f37eec934ba678bd7b898ef56df85eda88c765e3888134a9000b4f593e45f0f260f97c66c19448d34425757aa91ba5d6d3f6ae9a3f83b03414bac2287358ea519b155d1b241217688c0147d01595708174ea95b7265c57aaf803ba9a3f5e5f6afd89cc9dde41baa6e63163cf4812e6ede83f32024f7b523268490aff6a1ffbd98b71fdb77e15efc4733d2ec6a4c51857b5aa9bdf03972d8d13d9f6e88ea9f27e93ce523716c568a9b670a173c26f3741d0e56f2787a4d4ee00cb1562e327b94b8314cdab6c2c071c4137b359aaf6b7cbcf460b0029db36f9558c3edd3502fd05fa0f37c1b6896ba46cbbbc2b74241392674f6998e1485c4eab7b5bfd7124567dc50a6a0beae9bc72719eb9a02d12552dd85bd2eef8ea008d806097b9c41a3735c294679892a90324f80be3272af936a2637cd869180f510cbcc15f5d0978f5391b076f8e14f130bcf8b697bf9ebaf0eef3144ced90013b737125021306b6fc3abb163c95d50e31a9dbb7a92c274432340848f6eb4c2611ff4ff849b986377b4f44fd22697d4aebc227cba978c25b20bd2bdee12692469c826e9a0968008c36a8460a546023fae84ec994f79853654912a0d3d0c60ee18b722c7c45c79057fa7fa3a66701638a2c23dafb4790f355469d8548ea6314f0396e06c8349e1e3090932bf88e73f5eb394b15f742a53797304fa0997757e0f943ec01056f2ae03c6f130368533f008d0c99316f21d9ea107dc2c1cb29e4b5e043d354a88fe5bdec571fa211e295329949a5ae95e5d349bdf7716390cd5d16bb4b7768290791e31ecae282acf72616447db1d55349010b264031e36519b79b2dc6e39b23d45061ef599103808f51d22a0f372c5995e6e3b8319e4b434ca6dcfb8ffa381379fde366f69d9c200ac95d824796a9b2f2e08bbd9ceed6121c648e6821b4ac1e6856ee030785d226cddb6bfc1c79244584ca782c8b5e073e76bfbd114d4c0c2606cd5005407824e782e26e4dda816affd3374fb8209985e0e60162fe29ef123fb8dc130dfd5e7fc7f4888721e523b2189949943c1a8deb50042400bd876230c56cb8c0d32b957a75d365aa6001ca976dda6b8d842d91658c576911f5ea8b7d274b1a82a3a5f4d583eb1bf8d599079a05af31c6d49bad0549bc704f222c21b6e300cd3058e1c7bc510c5be10696384a396562b16df9f8f38aa76d251728ed524ef32eb4bcd82d6afe3edf5a7c7faf9892c21688f7fdb19973bb1e204f88609c612b543f24f9348311ac6a42342a29859590b20cd70924521f0c5b31c274ec5e80f9d5d721f168eb0bd6e5d06539d4fa234608be4dde232595a6066d85da36dda569f67ece66e106af561588762eced70a9dd850c6c164da096c55ac4839b32787a95bc18bdfaff06c7f565a38c21a4c7f35351e0ed8d6aff830be99ce08e5de770e3de4ee7a395dc76f4a200098cf78caa6270fa39dcd6e5115f6e098af4986e928a01d0157e6b330b26a21c2da9d223fb11aa83bd1572f94e5f70abaf14a24162844252b7b6461c3c46b8fe8796d838207f7a722be89572a87ec78e4999868c181dbacf33b5d7292853e2b458598eb9c67e3b20fe02e3bc63a0b968ddc304a518078f5af3d17648390f6680ef7a7746cbf5b2f8dd5fdf09859029f9371b73f2534df58b12c82b9df60bf697d691070e4ba0214cacddc8b018bc736da923be35a0a1487a19cafa8403b556efcc553308848971cc15a8b8b7d708f4d49c3d2988ebd3211fc686ba07bce20fd99597d2ffe46c3dcb6fd8247fda0fc880c62447ddf0dc40f7ba9ceba457907ba34a88a201eab04ea0a950bb869e1a29771fb84d8ed99bba700d84592ca49197d9a1e6cebb68a1e9055237000d614508904a8c31b6cd569f4fa426ec481e59bc62e1a22340bb73c212f805be7e691b456a82cc7cde19614cc0b4375244e2528ff43fbe51ffcdc634c55c88fe1202b651c0b3731de62ec34876385521e077a99dc511befc8571dcdeed7ad3105751d815970539854eb9df55af51086796c7e5794bf7bbe67b4a8154ab4167743f416f2600fa5f1b1d897ec4de8691ae6fa2539227f0bf883bed302977fc617bdc49809880322ed71ae0c7e6d7e86ed46a6dd0b235b0d23fe9a58ef022bff161d0ea1a90fcc7609622a6a064e9ac41748d8c0508d4b214ef0989bba035cb69f691af5a35c7ca0fdd43900832b9b6bcad0c76fb46ac6222a31a450afc741f0efdeb1e8cb5938fc4ecdc82af715e4f7b2c27090af599af47382041a4fac2d31b028f29337f83418dc0f57fd759732a54360e074fe94e315b697023c21750f73ad020374be0a5514486df58fd501076cd0b98fd793d8af7158c08ca4e54792184907f8bea05713a65612770259695e2956b6eeb10b15404a41af102c2978f541ccc2088cd18754cfae430e9c8aa2ce31fe6c01001b28a260ab46cafb4b2a9b08fae3b51498040e3fb452c77a36a68071f1bcca38039452a522f280a13837f841659239f844ba94692f58379ef57895db83d7aeb90437b800a17c92d939e7dde09ff521f72638a8f0d1f8243f14ff3d178986fed820b628dd495dd4b02923302deca35b830f21cc2afe875ea974d5178226b02be3bed6d56b0951e63e9f07c44f39e5aa76995c9ab3f9fae500008855f66007f43cbdc93b50ba41f22c5b929fae13789c411cd1ab1d298ce85e577b170f78c253dc0a3618afc38242d59da94f799f31dcec4f0bf472cd5427b7df0ebc368c5b3e5eba952f685f989319716318e3401f90bc450bd89f10de044d248f30e4f7a5f647db1e92630596115bfe366590a1e496202f703675c5694f75f1ffeaed9fdf35b31883edeeffbdf3cf022a6c976986c5a146fd0f57ac7e73c1b73c62c20bb548b39a406756b362a8a799ccffe992166945025d99c844fe2f1743ad1019ee94771c11d25bb474c86792b66d6a3562e072fb9571f2289cf723a1d71bd490e7bd9bba883cbd8564edefa456dc949a17baab6ae45a8cc38fefe6f1418e8e45a13295724ffd8100ca63d9bcf76f617a7e5cfd7a152e87f1f7de35a81e1e5500cc9afac180fabbe7f3ff35133ee6761497ff43648a7b8a793486977881139f8649246d36762ec753bb7a9e743683810ed23ace5540a462c2396f19c07301c0fca0de1352536663abde74881939719f0c8b8a39d776815abf44504f156c5d904ce15ed283920c9229e58fce328baf5fb0d4af1c1e28011fb58f69250df8d065a51b270493a3daca44d1ab0ac2029bfb208a28be0ab064d561f962554d8765225153a4510393bd27b205d1d1ba7f774ff3ee54000c09d25f852e1834db1e840b26ab0ff8a2af086ad7e701a43ea687ef3fbd3261f2edfea690672638ab9bd8c2cd48204e3b678f8282d075e9fdb3bf9b7f0bc2d6715cf39dbd20f99b22cffe1bd7339d23b1b14f24782990f2238eea1a9e464fd84258c4d358195e6118ce9720e4b53162d3c9b433f65108898afe9b10fc785f10edd15f4774b4aa71c4a5163972c32c499eddec82ae474d1cbfb5900ec21051b584e5d25eb500db4856e8196f81ed6e6c24ef0de0bc2657d863491d53cd27a7c994278a3f9f61360c5bbcbc7013284f909720250988619d6fafd0dd32ceb553a3a6e566aa695c85903f0865ada9ca065ecd44e6400b30b28dce6d9b2766d5736858252f9a5e3bf1383169af3e93275cf0b2dd1cc9ce28c1de582d9e96c36b0cc67a92c313fc93407012d9da82ce5caa1906ec04db0a2586b69ffa50affad8774d1fc523ee43de74d5102b4b9c90a4e72dafb0bf086255d98d6d4bcdde115a9ded53c8d98b8417708ca7d07e87b151443a092f3515d75d26c7b70aa7ad5be5608e98c43bd2c24df0c9ce16065bc1a44f0bf85e3eedffdf34662472d30c4170964ff6cb3c36997fbfadc946fd5bdeb49b826116823544d2ed11119669dd941885b40bc96f7eeb71fde94cd43755bd3b8f5ced939c8b54f8a509ac83a202c8708e28047a3d6f45268f8d86ae9221e5c22c065e146fa87b8a4125a1c64024bafed36284a3d028cf5d61ca6b6ae3c9adb52d0cca267af6a003353cc3ce115331c7985cf5ec91e7719838a55147900e9f1c97017e2dbf209286c6ce2b1c76d3b0681feeebf2a94808b8ca7b300efb1043520d399680aa62e0b65fa299d3a9f813f7bd30b5701aca1d7853f8fd885f1bba8ba354f1ce57ef637c4665568ce20a0330c0ca73ceb7ffd6cf70a50f350fe9bb5610e931d0341b18e4b6ff5580087729975688ea490d1ef4b42018a2588e9eba81735ee7d6d8e2f68df1102d8541b5de2c38347055c4bdf407fd0917e809a36c0c8c17ac3fef19de41a8848ba29a7ac7ffe26914206fb84bdfc2318d82c4673e54abb7dd20df64b22ec8ee407eeef5b59c1c5fa66a09ca3c6af1658e02921034d952efdd95f049137122a0b4086f24ec77eec2805d5d7d8eef7cead989ddd4db1683637240ed594c21853c15148f4a4ddfd39b1c1003c9f85fa1efefdb434868804137589205b85dd691bcd8acd09b761190f1c3c84dedf4001a8d1e43c5d2e1f5019d044e2143337d74b6ce15b8c035cfe4dd02cb20041da62512b34f945420be1a5436a648aa423773f2a162e27e64382b006d4a967eb6c1af6c2e159bc03b5838861662bc9ccafcf198e71cb5a527ed9ecfdcf52c9fd72ae8cd087969b721bbc08e3ff63c69d09a608a70cee22a95ca4e48947e8817c683be929d33b03594b588e0e52489772e2b762e05370a8f0642bafa9d6416f42f1a3c3cadb5102730b7d9e63347382a53dc7683103d1252b29b59c8fc09b7abec33f4a70dd9e4a86a458d0766efd2c9662a1bfef16464f865d4b92b0ae244701e963a11f3a70a7d0590fc4880261b41ea68514b0fdfef5bdf8fa58c46fd4d5944781f61272b5a5688676990031a36ca1cb73ae418600e0c7154f3a58be0891021d402c51b5162eb8ad20d4d46208d25fc893e43a883979a67d8d9615777c0c2b4fca077203d273e7cbdf49884231abca1f6561cb7c55b5d544e56f72e2e88772e9cc62bee52c1a138047eaab8cdf71e5778c2b10d97d52ba4e80e2287d2488b8f303b8ade1da1d7786a08a524c62a572aa54ee90b456ce97d4b9dfa3d63af719c55a030be8a86e10834820c33bf7270e1aa853c1adab40c4f74e45cbd24041aa35cb8c36049143c04d34a92f3e2c9a8ae36eeb397fe7443172b2a3e1486c6351e9b7d14373f6622226c403b24618b99a3f4c31205a24de4bda851480b3d3f47b124947e0d40c5b0f8224197f2139f33d1674c9a3eee28d56bafb0c17749ed6c4ab1b39f18e96aa87e3a3e0dad8a602693504bdef0f30e1b1f8870ba1f66b99862cf15cdb2c2c1394572afef3673acf38c0481b9ea512154807aa02da442d05adc895ae5bc8e1c548c24029e38789f3ceeba51c4d707817d0d49a63acd43fcef2249e1dfdb734944034e5e0bc83ed4aab86ed90a9fb0f9b5d8f1210d286dd8c2861b8002147578afc2f3ab7776a9425750ccf40d781d099f7fd072540f5258d83b99e6a6eb1a37554abeb82e081a19483af23ce0ed997bcdaebce3d118f1a76a0835dd53d524e06c7f468a1ac86e99c8822a0870b9bc196b788b7f1ca1132b917342bd79cdeb0b3577281e123f74b20e9c330f2706f39c10c6a64b948ca6005c6f8125668bd6f5ba088afdce5cb4d4e37a38a45285b2aaa0364b994cba380a61051bf5de63d44ad3bc6fd2ee015e54cf2138b17be04e60753cf9032a3c997052548c0ba8e799a7cde36a19d3ada00a9bf86da30b58b08d7f1d05a4adb9a516676e5c50ed0ef8d6ed9460f8532e78a850e8f3043966a112a3334a93045890b9ec73ee5c9a18a4ad6c718c1d6472bf2fef0ee953443fd6a5376bfa18659593da051f26b059dad0e510ce8d1f6853078345f98b801ccf2a5f10bf03810c7d657543c49dc4387dc566eb4a24790c6f456bceade00ed238378f2aeafe3bdfb1044e4cfec5b6160aca48962476497a669783471d58f77c376c9efe55718eccd9352b2377bc2a3956cb70e4fdea8bb7f4148526bcd69ef7e2176b82eac1600d091e646170b13947a07deebeb8053262f26f35880900430d1ced9a3400878b3b21281d5c3878763fc70f07fd75bcfe538cfde192cb15e83dc504131eb7b13abfafd6d8d4df2742bf9da7c67633e4d138f0cf4a987b23cff2882d458e6b9908acf626b5bd3a5368a099f15d486805d17bc5dd5937634c0a9b7711c88496f8f03d21211261de1745d777806975f7104dbe241a5d0b2e06f65d439ec83d2ba7341b070d1f5e6bf26673ab0d00dfdc36a92bd5029f539a268088a611aa7a052067d653ee40c62b1f9bd091f1a020794038965cd948eb6d77dd594e52152ee248e82540d5f773a2f43670f748e0328c6dad88fde9178b57c581f9f03f9816f86a7dd687e8f2b3f111676a4ba5d68dace2aa3bc5cf6709ee4de7661299fbabe9f1bcedc467942943a49c604119af70d22500db5f4c39a0d232abed11e8226a65606cb420f231e3ddca89c2e49d30b897c8e05ff09eff48046745b86749d17551c1d4f6603f5b399de2f792ca99c83aaa167575bca4f494bd25a315dcfb4f5b3aa5b76c17513407aa76eb6babddfced4663f0015fa96b456c0eb972f6d44090542bf90f18710e3bdabca71bf7afc3c5d5cc0b39827c04fa075c1a7ac38fab64862699305950ab030d99ca3d2436bf3f7eff7639576ff721f53ca397dfb24d5883402e51571d1811579449147dc1c58f865f30eeb39dee21886fb5d7fc1b1e69a44202087cfbfa7ffcd643b6a0bcc73c74eef47449c507a25a839cc675243c635c058da7143377aefd03c734c9030eaaecc6b445b377dc6a1022d48e036548c9c2a57f133c5835d573c20f0179ca03f080bb5fe2ec3a6d2b69db1eb48eefaf3d449097155895ae1e9f974b092b0057cd31a72ed4cb0ae3aae21b010ca340794bda0fe63b9bf33e484f2ae306c7174aa289271dc98baced5bbd09bbc1db08acbfca422ef467f3cde674a97c434a6c200145bc35933702acf5c623824f9539afc52d31b42e5904aed39308264cf9e4dde863615c9da75535f88d5d30b44ffe46b26ca09fdafe93819deb9c2cc93978c27bdc842c6912b588d1fba1b1a07f0abbf53fd26bf1952194c4d6c543ca0e0b1eb08d710558073cd5dd53dc8721a41ddcd70bef06f74ea14e64fcbda3932aaa75104dd8874dd23ccc322eb4e3c645103c19ab4dc9d81df7402cf8245cb00676de0e0879f4d998decde2c73fcd23dcec86530247e37c5fcf996f40d26eb9520139a57aeee48a1d11848c7b569221f3a6ffb9c2f18326e7fa41ba0a8df22d56411e9f436f6e2aa4af4a18f851aad579ec42c8e358bead1eab2086dce3284875be9061305aa69a367fb905f12229b890c8a0d19b6f6eb62744ed1aacc75a22bb01b406e1a61930f72cb23497e74a0b76ab0257f6004d32e23d5fde9235b881090195e6619a55c2a975c24c8fbe0f05610ea96da251c9c2f7d94217d249a9db845ba692770350bdcfa15dc433cd84febe6b85ebe9b73267836ca717a6b310df380799e74f168207fd9e185d65f39e3c4732d00b2b43be7eef90cfdbd1555dc1af98a3235f3fd555048f6791740f5a335a435c92e91162d5092d5a76e3ccf3bdde8534ccd8d6507377d6156b5435cdb2f36d4cf71cabc507cc29177260dbdd74df1d9976f834a2e311233f4f5af8010e9a87fd0020f08db00d94eb95008a92a64b8fd527d50a6f092a9ceffba0c5ef1820c4fd38e5aab36b2d59ff46cc025c2eb69c8894078df706cb7765fb930543723b67d51bc679c2fb15f9d89bfd1c456ef903bc2725350148512dd613347809f6184aa12e623407d2e53aa650d7a866694fb755b8ce3013489cf19985e2d9461d145122afb6076d6a59243fa5be829bcbc12f8a326b56f01d87086c8c69632fbc738040fdc83227df625b30ad450a5639ffb4b91ec84983d7b3f2c22616d0285444ee77e0a98d66e7c97fcfa9b72df7c654e3c2665ed832d2d24e14db980dbc13a5e678a735c8df2d01a17e985b7cb22e2287bae86c91341ec3819d9da834ba9bb8b1c1df1af8a4d538be99dc013d74c5f5b8281975455666967019bb8d055dcf89fdd91b6d5247abdd95aa048ad3c1c14d464bb70592a75b7c12e27b3043aab05c51e33c5683bcd7db85319e71a273bdc8e917893dfb911ba699c31b6dd5a6a859489bd99edeab989d7546df0a5d2254fe4af606c0584c212d19e540a231b71c3b45d96be3d372df2cb9ad1b77286b405c265e0e3a21fa167bdfa057c61b8310bd6423eb0808deaf0eeb1be4c3fb1008bf1fbff0a7710cb108cd3bcc7b98bc8f977550bce11bd3bce8b1496cb5907ec904ce612df23ff0fe80ac0f59fea9d644ed2de25df715fa8897f61cfbbf2bea4913714abd71691b57ff51565616fc96c26f98ac761ccb03fd111af8d109c56e9eb4064097a10c2bf2d913ff7085003d0cf778c94761feac0276ce79fdf4e0e6171351068256101adb5eeec0a00bd7c738dc86a09eab6e5c4a3e13b7d691a5a984388bb367b08cee58bb537df6ce887b7a8034b327e6dcb6053548063d920d98a657570feaf54c22117cb47758b16020fb0bc7bebbf87e949f73c8156e02170afa5f5e1189b9119c30325e20dde628586727b020ba0897583dbf8da99c33fab4efd6ffa12a028f38b57b32412bce93c876694b4a39d6ad883cddd3ef9bd7c2bd3de26dfcceddd480424b9f244083785e9d008aa567ed25dc61e1df8861b11c785071c7d19a5e5e013ebc7a43fe042a1798d9b3c5f3419c1e8e353d6c6954a59d6e27c7a494a17f9179a99400c063d5436c241f28ec9b6ae15580f0ff9f0e860b46805337b058c3b768fe0104b5136f7f2d3c101f73bac6ff273db532ef578997a568be6b5e364a92f27a9c7ac88131cd8287eb16ec1dc6ffe98ac6080b8e4409f928d0e81b8bb956dbd2ebab650d36c5e46c6d1b06922caa7ee51e98eb8077f6cfab0712c799a1fefb53b368f44d100b56a2d24e2bc2fa7b0f8203542f954a3ab801fb350e1f41e12edb4fc6d040c318e98859e45b2d72817a8ef9d6f599bfd3b080dba8551d93d16eace4afae6ce415cbb383754d8741f757d4b5ce941e79f3c7c3bfbc59db060e99c0d14964c66f4a3bc76bb5590edacc756c5bcf479a4b063cb45240493094fb7558af3c9290ca4fbcb1a70e0b421f4dd7781eedb4b91883911c9879490ca4ff22ad2f1f306281aaf36d7b93292e474fa6487b8b8f71c4d8b91f615af391070f81c569409ae2badff0f15728f795c86a2edcfe1251784925788237355e03eb4c6639eabb431a37862c169258b546db211467a6756063b21526e121422fcb25dc01b4932635622734302ea63444f30afde869f16b6ba9210daf699469cb05edae95e6bc200e48d0320e7ca4636348f9c8b37a63049f6033f970840554f6791fed4001c768f4fa8414743eafdc771f3b9ec05541e9904922630355b8a680cf48652516d9e849b582ea2566c91da788213fb2387d6208cb5b7c9d29d47426d1352876c401dd0dea4030bd6d4bbbda6b15d87a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a5186bb199d5c576c2ddbf69551cd62e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
