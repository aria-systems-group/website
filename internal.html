<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6762fc91e0938e0c8763a4cebe39da8ccc2d5477d007546834fbd161db59049c4bcc5b39c9431e7cf0fc6908ba70f8173ba82c455652eead29d4e6e805a0f8bb122659a7a626b3d42f36e0d1c16fd73ce00f4ff6a36a15eb70fb3810b378d7d7f62657f1f0d5acb8086664e50ece5354c0ab2a3059bbab142a43a3be8585bfbd11268923b1a72f8060383a3a8158cde34c42443553303e5876f4970f6096ec7a5f55044bfb5dfccea4dbacddf6e64392a740e8120e17114050cc4133a7fd74d94245b1adf39c81dadea2754a6906f98c78329cd7ef72d3d7b7a337e573ebc190ffeac7a88421a8daad0b6291cffde0d68e069b70cd836528f6902e5c8a4ecb8595d524113718dd9a500be5036d86016501cdce5fd2697e93bc73c818d47ec6dc5402cafb030841d0bd73612a8cf49a68fe076ee2eff9239238c415a208b530accc1dcaed31c00cc144918dacf5c703344a59794873073d13ce2370f70db6ac7c9385fc4bb25d5388de514f5fa62bedf6fbb5ce29165daaa4397f3911a6ab305af17161437074724d986630fdd9523e604f2690d0d930c4d34ad06269a807bb9c3b52c78bb3dd2c94d062415265ad6199a3a5594c5cdc06d6d0330ddf6f707c1b63f9ef472057188d169d80d93809ffb82f316c349b201fce157901f215755b15efc10706437e98bd3002b9719e287faa06a6b8814bc035adadcd89984d3e05230eba4517d42c225eef49390cf056c39b3bb76ab2b9b41dc4d9596632122dc6f0db76b92101ed459f4df62f8eb55ae6d74859016926c13e1d4d43b3e2815e5a2a9bbd0c8f480ff07c039dcb0edab92753d97c144ccd6049f065bf44466d37e95185465be6a2211931676cf3fcee53f7911d890040ac7b52cd234e383c6c438e0bd5bbfe4af0da30b06c2d28576cf125aea0c4e384699f813e5f612bbbbedd4c841d22e22a4d03402fe70833e27db02c6131a287d13c6a66faad16d3d2be309fc6bbae0de7897b48bc6bdbbdec5b05c5ffbe19adbae251a2a1b2645f4a8e087190df68745af649543db45753b8c810d1fc2ed620e0e861f7b551e5072574afa8509cf9dd447a597d068344d1132a3e18f4fcb8aa703e2fda0ed530c4ad6c7e23389fdd1ca6c1bff8cd4a0e4b20abb70969a7ad9b9b9e75fd86bf3d0598c0cd93165ffc7956e871c277b5c27518d41e0dccf84a151a4dd9bb54eb6869aae4ee64ffef47b4885ff316aa4e90d27d630ad0896b10455c4535d0882cb877f38cef91cca453a20b894405a9477992dd8b00deff6a3cdb7efea2415654bd51cba7cea7dc8ba10fef2cefd7d2096cad73a4ae0d636d73fcea01403b622f93ca8e5c80a1400b29432389b5989fdaf5421b4d897d5983e957d2a72f1e2cf9932cbc893c35f8db741e302b4571fa7640a4bd10eee672078e286832a3093cdd5d3115ab743a59e55135df3cc4462009c1f537634361a586f197bb5db26e5e7a871a7238a956c1a52c6746fcaeb923b9c7c500f11728330ce7b4bc1750475aacc47dae427e8fd4e93e191d4b74e18bcdfda7f19949b606768c323c8bc3601d17e6c86799246b78c64b24e967a1ed8a788543311ca7d67eee931c56ed093679bd41000946fd1ad03bae511d97d4bfc0b059d89eb0a7547d3c5e02a4f0458eaca40193c9f97959e838efbc261f892e0bfa416ec39c5236bcf9e9b228a30b6fae71f69224b1c2b5ba69b09c4293be5599ba6776474262e89ce8dc6ec55d12427c2e90dbd1fdd2998df54ed6f2c63f83cb264c83992578f2cc54b5db945d4df641072921875a3165e06a23b8724db592e9a6270e7cdab44feb88a368324563695b66b1df90f95998c7f11bda8c3ddce85d3a6fb5e44689d536afeb7f8bbe8403dce6827f0d0494b2d04c1436e82154f11caddaa91ef1ecbaae95976c7b8cd9a7eed2e5ed1c3bf3990efbd52a00a818f20568b1fcb0fd464472750ff2bb6c4269dd4da6217619b909f409ca0c06ac9b875e37c9ccb15d218ebf67edc805a7e739f034145a62482e360472d57bae876a25efea79db776642b47665464b0d138f22a9de2b3d4f1655b76e2d33ab100a046558a0373476a8c2224e5940581fe2179bfd6ae0446c219ded59b915ab5d03ae690f6640d39ca06c9ceff2a494196a21913216e7ffe09e6471bcd7d68e3f2118fc60db2447ea6d3e9f68a3026f69adf97afac04bd13620d2ce429952b10d53b3e8689594bbaddf25bdc295becb1b230df58ac1194a2d8afe444de5ff6ba50a04d2f00a861539d0c8d7ac6b5624dbdbfa1d25ac0757206a756960e437f6ad9770aa420907b484e0ed53f511117ad705d3330e67efb5b1658fba7d67bd3731796d6b0cabc23e46d7e7d41b2401e51cdde2006f21394a079f2767c3cdf509f76a8acaa3ff4c122f1625629eee546a9148f635e268fb459f945290c129575d833ce9e495dde5913445e34d17d4f4d6dcf627fb86a49f58085a58804dec34e9fa7de88a98d4461628bbc5dcf4c6933b1c0d641cfb88bde2dc503ad2aa7f496953a855307fe1cca8d80ecf0a64fff98f7c11b3b152367baceefd0e92af8fc6fd4038e66eda4604a184faf865a812f1e8e5634efd56474ba7d71feeb786f92822324173f1cbe16fe9c2a0a68a26b232746581a0141b6e70aaef05be13e95a97cdc7fed1c960a09a52337982c8fe3ca9af7da452da50df945025551d089076dc960cb8b7c5f61de76fc8782e1e8ea12c4b4bd5f3298b1cde25d4727b93d02adc7034d0ed0597a680e45409151430db7dca8bbd7b87f58e45244d27272ea36d7e0207aca158b7e5b3e5f5c5c93e85e5e1ddc5dae3abbc2cd31f254586d6d595688bd80128f21936c4182f9b6f6ee9533cceb8a3c9f9d7648152ab8f9ec36d4c2f278ecae8615da50eb8d04f63cebb7fdfaff9706d1f395cfa92006a3991d2ac094fe4d617bc860352e603ee2f025b4674c6d4c103f7b600d11acd0fcd7e863cca142a405b49b43414781e4674ceeda4fd7a0ddcce2df3c55cd360c94d29eb514d100f2e562add1762cdb665d1f575065cb5c7d49740f48973b3c25af3ab234551a6062c0b41261280b6940614df41af91107502b69163153560c04bc4ccbeb7bd79f8e5d3045006b5578e0f7b003468eedd54aea07a1c653d3c1ae2d0204cf5698a432fa2b3a2756841b6c6ccadb6f0ba03712f28a751f38d621163070f00147c74c1e2f794f50a7ec0d76f7da206ef5abf85d79752e6fedf2f92bf431652c75ad3d9581723ec0bd845dd1c50234c17caf42435b26545de02ef95b710d42755bbfd87d1f477992036a393c47aab8f19ef4f8b68bec27c36e8a4aa8f48c0c197c8245a156432936056663f94ba7c17a4a3aec57c68e00fa8dbfc29842303ecbdc6556d22b055400f69fc974bbf26479675265ca038d94b1aa69de8d78c3a04694c9b90b361f1e5e39dd40141bdf8728c73001ec01294be07f366c6181cbdf2e85758b75cfbf5a2ee6b88ddbf83804e8f0469b806e29dcf30b08ec04007fd816993c235129af5e1f40b2913b49ed09fe01f477bff3ec2bd6a6070177337178202bde3253d319a74faf8fe43ae79d48671bfc3b3f8701ed708f1dbd3f58c294683904409fc9f417ad1086736eb9e8d43b6bd62f641b09d67a82f431d1d5fc222231b80fe88668742369806ebdcb8851719e909427e051e9a7f1e3cfaa8d8c7d7485717a6d99f98b424d165ed99d78f29871d65e243917227c1e368da2fe674c7fee0a0db13332d1d94a501678410aafc7214fafdc9b7b06e45e01cfc8d49e55ab85f27c896d8a42297b43a7917325f8df8d075009db940d43983a7169f4d353ac844dbc434801eb826a0d3c2f27116d1f288b8126e37e467bff242e443aeea899f3e882cfa4dd2a9660aa229cc80ef3a52249e2b9d0e9717051a1e4a10a785834c0bd6a2979b9bd096444cefbef229b0d976df499ae7c846f5125b40206fac27a45e66712eb6b7365c1bb1beab5c4c7ab19082655549fc845f14e0652fbbaafb4b2517583a049a64c47d81b05900eb93a619ab994608409c321e9c6ec813447cfedf1ade8914841a6b09d13c8f2bdcd0627e86dca8c370f03e92b2eb39a61940925ffe73f8e0b0a7c3824ff36ae2c4b0e4de26c845a602e0f0fc009324a8b255b6b0f6ac92722f54ec98d0dfafdc11af16aa0c6448a1057fc581a0056640c8cb559e86cf6704f0912ccae2e41d31af143d5a9e388608cdfb47bb25509f3454c390bd4c2002f61c35f60bb56c7b5aaeb70420b324d80b002d5450f30dd25da0644d5b33ef37765f53e9c515d8f75681bbf166c24633c0fd8fdcade4ffa50c7cb98a9e0e5d62c8af7951127ddf737b20ae900236463368c3264c39f1ae429a26d9f713308fd62471d088aaadcb6ada154494f82f8c3d4b207628a742c8ffde4897d31dbb5c1b404f162308d6b119ce3b6b96c9c2f00b8f17eada001048853b3f11575efe9d1248943ab11a5ca669c19f3a346370425a062369aeba24c6381575f2b41ee68bca53d335c3ad0b3ea2f126eb32019a3b61c8cf7ebef8bdeb13d75df3351de27fd14a5fbb99114f8abb3cc420b24e7a765272e669a588d81ca4daaabf9962513414eef75c1431c657aed85cccb70faf666e204fb8b340c6fd15a230e02d00f8e46c61b3bf8f652b00f6f2328e974e8e209e35ae5267499fb439d4a5439ae324a7971b0577a3dbe8065218e8184d8ab81a204f8dc3742c8f8ea0e5b3f3343ff4db588add40b520b814fd3742a93f99dec5eedd69ab57caf6e87ab28a8faac002a743cac74305919796b1ca6490d644cb73c480415e26383d801feefee58c20de26a05ecf1eac2c97c2fd2557e6121e6711d3de3111f0e2ba85ef29f5abd2a94238a021614ce319b9dc7d70ae570ffb36cceba69d79fa55892baa072ba638f8158a5aa68137ef5cb2bb575777a5f180f1f19ce3fcd4acbda45057acd08f03a2efda94441ad3b51e4d247b14f7724742eb0c18c50ad1e0f3595e1b476b980df38afef84dc85c83c8b2d2cdf925cf54fb994e6ee7ceb94086bdd6ab6028f673a4ba13b57cf5caaf452ef081a2220e049d3478ea474ec6f7d23f7e2453f7d63f13c084bb7518108ca6e47334bcd650182c4cdcb53941dbcc9fda0197aa86b4e48f2185cae24bfc776001e6383e721c256272232b09613a611515e2eb5f2810e042996f169c3e966300512cab5aed901fbba34b151b5bb5e66cd10b08f817fc9a94d94a461abc773095c8be7cad10d8da199d4ae91209944d66a49ec0d4d3bfe4022e3b8b7cb9a185e66bc4c367d50cec595f8c75b287cc58ff2cf5eea7c81252a7148d153bc13330d2232dfa35f91125e7e5a268c36baa9a315d2f7b7a48d72691b44d83957c697d06f33e7a317117c87af024edb7b6fa414ebac0c7e05c120f3e4a732847b6e304768ec1c620f766b43912a81153676f2b253d50c8113469891e532573ac670bcc55b37a0d2dfe3b9404487f4cea251dfc6b1f8d9d7f2ab60341e4a27eae97c73bb16166c77a01999f0571aca38ccfd9b668225018a5fa29388e3ff03b8b2eb453ab0a9c704a42ade85cb41fde3f4a534d355a1a3fd249e8d71c449c54d17f1272a7aab15071c35036eae19c3a367a1ff663b77ece5b08ca7763c357fe74763797048c1fad3131872763d62cd36abe03095fb74e84ff4f490f347ab80ce7d148bdf81970fec2d5c29df806910de5ae71fc60e397cffc2236a3424f4b000401455009b957698c5398fa888d633fe579b08d06df2900f5e537eec6accd9aa26926927215bcd1c14c3d7822b6063017e7d8f48b433fc434ee9eb06014bc25424d1029387a6438d9b7d410f95b3dc3d85a54a857aa1c749bc705b456e6c349e642a6c44888034c2be1d1e173411128da248220027e78d9515f573157c7b6d4de31f4f7f0ccdbf0ad9485520d4eed7d378c16cb08e70cd0425633efe7efdecf20fdf93797466d352f1dc86f3a85d447553e3b6e5418ebc0994ebedf123c3b6d9741ac89c1220b406372256f62cd0616f6aa8b67dc942136e9cbf1838bb5dfde138e43782de9cdfaeb11dbe7627385ecc583538517702590a9b966ae2296819c4322f35e99022c4ac17914fb29c95f215c9e11accdfc0986c28e63f326e16b294047e0efce5cb767865da831e2ec4777a1341be62851bb082091a8fded4c05aaae40d017b59d02451fe754dc663c538f04142081d6525f7afe26eabae7196efc72c9f12ebcb0784cd22b1114388ae8b16aab9438c69f24638a72613b1e7d3fcbeaeb5cd18be8e268c07585bae0a474485f5361a87b1ee134d93706581d01470dbbd08371d331b48b956999024905d0293075b63c146fdc4457ab02232bbd2f9739b0296f7cd552e33f4088705bc74c43dc24263538a7372470bea7aaab3b95a9c9ad9e5da598497e694a0f58bf35a4d053156fe21ca80633e01e60b9c90e6da8d38063df942c1b24b0429edeab763e8471df077218ec03d68bc3156e69cc04d9a2de73e3a3459ebd328de0e943529689e430f0ecabf5b919e6c972412bfeaf658d2669078e35f6be302f65156c13aaaf0fcee08f68bf95ea1fd864bfedd13b6244f1414c102df6b54ffd066bcfdc91ba523a4ebcdcec4a032bf3ec01650f0a3b191ce290bbc073a99d0d831c7828a6c943cca89f6a3c6e1656127befb32412cbcad6594eb571dc49db5b4a7b0f23361ec2336e33eb464583fbac826aab5e8dc79f77896778ec5498dbb508e8dc9e242f87744fc5ee3f93df669818c1509e78b07fc96084831a6e0546b520be921f5e3cf131ec160bf8cf7ec1117156125d5ec3e81eac75faa57025ada868866358123c8264a9bf9adb7145d7cd5fef381cc2670f8260bebe94153bf306651ac0ae4ae0ae8e99cf04d184e5aa22e76f91a4ef93ec1849ff237ba2f3884f007685caead5bdc51c85369a30b103c997c93f7312c7e6462d1d463d3d9d856de0ebbd02e921f4819f3d72535653c25282c9e3a27861ccb7d7c5f17439c900d2d56217fe5f1c45f0d580aa2ce9787b56fafd57b53cbfe6e807598011be23c708bddc963f59b2fade04e23874ed36d7840ec67c4bee08bb1c37c53c817b4619bf9dd96174fd17c6de27dec417f0f41135ba0f8c2f74cdf909beb1578fa6acd0ea2dc56b68063bd08d793459d1490110a2a8bd605f7093779bd056e64bf27eefbccd6e7e4a4a88430b92903ab0d355ee24b7cf3c6d61515fa29ad8030521fc32b5a6fdd0acae86a2ff05934bedf96f9f5e4b5a9748f920996412c8581cf7948de662837bc1146f8382f6afccd167637919bc426e4b32bd57603f50cfefce409cab839cff47fcbc4149b3a5a10d0586d362678b97be3adaebb613844eef80ab34808d601bec5bc0a753ec8e9f05ae8fcba1eade9617058df7c4f4f8a99bde9c2461bbfe47d18c871028872e14c567e58b9308f210f8d72624f574aa691fb95be02cad9cae63f276c7e0467e8370d2d7244966fef20053450015d13e86898f1afc4e7aaa3f42522ff13b81e92369d6aae6ab672a9d15bff86c5abbb5295baa61c796057d0f4d9e1d74889a81af3b444150463b0518267699ec1abd184cae5785ab155a3d0a3eb68e302b820c1e8a03dd2060c26831432a4a1da4ed5f7eb275d58f5a5d6ba2d8036aee65c69abda656b845000f0c261eec31b288908cc9ad563962fe3a2baddeba684e4c58c73c56294db8289bbe792ee7b37d775465a45bbf21fb8f6fc294e8d82b82682fd683735c9f86e6c175472d2ae6efe6e264f976fa26573fb791616764353dc1f3ec4e576d35155ef1d120d5f76df95aa26c37dae4f70a7dc0eb33aab7469225b18c3efbd6eb413f65f5f2fa0bf1be821deed766034154f00f2469751515c20901c4ecd8d6e8ca2654c8cd3fab6f4cdcfd3229676a66cf79be4f32b8fc8343bf7dec2047c06d9edb66e9cd4107e84403c0e125002595327116d65c8196444a674849622b49c06f7827595c27c8acc6a37b9e79c39e2a4d31e283884bf11162abc59c569aa63c144f7494289fa2b7e9b43cbc89aad318db4cf43fa44a93704d9d816916ba6a2284f1a4e5fd49826c98b5c38bc0874aaa56fedb87e29bffde71df5dbfb5f98732270ccbbfb6cd73349ad618f3cfa609c33f2e3ddabf82a81fed511d39119eadf3fffcb52ee44e263c5429befe1e6f17647f152ecb1a30a36e2c6b9c447277f89ac776656706ced8926dcfad827b677a2b481dcc438168884e42fabae812e8b7701fd7c40cfce46ecb027579988411c9d554ef34db0604e53314a53723f8287b18a834ae0e4de42def48e206c47faf0af235324a4f9345bddba438cc3691fdf1df1623e6ab4025abd54179b5df659cf470513aef51a45078d97ee7c7ac4b293c8fc4c382e21f80c520a494f01f404e8da8bbcc5f0ffc4e73cd28dcea4894f68f8dae476cdca44264edb65d86f6306ca583b953db94ffb98e5a300c6163e04883034d2505ad7777295d799a5d96aa642ba6ff501c953b41632ad64d41dfa4ec04188ad7ca34ef6dc3b924440f3050eaddbab34074ce7f200a5ecc30eb5d7437ec26bb605eb46200fd8a312721ee33af91848509ba2ff91081ddda34cf1e493e744e1e3e65da39012bf7b9fd1beac04e3ca224306e0941a0332a0dca770330af8418bc7b9c54a833906a69df044360200ff5d4850f9ab0fb6e487259dbcb44f5a823292eda144560324215cb4af4878d8d2cd2ff3fb4f1c048b34f4d0807030389750a0cc67876449139ce7efb905e1a7a3b78ed04033237e98029f86461b4d0c314c140becc23989f3c841c70e480195d2f93703a026c22542f0c77de312d2eb33b985a4f2271560cd0e7c8886a1537676f6a75465a6bf3c24e5b83ba653aebb4ed7655515005121ed2415d67bca72cf688bd89fb676bea34855a934fc948ce5d38c93594c07f9a92c5ede2bed52442de8ebe75ef7b7e81f065bea41255910fe5cc2b9dcb35d230f9f54b3700406acf584a371fa0d67988d70349cc65c210875ead6123b37eac9f9a6dcc351b7559642a00fa7aefe8041f6cb6fe767b6c0693d109a717e031065a8b4bad76c2ddf2fb825c5c94b15e498c1db83bda2020d3c96f2a45390aa3a291ce1a294dd05cfa0f7a5ad20a365d99f09483cd3d574a9558c2851af4c2b555db32af2fe1d8bfc27cd4546568b33579b52cc7ee8e6c505353c65224e42a238386ffe6f000d1c292cb9661deae1e070305711569708c04618dfb3c9f624873e12a38bce290c3c358981e7e0709e435e2d652dd4416b807eff7e45a217eb6b6dd6d6ca784e866f0b61a8d55fdfd7c5b4aa20035c5c1db218cbd499d7dff3d3e93f458bd17db5a4077e5c7e5180878ea3d2bc70c9daaa1b2b0cfa1941251db90acbb104509d77333df7aa01831dfc1df41d73d3ed11132fd53c9318c51c486a9995419be0a0ab5f71a58d23090e3fbe20c97ca2292b554b65a07ab9c7d6baa85a77502d4039c045f2cc250f2e3a5c4bbfd9d2b9b76810f4c19ee2a6b2310ac42ec3501a246e35f4b398a875b9b1dff00d5c113b7f63a4c821197619e46cb031520bbad3d069931689839e9b20d76ec2360aa2dc72ad058b511056fcfc88c977de15aeeffbeeeab83523e208efa2d3bb8a842bc7f151c754422759f5321ea34360e51d712394a5291a096c71ec5a81487935078c78b7ba7b42bd5eaaf4b8bb0f78a8f96737c71bd0dd72ec9e207143fd56f3053889f781236dc3232ea206814e5a983f70711b0e4d269200d4010cd2b98e5c988a2cf6379e916f31668df85058596ad646ebe51af13288489f27ef42b2e8403381cac12a9ae42180e6db3e34f3af399544898d9a3d620367e4939798d00cebba0685c023bf3debe30838240a82112c061df57eb2c2a59932a3fe4930557c066c39dbc28e8d0d14db50ca7f7f4ccac45d75abe97a8d2a4a1e1c7de2dff1430755fafe46d84ed99c2c5df47d7b5ba65ed0c0fda68de521eb200364367004cdd037d1e9e0be7e5f34a0a1ecdcbc89426e3af4ec67e37680e12c8686e0b3b668fc68f4cf2fab97a6dbbdfdb0f2bfca4b1cbc95f41aff91d646a3ddc67238059eec97844357ff982a4d16067d3537c5f8ff4719c2701740c1de0ac186e55c20d329c40b1bc4305f29ba070344f89c8a9588a54d1e29d3b54bbabcdb94daa17296c634ec6d107fd7d05956958458fb2e80c4444ba12c31e9763da9f846a8d1fc44a111f604f611caabdb032c1d620d5b29d2e08c03a7d85b687ecedd83e08f45339e82cba6636d585246b39e8967ceab5190d45d5990e40d495123399e56c7ea54c3951406cbbd994d6da018b9479436dcab6addcddac5d35274634514a21b69bfc207be249a4380f1f91b06d35f6140a84c098ff3bfd7fd9ee74bbbd299511b12898b41a0b1280b5f2bf8a2310cf40aca04e7d3d32687f365e2a98f72ed9fcf7a2948341e30f018d7f8dc1cdb7d6e3830cf3b25393a3f235ea8b4bbe51a7a0f9ba3737c704c8b756db24f4d09a20dea45b0f358e49e035fb2a90291e22b22db83f9e3b227973d509553f83d05e5913bd86ba5f6bb851f76e8e9496d85ff4341f2ce8f6100e969de8e600b0f32819fbf2be3f2780954be4cdf4d6a65663f159fe4ad55a5ed56c19f8e3da5488a8df4773de00ee54e5f179a0843c4a67408d265a346319e37f36500e6c186e37bc3c4c6f37ec7faf01c84287c00e5a3892ec40d8b7e9249fb982d29a2a9d6aa5268546e548b65ff8f09a645c89129eb87dc5339c676419d554a5a1929bb9ca10e0b166a2a06573a9b3dff4d8cebd403bd4f930f0faca12c6b6260afebcae547b33af8fea5397dfc8aed20a80fbb9fc5450ef40be8d6533812738e464aef713a68847119d373a217e5e97281e889e1b4156a230cc262fbb58b4c73fd5069e6c2f4b880513a3d588b819bd67ce58055d8f4c19307c2d347be32f35e543e92d9a56b5883b000d75180cdf2a370189c2ac3678e937c86d879a42fcd04e526f5ec303517d0c20fff917c470a3d17ba3b18579a4ca6285400bc5588bd299a77af126146465b29d3a2113a50bed2b16e17a650f4c1a08670c548a3f81ea9eb61004251007689a610d6cf10591618c6836900a3e4e39e8e9e3816cd8911f9cbd01bc98653deada304fa3bbd7aeefba1b4302cf45caeef389302ce167bfb9bb548641f118b4dc1eccba8e4a6c23bf194d451e93a3ddee8fc0c54ebf02729fb1cd772ee8dcef19bf906c68d74abc4a69122ec3a46955e6720c9f6635f13cca29fcad7543cdb3cf0c14a12862fef66a5ba2835ad7154a895d4b0114a4a218b8c1d8351e7881b4244fd046991b48e0a41b3f3dab40f8f68dbf8ae020056d191e19b4b2e6fbef334c276a352144e1d23bfb7014ff953663bcd10a4fd9c1091cd98c6c4c31d28a5b223d4dbea8f81b2885043ea8f1e1f4c915002965fcf752afb2b05fa15d44a4aa069ae3cc3d9665e0ce5839687ef7285e9f44c265d80bac612c25cc012b6e73adace3fa4d1fc0e16bec6bf12a4afe0382cc6b1d06feac50f40dcaa2853943d9fd0503a5a33a05284b24693984c658ae532fa18c57e86323890971d530023b7638b953ee22e93f69569815f74f9c03ee036c389abcf722838b7b89c46cb9700b3c0480d6b3ec09c512134c0ee600f9b28c3c0e0e7966da7acc2a303989604927476afeaff2ebaff918eb445bee9df93336796b94f560219fa70fb9b312589e4371f99e5eb53bbbc5812474e4e1bb88d8404167d026663ca8ceb701901b18e69303efdb45615d3aa06add5a39d38f088349d899df233e6c24c9f2b192539afc1728ecbed612a2a25176771dfca8d908610227eae0850d4050a4023f57ca215a3f81220c3ddc355b65596c4c71a7550b9f4fd118cec9f7fb0570b044affb8d0211ed25259abe4b053dafc4fe7d219e6942bd762e5bc01ab2b6175c423ff9709f012519fea48ac3c297944a7c2ed9a0a9f93f0c838dabfc4e1eb8fa37e6255a1160f6d45adbe2779b42f68033d07e725e577edc321b6b3ff8b223f1da24602b0fd4a382c2c0325358782e11e9266536b1c6c6014e1edf90c048d4fa0440741129b0f551fca171943b6129026f5e860087eac807d3703e2774c7e52dd70cc47c204d42aa24707146d48ba4c2b5c7617ae9a0b19e5e8abb16126145edc195c32c11ba98bc345dae9a14e7ed394eccb1f3feca083fece6f8e20e641014eb880aa2a7fbabef33d5d6e721fd1952add88a5aaa994db31effb0e410a34e5a02507a60517d60fbf9781348bc234ca751a5fc0615bebf1e94181359b041643f8b13ccb9643d6037328a3428fb8e8e7c0a756a110be4d8eba844355c3dae356ee45c447341c64ed64602a32b525c9034fbd18a8efb60f900c5bdcca4944b08032b39f24c70923f54caf1da0d1c3a07f75cab06360d009126d4be4921fa31d5f98759b3880be28257b46c280761fd64d4d309c5031f42b906d8c3b0da364955026678e77cad3f9b89935a4a675cedf0a48a8c54b720da870eb38e053fccbf396c13b4d25417f3e71ae850b44189dbd84406165ce7d175754b837d5e6f0727901ab4d07cef5854b5e78f5ecb94db4b811e446af75930f3b994cd4da066d0e695acb9457071704f6913d8cc6549d7decb035d69683e8e552df8e0fad17ea1d3503b527c502a338a53c6066fc64f56cb219aa22db734f8420fd47f8f258b87f671095c77a15e7e388273a9454b3b28c04bf882138a8ebfb9bd0ea46a883c6b58f864b4b74175d25ef0e21e2e3b596ea36fc45b48ac880294e2498c0ff6be39dd9412caad3bf68406c7ba98a46275e7457e9c16e032955dc7957236c900f9094a5a3a3bbee503b020960cae4d37c17d91d285f613dfb3f13a1437e0462ccce6af9315ef240f7210a8894bba940a1257beaf56fb42467e04859f723de0cc92a1ab2682a204c0a7b3ec6001ec323e266ba8162f4c72750fa447c3be92d5fc31c5249ec04e6a1bbdd4bb92a0cd7ac2cec8bc5a28faef8b5f533f272c614f53a2adcbd050b584820e89c733fdce5577d4ce509f9b551cbd512bc5c745906019a4e7a43809f60d3040d27ccdaf0ed8c082a31c5ce17fb825158c75d2c89a8a006ab252e07d720d6d04811f9c59422d733f7e734c7991d5cfddc3cd2c58621fa6a4a753b2b1d45d442b0323d3e2a4f4c97bd7079008025e64916148813c7882ceed7f7c86312424334372e0fde0c4db003b593bdd0006540409aee207e8401f2aa3ff2e1bd3bea24cf760c9c53c134c33b01e1d638012a3c68911a7e82cdd5b67a3f19d213a6da1e483f0e5120674ff266643605bfe6fa3bf21585f93461c706a1b39bbf5c52f47de95f2998d9bb7386cfacd7a23090b95d7f8467ee275f7daa32f7879f25cd09d64e1e0d742b60d536a59fbb72870c42a450ad54cd97955e8d8cc99db2335affbb89534f942cd05f2712ff1559691674519444f48a56c31b6c65d87f7e2c4e6ab1d6c8b1f2273cef1b507b38ac1e28f0ef222676ee291dcff429d98ea187417ee0996d8b0646d5c5311a3f7bf66404ddd47462bf74246d1c32d2032f8a41a7289a68cdd8425ce958a0df9aedb003f153c6733bd15c4c689c819683f9501a62a7304586a04b4ccb0289f57d79c369fa8401f1b62892cab94d909da7c86fc290beecf43e0fb98d430674677c5cb19997277d628ceaca624987613b71685ba47709ed7e2281af0fe38ec9ed06362aa6663dc319d9d5c46ec1092cc6509b7367587984074745483892ba7b9a3aefae892e3e196b5afda5228585664324cd3ef3a80bbd2846c8ddf49d853b7ca8c4ada38b6495e2c2e1975df115a8077b682a04a2d093bfcf397ddb76e091d81481e3624cad759b5451d23d286f7082ef17013db4134a531dafa11ff2ba0011e548f9c723e2eb021649227986542d846886571f5dd5950194104416a068f635b6bc017fdffc5c2fd148207d1e1a01294bfbc49bc147f1dd39bc3e7f0e2ec0d7192156312234c5c98d89faa44a7a70c90f1778f04629dc65e7c7b68415a859cbecfa1f43dafc11cf3cc8086e2e5c05a1b4f6dd623d9974394294a14e063ccc3cf01aedd4405b7a52aae85a6ec869a9ae5cf693d6d30c4e33480ce6bb735a2b28420edeaa8d41661a2505e6afbb0c80630dc1766505a33ac3a89481619d1f37c8c5add848431677017128f28ee142056ebaf1a4f506de28d8135466a00eeb31bee0fc4992ed2701965094bc7b7fca56bad7ae8eacc73e2017de351355146850f3d662621818ec2d0ea9b085f24247b93fb80a8d19dd7be818f6257e3d65fbac831dcc05fb9f5008c82cc64b40b05046cd5ee7b07b82a12623ab7d4ffcbcc2cf43d26299d4043fbd31c7bd7c698d8a09d3d48c0c98274ae05feacccb47c331afdd50caee199719932119e75c9ae0425a835d9a14c45d0eacdf94caacddf7d074b712ff6d0368815051074f70d4677654d347e87a2441cb4e502236a40415aa83d4ee616d542f5c4951dd71252cbf888bf1e232034a92e1b2385987376e5fc33162369f5f328e1deae516dbeba08874a10ad6bd6dccbd904e4a00e5c106f971eaf330017b0443af4a972131c20bd389d72cd5a7da69d57bb40c412595d45531d73b8a31802802764eb0e2499355970b214c4b3ab18718c277e03e6922b5ce14307f2987f2bfe95c875f3d69e68380999dff8d7ecf754e1420c03730baf3daa3a366e6e59d8b301ce0c62b956a4ba3cb0c88c5f9e553beadba6c886f5f1331fd2ce3a8e8f39e1f47c5496414d553f569ed6640f728fa15a17c36d65a2fb2bd2eeac390a394512dee59d2c18e1de7a52722c79371baaee97e6d4856290fb3d8a533151d4374cf506b9dfc2c311d0386448950eda2275250e5ddbd0ced8e89f3ed95f9b692f9a2a79097ff4364e65647a40d2ba21734123be5099079581871fe2cc32854582a221c4fd9c03d2252041d090051f428424dfa5a9b04aa1680b6011eafbea8d0b891c92d621e666bd86cdf55b461eaf61dbf9ff04aae4701c74f67c1603c24852b7b5442af8e0984613a050646df5da184ccc29c2fd4c3148e7fc8734d5a8965a9e32ec0a43ea485c59f7a6dabd79577abd67d11aa6fac9f60273582d9f9f4a7f93cb98c631b6364119779ac31b032ac289c60cf13da407b179f9bde8d0c025406d38cdd68ff2bf623f5353b0c93b3638e0c1f4ffb8fcc08d39a9fbb22293dd57ea14f2013f83eada49d6abead9a391053d4489a5df3f611ea62ac6d094c2742cfdc8c4c0b0122bcff6f63a19eb6898127c1340ee61ac8c9af8c23e4e6cdfe6a07ea46651f1cea86f9732b002f25d230bdb6cffd039586d836dc69713a055aa40d5c1b155c5fe4e34942fff60769776a9516ffb026d43c97d4a8c5cd0757efaac0a10bd0dcf3c071a5f633c94ab821c8f39f2411f677d226341c2273153a29dd8e643ad5f44aa3f78a8ad7c958b389f2a4f9f36563fa37b4d3a38839e70351760764b99b9e9737c6db70fe69fc2d10bb61bd4411943d9feca217ffbfb157780cf7471be06af9fb4f06237f30b0cf68dc90c7b519da02024a2fff59ec57b7626bb7a6e7cb873edfe02ffccb8b91d56ab00021fb64bd3d8cbcc6803ca2f0235c4f87d88672078925a63b8233f058fe713fa7e7c1f31740a3cd096b2d116097370b01675a671643eba773c2f95f22fd9341448be2e66546dfb4737a1833663bc637893543ecc44e0a5669e446096a487f5e810b22c89b2a9762b80eee7976131d644241faec4dc240c5fda2aa1eb2d53e66810385788873db1150a5279db9ba3981e94f191725ff3f103926e529f86aba3e1a6127a706283400f36e24557438a3ba3dea5c4664554d8ddc780b46ae04d7e940432c6e572f7935c00b875868ecbab6f692a45aacc80c9c0c009074f0b4bf7e174d01a21ce0ef67a78eb0acc72e73fe153cb8a95eae29768123443a59f72779a564d6ac0117caed882019735f137976cc60df00e2e8ae189428dd169e77920d57f2ec7e17aa9dc43b9a7cc2494912e2a2939f701bff95d58d3ea887421256ab7d6e6a9865bfabf28b0cb7b35de7e67515b10c5ef357d48d7589520f94aea48281d04a7cc06e4f47fb02f4a6f70fd6a676135466a6bd28eaec4d93626a89581701c08ad2ffd8364bdf9c0d39c3aa23b0cfa4dc99d7ee362e65d585aba87717273dfa73b7edb7ddb1e655aa2d0328c61ab1a0ee2364a4ad5b9af4c5f0463cd2c1e4854e9e08a1adbf76e97bcc11a03a8013ca99509ed884af2285f7556db40e2013c9faaf1c42c5058842f38b24727c376ac3066511b1a241024e8c781960ef690b614f232b104c3471dc5f85c810758a004f04b34672aa6e8210761cf2712c42d55b2f7cd584ec9042a45583d1bf292deef26ce60adaeda1959b6db4847cb30953718dc4fc346487ecd4260cfa9d6b14f1f32fa8bc05679df53e05e42cca106a69a31ac4fc2304219ae6ccb3cc14a1cf8b6087a65611f98fdbcc3fb5772f761e9b00cca183a2aeee67d18b1d7935c535e99d6cc1451b7b4e2080c37c1ee2414ffad18a85b9e12334cc2efb13fe5b0f3d72002d2d12b8a7de514cc7723ec48c4d306ad1b9a299fdbee99ae910a593a796cb3556eb2a30b53ec30ec675fd3cd2e4575950abb358a12d3186d3a13be1378b482b3b476737b775dc84432f3a858c7ffa82a948d336d962d6e868f4c0202fdebdc502265ef9083c977fd2a1b82b796ac329b9204b9871ebf9f09b1287f1327613f6250b258a4e0625b57c5f71b9df85037330ac2b8c4105aa24b227a22a9054aba3f4379618d6cdfeabc0f388f2a3fe890998367381afc7ddd6cef78682cc68f578e7f256c42ed008290e41c164099bcf3be16014d796af550fb2881a18d1fdc2b8776087c9bb43a593e7cd9044f4d3447bd06cf78668d441ec4362c5f607dbb81d45703bfc6eab42ae8b0bde265f57211881c28614fb448e09435d9f2c0c914a65a8ce254f404bcba9bde60e2d55acc8af6d40591e469f849fec205e44c5957891665aad87e459b54fac44a8621f19c91d2293215b678bd18ed002ea9d9b29a92bf51bc00614dcf30de69ccda3780b6cc5bdcaf6701d75051806f8634ffdf99d3aec51e8be0e7745ab9281400f6fdc1be9e7a7fc6d697a9aa4ee30e6df60b65c42fc672dfa7ce1c8ba9daa0b0f65239fc46120dbe2546c6d8b53f5e9698622ae6c57d983f721b6ad459890161168630a59438a0d77f72b039654c62050d18551c93cd269e2354e5f2152f65498ec7dd356d603c58134f262ca780309c393a79e47758ffecfba3333438356690876bbaa4f433616ee3a91407e1e6fdabba50e284bb956f30a8e97433e61c72722e41d7d206ad80f1a4b0959c8bf57ed34a743601253af0857621bf989605141db821155a4d392701bee499e91acab2c643fcb2afaae95a6f6907c0e4f0881a14fbfa18518f98f6e11ef77c907d8e5d0524037e1f2fc546525425c09bd3211c41321650a88b0e8087ecf994dc07d2a1c9a57d424cd131f3ade70577fbf8a98d8dddc6bef89cda9b6559d306c26af8ee66e282fcf265a30c06a15940564336858cacfb5c5711e9bd3bc7cec569a49785481091544c7f505dc3dad1bbefecc0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"541f425e7cded50ed642064a0d12b281"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
