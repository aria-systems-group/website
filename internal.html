<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a4dfb43132b1ace752eac25c6c0c019d540d06727725bf6a24159c23d5e7bfb77d3e00638ba62dddf81aecec888a83c1fbd2a10398268059a782d2fb5a796ff638be40c6540e5b1a4fd9da34ad420bd659f8e9c09148945bc4ead7d30b5bf391803c76679b45db2727132ef994cabb6f5a762af8093c28ef2f534353578a5144f7beb47763f819be902c5465d43ac2a96e33c313137f51431b8478e884adbde96057ab469c3f435d645db34a8e55c61224836a73167650ec8b79d82ed5f3f477e062013dedd3b667cc693c747376ef0ff428c7044d15f66239255338977c1f4efb7737ed37536324ccb6d30cd372af5a3aaa2a1193fb1371b9e8f491dca1e712ed5eafce557f9320421f945811b03b02a7ab1204ddad32c179c1814cf931b0f72372cbbabd03ebdf1078ab5a7489f8887caaaa374256576d5449aeca368b3ecc29baf24177b772cd2048d6fd7ee74a3f9262338401ffce6f9b4ae542cddddf6d382f422a06840313c537b607aac7edd3dbf74b2ec59d5f5f15ba9d5aec8ce8ec0bc93ce4a34a8cb285056ffd9bca16bed1ffeb241f26e8fef155de6bd27da862a22552a84450409de49948f4940b577de3ffaa30f0e6a34f4e4d140d95ebbafd619b333de29a9597ec8c0b7f2ea52fc720dcf09b541233b7c0879e0ec6193b47852b2699310fa4c3d699ec305d15579f66609c705e0e41554bb0c3ed357fba221f53a6562f2b7e2b7dabe15235a0af733c7826ccc5ead9934716daa6f8b42181b6f4d94e72485b5d6866b2951ac66378f4e36ab7e3fac907d818434c1b37bede6859b5aba0fab162a63212c93dfd31977891e65ad5d176466271bbd75584c64da66eb0c9d37ece9721ebc4f24980d82dd48b407cd339c0249a74eb8bf48b99c176bff32a7d66c851157a91583f0bfe2432b777213e0f9c7fd4faf9cec0eb73498d1fb03d811808eb96f1ff0b4f411c9146be034aac4866a8a4d5ae20368fc49a08ffa6076b940c59033737e5726de5adba24d29868877c32fc0b9f286214c003a38262943161eade0122cc194da2ab6cfdcf7ecf1b78ec91e60dc930b9f50e40809a5f9d1126a7155e5474455c9d073c7f947245b9e5423133c9cd56aed47f0a50fc86932851b36d5844cc7e3280deacf4ed7440cc9fda32faaadce1f9c50ec17409f72e33a17feafbd5888e656d16ccacdfe9e4934053d80470ddddbcac5e88f2d952145b0cb4fecba02071d017bb46c458eaf204698862fd4bbe98b989775b1f7bc46b35aa40b947340fa7779323f7c2f6529f8da900205477ca6965068d39510ffdf6cd406faeb43e316e0d6f6b5583e5c247ec5f36d6a3c0fecb146e51274b79990efe7d691bdb5e57c65d92259aa019ca5d2e49b93b4ae63291f445613d1eb90f9023b0a3bb6b80aebfe8ac0358d3e84d51776d176d3912c382bcbd1e59bec40f0c50be175aa76c8855a83627d2c82be968fed70300049d38b2b68abd1e46d959c85814704feab543e3b3bbcb72980bb04ff4ad30d2bdf6a5c1b935d4468d1b93294a373e993d48799cd5b186cbda8e25ef0c8e0b050f60ace6b4c2f7d5d55df852c238e8ef4305216b21a661684561175e5e9f6526be598cad76d012c1c05d8befb718b747163a4edfb350cad67af5043aadc8e141ea039d9fc094cf25d20a109e8c7048516df7c7c4aa42378e938939ca53bf9c8f38f64e2529cf339ed6eed241722fc25359cbd93608ea7530286bca9f315f1c1ea056e89c3f5b019ca41a1fe5e0dc389aa3d9187b30175e50aa03a639b0d0cf5ba8bb9365947a949186155a513969c8623d9bf510b2cc9d2c5f871481e0f195cfae9f90ae731f81cfa9c3f9279c0b64cafd4a95ac3958af78ff839bcdae012ea403ec5f4d80b51374b4a04c20e67a50554d64e376070ecf87ebc99f0a40207fef20ba0b12805eabe5356fe15ea0a200053c5e90410dc85e233e8981be58ccc05200ac122b32ab45e9f058b615d7fb7b23345ff0e5089d398424559392bd58806591e2888d8b30a281215da6eb31897178081783d33a7ee6d2e75caeeb6cfce6b01da09a544d515b28dd9848c254459e97a696e3b91a7c08832eb72877d1b7acf382969b29279dc8bdd120def2767a86b91ef38b24ce8041fac342dc0ca7da40304eccd93ecb81741f49f9252be653f89f95ff81e5b1df565599ff9f9284c6ed21fdeeb3fc28b7bb189c5eb1dd03e55321156681ca8453a780481cb5fa8add52eb9b8a80e7e14d7cc251be0fbcde71df16332dd5685ba58593d1f814ae2aaa434a328f7e57a6f85dbc9b443fb231e33f4d894f66b8ef12c015b4e14a6c982608b5ddd0ad9f478e70d0405a2c635e3cdc1b17f22c6e9e906a201d49fbf626ec03016d7010d11bc0b7abd3dc0cc396dc38475b4b4424e27e4e56b6a327727cf9dab7652e45925b5ab49515a731f3d742c063605e70f0c924851668950c907a3d8e7c94dec0b9795f414940e5e528fdb44a965164781c0ef4ba15956fd3db6a0f093a6d401d3588f8ef7a380e8980bf01300efa80ce910710f1133f3a1f1885cb22030c675b70a5363b526be75e340e8ab5d326ded2ac783a3c8450b1af3e12b53be529be1400784e2f441f2c85e7156855815e4af4d3db8c648493e865366ab6decc4f08d1d535f4947db90a45393aad8dfa5011511b74224a01a6c62ab5b7eb663ffcb1146f96ca40e0f21093124312a1281eb138056e27bc1f5bf475f1f1dcabba68e7e87df439af5489ac494e6f3062f762b1f714d0d574033d2e4c1bebd838de295f646490c951f0e2853b231be8cb79bb5eeef42aeee05ce8712abdc91b303f606931bc4c53a75b1168964023f9ae17020721f318e1b34b3c3fc61731e45c1fe6639c94fde68a68adfe711d1dea0a7742712e35652f081282c48106b2133bd5cedf50b8a9bfcb99d9b5244b8b5cde6d7e4a77b1463db32e2e72d6d7a0ff7c1ec6aec022042d8ab6b3f6170bb8830f276a9a711fc3360cb2936a10adaaa45b2e93d9726373d55004716f3231885bf81a35ee00c013c9680769baf30751e46c4e630798ebc1ebc19d15333165e8b21cb53a8da0a4edece4a1f0c712c811baa12f780f8bc0c5dfb9d49fccaa98487f25753ea77c6bb75a55b6df91f6546c56e08e5ad7e8667b68ddf8e7bff8be3b2811a3d9ae3907545c2abfec2413a3af666af7f7365fcb9b2428b8b8d214102dba751693ca346afaf8e30d368e438b35c15e7a10ba59dc58136d688be829970b1df5898dd9c32bb23b6ed55e510cf85169ea2d15ce6f349276dd36796a2b8733acc29fedf6a3e306c14e908626ac2a3693c5de3f9b90ec4dea03aa6f82ff6cb59cf06fa8b33b0e92c6a6e8c8437864fb455e03af894bbbc047916f6eb402a2bbd32d7cc9fd9bfd7713d283c0e3d6b00fb428153698f859a9f6e6beada16ee6276d08c92fff0893591b4b98e1277bd703c450d642902d814f57506b4d8ad28e53ec55817b922aee1260d180a804bdd0481db57011ec5fde81860964b3d2259f05444a4d95e67cfcb28ddd9af2a73e0f00525801bab6a63fd401bb72a8b917dfa0153693dee047bbf4006d411150b4b00172dcef0231f6c5c69d5aae34ab3f7ae3e5a01e00291c4a44d54be9b11599ef6434207f021eaaa8fa431b75ed030f02c76dbd29402d7fe2c3bfd3522c49036dc7f125a5d090fd543b9ed85679042421cb9340cad52d3b5a604b154a9bf5cc372f3e0bfc856fe3fa7382306c57247c74e1e4e0c6c8b3f7be641085a426ef433a6c21778bcae405c81c296a7898d3e2e1d6a3bd50a41e084dacf702ae8fd32e7f68b726798fccb4c7eaae86b4d2cba2d60b1e9c9e54933e50c051011b5ec4d785b54e374fa64d8955cda3cb2e030980bf6d285c9b15abb545a29585823c88472e03554551b8442e9dc5047a1458d9e4903cb6019383402fece6d4c37ee8713337bc717688002cd7005ae371b3f74d63744fbd66cc28190f7ad7313b251224c5d319da8c350e408c5e453904721968c12dc2a6f39d818aafa25a2195ad6d2d72495489950ca5fbb09acee56df37df0c155b3c35220cf30b7460161a1b00e62c707c53dd5c0204ad4b555f10c053900feac15378bb24bd64ccc477a6c11f53a165669ecebfc092d70c6e68d0057d9768ace913749fd6d7fb370b5c0858812c255a510db860eb6aabf535f6e23a4a109a84e39c5cf780597d51e9ec0aa45e50f18d2e3255a7251968ae710b6114c562ba185902b0b1342b371df0a332992b7b898abffa4eb43e22c5161a2e8ab5e4de1e5d2574e6d9e7f1d538648ae9fd137be3dc9c808343001b502a36181f6737b14b36cdb09bc77cd07a828e3bf21bf2546a18bd210e42599c157ee697d188911c0d23e0821cb88d6ff89473f8185c2f6806653c1f4ab81265317b904b6134d5d56f167563357354ce33a7588fd3fc452643963e410540501e9dae9d221763d53db8d54b99888f6ba4322863189cc5d253d20566a0342acf427beae9b1ac0cf13a570acd9f011fbfc8b8bee7715ff6439ae364721ccfe75463256fdb057a539760f265e3966d788278bb97716110990bc9642c1af36dd9d0c8edee98f7393a713719db51116a728ba4229e702ce27a4edfd9cdf80871ce3a41ae73984c7c0027f10124707f6b90ef45e5c6004c0d663b56781b29d51b765eb7077c838ef24e65f12d57cf247f9ee5c0b17700ce3580869ae2ab2a800b7557bcf65f2601f6d65ddddb8ead7bba2e232841ced34cae3c5db142e28fa12b8affe97f7901d03657e5d7f0e7d476d37caafcdc7af2938ade5a44137b26cfd155ce23dd442ab25cb02ec7616e910d44ca0d4793f3735085272581326c4788944105d66b4ba4ac0103a7838927202b46e6739a20567293401c04ed790af7e1dd998756cbd31774c8e0e87e134cab504a6f679a3ab6aad0309c3a6b4507a003ae555fd86242de45635a017496476d2a4cf2872b5a713bed9de0202f93d653ef4fef8c87bf282644ae0dcbfa7a61bbc02455a36005764160f6a247dcc4b720a84cc4fceb7e90f6fbbad1d4c6a2d59cc704c44800006cf01eef3d09033cac8043262df89e66ec42f9abb027de1f6ad2afee8a820e9727528de195b5e5b6d5ce0e0fc89c2163811a006ad18007f058b94fdc4c11cf78dd9af557c80291722eac95c375d844932ccdb574ea81ab8a952bbe9ffda00d9972b786fa4dffa62613d0c0f221f41289d899b2a06737b2813f889a445b3df7f84122b4ca0d2a80d205a1cf172b9320fcacfca285882a61c7c985961b2df81d1dde5e33e87f7ddb6a059c4422fdc4d2ddee59fafcd1d9b3a1372bf9e2f26f5a0052237eaa2fdc2be3483fdcaac7a95ef84d4478822797d26ad99b69036756c55b30a79af1ca327f1dd60ad6fbff0d31812168dd0ae0552141ca5505ecbff7c26d1277028342dd34f90d37a72193617289e81a89e2609c7232a78331847430fba6f8f35bb110168302941dda527cbdc404bfd07fc401f545c29178ceb60324b4b0c5c91e2f93607ac5f01f413dff376846a539e868dd71e844856abb83c234a9074987bd9a3acf74a330bbd1b4b3de641147666bcb94bb159129d884e944e196d0192d4c8361504dc8c33ea0702293674044a77161bddf2742d0678e1208c9f6cade17ebb09151b69cb8170c5d1bff77a206ddb8c06740f210c5f25f74e91ee9e5ed8e9896bc488d88ef7ec10d9b835d9aee495003f7299bdbcc4206a850690e2ee2e89294f5da0ce830234ff0c681d509e15a0be0c807f102604431b7a678606fa514ad17aac556eaa8e30e97a3a9b7306053b5bc83b0732db3b93d75b5310fc0b87ecf75e32323aef77cda84b9a8bc54797a14c8dacd5982561a4d17b93bb4c06099e3de6ed3535e2325efd10b4f65783037443017bc7e63bf37b0abb362ab73e6307fa344fc4b221f1be25974a8b803f4181d1303551fe8f15c22686aa499eaebdf946076b2e985ee78d19ea6d86a97e1b0884d0b4aad9eb323f708b82d6c79f3dc452a1e4dd04c5b18a84ebd31d7edd32f5bcb36a4c3009d850c39fc265210505e3fd25b99c2578dad91056feb2b1e95ccb78f49026148fbeb940de7d7bc51cc87e04a57f0c9184939af928ea080a896338c5794fed23ab83f4a68e1d371c3157f492557a53acbd6b16e4585e1ce1cd934056c3a8fe3b8c61eef4d2a2da82e2ed8e0dbb34a40ad339093484714d1b35ffffe96460bef441f2589c300549aa986043ed20069313dde2838e0a5564a00989d783eeb5dbce0fce9e1f90fd520d29d4372edca5513b8d18799207be03b0f5744ab4e98ddc55784297d29cc47f775fa68e07fe7762034758fa8dce758cb5ee3faa42bcb1acc2ba347a5b2ce8371bfcc6034417a1f705be8825101008aa733b1ff4c3a7bb01cb81dcdd72407e06b407f6ea062b57cbea00bfb0332330e33b6e2f9ac8ae5aa6dbe07f7f4a77a03d50461c471ee83af3fa8c87a3dc6ea27970611b65fab9007c9a692e1665aac0f6386af37360c73b8fd479364d5618b51889c76e37ad02877af938479d19a625398d092df8c56cc0eff98c11d1485ef3dc5dda3b36a99ffff82a40c2234024303e5f51da9953f957704329c74b3ceab71fdbf7098df07f15f6b9afcdd12928d16f6fc82bdb11911c82a6d2f4a122fead5dc7f6ec3f52e71da062feaf33bdfea9f59913aeed3e6add980be4716653dcf25355619fa66e0edd57feb304c8633397acf351b640141d8c7e0122cb786b024051b59b613589014181cea2b4d85b595f46bde84c5bbcb4cd032264443f997996ab8586bba1ffd67f51937b98d1cbb8e5f6bf79f06bd9a38c9e2dfd59884c9694318a6a7e4e9342b87551c1dbee2c400c6feb118578ae4837f43bd24ae67f35f2c2de558759f970c00dfd3897f0e2c77479747a2fa551c5d54684136fef02ed2791c0c6bfc95200e10109c89aed23f74cc8ecf770d2bdc87ad62d7e26958ae4ea5b2bcd02d8e4171cbd2a321986bc7fe9af2541937b3799c6b30b60ea027cbcfbca763b15f7125bfdee69a93c35228ade22e409d6907d5465bcd1685019909ae4f1c9dc4ab04afed009b87a87e4dbda0c64bf02d96cf9e8049bb01bd223751e7a136a4d56ad4e604b05fb7759d8a3fb2618ea2899a135ab4117d8f8e922d624870ec78b6c864146e6d118b65175e07f9c9c83a8365d62a3ba2119a521b331599dcd21c4305ab9e590b8a555cda68d8fce2ebed454760e90123dc25323844bbb80948cbc787a19a5bcdea762c8ea5a91db9f8d12f3fe8c6c5f0eac943dfdee95554164930cdbd140782d9e9034be4b847f5b95f3b200e8c17ff1e58a9c668170c82cbb54f8fd3c29776767ab781d4f039fee648acd6ec8983b963c9aa6e810c412c12ce98be59e506190c7de6f665e1604ea4ce660ef2095d60aabe341846f8ab0971bbce30106b423642fa91170f6988f4e77b4a6dbfb297f44dfa34216b242e22bd1cefbac2499c6521bcf9f16a1ed389603e8851b1167d6eeebf63d4f9018e58d8bbe6a00c9ef8f29787f863e29a0f56ca52a642de3fb1d4becb87b0887816de4be731e7fc1bccb0a618f7130f8edadee1b2a1f583c25e1be0e8e68430f5dc84dd9952d7b63623c925c128fa106eedd58368763ac7ea809d3398fd0d79fbdbd3a4af28bebad034ac2c1dd7231a4a71bc4bb8946a38725db4010dee6f3b59113fc5a55d9d618df4bd3529ee782ac72eb5a8d85c48c32e20e4c88f6229e79bcf0b6769f1f83f173a22dec964a9acd3160be1ffce4abd67a578dbb90b9723a1aceffb54840d9a34d2a9f63081eacdf86ffc8f05e02c664515b26e3cbf49b77cd222db375f4ee8fd9202c6548a0f4cf7226fe62bc184ba57e80d3114a6c8e12cad5bb8fdce6f7b24bdbf44b45816ce540ba4ab18e7bf18ad3a5a63b9b2c722c66658cf6854bda3f53a839061dd52ab09527f9873978cb551d5f83de0108e2dcf70c142049849ff4504ec667f28ec84a14638736deb18798f20d19f35996fe58f6d6d466daf5e4d0b8bd605e98f8e88c73521f7eaf06e1d327739428585e53d8637ab84addb3ccc9827be2fd31d8bb6e7b82a53acfe1b369807a8105d712175ac6e310353481cfaa424acdb23ab46fd021c99d8a6e695f83d4f3351fdcf7a538bb62392ef50292d7cda913340738d1504f7d1820ddd09a7a0098c89fc62412934208008cf16cf3ea99e83a80aa6b8d02adaf3816a2ba08372844ecbfcae622d063315ca70c6f4a827be9f30176cac9438dd824fcd64e356223dc893d340b09c563cc767ac916e4152d5a192e7471f8fc11fa11c486a76f4e8a65d7bca8a6141e3f0e4b6b8f2f15e5bd21582038be721ad1aa3b40082d2f2ecb0f5ac72311af235ae3bfa0b9f5ea1376be824902e4c6dd7481b6f22b777f79b6c0e87397e1f34707af218b329ea9ae5736925a09c4a033d7f775199fc35ffb1c5b158676b73ae5ab5a502c9d3d042569e8488778ff07ea6ba9a796e20dc8142d2271146fca557d1cc3283831ed730ad685615c0f1afb94828fc918a16acf83896589d4cfa7eae2683c4fc47d11c15a6d5c110a5afb95795d589ab5bb6484fb08277a89d4b997beaae1c0e287a9e085063bda71d24c50140c07463333f8c44b8dadfa17ce3bae136a7039d49ab15c23128da4c0bd9098fa9b177bd47c3b44ec4376d65719823349114ff2d8a25a96731c01c5377bbbba1ca469583e0b91922097aaa9cd91e76fc701164441e2a2a6e5ea9201c3d6b310925e10862bca6337f5e5339d40e83159bc48073ab8373caf8eb6dc268bba8b4025a3480836f506703545780f4eaf4301ab3f0b2ccedeb69758c409a4d7067cc6f5611387a2fed552dc5afc688ba1b5a66d47788e26ad909afe3df311ad31a16256b1467f0b98c118cae25ab8068345056566e9fd4bf3e1aab3550e58660527f87e93f0c18ef6ccd1a00366f9b8395b28a213eadc6112055c4f6a7abf4cc2de75e20a81fd198e9f050d5f4ba49296e02cd06bbc8ad1f2b85e6febdbc36d12a8e97c99177cbb0845226bb2574e266d6c373dbf5b86867dda28ae402ea81b14ab3719a9243e126c65449c17e5a444127db53f4d866dff9904a350064946bfcabb29cff14a8b0c0409c940c659b8244904e9e2ca76279276025a1b5e3d49ab5a755bb646894ceee9f5236fbce214a30cce736e2fa29f5333ff2244db1eb4878e10ce668bba28c22875c4d0c8ecf19c02644a26de70985b1c313fb5016dc3aea1f4b6d20bfabb419e5e8feb90bd419e183f69130a54ecbdb791f22c42ba7f1df3d094dbb9221aea6e0c7f7b0c0f9bc7ed694928f911edfd845599274150ac11d0a699e371795bcf3269a7b2028b8ecceb5df288ed8ed21e49954fa6f550ec5316de8d07b7d13a31ca6118c79df3658769dc965eaac309f5815f50bd4511815076fbdf1865f66efdefc1831026222a42fd5738f5a62658defeac7ca2648adba4744cccd6eda1d0f1d358769231adadcbb0f5895438b17290f372f57cda1347f82be789e9432c0d73717693770328d8b19b9016e8410e431290c4df477017165a701a056a6d256866af3edb785fcb353a56874f3e4d1e1f05e12cf30c2193802a28cd327a6ee5bd52ae85f3c90254fa31d62994a44736da6ed907998ad54b7737398c46d9cad8e367d6573196ad5369fa16f54a1d4eeb0badd13fe8ca9a31abeadb184143b7c393c7e7c34f24bbd00f0afa7d20915d1ce0e264ad5e807f83e0d8906bc85f57bef9196e2b8f0ff046cebc3f94edda4f7944fd88c8d3fcc67c87383b6987dec844f67c6f07ce43050be3f53b112947940139b9e9f92610dc28da33114e9d730fedcb61bab573a287a6817654a8563d46e3702ea2019eb84fc083c61cb7f481f459d0be211bb2af083e1a78f013e1e97d71ea8aba34f5efcceef406e24707c325e13a6aa9e4dd652c5b374f489d4c68b24c15f7dd337d55812cdd2bb48fd51801da0adf72c165a188594cff8c92f22782b96ecd19556beb38dcb325241c6f33a5916c1a3af39608b5677e0118a8b3e7577cd72719501bc72260fe3acd045af49d049f4d4291af38625cb8312f393dbebc0dae9518bfba7cbe2b860692cce3ade83b30cdb676cdcc44669eb2b1cc9c1a7fa3874ba4a8690bb259d6cc453d871a3685b2ac9828e9824333d35d4afec7950f3dec24e3ab3c58b7b49d5edc34e64251dcb7681688b6deb30ca4366a6b29139a0e2bc101723f6c46b9321fb67a4c3382cf3313b249629b0b8af0fd1a0a94fbff21866fd0472e628898bb4627377f01fb6341482db6a649b78d316acb89242a2d07db6b3b926a7b39d29bc1c5d6466a605f39db2ed14168d81390cf46ffa96fed825ce7d7012f2f74a6736014f5669a629a78008d365db1bcd03e654f90ea81f1d9771f3d6b66294258a81a32c43fa05e6c306749baf8e1665c0586a818f57f8a46a58fb5e95da7b6d4010db4a981ccfb15e61f7ea6146b399b60db1d2b7a7bfb366f348d6ba1bbd837fd03b7f37c035473a2bbf04b45f1851ee7e8e44a78de93cbbf98be7549a9781c7e9375ca3919f39d075112db6b67535e5d8238d8d6c53fda7cd92d828836baca1d666b9658431273e91c67577d7530b760c85aae26eb77c2be121d4a9b987edf8234e741b23a6ab9985ffd75266134daf5c6d6300babd7233d876cf14112bf1d9ddda38912d1cf2e9cdffc4c28f81b67183a58198cd1447ade0d0f79049f8098d27b1bb75d1cfa9a0db782855fb3ca29f1dc7561cf6299a55985cb60c957b4d27a98719f103301869518c0c1304cb89a3285da45fc8e1cd3257bed14849f095ba1fad10f14a870305cf0e02412d6f4a849dc265f0da4f4daf916a1c7eb2d7e9018abdb7f2f8a2961fc60b3484c3145042572f3b17006049cc480dcf120418aa59bb2a96989427f755b369b344bccf436e9f436d563d44693e4551b328bcc4be2f4c35151cf02f9290aa782fc510e24a684939bbaea30d634edcbbccf467cb6d4c2586e62b61298951d958220283ff5101787de67fecb510a7798184a2c0429920c84589705f1dab03c4ff04a9f3f1d0b125cc692cf81d83957adeafb68dd27be93570395e31031e00443c79e16042ba447b4a339df36080d7842dd4e8d24ae085cfffa8ee2d2657be4569ac12f1435fdbe7b96eb89da755ee27c3a9bd1f066c386e7ac06a07e57836a77a90e1133b70737659ddaf6869e1239291152581fe6fd0bcd6b5b3627eaf51aae24791c5675fdd2630c89cc177bbe3213e4fd1d6b91512d3861597e2c8c2ce0f94dbba3d6ea5e38b504c0b0e3544eabaec60f59a753315c8ed4844454f50fff5cdf73d3858005ae1778d149fae7a7461a6d056d58e24781150d0289bd117a1bfb28c1eb00e35bb52bd796ac5bef2d43df3144db07871dbec4556a3dd75a98e3e1ed951ee579861a49f7069b067c1a8aa1e2a74135d485f7500d9fbb2771634d947fff5707c5b348f1da9ff369e0c73340ded0a68cb4d9c6c06ade175aeea1cfa4a025e1d3b60de91b850ba69d0731c869673c985e83d98ed6de027924eb7027ae7e7597489d67e84a5fc0e2e9df05daee08af63d44d37d8ea68331b8a316ef9356f06f7cf7a980f6150a02d476534075dab2bed38af1524a372e16bb0f44fff42257ea004c80a8113a22106df26bbc3e277cf69d245992242f4023571d4da4989ec1e77e37defd7500c2eed1acbdfa0f684e4372e03aea17d723166f70cdd5b8e4d4578599ac269f2898b406e077759fa7df87f223f6a39024dc7a666e8705dce9a817b26d30c08e40177075832ad8b5f7264fa44af8064e946f44e1b70275761dcb642692cbff69b7e125bff09dee7216be91dcab2d53a55ddeb757d35b14e74ea500320f5677eaeea74e595e5a1597c2be6ffdd8d289164e329db2315fac7caa403146c480d9436f60c1f636c701c026eb736ac0014a97d8477275191964cb6dbbb808c5a57c653f3f551f91839eac07d98bcd99d1ad1a11fd8acd44f4095028ff692bfb5fca06e8ad1758dfcaf3cc943a1650b06d30ac27cce90008481337db879793d00eed331e0d0d0a18216c7100b6997d65e370249362ab68f29e6e8de601448017d436a083f6a0c476bf25e4b936b0a9c85aa1eba986ea1d59c3aa3d0acc91a7a16fc8b89b385405a57c1120ec63c2be146e516c1fc7fcf7d90c28426165428df0dd40eaebaca3098e59a17e67ed6f23305e9782461c6df4649d572415af94809b163aa4bf74dd30bb0c4ef16e39fb4659cf85bedc37992216d0fdc9b5aa9f31299688ad60c0451e87b4c38d814e25640fd6815c4706b314606786bf3a474a1a96c62075ae7d5cedd2258cbb06bc5e02787620d334146b3cd1acb425b8ffdbc79c76547b9b819f1e04f4966749c30d2ae3ea4c168db6fa00ca16af918031709155528c5fd5891aa1fef1bf8e17b801ca970e115b1cb30c3b62a2c08b884fef3d93734b9f142a132221c76ed8c9d54e9cc3fb7d77858ecf5b34e1014fac49274b9e7e5e51fe9a859cb3800c0e597d4d03f68f9d2c68da8f5e8bee009fd87cb780fd1e84254b71832581e537c37c56060be401bbb1f2e9d9c13df1f00b58381282e12b93adce91b16294190cf2f76099469e5ae225bbfb36bd8846f95257eca660fedca38504bb09f355e28fd6ac1d1efcf6674358fc553e36b7ef7ceaf4071d2ce7f9bce3e47b6432df0df258ecac3157a652bf9367ab3e8716edbf5702a70170ddf32cc40766339167ecdd60c98b94a4c017c7fa25f141e5ce4e44f6993ee0e73aaea264bf10e10545b6797c55ed124a8298dc43db92683eb00a79f61f8701144a1774ca5815a1fa7dcae7b47e1c816b2456666e24534ad7fc319a41b8e9d85b21f0a126dea5d1e1cfbbcc4601fb03287b303d196b1a1b3398cdeaab84be8b86cdb1ac4e2931c4d704f54d32a687896e18102be578f98e9ac5a7e1e9c1c5a656e667d8b60a0260297cc98c9718d6f8cf824f844c0ce989767d039d8cbbf68fbcd760bb8336d7c120bc7bcee5777034fd7bd848754080ff683417cc14ee1e98531af71f9c1d60a31412cc7c22d067041be7a81e9600914f9155a2494b1aff6aeb3cad392036add6f6c5db1b514fe9efd99ff74c413441a1e8a0857fe1d2c4acf8e0b306e75c19139624821198f57e0ad0e5968de57192c90ff998961aa16397c80bd45801b0cdc219095cba42f87bbd9f75331823ba20cc9ec146659c492e09ce7438286bff19823efb03f4bcbd2002447776024f506cf569115945de1459a07b59237974037d956e348c0fc37d86a3ba81adebce413a0a659890174cb379bd48630b213d2593869762ea80fb28eb14ffab8566136a16f367fc5e67823923f44c08193df97117922363885ea4d71df8fa0f24693034bf317bf55e638c9d7243686cd119e3558c9f4dc02c758db9b23fe262f90f8cd8545969393078ae427e375ee555a0dbcd517986aeb73e7b0c101414019c161191013e91331d9dfd9fab48b01f048b07fcda57d403288bac15c8e6d2610f1cebe318cf74a2bc7f8c95bd51c10a1f2c9478720a7222d57671c506ce9d90d8b5322648a1a10338410f1bd83d72a97ab35884af3440499711a0d6c93e7362044170ddd10ce6ddd363cbad2e0edd04f97a0d5ab657c391d0faea2f9968134857c20a721307ff108bc131cf1bc4e45d0ab1f131d617995dbee608ca2c5a47d4631734b50fda38da9d56f907ecff364f1d450c862b7a8c37bef059fa792399e480a017aa663fb87b76151e6fe0758d60d315d2e21e6a96e9dae50737aff96cca2ff73e15da2e663deafb09bb587b5bd16db8ab07721690ba9f711068ae74a61f4647ada7f2d8f4c090ce9bdc17474a9a016068e336e69d424bdd57741ba73e2a065b7d903ce2dd8240a36d95bc93e29b71bd9a57188f2fc84e0592ba9691e7fe809dce59682269a6adaddb22c68560dd9fd4b5bb3a5e8a616bef500823fbbb6914cf45e2bc733305f2ce0a9d3e7436d2d61d2b568b9570fbdf3f0a98b61aecb3c9a34175dec43a265b2cbd6c091ef0da19388fdfec4eef071a27d3b33210b274cb47875e5a42bbd90931754e3113196fa02510ce33fae867c474fce4bcff637d6595da980e959361f77e79d1da07d6a007af033f70702fc040d99616e5d82b81c555f43b6359759215cdd83db60bb85a3b9b1e190c4d9595ba9f50bd3d3f2210f52520b1db14a463c17834dbcda65f9758027f6684c1139d84701caed3022f713a8f81cbebec26b55a91fb0d1524e7951a8321b18d83b37248d337a6d2c8bd0a20d5ba5d7a603f666714fb11e7075fe6cd3dba9b675d452b9147662f139a156221fc803a46c097c4a1b1e40b05cb1c727a2b8e00064b4c23e84b7a54f27825744ae4412f06ca1ac8b3bec935162d7a63630984d9ddf183eddf0ba66037d61bdf66cbfeee1e3b40aef6234bdeabb3c6d91d84d5110f8a9449c14f564f82644ddc1c2f31f1472ec6ff9b62311c672d97b138ba9bec7f231bd3a2622026410dc46e9c79f0c4b2547c2401d6672d6dedd88c33c5fac5b98d8267989eb6d2880480e372a59d0c8f95bc9f39d924f84ecdc1859b420d1e32421c3b9e8c93aab27b303df43e39128285f73faa71ada29f518cfecb9f90abe42aff620b2b3c42400217708b388684bdd7a0cd2c2faff9c1e65cebe4e7c9528c67f0572a503461b1cf6f9ace42534dc93f354d7fa16751cff28bb57f030650ca7ef180c8062920929f4ef3f0aa181a9e7fc23a5ef78436a52b7555eb12a64f965242d93484bf81cc9923275133ecb0e0836600ce2709d23d1efac76236679ad8bbbbd4dfe5d7abd14135a994401c7aebc9385fbc604b2cf16bfd621552bc19332563f03aa1cd03ffb57d9c050f1e43b112093957bdfede7fbd05dcd5411ebf27718637bff2c17633a46f8815d04211ec160178ec0fff32a66d66cb0133331582b12aa14dd3645b2c35eec3ca0ff6145747de21b6d44ce7c0a4848ede7f4e2430ae7bd323be7f6a53f0a288e247c0a6f81cf4f6bff807b11a64f6341f789298067b4b8ea018fb2bd119224e1f54f426fae9a22def61838335810497db7fcb94ab8d0fc51901e250842c16b7cbd9ea2591b5950d6b5e3605b9aa2f864bbb2694d0eb2f028b499af9112d1997ffb1d742f19b513c180aebff99bb62d83af67bda13952a663209e604fd14a8f6a9b347e8b8655d4eb346f8adcb20333f15b695869fb7cd57366e8aabc83c0ca21865955a8052bab14b776c8c387b0bbf917cc68bb15410eff9c273ae5c39f899a59cca45304af7a1c0d46b407ee271a54d3678e324b5178a9c4bba7c7956746b6aeb46d8b0df4672d04acccf95fe241941a3293202b4f58fa7be83760401c306d69ed651b30e89b7ee628dc0c439c6def83d30a035d6b87821188ff69dbd9a1155e3f7a9d3d4ca04407349a2bfc1d13f4909dfa971c854566a5a061ea9e71388c12581610aab53b7eac508313a11639b3ba5596c1438f238b0cfb14c6a2520537d84757c69945a79e454d684065d8155eeb7e5b35031a3bd6d18422696ab5ede5d2b7f177b39c36a7c7aef72e57088211e951ceeb8a069164ced886f5f6f67265448f4045d1b6e4b42d6b9707e0aa1e3a3e94858875b8004ec836c49cfabe664910e77acc4ee3eca23c563392cacec1b9af416ab11ab6c38e93358712795e1d85ca2a1c54e06544988570c9335e198cc4ed595161c28796ee65c46c0771835d792164bee8e33c9826a8bea15851ec02a54cccfc1cab7b942c1f68edfbbd2cad603dcd0c2a94701b77a4998b7c2fa2b476bcdc1ccdc25854d1c21dc4010111bc8224b5aaf177f90a6369736c75ce15203ad7c099c0bc2921d3f11a03b9b2051b718404a4304e332f8f0bc0d96267b3b0f51b95deeb2a0e677c6153300ee06a2f6746eb5d2a893e08bdab2551bd9df933c004c793dbbb43da6bee5f2d226f882e410af4f0c0b804fc4c57db4e3bf3b67ff46dfdf500ce3bbab2ce0ed4df8aff9ca9bda3718f733fa0f51f2cda50bbce11f476001f1f8b66de68029bad791fd56821cc855cbfac3a86371257d0104639af263c59f08ad944058a9e04863e340c723aa5c89603ae997d10cec3b5640efe7b08934838a004061ae371e36cb9ff10b6cbff3abd42e2bfb34bc4b88adc11ec89211b5705976eb690413c7f636315ae6d5881d1693f2ee35f98b2597e7a5a62a0864d0813673488cdb329814f623b873cb7fe8be987ba0f133cbb1d4cd6d5b2daa9adf234c024126b00d5a2ac3e6a7c5efb0db2ff7aa7e16cdfdd2f9c6c0f99d451b2a8d17d9b33330b006c2c0644547496a64d453f4bea33e553631a5ce7fa2e45b31c8b832d430550e59aa9ae8bb46b4efd1530d36ff72802c86c10501323fbcc2439b9722126cc5467d03281916822ade5ea0cbe7c43765fda62d708f9f4b620153dfd92192ad73d58ed407f1030b9202d1eee83f49d8ae048704897df6eea207ac4579eaed200ca0e5e2ee87fab1cb5307f58299f11e6b005c534cb3e70a8b15def1a52a04287594eeee160fdfc141edab17e220d792fc859a5f489b740dea2d9891af16e4a1ea7b75474211e6c4f293d1f93ee7bda16454f557106f2efcd575d6cae6046c2836e6c801e085b7960b18fb3fa6509127e7cb1ee8673b4d6b751fbc6d030baa7f1effac31997f8d99451d25132951a120325f127c9d8ae3ad39496d52013124ccf98c0f668ccbb0cba7837c753bb5013337f22b991acd930b8cab0beaee9490438a453c2c20c82aeba53f828dc12a8bae234ef4ee74501374985bc58f28b94931991fa4a431179a131fef0857e06eaab78d9b99bcb09e66d8203c5baf0b25344ee21e3b0b8adce690f9574ae14da7ab3cf103a72e04a82e47d7cc2965892d488f1f628ee977eabfb5992b902664aad2375ce54d26cbc398d9b4858da67269b54710940ab4e1834725b0d72d881e51a88ab795587d0ac3c00d6a6515a67d0a4f44cc643b0fbaaceeb8fb128589762705da8812c5d253b799c47b644a7efcb9792c4c6f59bfb31e894a064653282c42dbe4dc51428f4dfcbdfc689373adeda137e4e842847c9aaf38c96e5f176e4d0d6156e09b2c7b216cde6ded725df75a994ed15bce035df33798f4def9a776300f8ab44db5f7427d4947c83dd9968a2dc1506c6c687f02f9d660e51745cb83aacf16c01b3ec952a35c6945919227268e6f116feace0501757c5d8371ad7658dfa554de71faa8d540259395bd59779cfc23821f945fa440f0510f08b7c58179ab7a40f4317256097ec9c321102880dab865350561fdc9c657e3070324676ce6d810efa674491c3f2b5a990294e94b58ca33618fe9e5cc1469e9ba5b02cfa5c4c63bd5e0ad2e67c56ef134439abdf3b0b27619510eb3f395eafa3bfb5c0cf1f395becfd69e89bd99e905487e9ee3fc91fa831931b5f8b289686b455a9af29b76f88fc88235a17b97bb688a51d6d8b1e028580e75f1be8c7d40785aabedb6ea4891bcb180f07362642097a162b1991a39ac6667204afc778b37b028d116cf6a41f9e8a9f75f082b53029d6e570b30578e1dce072d038217fb15b56fcf00659e619c48990f45a4c079311310b41573","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af1a4e7bbc5c07aeda21ea5fba7759db"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
