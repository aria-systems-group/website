<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa018c0098af76257aaf784f93d36563aa604393a423a9e8252880ba2a1dfad3e22efd5ec200021d84d468b43f1bc1ae11acc217732c91d4f54638d9cc5d3c36d4fe268976c3f1c81a3ac70dae26cd47d46c78b2dba6d01a7188211ae52d2175d3c373c0bac21c0f138b5879bc55b092c79ce1a5a1d9e5379fc0eea78ba4654d6bdc2a2f828a31ec165f424939ac04332581a5a65e4f11be099c5062698932eb0b04d9eb77a6cc5a2ee1ebb8525fbcb563a69f13963bbc8c08ded7e96dbdc3b2a891996523a456892bfae283f27e0843db72f7a33aa651e918f352e4c49ded14de5e4e66685812e2a9244189b1f6ee3622608bf7194206e6d9bdeb826d6ad9c0cd59292e0bc808bfd45ee38425da5f9bc82f7f8c9cf9d86dcbda4515b9db358fdc38b34999bcf529e012e2a685a277ff05a38f5f2dc56b191393c9ee19bb478cb7d3644c3602c88e79671a4b38a75301d2fb3b662debd66ba1d2eb41084d959d5572dd4d175aa0889ec5f739106858ddd0d6f498823f699c4cf4dcef00514d56bd3fa0dc3b4d52847d942319228d21c569e3b931d9beddee642270547e09ff80e87550976526d1e76bf69aa9a8bcc24aa3fe0b6b5bfdff43ae6f451bcf7d8c441df1ec3b0841fbee04d5f6b8127c101f6e2b144c9e7609f338d11bbd02c3fff7380f8f81bb546d7b04d7f6ba195c07db5b2e3303940c53141e7c9b0c2dd11dc5351b42f4b910e0b0030adb9014f39a000775d5d315536d40003c819ba6027a7e949693c66260ef5cb3dc9226936a96297b12b753b4644588e07de74a69c8505e4ccbec63c3cee1b3fb083c65ee0e375b2906508479094970fe90e7b36397ea88ae3a40fe0fbaefde18982237a0dfa8b8b93d9e2c72c85f5389fd6c4aa6e5a48fa076cb5b5f8d104dcd957c24335e0e1efe4b5aa8359f0f88c26458bf8df52247e5586aef39030020ef369df03879860cdb43de8b5cf8ccff07bdb09d924d72775e7800b040c382e8edd6a7e0b4b707c6c51223e1af2cc288f7f87c220c839fad880e5ae8a8418de6dd9d7564ef575ed12f713afc982494c6ab51769f2ea27aa3bb487b35173eed2f420232fbc24b5a9293dff5b12b66202097bf6f040979f81fc7667613efb66cd09b262e2a3cf3d5c2e56cbee77672180ad7b337f3221a80ba831ffd6a540c1d7af237c1bb972c0a5b1bd43aae36cf6a4ec1c19dc34c984a43f4d3709676df91df3b261a8523dddb8c54325314e2c2ce1c8b3a6250d2c53b174b71de9fed3af0a35fe4e78dcb579344c921adf4dcb593d502d899cb70adaba42f26e58bba5b6afef1934931f4f5442f7541eec0147060d19e1d7f8825648efa8c13ba76fc1faf9e32b9dd7895a99b079bd62075a63eab6601c1ffdd800f35abb444a165ada2fcd8c1182604fa7584ce11c006bb31de9d9477acf6835470111f0f1aa95a3042c028ab23e66166ca7fdcbcd4f6a778c82c465826438271f1caef21f5f1da6e32fda279f84004a630db6890a0c8e9fd38368970fac78b1e55678eef2e004b8c0b56d7c433813da4ed101546cb2c3bc814b69ddc26342e5def34b15d44bcc0fad7596ac7a9058324a87c14bf2f1c834146ca1e94373c3348e85122c55941f2119274549a1f97aa9732c8dd1fbf8e5a467f951a7b90e6c3a14fb785986c032530a59602664744c7d64c3756fee70d50bb735d450883d197f55facc347c7b147744b6718ae01f9a1ae1141088bc29552fa278135997ce426c1f4a611d821a60bf689ccd1f2c735178c68dd7fdf5e6d4895bf039761bc9060abebc7124fd3729d0704fa0ad825686236a05a1255c3521597b4fd5bb062cb25ed00d9c336e1d724d6165c5ddbb1a2d6d95155ec2d75efee57acbfcb03330800c5d50cf897e7262c4764cf6f1bd4f4b4f6fa4f19896516d9b9af62e204eb67c14454e9018729682589c15ec86ef72992abdb71d8f1592324c49ed26068b2118fb72ae5703ed61715154c73f3520fc7317cc887ee23ce9e0173cfe75536a27384ef1f0c91e57648f7a0dc5fd0a971fda6ffc30ea6f6edc6cd26292d92d12c9066391380b468636e0015b8a69d1aba2c8dc956822342c4bd652c6dc57cdea44bd7a9add0993e3fa5f9dd68aebce811cf009f67759346dbfa8249f85c828c58f2ae03fb7a93d60570fb9ea8d844008483ecb41b4e943f416064c8d8340309df58ce2236f6ea65d7d04f5e0222459df478097b45fafcc7fc9fb811ff7aad2206f5f1e7e1aef5608d52408e42a059eca816a2cf1fb8fbef8ea46026184fa3e54594a72732155b34ba5ccdd6c8f39a1c03d8467852185a0008870fda438de8ddf54d66c9391c7d8a0cec3d1cbdd6de0adce3afdaab775945fe539e9d89a960dc5dab4455079eadcc26aa500f05736356d78844e8fa6b28e73261f20c3b5a5eef46ba0d9a11bc72d9255f99dc1998e502c3e0c11f91d8ecb8b2c53dd2c245f714484247852b2e20479217c4e1aaa5e578325f197fca4bd761dd98d6720d172d9ac00de63aaa66d24f82daec73497e59185329068e8bd26a76ad40090efb1e83a38dc555794408f972a244ffa36cdd63eeabad6f014b31c5f0348558b22ddcceb97784ad7d45bfa59f798a81b0b03ab39c2856cdd4f413bd6620bc3c70129a25e689411d7bc023c309b5cfc4111e574265cd178857a4f96cb280d755d53a00f60673a89ee0b1d89284c86dfcc07544cbde06bcfa3f2da3f963c9288e755cf112f32a66a63552ddb7ae0dca4c2eb40a731570c59b2fe96763029c579e042956480ec5fb49618559f739cceed96fa83023298dd1c1b134eaa4fa2a36e57321adc8b520c9cf196ddcec4175c5f6b4341d1c96c1d94358d2b18b0148a9f892b1c8c2a54310e35adb2690b5ac60f86a385e5720009defdbc3cb82a8e4b134916c4196df5d236571926918ec35dd593264972968723a45ec41dccf953a2438dbc021d1a238c985b68e90a73987e212f44b82b5f3d6e51f2d74a3815078207c4de11b59fa420fa97aceea599b1a63d6d60361416ec250f567a143ccc360d0a43f3e09930ded86d7759be95b072f282f6eff704bebcba8d81575513d66315ba942e8a145ab4e09bb6cb72aa61a4c8f01ab29cb25da823dec0a89c7a6be4cd13af28b033c153585603294c50c34f819c4ebde8e6519e5718e01176c4ebb33026429a27f68ee437fffa236bc361070a136d3493af513a9570e60a106fb3cef894b1a000a96414541a91f97c7394e115c8940cedb8a12d3523b0d7814f9ebc234412e57032df2390b77e53f7b3a5cb1248d6eea2c9e85aec937fc5499db2e87d682c014b34ac8454d8ca30d852a870a9cc65bdcced56ae5b44bd8360714eebcfba878d3239e4f714dd8c647fc90851ae7f54eaa9c2d0c6c4376acefc7f5b1d10b992e0ecd7c2a5315064260449f3d2cd1c64158ecdccabea3addbccfb3499f9bbab08b1da174bf2911244785cccab9a61313578404d428880cadaf63caac3d34cc6b516b4e32a5253cd481349e931d8c48f9e9c0c715ac5c405ff0030276053d7fba5b9c906fe73f9b8b7344acc8b8eb911da6536c3514f971de0698488165f000be941496576edaf11c15446e68231c63e8bbf1eb0b7681f39854e2cfe02daa85bf5545f8b7d5ff56d3765766f40abb63f592c3767228e5e813028b7e5dae479ff38cafce7b3c83812de5677eca759a1352d8e01b0a2cccebe46a3c5322d4e0159d92b4ede55b49b36d3e2ce583218a8c8efadf49f5c20cfe4d48f383b77ea7457978caefcb20570e9001136281639c3906adebf03f8f510e6894bbb876dcf10aaba4f97ed503a0c2f611815ce4b66b1105ab3ba3a5e908e61f359d2960eab62e4bf8051c08d3cfdca47b1c9fbc2120057a1c85985b5e12d145706c03d230ee3e6364cfb2551cd212787f04a8de26366c6775f8f91fd5ffdeb2ec80a74de5eccacccc77cd171864e52e4818a6bc4bb8018e493d6c596cb3ac73afdd529c002735e32f5a7eba8311db8325f093bca2f440bc245c267c402f5e3dd1b6ed1cdf66f13cadf682d3dddaae3eaf8c844eeeff1aa632a1f3d20f3cbfa31d2dc5faae718c77f9f1dc4288461817d38c0597a04f3350b4cf40f27bc0d5c913f3a0ec83f5c43e3441cd94e0a14efcad979fce8170870ab3322abef015e67ae1ca2ef8d7b1236e681ff741f557b355b37b97d7e274acf0d49d2427a986c4fcb9ee4cb6c98c69b4ceafe3a3fc98bc159573e84efa6580413db494afed8a774f0491c26f414503256769ec99ce3979f0f40723684717b6d9ce254fabd2a90a4c03c676ed11e1d9a124b3166cdbf7c9c56cf923d3cf156c70701aaa2c9eefaf0cabac1249a9b21379daafd6bbd4c74f49cbac5ae912d6728e549826612c52a15154d22c03e16deb1c8d458f20f13bca21e99622a2924d0f2cf403c4b541fb5d561e5f8a130327b54bd4dcb78ea955ea13a9e4199893277e0b2704f1c541e2085623d186b3741ed34987ae77cc4d16df8eb9190bda388c37d0ee77107cc6fb3906a0f46be1c6c5f4d3f784e7a388d40c40aed8df69e20b9062402642cb76fe81c2afd2a578138114a818f3fe854aeb781bb8173e3898d4b270d28a531a0baacc48640a54b76e3261d987f76c97281c5afd4f5e1e5c6f3870966d26659a5df80eec72d767999b864f0338370750efca12cda1a7341ea033f36dcf3fd8e3446335345198d1f8bb4e816d3b847ec6ccbe642f778939de5f6d5b2454215f8d1108b408b0a93fde80fb0ec8304a90f766ccaddff5fe153b76f50c6f90c21bdc818c675ce2309da023a64e30ee3dd6b00776e264052b8f9a0189de1fd61794b62cc01d305908708f6ddbcd488e3e14dae59d82942c868b2c1fac014ec6df3049c71413ca8150e095e1132aeced5ddfafcf0535111aaa71b86640f211474592331c410451cc9f804da792d74c265c741044d2b63381ebe3df2cf9d331ecdae7649f166cb2a011b3d6708b71b3d719cbd73e3a57079632b25f280000c0d670f6b65f380760d4d599cd3be8e488ee238780f532b468a89dabb1acc6daca0a9f922b374caee74a602ffdcb24aa720ac39ca3dfeb70d9113829b9900eae00efc6e57112a4717ea7b86bd37d1edfe7df1d2d25d4fdf75f509b3b80cda338140727b0dc4d383867b33ae5bb36360edc68bce1e3908777f1a0650a31d348161dde9eabcfc917d344df6bc2d2eb0746fa8a99786fdc9e8e82aba78f15a0e610e25e9a4f6a48ee32b491801f133b06a849f0c3bfb50614a74dc7ead6ada88b7b8ff3ba016520ae9c2e0af407a44df99855ad96b7b252910b0df7d2f9dda0da61b0a7c47b8b54fdbf9dc6d2d5cb4b5d2e2500c6ebbd462fd3ed2d0d0c38df4ec6db4b258ce5d44a32ace7164982c37fbc046301b231d4120039237a8bd1b1821fee33efd92894506c9d9f1e16eded73acdf6e92407fdf19c2d98f0caec0a78e34b95f5923e07d2d79a1d5f71b653a8ce553ef0e2143440407eb9d5442d2a2cda11e032b97c942711926ef1a38113698666cadfac5ac7fc72c836b30852ec45c032e6bcc06abc5aa5a1bd17f936f3995270c1fcf2436df0ca9d88d1478dd0092d45fb0b6899e37acdfc57a90fb41c1d2371787145dd679a03f8433ec96ad9f2d3639f467fff3ae60bebc2245fb2ea04e96ca4591215b9f6bd3591a5327f32a714dced68ff17385a17233f018560fd0f27bb40e595a4c55552ee2d8bb665a0e70e17db389e4b6ca2d1965fdaae1107fe152abb8467aadc2eeefb3bdf3770e1093c7ad61099cf424180da19c06ca3a58af5603636844c38d88914d4030bb27c9eff71f061a95e12254b0a67484b09872011d0a0027a0b8bb1fbd364d032a132703935dfec8d8ecb2a8e9f7c7aae70695c48e2cf12fc28ffc8bf87c6d46fb2f9a5dc6bb28062a08b41fb87fd0efd1d3c8231920a441e04da32e9d4dba830cdafa8d17e446dfff70e2b17ba7985da7f3f67fff23888e419eff518f91d0072a2e74df6863f963fd6f08145d6cdfb9cca0542b60068b25d42e213fce4543313fa25b40003483cc1db63b85dc5a7145b201cf165187928acd716ec1eb1c677d86ad5000c3be98339021ca1e5dbd4f53891a206ce66738e904417336367d978a026ccff6b2006430b3a783e9256272480476ee12adb64beb79d950aa91366d9fb5f3a957cd69266e2530d3c4d0e4d3a49f69000b22e910e94e1cf8b71c034821e53a8d73d05c99e9015850cf98772131719405881a78b61fede2e62dfdd682fb245ad9e9825624fbac4029442af3d1ffdae09f6cb4e02f8424bd3ed20fc5a5920cd6620af047bddd60c389addc1431afb5756915576ddfa5004f30da9f4f81caded7c8cc591438a7c05f43b4c613b73a803fd7e1e74a47c72894092be77088819db8c72940958b070382327f7314625ad6290520ffea20c423ffa3e878ae01d515d6b2f118a6e9c34061c73d6073fc1644bc298e52b1f9538040afbb203dd5f7a1f88c7444671b1b76045c36fb2ab2c02579df9a6e755c3272112a66c27617d37aba240bb702061821b202b4fae36df5f224aa2645c26086e2c96969d8eec97b4baeeeb41ed47fa637c76e6e4ad16f7df70c590672cd85ecb0d8e1e2f4f09c0deb6b99d03e81e3dd1e42d27c52ec8aaf811cb1052dae897bb4a51b66afb69d2ba502176b83a28bf50a6a73c741ec6a7b6a634f9fa9fc0aea767ae7c6fe3887edbc748eb400ddf06ab65283bd9044b653443a3cbfa2e1a0ca1b9ceb3833685219aeb002541220bb9115a7189d3396d009d916ae7401e979b14a06b33d9bfd968b1962446dd073cfc0c9db501956f2f0354c67ecfbe3d25463549901805375a992b63d4f64f533741865af3222ccf00c0bde0f88ed28c67768123afb68a42b852270a4af1ebeaba3f47bdb7236c5b6e673a6fce5309eadc7043954f2f779c8909bc7485beb50e5689aaa2cf9ef78874daf83c03124355dbd4e837082ce576018ad0faec7e37f36e0c9429cd98147355c5a52c820a822ad2a0a1ac47cca422f32b184b81c76eb9b7a5ec062bfc4eec0bd758b428b5a5e8928f7b7cca382268b68ba7b6a22fcc0ffd3badf9e37a0489e2371e8a5d94643e8bb8b63de463e9d4c823c5e2dec44a9b22e8127ed0a233bbdc4a2cece6c23cae8499dd9673a49fe7deb2807291bb9689f1f6a1c8b853df94dad6fc9db32ff0fffc1a3bfca27f7c01f1dd11329d86e6570a081c48064b898f001c16db74103bc3d6059883e19c6f1f202ea6c12f46821fdfa12fb996ab8a01654b135f3125d5f790a910b43c0bc02f4e40468a433dde4466299e222315011f5d78ac9b3ed91b6542a53dab70bfe727124cba4dfe0b3ba1ec86811ffbd831c483e4a6ace955b31b480bc7795e23fb1b03aa4ae3716e25b311234bcc98c268c286b20ef2d831da4335f65e0ddf17d73073c6ec9c2aa73170753b51614ff868d331b36e29476bd6433a7f258425fedb644de35d6b9bfbbb2de4330b07d491e0ae0a8c6674e0d425138dc65c193e1059dc7cc67721ccfb86490324783e68aa9b4f14bec4f80f456a85b9274873f88d1178169590b416f8e7ce143340f2cfd34cf284bf5d80546346b794f21991d692257674167c5d44c2aaca691a7c9d750256c1dd7133dde83967786701cf51fb97b8d401a31c31a7efd240ae38100a02d73d26609e78fee00296631dfa4e13ad34b09c132f77925e2c4190493e02fd1aab8f47ed4c1a6a0390a454fbda5edef9d7252d67339b120108e7a6d89788f2738861b584ce091e2996e760a6d87b49e9f94ad6516e1b5665e84f9c8c35c6ad4e33f46a596a5af8eced756604b88c48e5ca15a90bbf679d5ae656e872c4f38e86b111445f595e42325b5d907616f66422ce4a97dc2e8dca5ad6e38584875933d50d36428d2f675ec048b426071d11c6109688cb7fed34cf781b03caf4829d64a631fb37c2a3765e7fec80ed087b91fa94859d07ca00f1360b582652554db51c38939fb2a9cdabc187b0388b627d72f497e10a336ebf8e35445e1f535de83eae3d17deb2e3f192e9664a51a10c6c66faf872265249f030b209cc999bf94e04af20edd5390f30a295125988aee93a1e757607c09022b5310951d6a8c8e2c3461dabd77229b850288efa7c3d00a16589a037a63c481719777e4c8e77bb72f9d355680bd6a5dbb2261c0651e236f70ff3d0f380ccd834f9839c338903cee3432a7680f1afb4477adb6b53b281566c7a762440bc5d6fe359437844bdca5a57392160ada5c80ce64172946170e251e092b26461abf113e045cdc394634af5ea9f26e7acb072938d0aa658ac4e453259c5c4ed695f44322a08e43cd6043b7814df4fde5cb244faa12e618c84a2ad1034a7a2cb234e47aacc9869347c139ee2301be7fb7bd86934e5dba22d6e6b796cb5d230e6102841091b6af79b2089d495e2536f70a52971df0f852ee2c2c2f1c8eae0fe03ac6139ecc9282751b35a3e773e336832a832d00433c8c5f3e854225099ac84b80f4ad0f4ee82450c58f6871ba9b45b67e9028bd8a06c0eb49fe49d52d4057dea35111e4f5a7d65e0ce1ab6445a7a1a634153b162f363b3199c42010133ad3216c066cc856b0d3e28e6277dfcfd3c9cb901041fbb7416d27cc8f63722cabb297a0158949e4a7ee20c5abcbaafdbe717a9d5ea053194d0898a8539a737c56a8ab4b93180ba455dc7f4d49c958b4ea3fb86429d2d41ae701b2cf91aa0b3a7152978793d9612be4fef1d44489a824da56b5d963c44adef7063b7aa2506f6c79c0683a25c07e7a2b1744bd5dde8985ce9b159f9245e081b18ed16fb90d6bb48374337902df8b6731b0059428e640c98c9e39697a05ae51520bd922f4175915ed47b93922de765ea274e666248207f617af3a873577bd273dcdea79b8335a10e4f9ae41a260c4e2e5d4828e000eea05438d41de52ac6754145d61e7d802b914cafd34eebf3cb6b532c970c41a703c1be70b1fe8c20b2e816d1ec0d40136ef5671e3d0c06a1912d899bdf5470dd0f78b2e9fb350ed551dbe82aa6978f043ede6a2184229013e6507423e730d1391aed95a9858dd8fc85508f817da468f4f08e74267338188bd1f4e09c12fafa26ef4ad01d920d40ddf5a69cccf45131d347b0e7a72124deaa7c3a8aa306ef049f58abf36c1eda7b2a4917b462ae386f28348f9953e9e23cd63ed2d7d427bce745c47898c11e8befa591f25a7e5983554e82a8f6d4ed6242fcf82f032cd04e31d6dc97c9bb58ec5e6057a457af8715e3a1c2826b793c2739ca0a7919f9259b28c092559a89ce517f38ae5792bc2bae01951fb916d97ae09bf0397782b0fb0db22ddeae5756a86b02b2b10667b44c38e183ac50e7c7bbed37ec815603f755bc60ef11c33ed2a7b5bc6f0f05c23cc34bebaa83f2325fdf0d1aab1b0a760b861e5d6b8a9d666ee4a31dc4eccd9736736ad539eacd6a12fff9382202beee7bfc49027486e0c9eb89b4b457fea896cb6d40235ffa6e2dbd02fcf8c4c2647b48e022ccedb1ed5eee1ad7c7a8c07945144be3b8e0fcac8a24035d1b4b1ec069587673d3c9d84f1af95c6f0776eb2d99da9f6fc837a0606d5b57d8aa0a734a0e326f0c36f789d3fa6e3e416b2dbd777a934057d2121595f86162508092a8595432acb3b31bbcf72bd3ee88f4230e8d438f35edb35fec0122cb958607832c236a5acd65cbbbb0a584c422bbc21275506656e34be7e1c2fba5d49b5d5d27a0aa8b5c4b54aea06bc508b70de0dae36c25273ac11465992cf21ff48b7407fbb06b61f4e161493251101f6ec981b5d9e0c68e021abeb7d46ea85cf542787c0221dc502964815166a7db6d243ded78efc01dd3e9be02d1157dac7af928b4ef99e4f0c03323deae700bcc73d2bcbf4040665cd328348bb19efa3e91b382aa920c1a78c3376f1edfcea9d961a347abe31fd48cc8d328cfc0e32ba69132f8fe68ea120f61ff02928ca8f37c30de614751b2c17c4f3e2d54917ffc28416c82fadfb2820242ff78c1963bf42984ea78bebe4dc019098c1d6ae5663b7c241c8bc5e9ae7e4799e13f0745d6aa1d0ddb6d71f2a0bb6262795a357fd099b8996e81336358a647a12f4b852145e00e596f4952eb42b4adffb176112ea75f17cdde849ea023c746a49b50ad86b87a101a8a24cfeffb2db587af93423b3a45cb17e0a48c458b8b00b46a4fd7882c757907f7d1fdbcc419ac1dba887c25725325f58c5252dedc4f406b631beaa0a54b60a7bedf5a853308d66b791ea358bc276182d960b208bf487665a5934a735585225598cccbde1b9792948adcbd2b9405c360ae07e86b3a8cf33625fcbaaacc17695628c7f68ce7c35680a11e00e14be74f898f3cc09c2016ddcf062975fb553a78ad6fe8101a1e9f3382d828616f1a6cd36d811558ccfe297877c4ae73663e194718245f2d8fba37b01c49d564460db03c379d053cd3ae25527350431a8eaedfc017f0dbb5565f5f03b280432ea03b262e3f9fb9bba07844fec699583e589f10c7e93defc502581629929de269fe23c07cd9da18f75f90e0d265b793ea922ec8067a1345d652616c86eff25f5e00bb0a6e182457da7642a0911fcbae22743c9f65073fbddaac64fa06683462d6e857516a5feaf3e3aa74d6d120b610386f575878cc0f0a48c5e7bb11b4e2569241ac57d892c781f8e447486a49b05a631854540d2a6d62c67236ca156ed80cf91c2033209fa570b399e9cb35b3b7682af7cb209a50bf15ba0aabd97bb0dd7442bc7dc40ed980a96bd911847223b04b60f0c62786c5bafad5d71ca8456be5ffa5dd7ddca5cdb1cbcb5bfe43a35711033511ad74dc1d118d587b04b5d0f9d95ab7cf2b1c93c3d72b166467f7bb82fccf0fcbb01d99c937496d7514a97c536144cbd250d7ecb76c6f989b947008a398422d3e52a4758f9791fdeba22a7c626664110b7cfde5cd25512ebeac503d79087fffc93c282e59ea548f575620f904ffbf2ae97cbe101e3c422ca941a458a1e096361240f75ca2294bf45ff4b2159c53b5800d8162f0dc39dabb253c5bc6575b6125b775f4e04c3ae9d700a275bd41f8a8f24cb0716e13426d8e7002dd72c8906965476d2ae14ff9407596fb1a66eb866e0d610fb3615abb770382de825022007e6d7fede62190ccba0627d377e5f9a64752f23f81775c6c5263e9a8b720f082bd78744ab6e9ab7744fed61d6bc8ec2a623f524a5ac9daa6cb244992d9552f59126df2f2069c8c2eb07f3b7b99ca9d7da18e3cc79e091ad89c1088f65adb1d6bed59ce703724d927719490479218eaa4a9114713b8f5b395d0a5d8fac4231f25f570b52345e5ab51357fed9a0a5db0453860c7ed8b297a609f351b17014ef38447980b1c39bd5906abe7e0f7b49502afe81779024cc41c91e3bdd7e879600ceb88f0031bf1d120e1f92a4a65fbca1c8ccb7645e14b22f0c43b8d6616861db928b94963bc665c359f17bf9d0aa72ba6c40e156d6d5ed49aeda8ce673d69643f524270873c9d5fab3add07ff8d69675edec6c40fcf436ad90c0d2984ac1a77beee4ead7ff89c0c020666ed2068b60a0dae93f5ae47da8831fd479f9bec87077d0acf2f92b93e9d86f14be578e07539b5152e54260f2d1fabba6633a5c4fc9764ee09e653beaf2b150965d05417721674841c42bac7b54459f45b1facd183c16b9cdb3358901ceaf30fbb2c8ce05484ca790f39cb1df45ecc6f1a6d7ff376876a8ad57e9e0c391ffad71642ca5a8ac52c3fa93a85e3c5690a5c55d7815e2a7421622bb1246f13d715a50e6a8fc122f8f13b99509483cf08baccc5529f0e472a825a84d3174a46f194dc2805bd1539d5e1f14f2b793ad2043a810a13764c8f6cb699d3ef712a88589f7ca379b02ac6fbe83d25aa14d35b879cd306a662c66a920a9395bbfa5caa6bedfda81facccaf51b3d97f7dc29989c88ee67814b234cfbc91959c6b1115e4c67cdaf0d6079c9262110fa336afe9fbe4729f8f2f4cea5cf976aafb6aa05b5af0a7efb9a4daaacd1eb4dff65098e7069a84fc3747fb757965901f2a210cd327c6a2ff9d2b81002f793ebf40b17686e2d3e612ef1b3149c3720138687b363fb262f2c7d8349618f8ad9fbd73e189eec7bc2f4985b7dd3d2874c8e138219e89ed4bd0c6548dc369a9f63b28ef3abe350cda9dceac615af72b3a3d733b320b1f470b8d6248e14a0e0bf315580faa2ad33cfb38f89cd964773366554913b0a9083d4015fd4e469b3d5e0bbef9deb89f895158c448cdfe81f7ef1cbad77a16c6ff975fa5cb1cdfd7f95fbbeaa6e6837ee4cf747c44cafbd5cbd6c9ff5d9e8865cb6a7ef588b31b9ed3494bd080d37e0e6815689baa0a6c03709c970b0c33fe238fd4cc06c3ee0eca0904821ba69dc3c5492d69bdf5eadcfac341977c5583e6339f796b36d7198ea9a65089ef433c8590d81981c9d516bdcd473a7af46fc946876ca5335529b5bc24d76c0d2e23556d924f8dafd813101f0728c68bc3867512002b81a1ce431ab948a837ea363eab239cc0c7791a80c2ec6539cb33a47e8809c0c39cf885a119c6cf62caaf647956b9467fb33a81ff9640ee4dabefb145b21f065bdddcebf507a6f6848c09833ede700732119a316ab01289adfd83b1b59c9740334385ee754de23f685b88e0b9a77495b893c33638ad57f03fba3882921653043ed26bc6b0630c0434cc9adf6c864d96b1edb89ae4ff74ed3111c8241334df498a8541255c4e3cbbcdbe5d5760429697be4ae6c003c8d42c9466a57dc49b26ff084af4beb5420f3be7a01249c064966c304800bacd09fc1c1c0175b2df183fc99dcca12189a86dd5349db3a8503c10d5ff79842e62761df9583d64323f565dd49c6b7c56bc3db20418a30f1e90c91f5a8babf05765ed4beea421dd9e659de58c4186736f84e982e4128a97abc0e5d6a243b253c39b93e2daf72da04f6325fb1166ad537734d7ec4b7e77be441e8868ecb481f6baa00e5c817bdc572a379b56d7a67186ac22f9dbe337225c9f10ca56b41cda1dd3d751014ffa95171948c6462900f5ec8193b3f5b1e8db031f440c60d825326c0275f239c699d2315c459c0c574f3b892c8dc2753c24a1f4006d6d505e97fd775aac82308a1412747468a2234e5e657c3b43fc883fb4913b19bab2cc8a0d92473ee8c988fb508281ab5ceb63fee1aee0e1c50d2d97f66581c2097282620b1514432b9dfeabe0e4b19b7fb2b56b2c74e99372c6b4399e34d1ea522d2cdf64d4f50e2b3cfdb88dab4a79c38e51d193d7284c35eec75eb4a56c72dfbd74bae435f34f4228d7095cb559265d0f68f32d3d448182a9bfee8c6e003017917a2eb11ed4e2e1ebe86138793391df69f223bbf8ae0c851d8aad96b3a420286ab4e16004006fdbf600d20c26b7861277e30222bdc04c8d0c8ca96d002e6e19fbdf1edb9710774e7002b69f71f20438d75c818d03151bfd2e45fbe6c2dac8721a0a42206df4fd0c0631b7f76ace84ec6d015afeb6f3a87893538f1bd0d51f6489d2697c16279ef0e42cb5c2775e6a2624e96e8df6c191b0e13d490230c73be3108da51986c83889356fe8e5f3dc39ecfeade2e9228f64faddf11e9a800e8c24ae214471ec5a29578cd8703b19293dbd5ba66f032c2cd454f4bfac42a1a723e23bb0b5b3d6c4df9dda5541d71cae6c4a88c3f4898563c4f853c55583191143d2e1e41fb8fce4b53089610119928e001836405422b3b79a1497ce16922f2b1063af08be0071a077a45b4456b433cbba9de40e8bf237460876ee98c685278a917fa8504901d9493095456810f5b2ce63d59c51584190d06deaa16f893c58c022a07f62e39da49863415eebbc238ed84f55a04b7c9e5d15b6e1af6acc09897a57aeb50cd8220595b8df4cf83e6e1e98a64a1aebc8fdad735294627e0e5f351072dcaf6fe552ee4d465df71b06f0544306bdae352d360ce9fd100657b88c2cb46c00f929182d11480aba01e78c55232b671ac9c6390aaeb76e20be781d99cac56d9de972fd31875ccf38096f8e9e4d2cdcade216793fadd5ced683f3adc86569197c1cc0fc9ada913296033e70e33d0e243376dbed32b22bb676933f83cc5d90999276121d4ba37335b6fefc769d7fbca301043d316e75f56ee9189a435ddd743f0ac1e7a9ddad136effc566440230bb16852131c3b60f7a51b8318fca7bc6c76f59decf15fcdf5e9b6b16c7aec60ca197c3b768d84c2ff73de62ee493b98ea47b0d9a4e374881702c217740960d6ceb28147ad031bd061099a36b4d052f9ae548b9cf939c46cb9e3dae66066fc057ce013178903df2e6644cf6ff8fb63600ef534ff6332ad5cb867d7c45c63876273c88ed382a2c45286c9495d052a139836bf0fbea2c692d087cff5f2617346b5f06bd44a7f5146efd85a928675efddb007b1d22361d11b08298ad2f652344d17dc1f246b29e7c67a361d9889d711c5ee28c3896528cd1adc9a1dfe9a405fc3883ab39a361d6cac6335ee3d3b9c7155e51cb2f1697157a12f0062b13437d500537033dfa39c769c81e6728df4621a3d299d8db744e93f6651995c6be8c548114a343247f7c46919d1eb570da9f31934fe58042f71f5708ca9016e62a6401b1163502f849e9e416dcaca348c9e942e0765e4d9e7a5fe3b8ea41743dc2f771e943d7c78c90f071af0d01c339ab5d7039a95442363941c2a18d21819f792470051865d5efb02071806bb71b67d2abb6727ac2ee5b04f1645fe512e8e279b3304e50a14a4a43dad71dced9650f321e3a6f4db18b9287f5f7d708d6485fc627d2521fbc91d5b81bb0d9b141bc5dd8538b5282f06a4caffea0bd8cd9e90b046ce4bdbb8ee0300f095ce931b7aa7d05f4130e6ddf538bcd3a90b1bb858886b52368450388d9da9998911713843231e53a354047fb3f663ed88e88de6601c25e0e101b5e6d1329bad194c50539bf58c4185b906c7882f4d2c4f8cd79a142f5e0f3f56c87df005222e9e4070a98ad512a2001c171997cd5ba30e2165c3eb97f80f6741738c99cccb882a7f944122652431f852540c64aa6beae7b4e447fe5cea22edaa985432a5bdb3bda2aa4df24fd909f7156bab0000d9c5bb243c2a77a668322735f4d9fadcbd7a198a170bc15f048895463f0ca8796c7a76dbcbb38edf92958838170af57764e418d892b4399ff8bd546b5c2fb36d00d6d906cae2c1f55d150b4cb104039fa66da2dcb266f2e6374995384e6467e2c3492627101e232d685dee61a7029d5d313df656532e855de8d996f82e311fed5642ceefbfabb89c152eff605f12280d6557281c97b8799a61169ae799a44327d0719a8e43806dc949a636feb48f222519434788d711b90733edc289bfc856fe6eb2c7aa642efbf3de911e5ec4e92225acc81e7376b558a95f501d2384a1fbcb0f54e32e49a644454f44e1a3ef22b3abb2f46d87559bf32127ce6715904c334a9b460185108801a80975d66e48d3deb9febc5932b1bd859d4b6f24e93f36b37bf8812f92c9fe046d9aa35ff00472671151dbc0dc18ff2fc449331e2668a14202aa46f61ebff353e23d8ea6b15809fd5c82ba5cba2c04e43f67268cb81c10c8b2d22914e262ecb1b2f1418caf267cc964d93a23a3d109a59ce6cfe531bbbd1916eb27a35b7d54238c0acf4fed6addc55f7cbc8ea597674ba8245891bbd948c0e94ec123603005f883fc4977daaf78f4f56a7719dc98fc89ac5d6e029c2574cff488ff303d8729f7b9ee462853fcdac87061b5015dec72e3d698740695ead3e0f1f99d96f22e49efe2d93ca9a0630807a87be3358bc53311ef3cd82c22c5d3f4ffcc5b566f428bfa3d3f95781ea0a7ec82b51e4f50cfd9f89a3af92a4eefd0766cee10caac21dee34f1a370b43d135840e5a07448347423c4c7b25440fa29e751537081e4bdf50a9dfbece3ceb4703b3d6ca82924239a04b625f3080d0dbaf8bbc70ef51d2b5bc2d39d6dbd68aa2c41fc18f527108925bff55b01089372377e1c71a2503d8e18ab04b5c7a778db866dc89baee3007fd3ca182a2fd707331106338f83943d48459077e045dd3cc45fecd805be97f59eeb2d3e1d845ace97deeb138b824bb4eb83bc0e63eded5cb5bc9573ef8bf5536ac81dc16dd10317fbe93b0d20f8dbf17805d1e141d9db29005233392a0862998fc9dc10063d2cfedba8cc84903f55bf7f9f2da7c66d8a230cfb36ca63b88519bec5f09d0eb7d40f0efb9891043f3f7d23c250b9f47d2cb001078ee4375903a0e63682e981fed211d909a752bcc298bfaec4db688f7a490cfb6bfdac3610fd35bd3be6aff3fd6409023c04de30c0ab0d040b402ef2e3ad72528edb56221ed045e956131b0f4fca4a163256692fdfe3a750b84ad831a23d8e3bd3a7211259bb7637c8d100248633142064933e63cc0f1d633bc7268900a2db440141d233f2d1921b2c6e2f7a5093b26d0f6c6cc6b849e57005818bc116b7e5fb209b9601773b0e4fdb9e8cec1619da495acf54cef115ff3fceb62bfa3c021383f3fdadb3c117a5b858e42d147ee45e4eec30fab2dca753e011dfea7d724959f5b2d2378a98ab8e4d22220de72d839c0d1f37833beec52d33d1d8da5e779f9d10ca7136ee440c06ddf70935e6773a0df090c4020acf76ddf3fbf2da4f44f8b695249973fa032ec026140658d736488b3a4b1cb1510c7d355ae08438795dd2cea2e82c617e4a2d16addd6381bc776e945eca3477e0112b16877c8c11bc34b1884f557f397829aed3944170b433ddbdcd81101b85005326302d2edd27ed0da82518f5f9221597d6a531e06b4c32d7612703a4d18acf5d4ca4c43798c7279928ed8c1ed776c0909e9f37f537731388eb26e8d930f0d35f9610b8add6d80a35640c66e38ae3181525d4d7adfab64283caf012ba7376adb34d6952a9d12df9e37d98ccc44f5159a2141852908d291c8b5b25e04a51efae2e354ffcc24dd92bf9ba943edace8461eaa26578cbc5b60947a54618e78379dc21503631f13d33ffbf38c42b6245d7e177e1572265344878809495282d47d62006cb5b196f5aa40fbd1af87c583176ebf352a8560283df280acc9eda4a3baaf824fb2e825357074ecc82b8f86198f10b48baf7227d73f67a0c5b8645ed21c3709ade62995e9cb963e4db561e39c5019799efd724a069dd583a53ec07fe72e7953587a5d8d89f5f37a91580d9a27b0a584f23b94ceee47726fc1a8df1676448bc8b0f04597ceb0f14a5b235519a046822fed44dc01be184cd55430707a8b2506c04bac19917e89c7f51a72063c72ff96e610b28096d711a7e585b92e4c06c7f18ddb7bdd19059cbfcc5cf23803453d1161bfdb902e3900fb71598f51dcc761ad1e3ba98f98a1088dffae44da0d74feb5ba1ecceb67fd6a293cbc0e7f905b9874c4ea4cba02b7c8401b4504a02dd5d217f8e667b01b872c5a3b8bc08bf424075df24cd12042af2d795da306af8a07ca40c10c67d0287e857e636d7687dbde6742ada393cf4a96212b2547932d99a578563a808f3520cc5989a0d6d92959de06016fd7fd49ba4a6ae874fa2323a5b745ec2b4a1c9f5846624a6e2bc33251d38309216ba3532cda967d29b1997f0767dd4e14a9c17f36df75b10e8ef864c768404e9747d18ed69c5923a8e58978b6a62d457ea6c3cc01512f282394c9d4f2ed2c531c833aebfefa48ed5da0c6a4a99e41730e8537c2f0487769d7b944e4f53e958d42848fe1e0972118bf4faa8265af3813b9df403837090b25a3b3ef656037db26af4e5c59df7f788d9740d4b4e177d3bf34e58e1125a50e096bdd160b5429fc6d97466cb6a0058085039fffc1cbc39ab01e476664d3110a6114c28464a817cc4c9ff307776145670457653be702d0b460c9e6fa6f64631e05db979adbc0ad69cefdacd3d6cee7903689874ac703df80f4d5c6d8f22d4e96fb62388fe859472ff002d1d56787b5b270709ec589ebf68f651dd573ca21b800eaffa77046927935b807f9fd062f1be66ccfc578ae9a4048d4388184a3030e3d645b02efb6855c1ae8192d5c4bd161b9df9535b2005ea8cf378f475a06a3478db0b20f8d1a591dc90c45886db81573d13db37044d54fdbd55ca513baec7fc6fe25c106bb30a7b48f4c0aa0936192005b727bf160052b5e0d3f740b4b7503c606f7dbc677cba9aa7590c7793df957583c37d11fea0f2d415416e7178256d5b0e38b6cdf85b614e5a6c14232727fd0d69945f90b499bc6f7c84f292c02ce3ed9ea1e012ee9c7b55f08bcd40dd8d393a46362113f3073ff5690bbd4b7d22931f61dd75cafa9b1f4da96c14c6abf76529fcf8ded59aa863dc4e688a51e8f30ddc3051c2d1b1b29f6b1cac29e124e74fa3adfb3ca95cb9d5de4712be3fdad884f31033d002ef10f36b634e81da23c001a30557a0bdb487a3d91d57647fdb58c0bd83c912ad775126f62302aebb937fb9a8f99f992a1a1b89bfc31ee1f37323907ee8717e805616f9096d8485ef2f4fbac1d2c6196c754903890c95db9bf96964d036078afba5a27be472fa7c6c3135d508e96bb3ba7872576748be86fe36a5ecefede7741b700be8bf15f0a1329f4b41b628b11313f7510d8f3378692f59f88cc216c869ea05c8a8eac4139b0749866a68ce509265c25c41fec46fd7146565","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"bf2ad358ce2d7706e1269647b3e9901a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
