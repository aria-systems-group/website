<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"395e5ea4831c8b9d9c5425fe75ecaf2f3b0037a8249d7580e1dc977070a21a11712b97b5523d8d7f5d451d2e93714fc92da6336f7833eee557c3abae14fcd0acd396ef4f954846b372c207c2d16bedcae9c5eaefefe075a5fa496b255964ea2435ae45b81cb8ed77aef55693c627e9508f81bc9dcd92ff1f41fabdc4eb24d28385da012b2fae01bac4265a6c96090a0035c7d295c1f6d1164172bdafba6a8b4013fe31d7807f2766f568f93ce8f3918cc4f0d61726f1f269cb36d2673ab75a1780a6fa3855b80b0931e69c5e171583442c032770ff1f64b21ee401e1aa186f8a7c68bd1746ae4c399ed14f44d7274fb69b283e49d29a435e5e7470f9565544c1fef09b6fba65c1e0624726770e033ae4b8e74151db6011b26cf591444a22c9e0ba19ff41029696386334b24a4ccf2b11b5810e2f54fe675a8b71980452563de7601ee676c97017a31881b1880de9dc530a338a08d9f7992632d2af859ae5a3c42c6029324b3897dc6d1dad965aa67c28a6183f39872bb193a3139bb5ecbff569a84cdff97a1b01678c091e35764ad470ba19f0cda01a57002297af8692068c5b759c115ea3d2518e29f1619528c2dcc1065ae3b425ad38168dd1d4c7b62971ef05f7daea129f26bdf33dd7ee586f982c9fef56e0d23dadef72def6f2ba58431196230148927afa4090acca9f578d11de6944bdc73bac8f59c9462fe3dd5f972f3c07a8f33dd44e55ab00977062373954582ed2a53eb713a73264c858a919105ccd8f71512b3f1c27f465ee7fb92b027211ec01de8928527593849c246727c12bab1ae713d6652492c57e209a485c47c0cea5e4d20cfb7d186fc841721bd33b2cbd1d3d6e4835def07b59a5325a97da189479383688d1d246eae03e85d589bdc751e3b622ca0d1df869624ad8708aef84c037a0456aeba10a5bd19548a54b6bbe6137fcfbbf1f6f8c65544fc4b132966b5ab698b33a140afa625284a1a628303bf1a0bf335af7d6c1383afe8b26fdf0743dc0753f5d578cf82fa9b8c1cedca12f681ba48c8e746c6778c855de458f89dabf32a9815f0a535f9cdc26e9d44839b55db310058a0dbbd17971f8e6ce7385bff0384898c7ed1f2663ae3f6b4f9621aa80169300f003feabcf8bea9e72b33c09c5a03a373d621661c5cb091710b86d2272a3bcb656a6d32a847560853f03efdef18af2046c1a13e2dcadb7d8b9caab87b2bd985c40cdd2423b1c64d6721ddd7e787e12cd9d52c200f43221d701ea283fb7a8dbf4f20d7ab022dee7a8e31375f432b5f7bf1d4480445e6ad0978e190b7cf0c61739ee1d17a487dab69e7cb2ea122ae496f75611e49b1dca9245fceb3f65b6b4fef317dabccb24bf074e2ada1fdc8403c838cc1d13bec0b325d3956926b972e514af9e1c13c1dfcf0675c07d39adf864e0909ad04c6a72c63321b7544401ea040b6e5dff0512d5e6574888b98d4830c517cdf8f020bd07284ab91b0a944648d9ac710b7586595e36ba61ddda8c607e1854ff471158b9bab3886b6177d6fcec05c8e42d091ccee0dcd668120e269acf2669aaa06579707f9e8688b60b105009dbf191f448a94830fbb94af11ef29061657e81dcc8a3d834c5982431cff51b4b0a3a00be0ca5641190621a63f1a9f9e0fdd6a79c68fd3f843b1a622ec0f7d7b94bd727c401ad923e688ed73010ec655c896b16483b86787d653c8a86a061e4e592a2f8d9cdab8ba4ec7fe991899187311edeaa2758190075152475b2d709bb587294c91f2e2c6e47105f60c2d343d604d2ca45d09ffd67b96c4574d99ff63dc97f3d3dc780db89d7d99cc8711d9d867aedb17b9a7c6ffdafa66e7c4e6cb28d58aa86a7ea68b2c540c1172e983c1fe649b276a7943a95e0411107294f080ca8c5b8fdec3da769cd600bab3d4824a0eb5b994585e26aab36c2b82437b79398bb837714e37834cae4b3dd912507d8e7908dfed803aea862bbf194d1433b8907edf24e4ff689392c2ecddac6886209fe16a90a06340153eaef17aea5ff0228e838de524b61d0bb44d63b39848831d50a3b823fbd1d57b9964783c0579e80d6563b8acfb130669be1759ca3aa7eb698f3bf2f21f7d39f9377f1c058f9e0f667ee1ed18428783e9910d1d443d222d4ff15acee35ff323acd2b19a0486b6c8fa885d83ba5aa4bb0e96387b24e90330279286b50ac222a8371dfbd110de7b72564852f8c5f81f56758b08058bc99fbc15ad26ec0d521b40744e37e1615cf53e2541a77566fb470013c7248907832ca9a0454b45aecadd64a7616661905d2c2db97f6520d3d78d7625f144ca86105d0fe47aafe8035f238b1f8b4b8132f339fd0592176f58a78eff07bcefb1ae06c4f6fe399a7dbb7583161c82c2005c67e3aa4b8dc4c43a24df7f7e0973aef707300b31a2e9dd04eeadad9c75c59198e222dc394ff79e9763ce3972bbcf2afaee21095b11885167f25fb6f01bcfd8e79c6c993b0a74240a5b19b1215e6ab42c6eb8f453cff18ddbac3f30a7331ab3342e088e46e5d80f6324c6be95fe55aba45793991dd90119af8d73d095cd93f51361026e1a19a9b6e9d050e454fbf282f7b06b97c0b3cec047201a0d936cbb870a2ac8f8ca534ef272285c0afc33ad306e439b81b46948f87112aa75057b407b591746130c3703a23ab8a39bc1bb6095a9e10d94a85c58dfde6d8ef17bb88fc8e947dc69757c58144143bb1d03b3a5348f5616e45678a030da6573086ba175a2c4f68967e82414093c1d861882cd7dd4fe505b9bc1b388e372b8eb404c06ea99e9ce63a8f9f97d2597ec40f3d6d64e1261b51713ba8e9dd8c0d4c2a11d2dd514c5d764ff85216a7a03c0c9cef0a74cc94ccbcb8df2a2e5874a47677ed5e1ae089f849572826cbf944cc460b348b877f31659346d4fc19a766b74d342f91269e1adea323679aeb487cd410d44cb0f40a11bc0644ce60083f5770e84aabb3a5089cf35bc43dbd9113768df7fd15251d9a555f938296d1095aad245eb2f1fc18306504c440e8b0b006a3be7f70dee0e4fc34ba2e84185fe7296d889d4352da5a2d9fe1c46e3809a2d15622c9e4aa391b883aa1443f9590c8aeaa26c9ce89367744aebb5a49a9dad1caa6f9b3b27341251a8f86ab1fa74bf6348943a7d8ae6386d63447474853d353330b2e838dadafb1c55d0efafa1d6af3cbe97805f7ed3d5a1dc8b57e8a33ba9ba686fc3cc6048f3434b039febb655495f14e5f41b0e23535636c6555be922cc7ae7a5d19b767ab960de124d0334885022db7dc9ae483bca743af0190cf1a0788ca9f57ee7e772ed984642510b9dd6e1cf67f5fe87adde85e7c91553ad87b0545f044dada3ac1e5002ea60e6391e59f1c46d18ca76e2d4d79515ca869b2a2c493fa07b83ea55b05a89f1fc7e747bad9054ad6d4cc91ed6036ca343d745441050da9207314de23b5e5f9b119605c6c4eac046045ff11934444dbebff6261b97630ebc19bfb4f5c8d6db49adfa4e8154e49dd132ad85905289ca5a0caf5eed8100aa7c98a047565c494281f4a1bea265b63459dbd06c0b8e27f34ac12b3b95648a1d9ec67e4ff03e39c6ccfda8a047e09ae47941fbbcd9bfa94d53e156952d6238c481d9a2a7d48cecb738b3e00629f1916330e9fc8f432e429a2a9adb8eaad90ddfce141e2a3b3c01d03e4e9022ae1d22881aef829af9bcb6bbedb13fd1d9487a208f713e35bbe433d35a3555d41c390c95f9109e389382d9d07a39b0b399495e39085cdb3fbe2d27ba7266a8768a5651091b24b184c443030ce501ca8824ade71a4e7547c7253972556460e0f69e5623b8a3ec1c6153dcf78a1bc5e4c06c8439912a9a67c755f4ad7035f0e1477a9f1df0fc2dd28499d7bfecfb9ea160fdd2a0b4b0fd5ad1cb176515d5da6a14768cd600cb58c150a63171aca25a6e91e75096fcd84c8fb3ca2b301686fa891af9d018a7f4f3f318fe415f55f31a4dd332fae456b29155f8e58eced6c3320b193dc7cd606662e88812177a448be6007d9bd4c1280a41667d05b2cc26d61bd78be1f0f8f318d58f39568af266775c379fd5db9561cd13c464ef8fb18d1e55b4402eba1ebe18ced3371c69f0929c8393d5d04ec4bce7bc6065836dd8cf8280933226068a6dbdab3a61324459fdbd59caed044c6b09a977aec37561fb1fec983e718e6be7c5f8bb947ce916e65bbc8886c7fcd23881c9d924c96d65857a3aa5ee1c0f4dbccf68fb63202f5df0d85dcc9f165d90671d30afef6bcf778c8b09071012d18badf781f235603c347b7a04e6ce5ed69f5e6bb52a00e531829f9dd7ce9e3c76c6e10ce7e1daeff086379f53779a88beae533a71fcd46cbace74960fafacbc3a7ec3974dc0ecbbcdb372b7a7a79e87cf7ef442aefb651431b8a152a16e71c9a08d826ca32d0e6a921914526e0215b03e94c51864f218c58281860190285dfd0cf388fb680bc250b680e1da0fe143837a772e5e19a80d5c0d55439684746f791ded53f4b550b5b7462135cd20932cf6e6ea25279c10cffec8b8d3dffbc850e5289ae1587eef4d436a5d6d986f97373cf61ef0656e2797f45bf9ffd7a3aa068e7e3287b2036b3ffd538af15a1abf4079aad452389b36ed68d95aa454bd5494da585c682ff5a0e61ccc9616378319f7009f558f1e4e53c3e369439585afeae1faf4f079e0fe946b3d7424d5d4a9bd602d6d4aad7ee6cbe0de3ee57aa920ac9783f7d6572f06b0f7f261d7b059c7a43ee9e01fc1afad60b0cf86b85d182b0042885f2d63bb6a65b427eb45e0a4e92b3507db83cd9f80e82447dd7d20f0706dc0c9fe09be76b5f8f57e342589d336f1bfbfaaddec4eafee81e346d600083863a6824f8a6fa27c78a0b2e9c8c92146993d4591fb1cb57c0e301a13ae2f777b5d9d6a9e2fef91aad9976aae2455d421ce1aad0c30b9cf9d83604c734012dbc1c3e942f0b04ddeb06b906aefeb0a4ea7ab93121db6d5b691e08d85673803a5721fe2fc0fe9563c03e315f3b4dd2cc2b5bf489be3830682b1ea50bfa8b6d5ff664658a5fce97ebe937439a16dacf8b9b90e4cd6a73e3d3705ac76f0358af713b47a061a4cc10ba4695ad99a0c624d03fbfcf82aa809442b0242c0694f343c3112e5140c2f782a50544ee79f5a73cfc38e4e56b23b3bf426cdd19071668c06c14e2cd0e0ac0731a9502e04d2982a31fa357f75ecefd9e79a2e8093122c2a23cf8dc2b3ef5c716f69c8c7cd113181cc47922781196262f61066909b78ed25fa414c247d29094f512892d7f0e7dd72846568fe3cfb57ffba5335f7b90344a382736da786984831fdfb1639d0bd303d1d6c1463bc6d85c6355d5064ec134908db4031ee3b40686d41779b0dde1329349e4ae6abb210ebcf044dbd237ca0e5c00216bbbf4e167cc57fcc87b7c80ce39cd3c3782c029455a4c346e51140365d4b3e18b73b2f85ce0f1bcfc5e5d0c07a85da88660ed5b9f82cfe4fe684f8b259b4e0ecac437f709d251174511682cb0ea4ecc131643ebddf8cd4dcaf7a81e0e05bdf74098f1e7e458be99eb9f2786591b85348961eaa387e52d67befef0cf0bb566e7f99499ebf5a1d77391cf5a14094b33ccd14e4cf1675158a5d4fdba081e05d68be8db0582d02cb386d4386ea9eac0228cb411bea61421543979768d0fada895b9c0cd255bdca90953143a2cd660076bb098ce654aa4506502f915e85bf5815ee35f37fc3b042a5b5f67ff20150c867a723ce6cb9c2d8394465d412bee136e8778bd7c7327ade8704c8ea26d3ddf369d15e480e77af47ae61093369830ac81e58120ebb2f9d6fcfc5da1c9fcd387de2881fa9e3c753000cf92f88e71e9c22f555080592a3ec20cc6155dd7571aac6c6c7573b168f4a9d31cbfab93b2957d8d976515aba415cc81f27bd14a91c8596599462aae77b98d4f4820f5b52b1dcfff0d0e443c141c4481a8cafb94953d5ed5e26b82fa0441f7ce45c98c17f6e170ad45f455dcb05b1afcc101be40f43046f52efafb70234cbcd4e60ef5b0d20feeac05b27edff8a56d3e0d39e8be3f7c9505322587b41a8a3926eeca8d96f51d2b994349f3a70b5d8991aee3aefa0435f864b6539e42510fbc612fadffed9d07c21d1a27f9231625e91ee05535914c611ab82b8149de507e460a1815b24d303293a2e428bcd3912b2dca394a2cba6fd88dcb9cfe69c5ccc1ec49616c3474211c104e13cbebd63585d784b12908c00c38ff60eebde24ca62cfbe664d12281af116e95da5474bc18667c163f9863779920997b06a76feb87b3c29d0554aeb6fa3ebb16acc729694277599ba3f0a0a9c10359bf5a65b0670880358aed4c115ea8b831b03b7fc0610dd8d119ebee0c7306bbcb7a31fca3e3d4163b2d57bc15acae26155b4fcc61027cc99eec5a9ae2e660ef2eeca13fee1ebd502e233ff5d7e812f4fffbc269326047fde994226810380874f1998e1a5bf0c8472338a96d3d43654a57eec6a2e68a1603510e63e303d07a4213977b3a86c6b3f56f110ff31d70c4d15f8c5f10abc6bce9261f156f387b1d263cbe7aa09becfae25a00a45f6b6c28da167d3327a9bb702f3d189adced74803f66d43e366f0dee26e121a97c8a298eb5c1dbcdce8494aa2ecda290c6cfbfd163be2ceb60ea9fbc03961b3f80410ef3d8efda2fbb56be07cfe81d640b14b91c4c17f27a78c578c087217a4068717fcb117b2e1cf2761ea469504bca22ab37b915b2aa0280035b3af96d5968ebed04cd63a06f305825d735d6952c1334c33f9d143064167c2ec010d5aaf3a9743dc5d398385a095364adf8661a315ef37d0c55b2f25c906ba0e741867e95468b8d4fba9f0f0bfc7d2df7df9cba0a3409f39040f553c7ab1e5aea313edd934c4fc0f56f72f34f85c4c7f4228bbc71b323849c380f3aff90b4e1460dd8708df780eb821389c48f574741bff4ffc4d344ed7b17fa9a0a055550d6eddfcd9cc6bfc91cb43e867050515133d01de665016d8e44a7dd152838d7f0d05533627704cb1de4c4ecf905451bed50f1a88a4961c9eab8c5897011d7fd54bb6183903a59933875a220e56306400229ae9d3affcfffa0989b49bddb560a0d31252b07ad49d7f17ad6bb541997d18f3839740fedbab7354774bfd33ce0ad681e2f5f24f7a54ef14aed235781dbb32609bec6939513ad48fb49a961e1cf256ae8f29427a9b3ee8f66815db6e915c79a467b43c4e4306e25e6523aa8ba32ee0bc3cc36898d5d19add347edf10dc546dbc16d7d8b32b1e0d9451046f7e4f197549ac9e7efb188c1959eaad24fd8e8fefa81df8b63da192ca3534da5144b093e6b6c6ed59d5e7e759b4b172ef34e6a185d552926f6ba1bbc78f887ae12378430cc53a216d8ddc3b1cf0d4d415a35ae1ef6ec40060565177b9778f5743a4048bad026e6dde7c8987370b6639d392f7864f3f163219a7b9f15bf2b0d0b35d1052e8c840f9e7490615209e6ee9603b434e6473055ac89f6958ea59157ea0448f6b3e0332881f3dd7fc54b10605553ae1d7fa00ab8f782143c2b4475c01779ff0436d4b0d4749d3f92b774695d43fbd81db8cf9ac66c6ab90712518069ca850f59199ae21fc773b11825dab65ca1869e753b4c7fe0bc107a245cf808ec26d2c82ec445a0e933d56674807f23edab4d028d9e2f093f5c1db199a857aaa58a2c6ae7aed3a254f9df8b8a7a66564634c7f2d4b97e8d2cbdb62c287ff557739b65c03b0ae6dfc40ba89d5bc84bbefed435bb6bc4869650ee1dcec027f3db35b9ebeb194c701ed1c803034c4ff735db3504356cdf07187b1e8e244a1ce0e0aae32c969897d7008d0e0efe655fd7639ca76fc42e7380bbd169cbd9fd45db741d9ca15824e24f9737d942344e308b9d136ee7ff4badd2cbb8b7d25bafecf966d923efdd6db74778d70908dc14cf26302ee142c2f5cbc11e667f1450e1fb821e289a4830f549f07bcb28536b2b0ba515536da717b0b2e668b785606b83430c044aeeb8b5ff08c9adb6c2b9ae6f585110382daefe6395026ee4bca110efedbeeef9cc4707883c554d3a8a0bc449b7f083a5b32acc559dfd9241911b773e21a0461709d99c2840ed18214d67183eb151d6763a0a7c3f0180406b741b6597cd83776ddd4f1b0b856b7505f6f7c6edf6b4439eba48abe618797c88338cc3eb6da37c84eaa9b2e689b3284fe37d8593eca61fd5eefcbbd4f695cc896d93827e148cf6b4c1972a0b0cb44d239b41cc83612ed092559b942313078001c0277f2c7557502615a33e9cf0489ca7e0998d20dbcb8d058a210b7ba4334bf39410b06a4559dac8ff7cb26b52c5bd8c21bd1d83d47cb8104c68dc2e5ad10653845f23dd490b4b40c6a086b8a2152a91437431890a9060a0f8e048b4318b7b6ed1d3d640a001326ee72e50f9f8db4f8f172715481e46f2bca8705f9ed22fe8321a80fbf7165c6713a8aaeca76a434620ab9d18a15c128bd6ec9ca9e2c6c82a7f00ecd011ecdee9fa8def0c68e40bc7e89e1c7f955cf0584ddf5ec79a1f10638efb5c1b359046d94ce96a514221d12a2e8aa2f7b1e8cd056e0cc144dd2c8ae0b79ab3b85765cd3448d9e7a0b115dca73de617c863b92bcbf6e0e88ed6185eb422524f813f42b2e7a46617c6982054721bb0c76d849606605fe2108d9a9e9ef021e3dc5428e75aa44da67eac20bce2602c36db59b2a13cb40cef92dc48ffcbef7eb6576e5bebd33471e723938cdd53155a626dfee88ce119d4817b0475c525a3c2c87fa36a82afeeb8a430811f71fe401ae2c5a7c62abf72a8a068265d972c4a26575d53499e8395090fecc1e1c06e38f5640bbecdfd52306a63c2b8e1347a55181ec8b1e50932b3d0bda8072ac035631a475d9f58d194806b927e89d7a0fde5cdf6bed1984bc5783f1c2becc6566b9b5bccabc6d751a005cb977a7a2e4ec5756a396c048fa1a5c697a9262fa4b60d919bd59b93dd1eab8525923944d77bd4a8aa22b4041c9f4e05c386649001f7e458ea3e883373d8fe961592940b833871cd79f5a58ba485e150e426f52a42aa42b8515ff38e61b3ac29333b427f0b07f149d9c91d00145c77ba55054b9f610fa327ca02bc44a07910d397f778f36628a1d2fb1739a2164cbac25b872ce80c14ea47f4cf0329c48373d8006f28333c801787097ce281575fcd47ebec97a40eada71322c94e6cc0f111252993239086cd6ab40a894ecbf38ccbf7d990bc41924bf3ba9dba43cabd1500522d0b0ba2a392ed1769a7852ecfc7b58c29ccc4658e3a4dd8e585e416cff6d836cf17869b252bb90d0eb3bf69cb0d7ad5955bb8306fa013737163c0b4755c6c5f8d70956b911285e5f2ed6c5dab836672c1b31f840e0ee44f750f9da4717483ab249447f357cb7637c06db11b326968a00591b853271399779e4c34b95e1bc667319321868577ff247b05824083335b87451f9fb5d8984d81a37c6676efd1432ba7fbab5780453a114ed0e668eefb441d441fcc590da66757231b10dd8149d6dedddf421beb771c82a3cd4a319b42f89f79717ce67d9bd22b1d0d8c33cae220d7e08e5dbf99aba272d75135fb07a1873961172f8210f1f3ed7c2c9d37ca477150f3f1ffa699b47b2b5970b80e73abedbea4928f061e4cace9e53db2dfa4b0086c09505139659783007966f6528eb0ab6fef11de63e09b400cc08a101b25d3a1e21c5fca0f6b831ff20fdd08a5a5f7ed694b02709fd1e261e6ca4d0f80eecc37703fa54cef9e840dc3b5e015b64db68b13d94f2e4865cdde8c49dc04df3e55f3988ac703bdac07ec26950446528454b5b3fc420ff1bc8b1bef82638b818ca1b17e7c2a436fa327c6e68be4880cc5baee11a8e20ccad814fa961def0d88cbf1741111936807ee0c90c0b12987c47d182a9da42cc3d88b5ebb74f20ff51a99f758ec00b20c706fde4435c5682f96043f25aa17e1f5d1388987a8cde0c8b9f80ccd585c2d6e0198132f340262dfc70679386176d55b84aaeccd5367cfdfe39a9d526ff2988867766c19323a707c9ffe5f2577b392d81d92562056dddeb8cb140d1d52d3875912545ac0d8877097101a4bedda1ce1d769477bf1d2ec903c789ec8162a87de3c944ea108f75688a74a27a5ebf05ec962ea8ae2b2fb71775288d56f18662d7d777a66c0cc2284d3d28fb231b70a1e0afe75cd39027e9645c9df3e962441cdc809d5c71b4acfd6c4004c5f5851d5273b1b677862d5dfb1bb7fa7d9f2f5d9a05c32f58cbbbe54feb5a169730c4b2e165ba0286cd0d1ae504afbb4968f1fbf8d3972a7e4c205608626f35375dbb1ce8b8493da11e6c07d969c8acb8dde480548400f250265ae93ffcf19c482d8521cd2a165c9a437c2ee0a2051a22f9ff7e42e99c67ef0130733c11d780268298ca029d53ec9bf5c0669b4cb0a05af70e5444e4636e2c07d3ff739e72b4e0e4849fa8c1e1f0950b3151d89cc3ee44679e6413ad735c1f515ed5597d54e74eae83a1557fe6274bc289c589c57737170c04a1d1e6523c1787f8c93420bd77c8a7e908971d0c147248bdaa88f1dee6edc34bdef4ef09fdc36da0bf9fb981e01f5d23c357636a5601434ea3a5fe64389aa733ae803f74571827bebc9809fe3d9f4a24ce467965d2494e70e708b0a8c31150752e748d1b458523b44f7732a62ef57924d78a41b9207bf17c7bacfd119fa16c87323faada93cb1d8f40b890e8329169b770f0da391a20ae6f934f6534e7128e11844f1e71bfd683dd98f12655257ea35aab3c0cca15fd39b74e59434ef1c0399ae31b85a3847f059b88228f0c236effbb468f4f75545e8b0ce716cdb6d3158c2cd943e9b52e299b99eae1ca0fd46ec97cfd105155151f68dd95e5134f1b8da007dc9a9211cfcdd6cf7d5997a429ee7c6dde8a2fc5ab4c343ef705f9d9814f34d589a8503be230532c794671a468194f9be87fe3157ad58193e1812d0cf3865b846dcfb7fe73c868d16f627d18f038163d17774730af1fafc691f828934518e8daba737ae95b19328b336132c865aac6cc6bf16f5c971db6a0b695bd268266a4d9a9d9d29fe1176bf0bb3a402835472c23da5839279ec1629524eecc884a9cfe082ed238a8334adcceab983f5a11ac23d6e3db79f2150d84cb171804f9888ac577d163511caf2a36ae78360acab2c18800af169e705998ec9dbffdade293e123900e08520aae4875184441ec7d7dfb392d5cf712c7f9f7e281b23666389c8d7a5dcf6cec93a9ea897bac4ce597354ee16583ea32ca09df2e818bf22958773847137897c9a219ae5d47b17d1541c5293e2ca490534246c270b46240acfaf28dbd27d4ef06ec9ab990aa40000c13ad509025aee865e42a7f2e70fc457ecf3cfeb1a7e989fbfd8bdd2c17e076051edd73c718ddd75642e8426d029dc4d3bb41105d492a2946913d512cef6d6591f259c38927e854d03652e416179f20c2b299cb8d912f3c14a2d8df57771ce1d9569e67535e0683d1d78f1d140e7470b9fc6b8d5af75ea9fce22a5eac698eafc7301b317688de3dc67c32012e0642d73b518666f817e21da25a4d7484e22e02e61a9fc1c458312a13c15c50595a51e843ca2a5bde54157b8e1e37711c95ac1afe5b8075570cac7d1c0f1177fd8e34a82a1a56616a617593cd23a9506dac85950fee0231563674971771bbc768fed59f8b35799ce80fd57f3fb546c3aa9d793d2298875785c741f7b516bc57d36fe06e4d363afdabbb5a9b85b18b6dc3b70ab792429caee18a1c10e13e65c4fc597826c365e8c50453867102ae219b4bbd2497ac0fbd68d6ef8d5e959cb71866f232ce2617cdf8a474f0cf225e93be29ab5753dad9c8476ade22a09555bf028f65d6d2b0c6bc4013e5ac20a87161f91665aa30cfa2e174c457b0d3cad32db39416d4bdaedcbd15541b4d570c2a536e6d030d89530f97ab3c2a63a3a1b200d4a3a0e43b9161782e32c08c28eaeb9e055fa73b3770a8e0b62f61d42fc300ff2e0e2cdbbd6c4273c474bd67e646963bdbcda0691d19e13358673d9166218ba2a10bd1e6f9049ef59f76e219d1efe77c7eaa1550822a97bcafbb0034fe767ff26dbf13f195d3b5e5711b6734bc7812204b370744899ce936c0ac82e463bb8b731c954d114559c9cab37e8de6611a33af8c8652d32ed3d978e7b407c24bd4d284e276bfa167c4f8334117ab8100b3fa0182e5c245e1d7dd3d5b62b818e1de7cf1fcfec019de19411bd5b8ebee7bb323b80ce9a860a54ebf99febd2dc56077a4e41bfc8405a6afe5ec22f6a20821471670970514b6e9ebcac0af7611db6056a481affd2bbff24ac47ad76ef849aa9b5e44be27d1a5acf1f0e296402778714d99b57d1bb5f1a7170d2fd954fd7f206673c66c3d20a6e83b8120823e2586d205013ecf72f34ad5ed8a3bbe5ec10daf7c8295c33a4aaa6d43c17df9115f155ccf6a100031d0f814ea2ca1dec947f1e2099688daa547ee7cd102f08cc58a02627837ff9a23871f9ad2f124369a8f002f058fe7dc86bb16a5673c88f335a09479cb07a3dedd5c2a2945f28689a7ffdf7ae42ad1c8dcc08a0d60d9a3bc90912f8bc7380e636ed1080f99081b6333890090497f3df24e5d5861d85b7889dfedf4fe408c076bc7ec4e4061352f4414fb8a18f057b4b807957ecfe9246ccfad91ce10510606d0e7273afdbbb13df22a88d8c95e33060ef5bc0cc966a8455184b78afa976ff67ec2b3b6dc78ffad64642afa15af7601f19eb1064f272a19aacd9a86a538644b152673f1bcccd9b4123a9e96da79bca6fb8fcb2e0d0ddab7aa872dddb4cd90f561c03ca7f5e6b398688c8b5d938ecca98eb5935a270663e52b70f92b08130ddbbd17683a9b0204f8638948c7676febb8c8f8a1dd3f415ad037a6c2c0a3befc4b9c7689abba05843d15d5ba81fd582d8ef58650e802fc2fc515ab9fbed513f4bdf5a133069e6b620bf5f148fac6747735b32a947df16a85f5de160ddbb2feb1110695c6879a3082af1cc9f14a0e302c994c796b0b1eccce4ae3f4f8a3a8a157aa7edb78996ccda843e74e95c49edb87b9dab25655122c518cb02a77fa6800a121afa3d539f345fa230614b5fdec07abac0e2b502bd6a06c91dc1aaa647dc967d16f480ec105a7f5ef65ba518eb5bc125076b105a92fd5700c96791c69281c133912aee80bc4fb005be52fe41e6ecf0e12fa0216c5e0eb5d83978f018bdf093f28393d464c649d415f542862174eadb05a88e4c2d82326490c9eaa199230da6ea96c7aa7e1fbfaf1da80aa92335d26ba317363dad7641f3a53853a3625ccfda2c5e711f4170bfa551218c6dab23e7d5774767399a2d6e5570f0a98fb2bffae154a07d70afd9abea6ef18df9d5f171d57c5b410c2fb614b2da424d94e8ef67a8d61b413b8bf6d321c0e91a8876624036edd0cf8d9d7b3ef26d1e66615b247871380b54e9796b118df2d003cf6688d5ce8d2436bc6c51ef6831dc5ea8bacfe19adf5d952b7060877e8af6d7ba8fa237af0f2ee800cec978bfef61040156e060080cfed12f34f0cb0efb0990cbc23caa12947c59632956a6065ac06e03b587e02786bccb0eb039523dfc9e7676c0142662ea5ac88b07867715e26b0a43d9be5512a80ef1301cb2cd32d5b7650f2c7c9c158d11c2d2606f4a32e8566fa623d8be05cedb1fb0dc0fd6bb2305e7efd9945fe776ba15e3b54182e4f6508369b2324c170a72a7c8d77559746bf4caf074e1e34f34390cccc9a226d140bfa0d9fb616fdd325749ca7fc459867c0f6d13c6fb124830b70da0b890c0fa8e8e008da1602a2862b4560f7e30ad7342387227954243c3df54c3d88697f0dddd6118ca4dbd6d6a42e8188113c8e8ed85e87dfa22e95e2082fd7f85e5f47131824badef3f23c249a3fe2110c1640bf910b247b55d79414923cdbbc6bbc4f53e083addb92a7d14127ad29cb6efd0cc8cdf23c56964bce7a05d288764f1779fb17752cade70b78ad60448d75026b54fc5586e9fb589af6fb47269ae342448a67f4eee1f17cfaf722a1b07e589f8f2c4e286a815b0bcc494c74afa5ed824fdbb09636585f4b934be2a61955d24c66dc3cce32d85c50e9053b9419eb50a17b7ed17102d6fd7eba1f269333bc694ea628563f2c85bf0fb0afd6060b15134da71e591dd5f2a5820b1296b3b01238e1858e1958cbb977624a4925ee5fc5d83b5e95d532578a5b81e7df64f07f14fb8d059a354d28e3fd2f94f5111b0acef5f3ddc33dbc8120af78e6a9a009efdf7c1af1b5fa247738739d50f356a285317f1d721ce6bf0ea6019d4191795ba13f3f24a8a93018ed6449839f35ebf0fbdbb4c303d48e6c2b5d9d0cc2ddc83c9197a783ecbd2bc57f8ce64e237b3b2a76ef360fd5dc4fdf470a96ab8c604071bfc1f75a7cd1b3a3a1b7cfc91316c15017b00a44daa0f5aae2971ab80da24c5b562cc9b7811a251847dc15d6837ab281b82537d08a456b01395bb8979b6ffc3610cc5c1503bfbb183686baf086a99860383e59e4dc1750c9e2911c415bdb9837632ed383a6320d7094b761985b34e449bf3ca40e7c17f52e01b3cd4fe1c3d81096c57ef796ea2a545add95135511b4d6b894159ec3a3b85a08a63f701e2bb1f0bb057e4250631088c24abfeec0be9d3f96a106ed6b6151805c4ea30d922f7d3ff83117180a5fec5dcf4750e1ebc247253508dca54ba9535ee622efed82f8fd7d6bcccdf1ef1f7161173789aca22a2be0f0885f7a5af3dba2e56c2a02037ecf0a45a6325bf81830b9ddfb17313525c54f9fb620c0ba410e657a530dec00f6f84b8a98df8e02aa0bdbbbdd2b844d5da2fede209abfd02c3341e87c34d57dd64a234fefa6c0edcdcd3f0dac461b7f140b530b702552a6d7c77edbad22b1a194e24c057f3545537e207322b385ded4fe2c4bae6abd786a4da8e975cfc8d18e90461a2af416f33ad1419fa8fb2ef9f1eb5849a32aeb749b9f79f63464ed5f2dbc7bd17ef09f2fbaeb93e00c63f9824005b38fbf2770aad821b0b6f0f22a7934f40ff2e1170cf98fa0c8243645e37a8419670ebf8fd97b26651f6982c2d65da13be323e94a6761daf76410440dda3c912ac8ebb975e275919605f05fcf44057f00d3f9dbd53396a0cc758c5f546f8e81f3e0383d55bd3b8e4bf8ddef12b6d7d18fe08646a3f704b43e5afee631aa5cf8919248e85f5d85bba51a715581b223b6ac7577b645fd7390c44d6eec4f4512d86abd3ed54d45e11da8019e86fffd42773e3af30ae67e94796c217a32c84a89b25b1f46f3c812e3d82ff990d9f7f79e1afea3685fcf154fbc191fdc25c1ffabe811943aa8b437f1b36bb49eec0a44a82554bd63ad47157d48926ee43d0a5361c1d66d9cba155bd6649691986bbf3c0d10fba55e83aab0f47158bbc0febd8135336f737be394970a03b6ac8a6e28934cb6192af1ea64d1c33088a1d1dfcc8042287c9af7e76f9de8c26d882f61d165ec3e799ce3d43d7dfbdfc83a4c91385ad07c3fde27613e9c702c06443d0a271e6bc544a897c3d9a1ba3dd96fcb5ee44c2e098c8382f6fe43493463db420ce4f24f72b94b42f4fd4185130c3859fb88253e74095f26d3fa5e61659655e12010c89f76ee6133dcd4d1f363489c99b2cbe67f349f6251b57c814581e1ff59a3c2ef086ecb65e8e3c36991b3ab517723b992dc7c090abd51e867f019d98124f938a0fe1c5480463f202da150b342456f2766008bc622e0581a62347c9ca19c30a1d995483d09104395ec56a5aea58d69aa8aa6b67e86cbd1fa310422489abd350e19d3c791cb8d703c0babcc792a4d0f5e1fd8cf195604206a491f8756b7252955bd621b45174820dece7dc1830636c4ee45ca2b50b0d9c2ebb4fc82c1ccf0d6d88a50636f880a918039883c86a7bafd275a089d0690119e90fd95f139c97f48583a0abdfdbc444f66a7a0dfde52bc9af01a05811bfcfa9f0071165c366eef32fa34f20c656e358dece7d2460c64f470fe79348cd15b5ec9095bc54c39aee1893dc02e80365381446f560dc09780ef3bb69c64f1df30637e4eb55acae09dc3b64c29ee0fb57c281b45beda76995594e40af6ce7a999b02a84243329ca60861b15efbabed87a2a9adca8a6bbae8d847e8c3177f152b8d6ea4712e225027b9f0bfda322be3787853d69fcef9f011a1d327be546d82dbb72cef68fba7acb4ac5a8a8cd111c4e45c5f367520716087a47f68b880dcda10ae72da42c0440e4ea4786458d9399f0c7860e9745237dddecdf3b35d0d9eea5e66c94032a10341223aa9d9a564e5ad63888a1080f9a939586704746b6879a65e0d317ebaaa98083d4aada167f7d4c32fe484a4e452021df5f9ed947c30c90b5322ee14bfe7a4d41a24598313b021f7cc3fc2abbc7a070b064498cc2cf28bcb3f7ed04d477943b3cdc92aa03355bb8abaae62c60bd2442cba46525aac5435fd4cacd2e9f3e5f31befea81a32518e2591af926e8bb33d36c9d0c2356cccc797758c4bb3aa04e263f0dfb9f5262c864428d65764f83ac46d9a296dafa46bd6b6b74620780a3226606e96cb96c40fb9ac0fcfc962d6f8baf2dbdcff1331e6ca5207f9ebc90db1f24eeaf3095e1571d20043e9c645fbf87837bdb8f377bbdd5c8c5ff9d9b28fb0477aeda3d429cffa7e5e35cafe6bed1bdf4a44c9f4008bf6b5033d0b8d51aa5e9bc5a6b85f1f98206a1746da0f945ed3ffd6fa911fb6b5572faa71415efb90504658f6d3170d6c8ede7a31c0a8fb559d7b846de66aa3ccf9e185de3409c9bf0f05d8f2c3c6c45372ea9f1487e44a270959d1e90b18a91be80eb13f0ea778d6fb89f5218f3884c8612115bedae9add19a86b37efad1f8d8da6113ab637240a89402224404e8b0f7982ad959030d19137b3d2ce10523c510bbc1ef177a89ee27ba9f058e9d91e7b810f37409da43d5651cb0d06e45611d3f587e164171f59a62f67b4b8f326c32808ef620b2c78dbfa7985fccacb59c861e25219828c40f303bb4bb6843a0c497c767950631966f2aba0625c6d593a003ffc4cb6c06541fe44b7e99ff9b80d49a150299aed24da567f34d2567fd5600c53d6ceb122ee0bfff68f303b639205dbb9ffebc5912fbc7c6a9edf5dcda36b9644e91ed51dc22b146930927dc4f846690203bdca81029756aa7cae6716e8f33bd71daedbbd27348a89621f50593115591c6f3ceb3457cbdbb2c624a01093c3b8ac9a1bca5c7274bc9f1e6a3d974da4ae3181ff4193104e374e11ee40092d1a06db37dea6410e1440620299535d1b98a7604fdbf03138936450fb1313c66b6ee338c3f594e2f0998fa5442fb7211749fe4931c5d678d419deeff66496f4487d96ea289e8301083f41633c6e2b410567f2820951c3beb4d7153eef7463be6dbf269e540c53bacb4d8706c3a1b615e2dbb462057c6d2474f61b5af608239f510ecfbf29c0b28ed0d3225983b8df39f99f578ee83979d8a7d7ce54e9dde6f953af32e338592154919d118b3054ae50119121f0474cb407827162cb8f360611ce49b7a462b591f696707e3236a50339c5ab5ad85d294cc38a071f9ffcb76a752b77e6b129ab0d0f719280b8e4a8d310dcb1d051b8710d2bf3d33c740c1d5088dec95c590f8328bc93b7d51566be45040e6677686d0849235fe3a65bc4b88fd5b111c0f95900385b95c3e3e4f73a2d59c9f386aef2f2a3f9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"544c53ab1b4384f9113c6582f7953c79"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
