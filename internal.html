<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98ff4f97ac48f6dee66955923bdf52d4e1d5bb6fb02f035af916e718878f1ec5548fcee059d88013b0abf8f587d69c3a968ae116234e780772e96916a6925bdbb64c07a50f1f8c2cd59cf23fcba3a887cdda35ae87d2cb02b4d11319fe3367454780af56b7ece822e8953bbe3577f4f10313ccf7e63555b1af7e9e9c5fcd7a4c0d81d5498420ec4e07a0e71b8b4a1240a147958c0e2477dddea764fa6da213ace1a1223ba211cc4a9269c06c31c33265f6796b41fe77a051d713ecc573d8d81c8c3522b306d2669903bd803aaa4517feb7df90fdf54932f82d01409601df9a6ce261b31c62fd3f8b6caf521462d0838905739c1acee418fcc908ec44e8e09dd6c24f4587563866fc8b82a145215b3dc2c35f63751d524cd02a4f7c879190c10ba3ad4ac0b1ac519665c0809f81540fe4b164bd246b0c775623250057a4fbb13e081687cc0c137f37972119d93341f7ea7e9e8fded3aa1f470c9c9e39dc29d2aace2cd642f06d32ca305f102e1c38bc3ee9d3294616f6ddce7b54e7b93e76e4eb6d11c16ed56963222f6963e396df9d122ce45f05309e34d490c9964d7a8b9f7de7216ce172b6408b5724add17424e1936672beec33624d82a9227db24279aa037aeeb1e3fb53f7dffbc3177a4e89fc3a7f0150b25e50e131b00fc3f8840d934a20eb30d62a12344a7559a59d170a69cc0a489cf21c92d2c3bc3b19a27e661967c1289df6d750698360b878ee0f0e4f06744213e11ca67365b38173ac86b5dc4bbef0b3ba4835e013b0627b343d2a7adb2e77d0ecfc2803ce91bc16f8da38a8f0846f82a830b6e988067f30096ea5945c3c42bf8d94f86b649e47413b3542fd6ab882eae42622735f6a80fa4a34508af833311a60c175e1334156cf845feb1002ce18459a4f7176ef5c493525890e4304eec30da7d107106d411c79b592815ddd31f35630d1733552adcaf797d2e981071aaa222f8a9d51bc117d2b780b5bcc3bbcbc3a7efaac3f32d44a9cc3161ebe6fdf8c4b9d5af933b5b183083a7a360d863b38dcd75dee6309d398801ae3aa3ec6045859b74df549ee17f263dbbc650adbf6208d41847c16d2e17c6f5af7eb4bf526526c642e126440489f6b02e7bea7fa62c1cd8d3d8828959e459e6d6c80bd3437454745a2e16649cbe88f078b287ade0a912e1b54405b6ae8b028eae2f3b0b08e6dd5f7b2849bafd885b984a71a5b73fa7e9794943916a31f9240f32db9f9e69df2a4d5fafc8e4419a85e43be805a3cdef38465603a0db79e31d6249f1f965bc17e086d139620f0537a978b8d630d4409aa03f7b1607e6edb8a9712b9975c14bf71f402e037df4dff8c4d62d604720f53472544344302eb22e8bbed22d10992aa4d9103b270c82920437edbb4585f802141694e45059435813ed1d20e1974f140596ba6fecf26eec9eac3dda768eff25d252f4e823ee17c997157a807c47070667105662fd892fab56ce7227b3ea6d9a1717e59f5c9b390b5bc97a15d6a6a7052e3bcda56b61fff84e575e8e391683e96924609f8ce1f0db456343b03adb227cd601dc1dc3e1272284702b229baf70fccf1eb6a724abb40115e4266e7631ad07b6bac0b95d12d52bcb81da45f1946d45f06819bf23c14f4c9c2b73eaa3cc749c2600a36150047d9ca4791e8cdfa0363f1dea7fa876bf219182f54e0b278eb99af429138ca4abd5f5c6449fb6ca7b217905a34727b6d20d71a1ab857268ed6bac313bd3bf79a5bae51f4d680b28e60cfedf556a14f3173d7fc67bc277152014dcff7bce57484adf1c8b2bd4cb452858ba87d8f94d086e045f1bbc36416f2def54712ecfce03380e0c00d023cc3e0108c04485910640a7c35cd0ccf2986923a43e205d212c2aab4626f64ab1de65db82d5c1c9a2072e8d2fdc20c0200531f37bf9ddf41dcc825aff1f2c2055934538c4cb7f0f7408007d96804791408e16e320ec3c0a91b5cdf97b939e35f8b50361d3072cc22911d772eda1949e98d3641c5c4336d2fc6672ac4ac9f8125f65384a60638356dd63785417278071c91ea6c90b43146c2978145895df65ab7569136b496eeffd20131b24a082f329daf6e6a4ba469467fa84094fc08c4ee488e875773ee862497d230e1eddc1cc1669c503203feef0552132db9b66341867eb5c73b55d25927cbc1ade14e650d35ae50474a414dab23fd153e1ecf5bb8286a1c3b339f150e1c9a21466c57b282a3b3e2919cf025909b56f07373b2fb6efa6f646168271c68861c34eee33b43bf9c46d08ae5ccd88ca2d3b879c26a4adb74d2a0c6c236586042e5b77107880824e7f598800cdc30df8a842a6ecd1a1398840903ef25bb8db02586955124a22cf30df809b56d05934566892c7b01185b54fb7c78803eced332e219471122e7cf9e308a2add9823f51d82c652df085419edd9988b21c02693d92f6c18f859275da745105b6705febab3ca059359d62541b4fcc1b3e1cbaba68d1b73848a74696d441ab1ad5648674e24c23fa0a0d5944e3c7c14844e3f29a97d2b84d6b43be8de0fc91ac0770e79c20a12fd4922639e0a5b9e329a6a79da060bbf21b0440c4ca8256aa20fbe1cfc44a39d88cf998d58e265a9d975c616ce0ab0ebf82e7402c1e7c5f250bde88b5db234212120eb4c87ee6926b2943bbe1f1e920974fb5e4b52dad88e7e53cbfc6fdab9628325dabe4bda8c33e7864930d187de4ba8d87f9ef6879d0c2320e658d05c2d418a9f1a2b2f928d52015db0c863e2c6965153359bda4f0d9334aa8289db45a817fb4436b26e4f04c45d2f271ff608073f69b05f1d37ed50a50e25693af82e3478aaeb06866df52fba18648f5f408021aaa36fce6a524cde9ee12de7f3c68ac0053f246e1cb54f38151c2031d972e1bdaf6049e5a6d2780cbfc36a58c291009e610d0cd5da866f67223ceaafdd4ba6a878ceaf0b54270f0a3c13137412bf409a16bc8a0e559c0e28a93e04e3a08e6b92af3d1874a4ccdf523b5c0841c2db92a485bc96388d32d4e2c553d223772620d765b9ef2f1d4c7b1c909ffcc1732c07d15c5944b3c18d0e02d6d921977ff64aaacd08ac154128aa2d15951462dd436d7a7f46e8bf488a3900a825400b740e89be7bb4a20f1aab50b9574cd1b010aeaba3da62ebdb51e900eccfa4f5c8c5066775ee31aa36b42e7c01b01dcd877283f9c8296214c361693c5a791e177944c33b9fbd24ef5898e4612716b8f5195a2b8ad4c7f4d2e7b9b8e63359d4b854c43084140c12b67ec71ac30e79ffdcce6765b8d18d4147b7b6650a55393f79a66f7556ca879ec2abdf52455afe1be333755dccf99d9c53c68b28588f6877a6ac9565b9d70bf52b550d598405dc62497304806490f2dbf85f3b7fe9b1aa84527c4d1102300cee04d01334e6d1dbb0db9a140426aaf9db8bc715481f3b3e380a40a7acf18f01e19e8972f867c4198e7c89b34b21268655c1e76ae56713956b247735f34158150de4d09f3dfc656eb205ba7748595f5bec00cd56550ce4f53e14e1ff4a8b9abee6eb20ca6f0890d7fcbb9ceebc224543e65df7136d0b60860ac20c3e3cbcc915f1acdf5e22f294b6ace4a0d5f3e6a3d7a0c93c54950837a5dbc1c29967a1c80e5d508108f58277256e2685cdfb82734cab9247b2eada7cad444c84c9b0b7dbb7bd73a76b918d59501e17c862d738332d51255444d65def4834767a1512a7aeae214e48857a0fc1e663a759440446e93ed8400b53756244e0eefbd2f37310c6a0b8c33542551d673aee4f0daf4f3a3bb8e36a7298dae4113b4c7b824cde096ae15c17efd0c3aad96f06cfca90b6dd27b3849ae467f5ccbfb43b31000958668510793e94c83c00cfc00b49a14eef4815308eedfdd663ef3de0d8af94e5afa3d02ba0ec42a8ba520eed8908ff6289e4b1c008873ad31034353896883d7ad479d8cb627d94bba6fa9073a200387e05411bb7a3520e3bec2e48d32a48654b3596b8b16e6aec95fe3c882e66ca8842659653bb428f4394463969666f4638661e36d61404e730bbceb7bb380a2d11071a1175f8ea5847c77b8acc2852b1a006f2d16a90fe6c6319d51e157bd4a37463c6fbb5a5d5ea64aadd4c53fc3d89b5d51c8c60359e13fd2ac45dc702a2c27d0e0090fd134ec8a12b0a5edba2bb030040986a843d0ebf2df16d7c3f5f09ed509debd179de6e83c3b39dc138abb30756f835fbb6bf562e3d740327d151f625971b5c16e8fe648395dd75af3c97a13b07e94177b08af471c3e8877f9501760ad591058ef02c908575fa05cd736ba276625f1487703868d22d24cf59a4aeacb7da2e750d0e9674ea94779a78f92605ce60d99bda890a5998583329ea493c93cfac1e7993d20783fbaa55d2ae912bd5a13bc5e4ab3a0a46ec2478942fdd0fb11c99cb39b25815e108f23107c6a8353aa3559d7179f7746f346c29723c75a7cd8b926a188304cba96556e9165c1b6ab60e3f4c99c9b560a0ec65618c08bec278c178f7813747766510f06a6a106a93c7f33c6dc3541442a20f374e75f056f936ff6d3d8c54e3d5b08e68c34deadb2394e5c662122af6c0c4b6c1180010f0af38ab4e1a0888677012dfe77e392d3904b381ec1af6b36ab04af8f32aa37f11dee57ea2769ca2606dc18fcb9f3138db421b6a5a7c77fb55259ae3035e2f6acd3c26486ac8f5ad280f773c2bd0f8c3fb030739d7d55be73ed2cf4c33cf0044dddc726805af2a0ab8e381c37049949d44a53c4517c153182413d0c39be8e5aaf4525df863bee28863d4c585872aaf8455dc41ad570239c459e55610525d33cc79ea7281498a698725409ba5bada74bb567e3c19c73ff7ab861a7050ccd18c37713b8cf3a43d18c72bc5a9d1eae410097b7cc8ca1408de40ee652f64ce0bff21d1f30229ad22b48325f1348daf45b079b714036646018b8635e86c38d7e980e36df334166844b5ec71597d74ca8529b73128198584bd46d6fa77bb1ad9fedcef50a83e26f04e814d6105ddfe17d1c3c226e0514c5a9b7c347e1d1d87fcc69b73bd807b37466a6a063d9567ad74d51f4be2bcd3555eced5363820d9e281583665b66060b4340470e3392fa04bd759e832748cd8c3236d2e547c9c4dfb7e9087b28eb0032dccff9a6d7a5aacc6a72945dc80df3fe33da0d36189ac618198cf7959835e6277898b440cb659b693c6520e53cca4175b6fb9662a91e90240be335ef37bf323758f7fd33064a2e1149448b36e263c502e4bc33fbe9bfc0bb34c10695b39014b07ecca00280e09885cf6afe58d8ef5f6072aca7487cbe279e32c911aaa0011ead7e3dc9db90499778b69272c45875e532d90f6b1ad1b9332c0ff316d3096e4f69d8b75d7719cf9cf447ebe4fcc8d5facdd2b7b6f1299bbe432e5d055db6eea48e9b6033b27ae399de663f414bf948f344219ad3d071384ed744fe6eb9cea9e00d2b07ff7369b68c59137e698230a8b65f6deba27d652de5e1c4291609ff8265913c5c554695b64b49425e572e82bd5f5ea4ec79fe7b2e3573527e66afedacd3ba84455cb021820b1632ecc0f9b82e7fe71e53039e412f2e9ec81e8bfe39a3f51c01eb631184941643163ef4933e1f54a57d8f4fabf593839244f191a13bf1b36a444182fabc8e53322e078e1f7809d4971bc89aae646ddccddd74c9a3c1b389a7405e98de1dba07fb063b66167312c34e9f4dace579793b6bbe5076c786c1348aceabe1fcac0bfc1b1acd3587df9ab941445b3c09bf4775f47c23542eff41298ff182b0defb7cce21347fe13f549f2c19939ccdc184f7d33262e0eb75e5abf9ed56e85f44f01a23434501cad5b5dd0e3c58049723f004f8da3a120f9a9b20a3f9eab184c09a4da917c900ba6958c15f567688254f241a5a337f2e90e72253b2382fba8c60c06cbfa20322fa6861957e9076d6bb23b1cd7d28c9b5749bc321de2a2bfc791d0ec6956a80e1eb6f29461324da8a78e5b912d84067a024eb35a384d08d79699af2dd122974e97da876ae762f5c7ebd37a9ea25e226726cd2f343fe0535d3a54146a925ccd4f49ffbab5608284e30738727de4be8570b9f769adeb600862ece84670a2d5ce3332f5d4078a588526a6133ef9a468ba0bcba4dbec0820b34faa9d9bf7ad6e45d086613c48f22e4ad16ea2b32367b3452e046e21a49724aa3cb89d086a98aa62ce2921edcfff8bd62ef0e9e20a8413483b7121352ab1fa7ceb107ea18a28f318416c1eb128571f8f4fa868109e5d0dd3920e99ddb2e545f04120f5a9450c5183b556dfb2bcad554e19b9471319395df87c24db7b88c7395ad8756216993aad436a44233f382ebc65a176d1b8cc8caf2e83cc2ddbacb7adefbd4052ec04834e1579b8f1933edb6fa4d8c76aa3972be5b099694bb869ca1bfc0a37525df03ccd6ef28a806dc00da849966acd331e16dd79cc428a9e96d8418456e1f14e539fc7324207c3571ef311fa6667bfbed794c66de1b2fa49c576df57aada6a2480de3e0ff1c2837eeb8825c26e17dc774fd76b03a58dff60b6a13bdb990dcab464663c71139807387f0e5cb50a9f54bc83c7dcae2a2b9d85ccbee0d71d25e68e45bd72e629d076cedbc1c4facc238cbc3c19c36bb7e599eb9375eaccd430026fdfc460e130ab26874becf52373f1e4505a6a1751fb34d64fffcdc199fa4c17e97ff910b4cd12ab36d1001e57dd8674efe92f1e66045ca7372075e9427d307e1b0e799701bf17334b44730ec029e7f7d265ad16e0538630f0b203774a7a829bf8e42ce2e65047f5a16a488f86d3bd63bd31de19baa3ace09f3db5d264f038102819576192d035ab0069e5b2db9a977d49877b8bb34674fefd389ad46ecfaa63f172841ee4bdfe6ba062c99a3369e6df66e7508fd443c042c7bafeb6b5c4dfe63aa1f4c8bb3ef07dc38797465317e3b01c6eb4f990e61ccb380c077bb2e1ad592bb1e34afee374f5611fb60f9714ab9c47486b0465b5fb7c5f697c35895c9e0cc09534f52dc1ba6014cb05fe458cb91ff387908785e702b56a6e4686903927e25fc6e8e32b37768583fb761ec4a8ff13aedeeaa416da9b08a5dabacafa61cd4dad7a92d112e0f78127a1239e48c7245b5d1bad1a9ef465df63aeee9e34ef1a57c8ea5fded92c4cc153bf69990baeff80f5d6cf4582d51aa3847e59d82ede6b5fcfc112943a72d99cfde9ec3ee9a6dfdcba5ebca22bfbbbe6bd5f0312397c1f48722e7f44c9878231d24c52d649b42458f0d90d30c1defbbf38518b16662777cbc1254dbda5d58083962fdce00a33d5451f477190193a0bf1d44e81782e2650af8d6b877947f930e865b5485fb2cc6c2a2c30d5dc009fb23a16b27c577337a396cb4b839b53910523e09fe8778ead410e73774945cb845b5012012a57e90788e4d49f57baa663c4bef3776f37839ba9953b9f585ce5cfa3715c86a6e5703206b651a4cf614766acad2a6f4fa2517eb12728e0a67cba00e0618d064c48659dc56f504026ca3cb717d557370eb36285bc0f021e13c90e1a491df1b806213b4c4115d8a2b488be902ae0ddc9fad480f44dd59f95f9489cc84e3aa329d25c0232d7c5e49690381e460851310bc648f07db0254d399252e6d1b130e4804b4a22772288c5ffcbfd01c990cf695afd056dab8bcb92ba430a684dc48f1d7e359cc8988ae1ad3df80de6c2638598190d5a81cf5674f66db0e3906a581f38c153a36a1c8ab3c680a7d369059a3f61e861b2c3baa027a8f17c35f92a85b36c5af93d828028f97c7b59c93ef2e6d84adebabfa77a9963d76adb2bc52402f8825d5b0030c6f990f5c59f583b2a6785d97e3aefbf8ceb1a636e21705ba3cd4f91368b456fef40d254b22267723cab827a3a435a2eb30471b940eba58b57afc88707b036d4b68951f9d32b3081794cf80df958a321962cd03512022367e467ab1073b4d794d617d22f4dcc42281fb7ce60a34976a137a3eb2f7b95fee5212526192761c4bd86a005e628b596f8015e09b7de8a1771b7d5d9a32375e7a3d64923af66eeaf03ed2dfff8067f8f90725457a2191ff624c7dd47f552683b3ca26bdf3ef771077156771fc24e3753198d6ae21e43d1be9ca811ce811c64c0b80f50bd4d1dbd590bf1b4eaaf0338661a08df2945f81b01a5f5029fb35032b87c99720196345fddde53a999dbce9cae19ef6442d500c6d44bd2fe6a05bf8c5667d788c19b25601549c837ec0105a25131adf7f80cd49c70966585660613fe42ce0fb2464b276915cd7f43914195a8789fe575c717e93142db87a78e02530bbb093a6b9ab6eef69f7e72074418d4240089bde4f8f184336ce1d9778bf45857892032f7f1d1df9f73e910e6fa0ab4d432b1fe8023b123087f962fa2ffe9068e2f6be6a8d9aabf37d1f900edf80c66c3bae5be6d0627b726ac5f6237a4d154026d7dccd411bf64df69a8bf2b694386e32bbbe0c2b7675bde379703d2a21be1801894a1ded0703502cb959ebbe9b3d9d5695e80c232e163351b2aa27c762ae1e3ea4abb690b7ff08c21f7e5e637dd113b8f6caaec43d0f202f8d2ea297938c6e28145cbfd483a8af1f9690f6421d04ab41dd13442570a36d74249b9aaf5d215aff34faca40f74274c753047de1806c04f1b2a048e186f798ef73db6f32c1752ca57168801056f4d70147476d48fc6579062069e1faca0403ecb63124c404898ec9b148caa8c4a726a1e995d11407533bb1025b51e3340885391e438729e260098f02c35f22fb69383e68cae36a93ea1ad4ac0cda147041843ae871101476c91689fb36c36225671f973de756a3c189bfe1acb277dd80f46dbb19cb05cc9b3c430888de6264705ca8cd9095e3d3cc0f0084e2f47ed72a3302b84f51e77f67e52e81e55874036343e42fdf3e506c184a87bdb976c9791c2511f109882dd9add3f8e060dd8f36719e6e727c5da8a29f044723dcdf31e1b92dc24ef89e91676239e3a442d78128a6363fffb5030417d03e6f5496cd473a3f558f711084efa27f25083961dfba45636e200f29e4f1f50f4fdb923c057952a9ef1edf3512b3cbeab90a59bd76d9697a5c062c8cb2fffe46aca94f3c92bad4b1bc82d51ea45e32046e7858925fc246ab6dcb57964c558a4276d7768d2931435a377d2289e730117b27a11ac916d6365b14661ce4417c36fc3ae93ca354100785047b431407e3dd00650b95cdd70b700c5e66ed5c50fc3f340f86393402f7795c7198161dfec9dfeaeed2f4fb2b0e31c22a250ef362a6bb9cb02a8357f1b41f8eb72080bfb500e717161c886b6f04f8b4ce0c0b511c36cf549f6c08334191003109fa6ab20d37aca2633aba519feecc3ae8f4a212c1f7d6577a1683a9d1e46e688f22741a3537791afa211c2eee15fb820599aeddbd6021f20b3b775ab42523c95e2bb69d825b11a37281bc3aa6d986336144caf78242bef1db07c713a114bf7e85d48ce4d01e8d317a0bdcdb28f07785c9278402587e4e961cdd0f679e57b49109f9fba527b41a1bc87f11fe0c147a31fa4211fe292ef49ec8ee7438e1e3828e7185bdd48c87ba6cdb336f21224c21ea70718786c90c0f0ca9e969166ffc16cce76fbb74e9488cb0956d648ee771a3e991f58ef185cbb7582d6061ee5605f7019c12aed6bf24326a4e48826468f7747818e7def16fdb8931a1b28ef4c4a6b0db8df149482bab5c482c9dcd541fa462061cf5a46b3092f093d3f7a14b032d318cffca0e158ad4d4d5f6de84cae7abe69c510d79c781717aa47947c561eecff49115273ce6c92528a13f540600e0d42aebe71d4ddcda8b3801d8c6582a202977fd9085cde6100c1baf4ff647062950e62e8790a25a27000ac6675f6f3c9c093422cb7782b6558400859540ae52777cf02a65c36ebe0b01ca637668536f1254c72195871c07fc5519e7dab986075a1e87464152c8631fc7ffa5b45fa4fe87071da8d3e4274890c227ef1aa0548eae7fc40b7cc91ac0625aaf1b6456797c2689d83ae7b5d498dd2899615046ac8fb3c5b80fd723b62a4d147613f79364c83af8f20a9077aa75c5b0221d8010442da842a17ec6e408814dfe6da5fc9b630ec1c6262616077f6277d142d3d89d8add4a13f5b36e8927e2cd5ca12e85710ac191dd2b6f7226e0bd5fa53d9e60e9dccc2c5ef8573b774ea182638766c7306b252efaba71ad0a8fec9ebf2668627471b656575df172342c31df97dd83ccc23b8691a849e92c238d68bd9e129e5cbe8725be68c297f622efeed02bf3efcbf557ea1436d8b90c94e006b7b66c331c37163bbb1dea49a680f674e2fe3f6b7b4becc00247049240d76cee8e84bc23fb63acb12308fd3250f74ac2b076832f6c978982ff1478be95d5dba7e1c2af9c4eb681ec683e6a478c5f748b887ccc929f388d23496e46819677d67ec4dc0f52694d9a70da1d0c3b41e50179a944f1a5d00aedf8d264e5289f5315c8cc592ac9af823af31da34d03d9e1381197102866bfd5df7b5162ce8548ab05dc8630a40203022949aec419e9a47ac2bbce9ea5893a81677e75cdaacfadf2481da422f2bbe30518b4c8223f8232f0eb82a7505c6290cc27026dc47b6d0859c608bec95107b4aaccbcedc7bf089bb9b6184b8b180a33c724de94c056403f7299d7c86a0a69a16f09f5bf63231fb54dd3306c016d45adbf3f2b60fd384fbf7164fee5e09f00d3178f9a92c96b77ac41539be611152fbf6abc14fd3e9acc3f41c6473986acebba87a10c7bb6eaa8330eff62617e7da56dfb40d3cff9fadaf7224f900e4f6e718c9c79c384b8fe7c13d6403fa40650fb10035274ebb2806cedbd6be1bbba18a72f8ce057eb57df1420dc5f959180df9d935de54aa986322c5d1a21f28b42a9802fbdd578a9e05f8b0a329182e015f1695e372333181a156eb22ef0fc0cd088696496e0b7e270f76b96a60195f7ad8e08ba8abd32e61e848971157f87123f7f82d423163a9b3d10d7cffd2df7ca14676a948d03a0a98ef149bc6bad9502caa896b89ac7546d196938961579d622a5bc68ba81a4822fc1066e710254be018e8f829f01e2a5717f5351209fe3c671e7edcf26afc2dbfde0141a33b89161383a4876bd6e8a852399420eb1a66154037339a92204629ee9cb76a98816ea233bf1d72185a30cdd65253a6c4bd8dcd3cd0f94b0bfa42f1b68377260628ebfd3f5d17e7b64d917cc1fcbc30fb9072848e371f2e90b1cb370ccf2974c6a9a7a59b85b116e6851f142f4369f806c7e14c4c532eb3cf03e0fb4289da809a991a79f09c755866a187f5c62d957b532fa4e3a0691c666ed82d35b1eb2e57958adb569e07ea5ffcd436dd6ff0158de550d3b8be5f6ee1f821a2d9ae4b5de1e0341ca0ef21bf2819ca9ceabe9ef05df5e9c419cdbc187dd65fb827a5b7af4acb7d9723a4a78064de5faa53648bc65b17e89837972bacacaaf82217a800fc1be95a2706bf88c0425bd38d1e38ea9f37463a9eff406bb5342db08412f5a2ee15b2d8a8cf53495ba32cd2ff5ea075994695942036bffda93dc22c7bce18623922322f725ca668acdf293b46fdde13eee8bc5bc00d41f0f2d90c898c77ba00d35dee8eacddd826e2fece2d3c4f9a30251a24bba5fb4ff22aa257b76934290ea54c3d7aae3f82986a06ee74629207ace4b5ccf65ee5351ef571e2a2342e3b64c1601fdb82a58f159445539d7a078d67e476a31fe5b3cf8717c0866b7463eb9d7d2927b95d856dc79a9b10ddd8dd7abb2e4d4e22acf9b1797eea49f388ab73b08cb181005fde564b3610252ef6977026d67fb81c453a73b25e9204db037cd2b18a7568cf4a7d2f5cdbe1c67e74790cec0745e5fd550351016e651f532bfdf448f7b7f0e5a97553f82c0f6367679a1e9837718f0dcdca84f5026b7675cd05e58a46b1c2ba25641339d23a041576dec24a9c439f0a4ec0f191ce619f619a8a3a2527d233f9c9e76785d59a1935d4caac5e2aafd4ad9ccb9f6035d1005f84f620be5244d1768b2756bf8231c7e64012368fc02e7bd2b905cb2ab039fffa0948328df6af923fc911ca1be10456687fe032d08357bac64e236490da335ecd5158334e8a66cf0a2ff06478b251505360d0856322ada5e681b487146cd1ce373a67d598603ead8c8c9c0a2a7158d60c0505f762480fad80561c6ea513027778aae8bdc30ad563dd44d9c5714c0ba16ee6a52e104fdbf16f2586f96f856bd10c6f8950384e2d6639a9aaf2166524a5e3dfd988a448ecbb5e9d7ca3c414da1ac1afbe8fec30cf591e13924be0a66a773ac5acf71f365cb50459ed8f03fd7da161d3e8f835bba42a32fbb4003560b25425c6e86a2a7b515142f59f1dc88090f93db32d3632a18b91b836ca6385096e66b15a16403acfde75f00ccdd2d8a3e1decd1292299fe2c544c250757373f897ae0e0533a4e4c539a60a51cd67c89bad902c47f13257d6b2d95116490854a5d0c6ae8af7a897b009c0dd86cdee9d3080b34137dafbc1f20f7e485c6aee70c8c3918ce4ea229221ab8c384bf9e0648a8f8131522badae13e27848edfa5142c5ef84f7ce6e371be892906be2e59024832d8279fac66f725eb90eed5e92ff50fb01a9950b56ed48887a6af1ee120fda086989da8c0f5c5e60947af2d0fc56498da2210b39dc228f9f7a97d2377ada2528032679941c160f1dbc47940ea767cfb5024e765a00afee53f03143200ccf0f16883dd095d8eed312ccf29ddf530d7166ece067a4a7453fe38ec3d2d575ae63c92a90784c01bbc58c7bc81bc242077ca0f6906d7ed55123726e3df27a2cb1618fbcc089ec18e4ad3f8cd8ef49b525143d8e5a622212e93289be69935ed575a71a8a4236104f56d5bc7891e86fda4a0854d389ce2a50c947e7f9f4e883802cc563967eca68fe61946be81cd85db523cad2adb930292f53a706a48b56ccb488867b77f02a647a82007aa01ba767087d97e3c1dcf2459b37617be315ab151b6674aad207f92bac2a46b1bd7be6c0966ac61a282349b5fede43b0719f80870ccb4f8e722c6d90036c4a8866cc80ae4aa85afd4ccf09b1b87368d00e00f23e922ccafeb9d436a7ecee5673c140606b85591473fff6a092e7e67bdcfc5d6a0d352715f118fca471b54dc9da5567b80c7df9d60718289e1e9f6f5ffb1b1034bb46e4d3b304acabe61ffa36ea0dee2b3c3a6e3747e51e95a94eb26b061df57cfbd8660df7812a8d75e113c10c35e5fe5b203e176973149f6f0f9f3e00e5d2f328c283a76296b2bfca2b72fac485b7f0759e076b5f27a7adcee822ebd68e3f2ee2942cd314fa6291f66375df24ab509f005dbf79b2af9617fc5480f3b539d0c486383e087d986062a177863ddc8e592dc992af677785e6719fe5575b83ee8d85f064eb96dacaf41852878117ac163f5109cdd32053de4699f7f08180dd1ead579506ce9d7cbe1c8a6b6abe718bd73406596cf7659f31cece33cf06b9f972aaf46d7a62c5958d6e534913e76361b329e3bce13d91f948429bcd759dd30c087f740dc3e0bc01020c40d4156894b9d7b3aff1d88b408c143deecdfe41b5b416d8577fe993cac467d0874fec6f679fe21cc676ce6dc247890e8d61deac3270afb0f421bf429955f1e3d31698eb6c644e7ec277a5c11654bb771b7e80f114faaafbae18635660198de98a685c4743221411f2fa525cdbafe841dbc5cc0ea27522f0d743bc99e18b322f9cef7ff74f0576c77d1ff6f50e39f82be7d809d6b5452b9b6ed8dddecbf40b85c519a1c06637e82abbd3dc9c54df52ea74f822e524e47d01442bb72728e3e6f3380e5ce245fd5fa7bc35ba7d56b6d2fed34b07030bd4e47b0b6000619d88975662b832164da4416952f447b05c2ee7afa8f574db60d5238f32c14b5cf4aeb245d7e0d7cd9252d85b162f4f9f25fd777af19597155ff0b429faeaaaf8d31cc717ba0d65493c593a1c2fb65d1014b15b2619c1f123355da837fb8008af76acce88a42c58f374dd99fe8ee143d9568e9249eb9613f184db093159d0485ecb7e40d153d0e8f5f1887b67837ed87388368e05bad97ed0d47a799ac5916f710125dbf40c6c2e7a58a942a0614e08541fca741bc5d8324bed4138df3b7190e3512e8f4110c6a9fb871b1a9952126b6322876350e9bafaad30eeb937c3a19e129d56706f89fe806d358ada2e38e6fc2511237af7ee4c7d47acc860895c91cfaa84e2eee9bcf815f9af4e6549417d728b325c4c56435db4eb7ca542af0522f7493206d6ed4603b7313ba4d0149cbf75847fe583f6d982193600ec2abb8a06cbf13b3674ae2808b3b468f55745dadce441797fa604ca0781803034ca3b1ed66bbd9fe00dd7c138067d7b0a6b34bce3f079ad9605c1ed7977692af3d19c69595994b8db341c328ef22e4065d937cd55dc5275ff30fdc6b86f6803189d0c346e96a25bd40a9fbfad70c27baa614ad0dd8a654133b167af171701ab76fe8ff21750daee763f4eb5b72f1b2e12f281e754d9d6593d92fec6ccd13638a48738773ef3e8e7bc1aae46a2d355e73e58fa0bce067b23d962464064ce5beff39598f5e3f4adc2605109baf2d1b661edef0791c2bbb0b57778f51f28b2827f5c1aaab874fb370c30586b5759ec637ffd2dc9333968e75e1397d14bd8f450b96df813d6637459ae1a22577b2c9b4e626a745f49da18a74ade1d17b9777bd519ad7aeeaaf97a87b316f933427a586811c9fbe64a5c97fa027089f314bee0c0550180d2a0aa4b0b9d9cac7bd4927cd850b7280404bfb7da81637e8395694324258fcaa4a1e4a11ec4b2c0cc306a4f8175cbddb201e08ac8a318aa7555e731406f7f87820230155c063c988558eb9105bd533719d033eff4123c9906badf1739f6273b1c3762c1a76b1dba1ce66effcd6a485808c930a7326a37929a30a80115b61e5cb80cfd5e7cae99a18ea10e0433fbf84195aa20804f26620638ee370a3ce7cbb89363dfd2306f22845907427f3ecfda55c90d59f5015bff0112543a29e4513de5f5f9855a7f7ac4c1e587ed996d9dd0ba4c8f94a70c5f84908b6f7da902803123052e66f50a7721416276448e764e0a4f375f8648a2507023f1469f2a012d9e231ae62513703dc0308986d38b32242d0deada3f33dc574ed65b7ab11c94e95e911dd479a3f19f3d1402d55be79d2cca8192a6d428ebca42ab16329d8db738caebfe27d34f511014e7e33b53ac328a6d301a40abe87985545402e232f38aa58af7e6d43fa58b4b8ba7bc7151a78f9b868e6ed1c593251e36fbfcd0fa0ac992a55956ba0de75941b1ee13d31081496e12280af82bfc260b8769c963fabcdc7a75f013f1d5a549321a2eea1f3f567c422f6023b8d6251ddfcb9a2ba9aee886405e4342ec0fc71b8db6606a7efd48681a75276d93ed7917bce63bb0bac34cd254be2e6bd93563ac24f398cecbafb652530713e4b3ddd9a8ffedcd1de73dd76e8c9673db3ad108b19d9f63cbfd78e654c5f133bced868495ff7f67d38ba95cff03e3fd704075d1884c5c4e6cfca062eafcb3482100e6daa69d842fbe49ff111c187924554cfe04d1f8b60ee27fe050a3683e42965f02f17f32dabfc95092d8f6dcbe9e4d18afa78978aab29d4ce9284cc859ef73ab413b51131fe82dd73115355f796b91ae8f975ff2d8722ff36bae4ff13b2f39fe2732cac801b048e8a694137df601962a44f0dcdf041ce8d8f54524225aa413ce1a94f41e05573787df600b3cc97f2498ed0fcd80e3316454d94064058d44902428416f19e07312488f09501bc04be3c57074d0a26d187a1e9b3bb1d738a79befb0eade661fa7e52764908c430c5f58937197189ad9c76e87ea8491eddf9fe97ff66a0cceea0c7cd38bdc9e421c11b4d84322b716eee3f909aa90f18211314d1183346bc029e1dd3af7752bee3e52c0616b44f098de9a34584be75b381bd02c904d31519ad5bdcbbe0b8e7bd7e5f528911530f584a2107005681a9efe025aa0cd4806da005205a4e4adfbe931f6c4554926501f79e25d81de3c1d572917aec0ebf4cfe23d5e45182314304e481ef9a39eeda84738499c4d87148955ae1a96642b43c22b44b5c0d45f701880425db1f7384a632131468325f969d85eb329784c2269d5225d39a3da8d1c8160abeb25013cf872db20b3391eacfeec7be9565d212757c36ceb6a18d0f9e0df3691650a13f8468231a39862358e57e0e99cba83db5fb5227a154239cf9a47c3a6b73b143b4954caf4333d3aba875c120f6f73515560bb0b4ae4a51487f8f2ad89381f210e5bccb6444763c2349ce9d61965fbccbb1f3e0c07862ee094b4c7c8785ae3cbb0848ade3c5cb8b8e70f1ed3a550f4c9dc634085fc55f49b6686a64f2a4b3e32024038224b8cd84950982722a2fd8154fce160a2c473422dddcb88808bf3640869b38ffab251da70377fe06e5e09d200bf5e9414226dbe48b5dd229416a3c7bfe729496e93302ad856cf0d7abe00780b0a0cde14bd805e4ecdea70077851bfbf84e994c7d8ae570a06d8455c165fd17479710b7d604749b0ec566ba9564a50e85b7e1314e86f94c864f2444023f1cbd315f876641ec38b2d443ac1f2f5cbcbe2301908947a022304446558c67964d4b2419c600a7376b2d2b537cbdb163e78f5e8cb8c2ca485fd67aec187235cc39f3884014e27e2e6bbc7c174cdac3e9b8f2d3b925a73141a193769325121b010d050b1a54e1920979271c15e0557538868924562ac929a3e4c781fcecf30bdd0967eb6fa43354f02e563db39bc0d409d59faf6bd8443d5c762b367e7a4e8980fd2012dd1ef8b45d8ee9f96cd1f2416196b9e6574780815c1cf454c5817f18e38e371bd3cea7a4cb4e57c7920a262fda365cc77161f107f2df381384887c99c04d30672c09b167bfc4c0bd519dc924b7b893eed1fa82374dedca57a84ebd71851e47c9e1212f960fd9ed702a8f297de6222d502da5c70480e4c4568cdca415393e5ce46b644c4a95b0a81bdc8c00d2c9aa713be403cc2fbf37bd0c45c3d25895b6348c1d09749577c4a615f5d95981b512a0a722c8640f8036c5abfda922677ce6224b86f2fce14824378203e20394e5664282decb32695c77db19671dfc48e3f6ff23e4aee135aabf2811e4a37ad2e3dd97ac634176b939ade284d7db8f4c2cc249805747805ed7c5aa052a614f273a6de40f0ccb5911ca91f4a72b142c9d58327438fb6893906dbf8bc1be72cd193e1820af2c7654653139cd9c32cbb682c4498fb4c6ee7f44db5ee5a2cc85f38210d74af8386df7893c453630c5f4705f02851df2b1b206ecfedf6e9ced1299c6ebd4519bf8785c5c6176d43fec5c0c01f25e93d0114b2ac93249838bd1da57cd68b4b3f9ca0ae72013be5f287d17ab8980e2dfeaaa6a135db65c71e35eb1097adac3d83877c62183dd7da92e5a1762d47ddacec928ea43e84f8e04c20d2128107600b0dd12034f76a401b7a047e34706606724d92fcb4ac0e4aff83904cc0eafeb629ae7c9d1e8f3771eaed0e3fcdb81a158b36aac67b4a0d3729bae0645c87817e6217fda4c97cae514e8885b663f7b76577328628e0766b0268703b258e7cccc2cceaf468968e49f7461824f39ff0812d26035d80c62f044b442eee5c3087ec010561ce95f9c99a1b77cde552a2f297dc703b3b4f2d8dcc44f95e088bbc71ef2641600752677f9b33a8f747","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a8fc0af66073dc960a41ccfaf6d73fda"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
