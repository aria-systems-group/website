<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bc16d2837851c7407cfbab2a43f37920f0b421f2971f31b484af1dc0a851a16337c4e317c790e9384c09dd87c6e0fb5aba8ca73ecb472b92cd32365dd992fa9fea0aba51e298c4e057c12b49a34fc4cfee93b7a40b0a00914c5e8366eb22e5dc19d1104f6c520cdab21b1a6a5721df4855ac99e1f4737ecdafc2008ccb0dc92b1bad926e89cccda39382f97d5b8b6d69f0e058c16dc9c7cc573c59ccd1723e0ed36ef2e50baec0e198dc82e5e017be462041aa44a6b04e05f260b1d769011bc6503336d5261e4dfe1a9438a54e5b3c950d51cf9016b1777e4eec3847f1a9aa5065e19bb4903a10555cca1fa8d828ad4151849d7167fc3ebed93e39fc2626b42dc7864dffeaf7fe1e4ddd0c2bec0b28d5ec5aa9f13ab7385cda615cb351f72e15d02c298777acecc7b9342b3d6d15efcdefd857a841afd4eb2c73dff7bce338f1f29788d161f27ad76da99b4e89d644fcac307b080afccf5b778724ef2df6d2b1f3342c98ef34a088cd49fa76f2c6b1ebf2ae88e61e648317c29958ae82999248b4618824ec2b39b9cf7f7f786a9d5387444992426a9aa528b55dc6d6d39f5036f05af322efff23a981c3cc7ae9fc7d48897f32b7744f9b2da0afcfc38812c32679f95e2dd1b64f524884759f10f9199630d75ae6d674a084aea85135728567deaf6247bade04d04c33cc73030217e9e7e9454dcfd508aa569c74f5c9b3b7dae9a7bd88edbc8e467b756403e177916068744c2e0ead6ec1d906dd5b01407386a1d7abb29f63161142c6b276dc03a93f6ed9715daf0a00ff30dbac6fa598a20427fe99894e85b01539fe1c4c96f7646c539fd1dd0bb3e9a070e73cbb3ccb130e7dc4f4a563353e09a204c07a43975f4bc3e2bf33a1c7dfb1be8ba80539f89abb7170f53ec076c339be1b8914a05ed3f9bac6e2c96036df2e007725fc4fcc657c5cbfd5ab7c0bdc29d92d67095feb312bbb28f048cdf7a2ded20689b900f3c56960a12418c6069d0a135e1b9462cfa7414c2d7240dad087bbffc0cefb8dbdc7cb45207f4a7a3a7ebe67c757d8891b09dfd83bb3b98f1393cbec4ac201fabf8a476c12d9b364076b2857ef69e2be2f8633d7ecebe2a99f471891f9e8e2b5725c6bd9427666f23f088b0c4c49071c783fec9a6d8f8852cd8a32ddae06109f92decd017badff81fca49db48c0901362d0f460a8fd6255d47032a773f03b1aae47d4d2faad599e2a9eaca1ffeba58119fdcd6fb672f9b99c40653643fb1eff8f2fc636a8ed677badde927d5342d1cf350b9681ffc0d16a35dec4de9b6d8d159984d612108d24c72a876099e811b56463c3a8c9dc7a03bc2a8814bd98f2f225104f9b98fca1169d72166300cf52e023dd3b7f1b9cfff8b3034121f609d9a23093de9df17f6ea99bc35178c5f6576e2934437fbf28d1edd24da32e369d4ad67f58c9a35e1154dafb121fb2a67f2e9aab635c1aa5a009af62d26b4bff862630da7985daa83bbb699b446540ca9cc65268e68433d7518f4a17a42f610c9261bcb55047fa079e4c59a18267ab9774e9435e08b7107aecff8aca6d7d6cb312212d3367a00d483cae1b2d0166bb45a4599aeb16c70f24d5026db6cb20addd582a30c603feeb5cd500c19701e8d6bfd90fea3ef97db952382e2ae8cfdf5f884b16a6f17562c5d6cd07cc57ff9724e0e781815287a91a5ddf4c0feee0b7a3316655b2e55bcb7c1d04860cb99347003098548e1354d8ae5a442e11e5b7d44c28eebe96bf8588ac64f8ca4bbc34a5bb2b14b10f1c0d5f4e27e1bc7de70bcd063dac645d5a91f8f40c8e46f318b3ddfdaf76e3d4ce4a39153b893acaec28a468400b5df219d3db171edc7a43836d8ad897dd324ba0f0a8905060dbdf5b3cf2fd96c8d334557dca24e730d1229ba7f0d2478f4b5f3f6acd9cd01de5f681fa1df0043cea074e1c665a97f0cb773b146d5ab91eead8107650b73d43c896023e93ec0233855c53885907e2ae9badff3c818a7eab3ed228dbe27c1097f1819e61bd1bb81e991756ea0ebe576adf4dfa191405e94740c895a2b9b646353f33a5620f2bbdb41918d262b97e83a6aca2445218567fbcbbc95c00d376f02b9acad32a19d9538c2d0d1928bb2e154090a4a218aaae95ec1db04021bea6cb77dfe7e7b59b4c75b1d1c370794e53d407a0aa496a485bbc6a35bed5f65ba8a33c2c449e513b62d9d9810439f2b2ec861346cb63fc65e7eff40a0d05e635a89b26b38e8120829e9e1d9b0b2de4a4d260b5eb36a45e6a9a66dec15e2e710cce644d125f70ca4423d005d44c7fecabf10a163d758dc8677661dd6d3b755f15c31bccfb4259ac38d3fb3c17468be64f329ba7ac5b90092180be5b3e95a9bacd1134ced1566cabf817536e842482f8b990aea84ecf09057302c7d698a0209193af4b0471614e63b9bdc5ac93787c8dd2a0f00eadfbca4405fa005453be23ca47a01e041dc9aa35b590a45e47cf12e4d3ec18de71a4052f58621efd3e7416e38f767f66513a5ffa4658ef1ffb2cfa47559232dd4807f1c2d205200e61d6cd1486ef578c5b32783c503b5cfd6f38ee630a78ccf2fada48888b466c21ff49fefefa1997d0e2915caa878c599cbc14af13682d3679fbab0cc9f15598eabf8648a807ee8f5698cdd8c187c7dc975c5625905aa773bf8b39e027c3bda14311189f858436515600647e928e1348050084b181c09f53d4e6659c1db86ddb7f518a5021a94c89b7f4b081e1a9872a32847ae6f6d1617b21f70754b752dda2286dc75f9cdb2f4f2f15aa19f2765125fb8117e4ce45f26bfed35b17f0cf06cebac558c2005f16082e1011b6e9c4257e9abd056d07ae003d965d4a8869fe8a767bee6fb4cafc93761da5fe354fe9981a49cbdd40041bb6d2d79c8625a53284d52da5d6260dd051cc917b05aeb68154549c8dccba76adb38be3efeba1334f4cbcb0215b1bf19a3ed102a0f9eebacce57c41459bcfea80547f11daac94fbc9ca2b6e630d1dfcd5739c73063758c3dd8f9e28a110fabaaee75da8d5725cd9d4805e08ef867528abefebc56831dc56df50c87ae0684c9f0edc87121bf4b36fa7bb67930621105bd144a1d74c913d249967e4699eec9d9b469d4a151d01df798dc6ee1b7c1307b70d42202d21cc27f428c8474ca909e7ea1b11d2d659d1a01d8ff3489ed9ff09a728649a19a05b1f3bca31bed9d782d686d8eed089da34d4ab7645424b70a6b75158c8bd177b4f806a2decc5bc379d8107c3b06ae8e2c9cfe7335b541335de851de408e24011a8e08647d64cf78aa0f5880c6562a7fbdc64aa5ff32878c373c6cab76105f447fdc8861f2bbeaa6dfd0bad73677784e001e62443ae7052be43b4c343fe92404a91116e9452a04995eb2dc9c14302052955d068f9ee2e03f9a62c550e21e9f056a6a0d9a159aba9564bd5a9e3902da1eaecce93e074a9b37768b0e5e3dca5a7dda09ba74a24b7c49e93264ab2af9032b14419a11522f47ec987ae382efa883736755495e2c60268c8df8481de90c735caf6f27ec4e55c87156aa24ada50248065d5e2be05c386917fd2d98798999346468b749674b84fab4b0101c2be84778ebc2cdb1a1bb651cbba14058415b1e274d4347a1b76cc92263f3fdbd74259ccc90445303539dbc76ccd5ba78b10e0db2eb2b1c86278911701578032c305444a86f34217e711fb8c00290de9f0c6e1b7cd741374c2cc44c58a5883c0e9a3cc9b6071984a0ec8b0178b737ca1e436d7c9305b306f8a5daece877556d99bd4b9309111ada698d50678c6a24bce7fc4ec50173286214f9d67f912ebfd7699256d422e71c5776b5639a12236b90ef7ea9b0d3e52fd649d3df023d99d66b5de23b6be0585dc00c71a70f728be5b9c78c3795fd36b7483516d1fa3cad970f641e40a61151c5a2f4d54b4f25e938cf33c106c8fc15a531284102c61d9b59ea848f2a0c453223aa633e89bf38f718108a6cc58e3b1d8631c9ca7ec573121d58d9a49c4f02fcc03083d225f77148159bf0750a7027300232777676c7c718a821e3cf2cc98c4c181985a0941b8eb0fb6451409c78f1d9b65ef24eebf82a68f1404ee8608931c876a422357b167d0381fddc7a33509573a8c1b2300dc7982bd7827182042bac317a3240fca3d06295dba8d871875b2e5f4ff124dcf3bf90324c1baaa584ebeff76fc18139ce2cb151a48a800f1c2621ce37956d1ef01ddb379d45b7270064ff0a1ea6159883fbfee79454795294bb0c909088b788cbd37180bb3765c8b0b2c35a9ee14cd86b2e21148b1c9e500c00447c87ebc483dc6d1d300cef26c0196df19ed3b9373ea54ae5e7e2c57e4cf9e78d47abeab5013bd97bfbb7f2997c0dacdcd280fb5ac7d3a7e226c07cd0c7163b5a52d7ae8942fae8dccfd0c2d1144eef56766f5f0427d6e6eaa5e97d2898d5d6cbc0deeeba17e8a84b8f3138deb44ae072518faa68ca2ae19b252c6b76a69da2c843f488fdae4c026ef8465d31c1205716023cfd0792b5c098eb1d3031c945ae117b942f6162c6157f7a3ec19d733fa1fd0f4dd3c9b63c628f7d4f597d831895ec2e5a9fd73a25affbf167d48491e29f59068c87d7ef925e2e54f6ee7a0a5d9b64c4a59fa86160b841caa74b80f9d216c4ebc57c0f179589327786903e93d9d882140063c9b1af5355500cadd603ae164eb47c14e7d16646bf2a089dc4e2c519f01c65a2ab2a59db0c1517c75eaf6db8d77acde980864cae3fe224ff2f30181475e3364e11bc4bdb7423a89f8b68ff90dd21e65f39daeead10d65d2da57951089c84a6fd68b731caaa2bf14c84e8870841ad389c0ef63b168a212373a520cdccabc27ae6720467eb4691aeae2ec143e846afb3c5763de5f2b70988c97f7db1ecaa852261e77cd9c1816d47bdf97394859839a314c252719c766ac6b233d1a81a9ba29b4bcc25e9550836332c9734e0d5f986af1d0e5b892e636e5d106615c97c8ed421d1fe0f11682522e6e1318fd7dc5f963570064947e08941570bc108d399cbef48401a3d9639af321cd83f70b794818ac49573f7aef94da617a074609eee2c5478b75b86d53f04c3e76f441a8613e29bcb20d33e892b86dc0e979e44366ec86b454c3e5cf0b4d0c499f3e8c7b12ead0fdbb2bfaf3254719a746ed8cd4154905068c72ccc1403865a2da52703f68ff00185ecd3eac73194fe8f5d0ae251939bb87beeaabc92eaac4a4aa5009e33377cd6cf5ddfb1538d3c2836556d624711c1354256acc3423be6e3f35644aa03deb8e2fb01cedca96a89c47d003c3a213b8058d895d141cb81b5f25d4637ea8a34ab60adce513a8657dcea48e0a39d8209f98214d400725e509b16bb4e1e7342cfb4163ade190d77592d6c1c72e68c3da25acf73976788fbe2f725e3367aabc6fb4552f40ef06da5fee83c0bac10f54c75539cad9ee007ae8c370e8aba7b9e6273295c856f15cbca5370c10d0e14aa6090fd2c268d2a7873009a4ec8a208ed56fdbf56d51dcc67259dbe6a549c010b51804c1004a45bdc6ed98bff39a9d5de256bea11ae5d3a095dba4f38c208c7802eccf4995facb10ec68aada05c38775bcc082f807dc37e9ae1317ff0432bee7fd8de03cb48b80a20acbf1a63cc21cb9017754d4a7b51919e75f5de2a4d6d707c2d4e823713edc9c77c11c9cd6c514255fe6be8110faa492d48b1e7f56ebdda5b2512013a3598a760a92b1f9bf5c8c9590f1106cea9f83c069832d2f66f6bab923911c0edaa6e1c198eb1bce8a8e4046e33cc55a36f1bb85ec163e95effc4b09cdd9a5c5306b85a6bff0cd1df1ce38e586416b7857e29f38add9db33d9b26e8d2f6f8498020c45387546d4891cc66fe819f6ca8ff2842abdfe6f3221c1b1b9ffde7c05b4ba97100964ad4e37ed5e3322fb3570e0084ad646d734e7d6f82b16ecb30d3c63181611f1912295825c441c0f1a39b6ca38eaf7f8f5f582c30ca10d794d37e96bc239a64e6edc1d9a7c24b2342fe9c33b610dd02e95d16c848f09879f848e75f0b7b2be5720bb49b1b33005a486601dce01eba413dc280259c514890e3e4866196c312ac655042d8af2e23dd366476375decf6c0a93b10b8ab2202fd84aa95d96ae4af38410d5cb1eb07f4c272cdef69873775de7d34b4f4ccf6a9134cafa9df079c4209418d879249e825978bcdcf81ab8c67349cd05124d0516cef7b3d3251750793ea76340761c0c293741ad976dac67489fc8225ad88acb427933d428a42f5cd0b075d145760374cba40b87ff56e2f39c2018aa0411b9db35cb964ba29e98ea052c6e9268e483699eb3ed6a87e41384cd44c74c6132ae1da021d69adc3ddccd26b20bed8147e322acfa2efc929aa4cc60328eddb6fa9a3dcd62f9f102b71e964b3d5ee8fbd892caaf085f77a4bb0a7cabd5261e2f80ae173341b3bb7619ed50a80848f611bb0ccc457715c47f2ee77d1138792e502cfb59284b39959387812a8c347da56b80087f525826fe78940168b0c08452fbf8593ed8ca95bb98b62cd5f8a9aa7d10997f0f99bfbdd081c3552a10c2f359f403a946ad82bd6b1f0080e8537cde076249e895a11ef40a93f03583cc0be40efacdb13b90576982ce8978ab2880a6f1961546f89b238d04e8031e9d1adc8e092407758984711ba54f1f3a6f22cc4cc6065dd5676d6af294d3149c486aeb3bbb638e43b81abbd2729fbaa09e776f25fd9c60256e4f02817b1594901747755357d6a424c447b242bf3a998e343303e6d734d61eaaaaf57957b3c1e0e89438c522f8c636c8079653e981f8306cc4cdb215f17d7506bb199170e05bebb5692cf316a7cac3545d228dcceb7d2b8f5f998cf64061250b14815db89e5dc37b14bbbbd32999396b8dea12ede0b7b0b6a8a44c67d278df6fb441ce54106f0fb2c7a3cff04448b9e7867407c3dabaee6110dd28bd617a234b58bb6d3f461ff32a120bcd99e52577ee25478718d81695c51816642187850a2e42935a76647c10c2a684258712d1351176abe4b36be67cd3cba033b0348cdf4fd47c1d78d054bc8369325536d4e2ae4949197b209d3e8eb87a60454c4ba01fcbe028b9148c8f762fe7a56f2c8b6f6cbf8779816161ecb0c3d9d4d097ca35d129a4fe5bb8e214db852b621a43dfcb4a9030459d7f00a61f1483c1bf507f281b874c167bd97f8317f932e7a7e6734fe1239afeaa7546cff9a190669086ef6aaa42d68ab671b8f29f1bee984155c691730755cb2f1a88a94c569a9685c8f5f5604008d88702cd35eacb423870a4ae32a52a15d65d79202938dffac05f93095da3e36a5cb464f8a74b7544c6c5ce90bf3cbfa61718d77a3f8c15d94bb0c048d809f5adfb864546f632b57c0d2983114b00759b8f5b00d877a0fc987a37258a86d48350f6677b066fa5fffd6e2be4b739a4cfabf2f950b6d7bae04e201fc48f682399c077cc61e2e8cafae21cab9ba4cc55c700a22686542c66b77297011e90ce86e656c8129f29050719d08c00189c14899133e425b8e00285a3675de5034c5ae54a0673256cd1d85f3ca37db68acbfca59733370a229aec68b3ecb35267c1e5ad37b2fe7b5691e325009b1d54ea3bc32efc90c04219e2d404e21dfced9a54ad4bd3224eb48e43df18f0d0a3511dd4dbd2133db5f5f1a5ffed71c496d4fb1a12ab6d701fd466ca709c2e834de94a95c397201c2c803ae4c65f48f3e7e3037f1a9ddc7386eb6b24e6d78ad47f776212802ab8d1c40aa7d45e1383949098527595fec062879430002ad222459467fbf028562dc574a1672e79b924045fb5b2cd0ad6fca25984f97f10f6f40da5f22a9ef53bac67e6b7087203153cd2a3bab1295af80e4c1c969ad1194309ea99d4ce3a1d61c466c5a42d0829805b7a1f00184b35b4e11cf1bc9a6e667543d3978312f47e0eb3a9e7f247189c697886f48492b341c3ee1182d8e5cde87645538767c10aa6b7336b19245cdbf7efa4d339ccb79961a0b3963c28945bc4eb2c64987872ef9cba36f88075f82582df1646dcf7b96ea80a9feac88e825337643843c12734e362dc8f8322c6351e47efac04f8f6cba956f66b9215033ac6eb07c23cb808f8a84f0094b511595e44ac4d0e51cf1f25162dfcc022e1bcb0c26697bea5d853f4467c1696c5cfaa739f09fe6629019be529614b68878740de073ab0b6d003acd098332401b9cf2fa264b2e4353b3dd189e363b4cdedf17527fee82ac5eb6a7c2d8bbf0b0702672dc47c2c2ac3ce85129d92030592b0ce468780a1f11725d16251556284e64825deda60a3c6432064dfaf30948a7bde2e372366193790304dc43de68d8387283e98e8e0f5c53bb3f7975ff6be59b5e539a7eb839dd4417d0639b597f0d32e71f6ab15d51a536b30240e150550cc0bf911d7069977774da281a85cebc4d32ba9cc6536cf1afe483ca248e7d2fcd88eb4ce0b280a53b36c6bad224341747f7e73696ae791992c28fafaddd5a23ebc6a407de686e92f46835fd468736370adfa596a336b4cd08553b16ddef790ec3f5ea141333f5076077598faddd1c756d817e24c28469f7f18d46a1e1fa3545453075e5144c6abcb750b31be9282d7030eda61266761c4a2f28df2b98e72a12295b9550153370ca74b77149476e9c0147a8ee05feeb436b6294ed7e5bc30050c9bf156ea6d963d716c3bdae0ee57c5ada04a023ad41092c4f9f0a2ee35859b32ceb079de55d9f2ccdd813e1ff44c59be84906f6074b83e617ee2d4727d3d43d41df8dcd498def9dac871142ada7f0f5b1e3b73ec54077cdfa217cd7cfd73a0cdd9c9e1fbecd0f41fdd5efcda4775ebc1fc688e6fe20bc6509c62b39970a52d20f42eebb4dbc1b6f21b8ca56652db04d3c8823e68680cee9c6f9daed193ba348b5e25f56f35220b82eed3f8f32dbcadb457f5621a9309768643498c65ea78840ea2b64c327dac2b1782cb7b7a5e925fc3acde6e029c38fc1f602e24e9faf7df2f6ce6a995da16f69f9d6346e9d571e8e6d7e89dee0dd5954d9d8448da7dad28d3a5cbb6cb016e366ec2a0eadcbb38673f82c1258c43a4fa12254f1a39d8c68521c65bd4fff4597a24a626f4a9f77ef9cd2cf28510163906657fe6c6177e0c036ce9cc4a553dd78ba53903ba19671b3ae1fa8fa6a28d23a922402f4b5ceea90136631327706142997d653f7b02c5b598c06ae4479b25dd2c689cf808ce5849fdbe2efc969de0aa0f769dac4363a2f8680731a177d895abccd9d77c93e8c25d8f289b5ea2dcf12131552d328486308a247f4d71b60d27b454c991f3ab5c7e1de8559f19956f5c3e80cd0fded0e6178bac8796038db28802d8069a63bee497c1ff6e2370919dc954b0104e2fd7537b68079390fb078b5da7a79659c88d46d3936097d16c7ecdbdde40d0b90c971c52c3186de06aa574a6542e9ded335d4c180c538984b78dded5dffac217dccc6db3c0ada3ec31453bfefb61549d22b5e19cdabe5283a1a227835f5aac243f3f45f38fe24cee9bc73f3f53c637776aa9e11dd95affa9c7e13baa1e2b0e236f13a0c2707e3181c7f55008103484fc5241135a50a3b1f2d1d5aba12995e5d488ea673b6f7d972b75215c0c3575db87841d92da6624ce4d743dd9c9d11e359aa5d4fe2204be27042d89a1948e343eb6703186c3e4c81c4bf51289f16f9c45c0dae837ef40ac7fe9bce8e29157648f6d0df1e7fbcb1117544b1382ad907a0b21ca28c56802d61af17d482acc104626560987e88ab65efe571a09e314f6ee0da17e66ed6fc66b6506964226ff38cdbb2f7d39fbb15aa95d5f613a545d6c72eacb79fcb2229d9e1df2978243a171ed75f48e9ad4d5b761649f822978dfc6d1d311795289afb5f7fa04d25e689af126663e1a942db22b0e42e25a230f01f7a9fbd50702d50cc2159c23dc7609706c6acbd8a78191f2b872137f3b6f4ee43cdf1fb56516465583d3a5d491c5c103af4569509bf2535384748c2b9213162268cc2b2f329b831a2d5411152144a9bdb45c290b875df0027fb5263183212a2e688f579879bd501cfd482791ed4d29f2dfb9f1f784dcd0c32c26051ce7a523d9871a1dd1d550b8c7d1a55807afcd114c397f6d14eb36a5ba68445488189a5d469428b8877451e76111698b4061c02725dd9819fd144dcddc29c098222b4613eac5f6dd9a6d10797978c694f4de7a680f758ee82c2820847c5841397c9aa44c495d2ff3153c8865dffd8f09cd10303f20437879c6703fee624727c3ba0c4ea81de99f2342b7692393b37c2ce2da0d2860ef0ad1aee984d8b40b21b5ac6d40a55ace99e9fc38c86522ac01c44d21731c09a7b88a8af6ecc58432b632b6d64506793203ea31454f6d4adddcb4cfe87cc09db91335f300fa2f0a227d1a75880cec0a14615a92ca16d9a920091d638bf703e084c070cf03d02b6b93d5cb6927444799a0f3804a1e7d7facfd67ff714d970c8e257f1dd700e0799eae77b3a58c84039122dbb9328db993834222382f20545b594eca2e1bafd383e6edd3162b752d09e212d9b2b64d07feda90984aec185e11392825fc9364d3e9665f39db20dd6ebf2008017dcbe77a72b845ca84adddc40ebb18cd1d01bf2f7952df890001adabd1494ae4748743294dd40180d7d59c930e21104dd6784163f2899b34b809abbf468a48133c2b79c8ff9f07d4f90364f237c52001131736f9a23a9198704c5e77bd4a5709b260bbc9600fa2bf09088bd2540202650bc20c86771db5dd796196ccc818c160aa33076d16658fd3d4230bb270fa5b50c4bf5ec2772265d0e5f21859930b697b752409f8de1e8d400c9e8315dac7447a839de3d31a07d6927f1cfcebcbd4b3a9b7185e860abaf0d75d4e823e91f79f12c975df1db3114dbade47912f97c3649bd81ea8199bca38fba664bd5c42c78e2d5581dd39caff3b2d429aab113355fead2d518ef8f3fe24391b21f91a15dea0e13153131849b3df8a45190bd8a01df8331f7e28eff6806014bd19ee60a5734dedf43ea30c80f7ae9190cfa31b8ec1e0212cb3cbaffff43aca505d2bc56f0b37bcef23798558ed7eb07fc527bcd829cc5df9a80d4754011564b28932ac8b86ca2ac91c2aeac2383bc7c65b5e394fe6b122295625fefa2209dc49921989600ede5283448705e9d92168ca5fe7e66e326e7055d671467434af2f82230efa840f1880531b53ce3a0b8c44eb316dad4111ed714ffadfc00415d5877ba055abc9414dda3093d50d67f4db7b4b333a9de05cec9795e9a715b607bd285f081b8d82ba13e0842cd439ef11320e94e79124c30964e885a62350979b2765d40631da30a3544c856df30f57c3434c129128163c45a6b250404e54f938cff7f323cc48dfade1eae8e6e3c05a2f0623c11188737fae97d93647c714386283ccd2817f1d52f414f8dd69e0bb4c045c0c27a182468f34290e2526137ee8601481f67a2bc39974efa81e79b974d110c3f1aa4018520173676dc23644e7eea4055bf7ef4160f4fe6432742955acc10566e9ea3bf2704d1013c4f43895376527ed616d78f449725d13fcbf4454b03bc532954771f9266770ef4ebbe9b7a864a368028abedff03a16f9f77a146dda723adaf7c0d78bf3fd69668ef0007f4e552050e5758bcdbbd305658f66a94b440676a5a51436c553a73f7b24027c5603c6c6003d5887bfecd00b3629ee9be6aae8c8500b75c77ef38c36f8b74f4bc973f2aaab28f5c6b1fff30ff5154ef4db8ab27bce58c3e56b5183d0db16e1b40d7979d0f79dddef34b9ca129ea44045a0ab6913e2e3f28b55fa6204676bf0a1ef4c7fcfe3b50f64fa3910938a896b9191e8d133f1e15b4bcaba4c7ac1ef3cef5d76cec85cd7c62490d56d4b300e1f29ffcb2e870f64198a98584d2b22dae96a55f4f59f5fb0d52874e12d2b82f1f45d7beeaad4d41f2c5f926897f934ae0e80cec478fa0d8443f719ab80a45da98a0c047b9f57f90c881db6972e832522f0799a0cfa5a7026a2c1648415fe91f1b1dca7eda4dd1062f5e66e3c1f1a96ff29270272b3e7d232748a0ab397bd2c60fdcdb68c9ba148491569e12a6cade86627b4623c93da66fee7e86b41a494e41dff6c0d0681370cefe9d3480f6dcce7ac70615bae068aebe42e688def7597a1d508ccd0d535c26661748b766c51663e384936645287fc8ce987d81140d2aee6b82598f1ff97900af897540d12a9c0d9113cf1a350f1b8369e4b62edbcf9d9862562fdb4d1f3f9d456b935507e37c4050ec2bd3df7749854a3c0fb69c78c8811c2c92fc0a50d7dd641ef6ad14835017758fa3a4c013fd6d7e06594a2ee3cd90fb7672ef09c649ef190d4a1d3dfa8f5638cb5a65de7994cd0f5c54b3e982009409f13e2c9d456eda37c5b741614c25f0053a41d815bae6f70264a9056043437c0a63570302ab2b2f12006628c9d8d95a7a8ecfb55d42ffa90ef6ca8ca0445877a5596ca8b582194d7948ca63dfe75fd6a078691ed52d15e1a57fef5e86dc4ef067333434023f5cd353cab139886c5cdf7337f99dda9ddaa278e39c4e7b72f080c0e57f4841d909951842f83e2dcbae399e8d18985423b465580a50856727b9919055ebd63ed3210869b9528ff86f90bca7661c91f8b67d25138e4598a71c7fad48be2840d1a1148e6a799c746ce7856cfc5dcecbe472626c0236d230ae2610050f1eff43006b10e67aaaac7f08b0c650f4b99f7b484f129a435675e989f335200deed64e7331ca61d09ea7e1257d2bff84e50bf91c4eb6c5069cbb93b57bf953de5ab47f296d72f3aaec738810dd2184d32fb9f34c88c0e71aba19d92997d275e5825d00490a9b7b703df4e81aaaab0bce169639c5afa6ab85a05c2b5a5a960a1a0befe3f9c4747cdca4899e49cbdd2932c7db5a883a3429815bba51528a6a67e399cfef3a2baf301cadc175730f11f2bdcf2b27a7b42af53dd5eb78137af2052547587d02a817cc4a20ccc5a998a305ed959e3eded3296af84e02cf686e6f845e0f5c6bd4bbd7ac3c5089bbb80ad752aff8484f849ffb577b0c28d626582d97c64e36bbf3bc5f816e25c1c1d4a2be95329961438a9f7801f7f9d472d7ef1721c9a1844765dd6b4f3b6d79bf32d9f0a83a557e050e33a9832c98c949af00dd8f2abadd8b172a96517b5ff5c3fcf9500ef2630bedbd8c06202f5376884dfc3f83f446b057d950d0f2ae274699dfed8fccc77aba74ffdb26d551e734b059ae953040082a9e77d586e0810682f580f979407d938486c955d62e9c84a81d834584342012446bf3b65893cca9c3e1d21118615f384789f82f919edb6268ca63acb7f1c5e5507c3d1717f8dc105f88ddd78ab4a44b02f9dde0fa10e6c8a14b486e2b9558be290475c3d7265cce311b9821e5717f77d8be0bc5fc6d97d6ec1e3145c256028297450260e14c64cdcb620623a68f6cede90465c65512820aba4f8450d84b9d0d4aae594104d61367e535bbd410b319932bf1cb1bb273669bfa2a6971053db53cdc15a36e11a521ecb09615d597dbb184da91616fee57fd1a81e81d8e51294d8d200e531bf276ebc09244b5ffd2058346bcf433836d0e47f5c1f5acec35e15e4d68fc08b13a326a57675d3e7c1c8f4b8c61de40eed4f124cf0f9f9e9155ba97db8c9e768aaec46b3f86310b60a104356be8c3dcfc1bab08b0b4b9fa9714b6e23f74512d5d3b935602f75307692ed80b78038f337adb367d42f8027eded8c757cea547d63963ba65fa5f9285b703fa5318650d341904bd480c70dde86e18025799e356ed375e8e4b53b02be425b26cc497d6f2dac7865f25c337c45209f97263f8a1b355a1a695bb50a3737a9cffa032ac71619f277d11217d576934056dca3c5c0784b56861735caed30a70c1f5733ba8d835e81b0e51fdf71468a1318c0081a6c67fdf647a2ebba1f86c26cab1eb97a89f4782c71e2c9310ed62e581daa1050ac6c5d732ad37ba49a99023e4578caa099c66987c6641213950619cff1101aa7c84f2816c486d539ec9b21ecede2ffe6785c6fdbb64242469608ed6c339067e50c1040228b004e5a15eea6b0afb7af5b6b7b16e62644edc458efc5678a32c0bcda9074ec574507b616934a3007920cff9a78e6dfbce6dfac3579126907e304e7cf16d801e8a31c01f11917fc00a21786d25cae215db8d18551f597413634c598f8dc6f303f539ca69fad25ba682743a0c5e0609ff955b66a65abfd505ee20a050e9dfa6f5aa7ee3071a2977a7484eb50cc6c71d7c48baca5e4ce40682690e8065683dd159f0236fbd520e0796d386fd013e2c6f702816474ee3303c3493a202426ca1904c65b627c452618e4523c05ef1cfabf0d79ccfa8462b8310e461586c1546ab9c2407027961cd13c53ac42e5e97943bd414e42bce3bce397cdb0204e725919d4ab8631f492f586fa76d38481fe9680eabb3404ed230a6af5688b8c59c03b49f8a2b538df6767d35ca63f71b6ef459badf7827604973abc07773315fcc94315723dfdca4107ee1944b3dca386b127b0fa47473811003377bafdaeffb8ac1121a1d470686960504934f5a719d36ba6df439ac7b32cc379cb059e9495e276273dd1f9aba00787289a92b8519de164475357637383e5c35fd7fd35d3e72e2d8cf7b2877b3ffa14396843052837d0788a9abc430bd9d6a9f6873b1e333b6de56413e6608058f23a255c3f1da9e56ad6840ca2a5098f40802269fe5b23d2e5d01b5314ca46fea90b39e204b996096280eea51f98a80d6fd7626e7d9103a1625b8f50a79141737e955a501810ca72376280a3a22eed996adbdd42069e47a0771c39c2739c221104c7d3afb2ca9ddfdabf23c192334a3795f45a524ea56559e7d301b6e0866168860bfd901ab20c3873bef8138800116a0527805965c4158a76a7a20b58c379f4a345194f0ec865c8058dbafdbc501a2edbb52ac5050d2a1a90807afcbeb188f7175f0ff1ab440256b494790d563b8578a2ed4767fe073633e96cc6ca4b148a451c7722cb8c83fc79cc17d1821cf3a08c5e5cf826a67fc991ccd5374479cb828dfab8b5f04f4fea4358305683c154f51a37d7f63b7b0288e37b995ad8b873717c4f2123763e2e01a6e27004857475f18fe80c28fbb29023bb96af4d736bfdb8aab47c8f13ce662810f094c8f3db9099709f6c92f7bf29943a938c539d08d87502e647e1960fb02a99b1ac6ba4bfce1d6e2848098cf4d032173a98c80ceef64a83d40f599021afeb3bddd84a236fb88fc5a44f88015a65d51c47c21a24ccec3088668f667ee5148a63e7694a79651a13a57cbeb6ca9cbdf6998f534e2d4cfc9797b226ca3d0e8543010224a08d6f0aaa770e8f350a44e644acb61ea7e84a2234d392ac26a13d16e8ee2bf3a230af7a7887bc74b0e6c950e146e5ba5a6ecdf0bbc20e408c2f24d113d5a20daac0de63c8151f2d70095a30e2dfc3e08c0f566d051f20cfdd5bf8fc00d2a227fb1fd639527bff11f82eedb602585f732e2e5bb93fc9ef587ce8c76bd6cb59b4d26a2471518f181e8f0ac1c7d49a9fccc857f01bf915f20586b104780363f17e82bd9de6ad4b857cf8a095521dd765e0d32e50d21af988171dae051bf23603ccb45791b2d3e3dac2adc2c68403b2eca23215a7c6e7fa5d25e9ce9ff7ef22dcd6f190ccd2e87f13836947dd488afa0c629e8f760e00c2871b84a35f126bb0be5dc8339b4ec82576c2689ad347ac7f8031fb3981fc8987d81780311f9fb0685f2d58e6e12992c74e4f1fd7be86b3b993b9954a8b87fd75b261d55e14d38f0ed4f18d51bb3725c2bb0f2884581fd6b84c609cd9a8dad3f21d04de64697b0699b009267a5c904be9920bc590dff01e6defcc02ca301a54ea2784605c7743805b717f1b93a999d95a254de6a000c375663580a412f18f8812e54cd439cc8b7401f500b0a05b3640301a59e88780c3bf1e260c0a7652d73d03b6487375b204bf1943187034f328b12ad399a3744011d662fbe12ddfb9aa11f66090a32c0f224633f4e190ba6b93481e2ca968dd7f849fdbd731588a5931ccf4b9205f117c3afec8a8ed2d31406297a4fad9a3b4c8f6fd8c0ff80b72ae793f6883af137c444dee7fffcd48bb6c62d5d00a2ff89eb83b05091f0329a74f451c4d3227c8d00c67a6a6e68101b6876ca85f206a54d8a41bf748b616c06f9bdf70d97399cdcaae161534f59aa7a9151a746f1f0cb73d1566d17e6821ad5123d10a19229031a273d504a2ec7ff744c9a05876fb3c806f3bd6b4a41fcafd21321aeb5bc19e369515a583add99cd774d7677afa4c949b91912f8150b2549511758ab7547f570c8617383e00d6981632d45b10ae3cf9dc514f59ff4a1746d7e78cf1887d47f34f1c9594113639dd93392663bbf1552d08f60c5d3ac90a893ed36bc462e1bdeb3df6f6366280d3e42d09d644c9c1f7bb46c3d99adefeccafccf37c4d30786c625448d598b5724fb18dba9ad73f44785545702785b421fdc5e5f33a1ffb7a7c6f246a7f8b6f8bae2ecb7fa21ea18baccde15083e3a610aca868f21c0aaf759621c8c36353a72faeb7a1ba6fde57a90f7909469152a2fabb5c35dd239f81d81defdbe7f6a29e8f7fcb595e1d8996c47be1bc00f9ed40b35430e1931c430de9a51e6722326d611f476527cca1725a04c64f618bc4768f4dae9652ff39a1bf113f85e79eb46ff09fcf761fa5af8c4f3d17eabdbcfbb873a13c9647268141ce700b0cbab8f0ac4c4fa0f9e1bf42f833f47d62d05e5cb7a556986c45f0e007c3236d99c78d606fc97c8750311d5201f84162be9e0ecd3f7e01be0d6ac3cd25ff0d841b3d950e00d5420d0d72f7b30802325e9cbefbd8a29523973584294b371873830caea7aeecfd77ff1316333a7550abb9d9e85c095b1e38023e06ab612d0357bd3f4ed0727827b8076d4e3085daa93a16f0175840969d2d6ff8d534e9bd2c33d80d2d9f2b4d12f67dc6f164ee305aea898311b9ba6e28471fa681607e733e026a0fdbc8b892f3df1d7f4c0da10d7e3f2c2007d4f9def014379cf78d297dadadb9673e48446726f054a26817f3836c57eaebfb1e959ab029c6f1817aa45ca0a7d5322472f786966b76b0a926a929bb38890f47c8ed6b588e99f9d4e4b9da637d125ffc23c44e5618d9443794b96d03611096603e066ffab7d0576c7cfb375a46c30851034ffc7303721f1bf7d69815ce6760f4c9767818eef4e6a2dbdb9c60af5e9111870b9546a545a9da8fb5cda751f65ad1d26943c6b60538d246e538262563a25c43e6eed64f89ed70d71268958eafe3055a349ecac5b8e0b3aa706e871e3a98d89597807203410f4c0027146bde5513fd9145aae784a1b8b511c9de242ef14ab5f8873c31e00f07e5fabea27f2945daa286a8dabbd333415ad7405092054c32d44ff33ae39866dc499f994311230b0850db371837a1482a8cb0ee254418e5bd90f1f865247ef37ec3eae462f5993be847cdeda5ded1aba3ff9b11f001af18f18ea801ecbf738a1722151b09cde1adb51ad1d17401f27325d2cb60d314334ac3319d7fc15ed10d5326d23e026cfacaaba0d805047851e092cc381560147b08a7e7b13d66e6b15164e7e15292c5c3228c73382ded9c22f15c513bc11118bc39c6a20c557bde66b3f99d5362d91fab7d22e5ec54197073d3c4f50c8109daffb883d2ce7e572feb8b855d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"28aee35dc7406c962fee2e7f83674993"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
