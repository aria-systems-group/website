<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d25a33b7070c2f7a485a1b2ed214948cd83d5a4819ed9e11ae47f5712ba588e12a779be4cd0efb7151eec7d06c23da798d891dea585e835054de682d7e0a524b96e4a5232102bfb444af8d659bbdbc7e84ad777ffcdbb152a859c6190c3f0e2b7f1977b4d3ecd6f2386168e94bc11dd8000a99820a1da68b57701b739e6c245fc88b8bd91e136482d0125fecd604e5f35ecdedfc1135b027e665fb336f9ee0ad49f48774fd3e499f80a4c617aa39a55a6e10683e3e6310a2251d97bb710af9a18f78f9d986d1379e7f9e72e4a42ce9286476ff36643ec0c5ef05e401b68edf5fafc9f607a3884397d65512f652308052d6ac676760b88aaa78a9111a7045898443f79c24b143c01530fce95011221cad05b9897a991ab193fed3ede5da59f1ca6ef1b3e40c7447f8e3705f2180e77438f6736a9bed24933884272458925f552837edb269e632fbe12bd01b8bd981ad7e895acc15d3b85a78afe096f219cf471f63c7209078338f7835cd8c4acbb1ab8975c0ebe20d42667bf804defa804823bc16408c1af53935e6549d7bbbc566b4191868349ff8c653c6cc62416e5b67009e96f21a3b3abfb21c337c6be424199f558b3cf2bebde740149a083554099fc23647c3f9cdbe2b3e14eda65038abb5e36d947ccb1094fe690c18796bce79e364d8b8e3e721721d44c082c3a4a4c98f5acd1b46ec7cab1046ca5fa642e4ea5839665d3f9cdde894e1e31e3bb772bef6b74ef9e407cdd83b3887238ca0ebe03a87b35e7fdfb064fe6ae2822649b28d579f95a2c95636a921850237482d2f952fd9d9482400345cf8260787d79dbd1ea923293ec9c13ef7166d633dabb9be5df48de48b4b44f3bab3b77b2d19e69de36fbc10b7d270de25800855e04a42873dd97d6a73a197230066162819c2e2566fbfdf108ca5ded1d9f17edee1435c821cfaf51a6518e8f07c8749c515a98515c834cb4d1ffdcf4d5fe49294757d005a5effa422a18ac2af73025eb23fdf6e8e82b01e95d92e17fe6927e99f1ba952e68eb7385cab944bf69288677bbcd351b663c7f5c3fb942cf62f5885abd708793ba80d83a2c658c5074f6e49314d25e44e55847c630d940944504c8645ae2286b640e861e8234727b53d5081711b547440407ddb742fe7b93f003a94f2519ad6b5d9560ff2d25e2e0465860eb9c47630e562215aa4c98303762f000c17a6f3b8fed0edcd328ae5a1d3530d3f122d76eb4d717b80b2bae2251f23e29da15b3ea59c61a93a5e8055902b2e741929ad9dbc5d506b598d8aa1db26562c7bcd0afbe4bc7d035c596aa2c11b7009fede0ebf759b10a851beaa7aada219b8eefa84dbc52e4f641ce1ce252745956683ca080d4e8ddd848e628d8098b6e6bc9b8998348b4849898dd15260ab66d5df656b3e6ad00ea4163fd2a3077c9e7065d044455aa63a5b80e2f8e0cb09e6ed4b8bbda0a39d70bad6c3d13f06f97ab258b9ccd458817727d2f8f53a7df4e41cb73c4bd80d08a08c20288fcbaed322cca1d49be1f513a2300b3a5d9dda57bf47f4550396f5be34f392a2c8b5c25dfb89cd6cf60220ac49192859fa0131c39a9ebc5e2ed8effa0b37c9c0015dd802f50708cd79813623a9e5ef09dd71364a590282e6005a829e51c571c746d21de45cde14d2a51bba29a68670b8e3f639b5691535f836cff04da699d7b52878ea5126ce8a7d2682ed7ebfb05a25182eb1c255ed0b15c752efa6d20cbf07ce28511ae1450fddfdc0acc210fb716fbcb178579f7655ad567b52fc49fa558dc4ea9c84eef9f63a25938e111c71caabb2c046405591e8c3b81f3c6455469abac225690e03fefc07ca9fbc8e2c58d832a7f4e19d391c04b5546383ead9379dbbc89c36c81c75def9ba11e2d8cb564278c773302f3e27e0faec609b2ad298bd9a7569b2ef48eb731cae54256bee594e05a62cd69a9f98c54db42823ac6c9071d29f8d87512037cdfad3318bae8d45e966f60f71d4f745af5adbbbb8271bb4ce185596fa306976d4881600ef6fc7c49be1cd72ddb00864519a29ef98d8ca211735bcfc512985b04a9e5a9f7e51fa23d634f815edf03692298f67c07b6fc9377fcfd805967b1535777767f7e5c8c040eb7d8b83ffbf6a4608f807778089dc2abb0d38b46d7d6b7b95a045b385aa78c79a9e7b7a4e7f63d53ba3e4a74d5b8f020e4a6d2f9ddc1889db6a1b9b360ce66551148ed383d9237af2a39b005c784a7b774234ec4b8a362c10b1962683489135360a1f4d20913f502446236420d1097437069f23b01315b2b97e2ca1d02e7ac0acddd19989ae263e7688411f8da08163e40d996e6e392fa32da00d9196f841f429e57e7e5eb7c0a1ff0a29cfea9cd07d24f87eaa75c3a00db6382b0e66600f463094870a4c56948f8bc41ee09643cb634f6b9c61ca7b9feffdb00bceef54ef3494de46cfc7c96cc671d046c91701e19942d4671474552cb62e5624dc3b8772cb599a9a99ffa9aa09e1bed7de7e3b92949dd4fb40aef81b2aafc0f8e6753e6e5716392ef4f78f0e4191290f4d985c8609bc0c3da8c48bcb551fdbafbb60fcb9fcee8c6817053624807711c4aba243dfe51aeded319df7bd46ac121385be0954fb4d0ea73d4a469afee4c0796cde32c85fe2f8c87e07a6ef55a5d488664c2b0f16273e60ae24e9bf7eaa66f773ac4a096ff8dcb48dc17e02531a3f43bd46aea35f6797acc78d9ddbd68d719eb17482d55b8adfb8d636859cad8f08b8a244297880dbf4e7fc8200fc80bcc4931f98d3d14e02f10739974df5f897e77193c9dd50e56fb2ca675a90ab897f3fb3eafe3910361b5d5c5129526fe723320e7fb42140ea0de0e392731cc2f19f3e1e2a6e79764dc392a923322be0aab8b1f517b32e3d4ef53fb1595652bf4134f682b1ec6f9d6a85a1c3868eb761f3814e6a06cc977ea73e1feac3d1755292463964e0f8e9643ce7cad1399a2f3352bc778c50b61e240d5ed67b21fab7929a0b5514ae18b0bb02013abeb009c3a832e6be9b5e39f51f829b36d575e5049c9c0a8a6d0aaa789848bfa766ffbd3f04a4cb8ff139235e2d0ea4735832aa942d6bedd36d3f48f8b2bb91afaf4a1b113bb5bd849566d83a4f38210125e4380897ff39c48e4beee824a4a5c0a82c947fe2c21cbe95bd6f43f1f7b596d199a83c212f3266989f18ad1d9428151389ddafa3532df3c3de1226998b5ffec850d73cd44e6abb5d4df5304983331d4f1a1426a53c75bb6ef56ffdebfdb76c3e4edf399343b69309e6ca4580a12d7ab2bed1520d29d36228aa3e1e60a8af871b5bc5c0628a59a59034327ab9694c607691ee1d485708dc5fc7b0b0a7ce12a38092b28793253766dde6de3f53511913fe080edee70ec8a3a83d594770680db952a41ac7c3bae84cc8297fe6c0499729f3a708781b17e10c7efa1843a7eca1601ed90843f591f77e46cae3d3454d7520569d0c41af2094781bd99cfebafb9e210827b3090596416d90d98aa84e04fa2fa5ccc74fef2e17c8aefc3f8c7434c617a17c28a70698d0bbe83f9c5310ce26762f95ef726a0523ebcea02ee4b04f1c4cb7efed4826e6e6e8586652c75073005305dc474267fc10789dfabafcdb536b5388c1c11d6ad25454ab155d935ec0277bc68807fb37cf13900de215bc030f3433de68f40643cf8034331ee33256c8ca26f0e20a8aef83e4349a824b3fc40acfe7069f94787774b07ea35b8ed80d7b77bc475725a601ae64c4b6fefcb2f24253f0dd7ad8b4425cff6aa0c32c9ad8e46f926a555d73a31e0767128dc0402ba435fb6d0f0d53e4349d87a66e857cc8421485c3aabc853cb5b5af023ebd341766d4ed40881abf3f7b71f8a216c0472f93eec9c5aea2bba7814f4c1a199d97df6f15aa6692f5ce7b83b2ee35d2387b62454cd6c068f9eed22c8b495609abdc01dd933b9472334be92984102e4bd27cc8a815041af03749922547ddf6af80385cc36491bb519e4850a1f17ca9ea89b3c0a3aaca20519d42eb340ebb87d8cc3b634faff5b8dc97481523cb5f684ab106af5fbca0f4ffcb559b72db86d4779dff4ad5e3c0b3aec5b95329daf35646d8320642b96b17cf183f64bf85e2c9ec14eda09e22957cfe69e04ca6588f2ef897787dbc4bc1944b31576dfcd1e29b8386786de29b631162303ed49912e15959a32d0da53a31397f446780759c2c1b67ef90b54dc60bb9c2435c30bf9c22a570694ca789ada8195f08aa52022e8c3f8b841b06aa3604e1d82e9a89c01ec935970076cc635c7b3706b91eca4349027555802e20b1890f2feab5b22310d331d29868919f919b4bb712f0815cb74a41f9bddb6971c42b72c13b461223294d08ff555287e776a4b7a9e7410aca2195095ee567da4e22c28cbee847f6ccae255834a9354e0567cc517d86f059a6ce4ef9cae617c142a81bd38255d3b28b1e3c596453be0d6b7c65f53081c90e0170daa2e9abc3ffd23d7c53fb3cf221ca2026646cd4de304af90e99ecff461126bb5acd9c7d7380188476cb11257a5be33054de0919d3e987f2d454923580586cc725c8f610211dc2e9b334b3307b2d357d2fa8a6dd96cb32d9835f7ff0ba7f4fb726e18d48155a3dcfc714224f5b8aced8c4c21353b90445df4946b92014af70daa40d9bd1e9ea6353c10a93934fad2356ef9418c8276895e4e1f6838b522bd8c01d735f08ca8a04417a54c34f0d0c9aa0696759d349750fcaa0d10d998daeee2191d35a25c5a529bd6f6b8204794e6970c8b2c6d6c80e9bd61186608bc656ac62fd56fd92dc80ea018baaf4295436f69485622eec6dd11fdb4b1f5289619c33cca0c8532949ae2e8b7a8c58d66d42e8f96a21faa18b0d3f6344332dc4343c0d4a55e90521255bd909aa28ff70ae50866e2bde8ecbed5f0a6e7848373103a76716b368befdc84b43132e3635635d181d98b680e0519a77a23c0844c4aa149d9f480d6b0b2cc8669d445eb4b3bed863c3f8ff9d4182a02bc3d84c7053415ddddf8af808b040c15d121ae4722b6da07683bb8772ff8942a81a7953165dc9fbf7ea31db78c240ed33528606cf2464b51c6c287f8520ee012172e1485d55225922e069f0c1181935e6cf9883bfa70e413b222aa5164b967443130d05e7936d02f2766a456b4d374f318e8682df797c297d9e46f440377b84ea24b2e39dd01f842a1f2ed252585cf43e9384416d00bb6c07a63765980a14c53c33159f51311ea20d3490bd528a6b22a410acf22d85834f3c1856e527d9371e78d6e3559954cdaf8f312132ebbb4c86f5d1456e97d2a3722f4c0bd468ebd9061fee2d838d94e62a001876b9152acc929f0b0e5dba06085c5ecf91e87eeb449ef919b4f34294dac7bb2e66e9573f789fa024a2d0394efd17931f6dd90ae164ba6f98f6cf585e75c57a347de9d7d45dbd86441b0db235aca807e4b14b09a19306b8cc71a1eced6c4f5fc9b15c5c5fbd7d2a60b9416aa14e945e4a720a7cb01f7eec9e2d18532b6ae4e64712d0acf5cc9595a77f84273189796176ba620bcdfe1f4ff2355c0f3225f203546e75cef274f16ce1993000092cc604e4ffea31ab2dc5d9b5a1385d854298f725d9033c84acd154e3d58b44d3b3bc37e3b9b7e9c671539650567d5332273d42a145e4442d8019c7ffde8a29328d7a63bf83aaf7d775a9cc2bb0192fa66b03bc51b9ff19fa4f4ebf918b1e10f1ef852e028a2f8c41bae623c22a54f10cfa5f46f5a691edd1215f139b8f34404def0059bb8237e437df40ae699b188fcb3fed909c41c99757dd28269301bd71e3c42e792e33b6414fa62f953f622d79937320bb8532308e60bc071cd49a31bf27cba53b9d05b9b0a1dfd7f76446d1b1168b3d5572f0e16f8306e3c81a2b92e073d3356e414aa4c59fa3e33f30978ae98ecd1b0dd6906f5815bec74414675127b2810323afd47450f1e50163a9db28ecf3343f7350ed9fbfff29362a3d0320995ef5a1ce832d952caea8c3c1398175d205ff3e6671bcbbfe94be897349e03f1c7196b508503c9de69746b495d8fa689a73d8e51aa766cee997b9cbc46c394582f4dda53064f3d6c9a9b9a6ef7dc6b605b499c57c4019015f8a7fd7bcfebe2fe8d6d289a0bc43a4880c3a2771117a17608bf91eee70ef5299df22a08eb66d5d05adeb610316e0969544ec8b5da7329ceadcd8dc58750b755ae387e87945a5f0f069bd2951fd8b98ff30657b2e7f7bd24a5a89e747ae51962aa68d35c5b6e73339a2a3b2d2f5fe2e9cd39faa421f6abb54cd3b24b8e600fb9b5c2486c93450ff71730426cb88d45388981c5c886c20ce71cdde808044bb643b4898a80cf2a1268da8db45a98e021bba05a4e72c8b252bbe9109db781c27f9aff357f816c25f073d5b43ee11cdd6af187fe6f842f31923899aba58574a313a86fcd840327b12ae5a8799c7b68f9495dca8ddd30576ef4322f426465b94cbe3f652302f31ee4052b19017bb33dd7a1b4b34d5ae38011ebb7400936801a709a5b3449cb1188a6445e7ad1cccfd916a9e94bff0027731c3d940fa2bfd3e41260240bf553d8cb0074a13e45f36e87ed180a5a948164804fe0326c3a33e0288e9eaeab74d9516ea2c431825dc8627cab0636072de3799abeb0563e503feed84d07bb84a185e40604344627d9f6395fbb5afd50c51a2feec5356e77ef71197dbe7d2218291e45ae0c0e36b05fdecdc631d2325e0790089cc9ffd15796582d0fc87cb23cebd1e595cdf4978b5822904eb7cb51adea53ee9b5ddcedb3147e5aace1d8e007eb2d1c4df3a8697979a26a6c578091dcf43bf3517be4c8a468b3fc4cddbd157a5ffb9c902c1d10fe65b815e5e3281cfe6bdf1fc0433ff41555288b51ba4f0f1922a3f8013bc86024b5ca92da1abdbff349da5c6aebf68b16cb87f146d2d84c2cb5ac145cd168ffb9042316829d7ec18cc1c8dd4da1a359a87cdedc6907b3c652ddf183bd4ab0b49e3823433bf9b8c217b8d47bf5e6ff61728f70241c73fa79e86cbf2b40eb05156a26518bdd1db4c6e84522938ff334997cf6416f59bd79b42fafd1ed3d894c53ed9bef677a2a8324de1383852818a55c03698294dbc92b47a50b5852a4e85099e24595d2074c95391d50d7f13f1f6c321628d99c183f7a7f61113bd58d44d964e4be7dfc16ae0ff4e423fab10e3860fb23a7ee0087cb18a2e565705c463720a0070143b63744067cf628501688271a4f12087b192be3f77539f92c6bc0ac1daf774df13fe2ff008b533fbe542ad0b54996e34d9f6d9b16a3c216cc2dba658ec71fdb5e9af2300c40d8d40e53f680a4c9dcae171bb0df05144c321d33153db20deb2bd434895e2edcd36105b2389fe5be7778d94b4e01045889221c77f8153cf4f9a30e20417158ba725dde12e18dc8b3696fa54725f12491b336a7195282589eae3631f0fd8bed3314ca5a085f6e2fb99a866d567e4a20b53aef33971e204e99a35bb2708716af2712e5835683138947ef6d237a7a27775fb08386106a7ae176f543e45309f45cc196b678a271c46fd3e5750403ae1d47a13741c1849c957daeb74dbf3a8390ed06b6e9a3300af8303cd8bd5aae56e287563ad517b2273b66b337ab45b7587b55d6491d51179f45da89adf4f703987c08f3b0b9f07ce677e6ebf36531b59bf4c8fcb74e63633a82e9b5e2a0b3469751fe71a47231fc5897b72ea69124aa60614ec641466ff91051d2f4967bbb26a6c38b648298382603b49136adb0d683888571a6f9a2cf0cb4710c5a75376fbc787c9d853c3cdd263970e24d0ae06b9242f0c16f912e5271c79cd50c15258018f7a6e972c94fba220e16ed558e9a3c8bf7e33dac7772edca8d4cbd066edf75ff9eb681ca4c67414c42e90b4a082230d69e19bbc62c3624c70e4ec5eb3ed499cc2a709d2cc8d69c619dbced20eb0f483d2556680ec902471ef67546ab2cf27ffc08d815b566ea6dfe3b0c23e8446a8d4f5899612ecaf89b231e7f320e7e4c60097ce36f0248b5b7187ec9d5c58b88d5aeb144832c95d780711ce50e1940d6c16763dd2cbda5c01754d0ce31d5e311044fb6996e8e6206388ba0bf06c585a6e2cc6decd3c5f0d39a3e201d7471732dbf781873183038ed093b24512f7a3e4faf45c687e8b1383c78191f1df0f8774c46987b8865e5286cab898861a48dd98b56ad62c1c9f2371f0f2485abeec31d430043aacfd574a9c33c1a115fd46b55100e6f2eb840fedfd01afcade4563983ec0bb766d3e7fa022a38d03e0c12e28448eeecaf1707b9d34e5a4ccc0bdea6ff76379dd747fd30b82e33220fbc78aecdc442fbb287ae60d5a8db71bfeb2e0cea38e48cbc65a77ed72f053a7153b898d50c90dd6ce58f22619af642408d897adb98d4fd843f31633907dcd50fad3969a5dd2104706fd5848e14a9b816f1d756be7cdb91f897d9db26a7f0666a1ea1de7e26580913b3631bf995a0bd9576904051e505aaa01af759be87a52867fd2adfc41e35fbcf6c7bf9f022f85193eaca968e154b712030b5cbcdf60c65b727d5368bffa3f0e5cbc260809006b106a3c823b342941451b1ca39b198c6fe697c544d0fccb743daba9418db5a0d1cb541a6cd0bfd26d6c9aa1966022eedd9a1b3432452cc96def1494c1054a55732edc4b5e749e249ae2d12cc1575832212146aa6536bb18901fa538839580b4580574962a69c30f3a122a056b481b82d8ea91e7a737dc500c531fec6441cc8c528c2a99b3abb3ce4473fc42a408de5b83ec8435d104dcecf8e9a237be919e1c7e17bf6a04f9c64f5de59a0e8ab7d15fe32acf7e0d77a4b06f299fdc2f63d4eec8721db7808cccb6ec7891f963fbc24f7a29522119545dddee8c871d39b03898f24f7e682e02eff2204fcaaf5c796148b5cd9a99f471c3e2eb8a67bd0f5f12fa3e10300d5a2b2e0a9b27f07c0630949558988e064f31b7b8282607b908336803f28943185ce0c07556117d27b7aba88e7b46bf48e408bf306a4c1ae70565555997c95cb50e959cf7a2e9797b7abebf08a74e47b82400de785422f5a663da99e1ff9ab8c4c2063417a40a73284b6e9ec25c98e5c4da88c31004a3c73d4a1fedb8c7cb109d466a71943017b4d7f436e47db7aa6fa5604ec91ee182ad0de6592f4ba50c9e43c3dfd20fbc6107c3b182a4677a4273933739137ead954a3fa073869fe901cdda79dbe9f487400d38800422f19b22e53020090028d4e67bfd8bbde9c2229034bc6bca7add7990dc2124d0c8cee319b26c347c4bab8f696df17ce49c3ed852dd9e9afde79d1f09b61bc103fadd47ef9a9067f2b71f6ba8987e69a310fe20b4c185e438b0ec800de4d225b7b42be4bf97fca767e431954fd1445b92fd9ee1ec40e9877268a2e7bfade4031bc16331b30e48d0c52b54aa888d29b4ddf1be0a02c03ce82c06fd81de780bb4c59a4a9f944122dc345ab92c4b06a3a419c848a592b4161a4e058cc01d19365e165dee161b16107b53e1723741e497c7a9da8867892e28d1b64c30f4b253af7910b2ca84d24535d26bf79448292b6fc2935b4b14b9b558c15e13d4bc42ab6be213eb940482471aab2b08590c26c95506086887dcc317e880abbe94d9afb8bb0d7c1c9dca1036b121423faccf310ad03eec6cc018f4cab81e078d1c56bed6822ab2fb459ef3d507b3fddb498f3e8fe17ef773d0f04fb9d2c0aca59cbf753f6def69c1a5cc26dd246b261a53f562a5e752d322d4d96674d399e960ed5431a9bf90232169a50cc18adb5cb5dc5a0808f21ed79b06de9d0943b3252d0941ec8924faa6162c3254c2639b8e213dc67ce98ab4683712fa4714fc3cb5e16f2d9714926a5b8c8e7c4bd70689b5495ea334573b3dbb20a1dd954d6ec8e9eda3a77aefccd86ba997c0568ecc744991e49117cc3ae704b48c16ae6b65af77b58349fedfdab0e10c72c96975d3e0d0921249e9212b2f4a1d259065ee17d069a5ec7efbccc44e02159761034b5e33b65a6eb88f77dffea2fea8f712c63e7a303adc5e7dd0b87c7ace7da549fa800ce2cce2a742770adad51096e909bd161f910f4fa4175ab27ecfb7d4ea0993b3bbeecafdee2ccd37905370ca2d76d5dbd1a3bbc0e027a38bbeb7e6130c2e3ff6f40e2eb9de6b2926454fe251cf9e3c9b0ba16662475c75331def9bc93a09bd43848502b13a9c85755d69dce9d79fc33567c279356f826e870cc36a786a182daf0b9aca827c85bb2171f1993e9cf7255f9e2408e9234ffa799275e9cafbbfcf0f7b775444731163f96dbd73c99b9f2a9c67c2cfd5785731e0c3dcc8f69775b1f2ba5c3a0b40d7c7d760ea937a654ec614ba60ceaf8460844a117e19c7efc1895dde9ee917ee271a31421845c513b741153daab85d24e0ebe1d735216b92502aa3bb3ed64fd2ec8454962c78ec22f6efa1e57bfd150b32e90e0f379c397b80e5bbe7678e35238f95c95ab375b761a0c89aefc08d4024d89af662638244cf530ebc78b3001d409dc294cbefff16da0c2f9b75c5cb6b06ca938f6c547034b5ee268f3dde6679b9fa7c1134fec7cb3ec87952d3ceb7cd567187e7efeeda63523325ecfeea6de63a2d272ed531d251baf39754accc297769f070f7b544353dcdc38074c257980bebf9f2f103b1d049d8b797f272c7a9d29dc37d99517e2b3a60b239b10f373fc9dde370680a26950c3d128211f92838256034ec637a08a9fa328784fe1e6ca0ac84de7d72cd61c34cbd0b82e2fa8d2a706bfdc6a0fe116517b2b85663da6c8ef371d465ef42b5a9d08df0578d3d0ca28a3036cec7136070ba27af50f694504899598777e0ab60ced878e406174924cc473ab0dc2aea4d77b254cba73f2d27bb0e3759bdcf7fb1ed355660b29b4efe0711119abdffbec24aaf5bf57e2a933e6110e6c28279f85b675d20ce7d919ce2ae4dcf0518e16198856c9ef13c6725117037b8b83eab53eebecc70771b48fc19aafe5cdca50eb9c45f76827ea709c556383837b59f7e352d4ff8dc88e33f1d09745e2cac4f8e7301ff86a8bd96f2c40c84873d4e0bd24abc9c16fa505f57bb49ebbffc1150071bef6d8d940c219f7db412da95aff69466eb7844360365986caac25f4efc1136953cac502591944b32ecac97a1e9f4913a545f2aa516f320a5fe73bd5aaa8255f2c4032cf4fb620c2a991a9067e9f816c038544edf81b5f2ed12db0db7db09678dc715126ade89ff13c3f684f7ce31b55b7f036759831c6c17acfc8896c4c2d22c78b43b1dbf1189e33673069e1e941653e0c996509f112493ec594dbc1537a8f7d43046235ef5972d922f1fd0a31a24e3812755e547b642c896c333de3752ce633336245c46fe8dec7f7876180b080676b3b18f814af9beda0b265fee3ad4920e6047f7c7045f44cc8337423c0c83b23032c9c7f34d969f44d470a09866e79ad63de4181114cdaf48b05f7aaa4ac9b54bc0951aab523f48b24bcf0501e8e9b89fd5c909ef7d179c14b5485b594b334a8127c27fc90d04569a786677918728e28a0f58110e0d4d8ba78c0d0b292d8801b694b4dfc8de53c13a6c8accc5bf71ddf9e355fb294d0f879e6739c4fc1964456c287969bc039f1bd5bee08e25fdccde6dcc789542533dadce75a1446270ee57d0844bbe59ab260ec2d7a4b7a8e3a14ad63893aa3a4f6316ec4f29e883f8dd982e7f12ced046cca176e4da1fb78dd46e28ad97f610ef8dd0482b686643906dd79cc2a105077488f92591bd92c26ffe56ca5e2dee4581decb572444767bf105718ed6cbd8d9383bf2deae93a25292452aa14849ee3940ee277a55d8bc43e74a54399c85d6a8c3c9005454c6fec37214dfd87e8e09c053ebb380f031985da8b28fd3b5c223df1c11ef87711ec360ee985b29769c4c939617ea7fa212c1959743a28ba1735b19ea3df5fc53fa3b31daac59757abffe1df867b7079cfde80b50d9c53aa52d42a976486b2ecce1886938df5d81d78c3229d60719e4ba079b6b8aa19beee6db2510c490bc5ab8a6e1b6fb92948f2811108ed73afa43a1384f06f1b62b1ca31a7d617484b7cf1bbdfc929faa88edeb0d92c0434a1c05f997fa83faf16876d56f997b4396b5890d83a70a81c997b8ebe40ce35e27d807a1d4d325589226f5fe393104dd2f0c1ee988c8abdc5b282cd626ade3eb97244dee1a9cd781c1aed8a55405d850764394d59cb08a03291eff5b5ca8c2c7a7c494aa8f22abf810f321bb737be00e1e9dbf86d766f64842f599dc1f969f36d192b7243160ad6aea99e400adc4be8aaeab70edd8bb4ce1012826e78c40ee56abe577da115d4696f2ff3ea76fb041efb65787018ecf9130bb686b8f0d5db343ca18416f181e672fce7ef72f5152af8f4aeb8e0219ae040d999a36e46b4d6d4d7f23ef284b2e0b7694ca9d8ea0204f0768fce3a9cddd4a231fb743af4c0da2abc7a2c38321ba16969bcaf677268228d1fbf415b2cd94433f4b884be01a643bd7abe7e01ee88fbe915b7c69232df92a68ab93747516d18f8c9d95dc3c1c48759243320da3f204484f9185cab25c1bf35b0eda58bc19940188c91057aee93a19fc4b7ff08e3d727f44f4aed17bffbd5eab6ca13068f9bf67d5ffb4f3a7c491e9a166fbe210c82a3b05d8b117cfbc1f4099c7cc812ce147d83826e69e85c04eafe7cb9ae8380540899e19ed2f7c841dd2f99f417bf0c530559a9a69fc29c16277055fd239e61cffa15b3aa694fb2cab43c9f9fac73ae22204d0e6d33b21943b9d8e63a18a97537fe7624d6f499a4f91c315419b28e38c55f8829e36637fd9f1a908f85bc031bc3c183716eb22a272afa468cdc573a2d23d5715ea57c01502fb11e85efac570df7239bd1ac73a6c6beb179f81c836157ae7c7825fe0fefa4fb3679e755cdd46e47cb0ecca349c92b9b0af7c0e85e18af904f626d4f678532be8d9d855673c2f36abf17307acd61ade2bfabd83d8148d2d6194f1facd9ffb98fb42c0f6eefa2263e8172062234fed8988837a11e6f9bd9434e6dd134fc5d8ebd2981f91961852d35aca729c26bb429e1f5e7a12b11c74e6b88aa16bdd38cb0fde29e6ee9d4efbdf2e4b805de83b097da6b4a44f3c907368a81f9ab2f47c6fb10821425b72afd38547cfadaaa6223a35a48c434db12b559725db90769853625655a38f3373b7049d02268351b1ae0ee12dcdbf872f0d41a366d5b043afb725f640b2644e073b93a7db1e6955fb715366c7cbbe1b2dfd12dd7011fe3353eee98acb8f95164a902ed893e8a6e975111945b0abd059bee4e4a77e5b5bd2b98ab1cdebbf5cdf1a40022e5fc7e2a29a583c18af29d60fc73cf39154d1c7b17639167dae3fbbea0681613bca78f611e2eca7241a6ac988406c0a3fc5c9b8c511f4bdb1a053a523af79478242f4f5eb374be9ca4f645c9b57ae9968abe62c98d23e3997d76450520c2fb24877390ffaf2d1f4973c2e44e76d75fb8392a4c6a981498bb175c2476d5942568ce57647af1257743e991634ba761cbecb409f081b8ddbfc6d90ff82817ddbb703ae16edc13d83c4f6c02a8f3dd32f9013663d455105f8e7cd824de201399522d6771f97c3e8765d1dae42b6d9e912cabdba40aeec5a6d1f12175fc27558ddfc63b7b6f8cbe79dc28997dbfc214f80c8b30b2fa47003a4a935cb9bb1ecdbe9b4384bb2be92aba13af2db082b7ef9d5e95652f0a44747f4f01250d2a9885104c3fcb3b110c59af0a499bd1a16420dd7bad6a5f7de39bcd89827d000b3cebfd92d662de2e3ecce8a99520d5b28aa0f1527dc23e355f3ae365a50cb11c479cacd65344192c93603596038db7f6f7717a26ed14f17a9f98fe10ba97856dd2ed6b2ffde0deabec6527c5a4d2255e43822a618ed011cd963af0ea73abdfb1107bd3b145760ea77641507f124f6c2ee4fe8be38867c78c4b5b8ee0552f3711cf9bdc37170ef234b8f0cbf15ca399489de4481c37e865fd731629e874fa1c694912e38d21491b1266f0f749f5f38e701cfb8366a835d0cadb681270e5a985f42ff5835ba196ba5ddac84d5a1e399bc9cdfd4374af02c02c839febbc232f64e58044a9eafeac27fdfd6b72b2232b972dc7972022afa62d1adae183a962026d3016d3db223cdcfad747ffa3c6b4ef875a41fb8a04bb391e71a37af12355924f9ede3bd2d0475e3c9bca6d7138aea62832bf4839b84a3a4af9464642f08acf26b57f7d25097af2f10fa5fbc42216aa33001112e79a6e106143cfcc6d8d171a010c8a7c7c30f86c6febea918d4e766e434913fe875a9fd7af09d436ec8f6f8c929305d9d87b3ad52d45fb9a27a3cba41d7c417dc82896e64ea19f99e8680f5a970cf2b36a6aec2690150e8700902df7cc22bd0516772a68e66431d4f239d021d5e749afdbf66ef0801509ababa7898670b0a5bdc733ade2641301d0f26de0c599551c5a1f2140b3238d22bf4ebce0f5a3afeca439e912382d5292fdae7d827f9f222854294e56153baed84a479fd920d452c9f65f04057d240dc5033ef0064c5af2264e5b68551ae9d78a766262b8b177ed14a084a2bddf6f601e7270f17d19fba30ad9d313b03ac1bd1baf2d404a662f15126e818762427cd2979cc6b33eac1d4096144247ac4bd79118a2cf717279457fb98393be9c0ecbd990f3a725fd80148a8a0a2511ce3ed695e809901535372babca5c08ec123c9da39812e85fb57e0f317e8a669d52a5c5a94ca0ab969267ae536e754fd3365c71a679f0bcb1d003b2a3f561943a168da2ead5b373c1b91142e7e041f6f274464954c77c6fa7231d795357680cc266e6b686e4f501b15d21d7e59a17a6b0107f7afdad4b6ffe61750d039080617321e088a9d9a235322ebd0e397a5c9f87f3e7e92e00bff8561b0391d3eabdfb3cdd5c05c4e2c9682482a0b4a0f8e0167ffa30c0846b3e6bf4952c413f7fd42c43572f98bcc5746d271507c043834a4a3569aa91b9c99ea3d1ad331d4eac59b5d10ea25d203c09fe4ab6c84823cbcb23c349bf2db4e71c184b830d223568ad1d6b161bffea29000f4304a57bf38674fd8e8cb7d0a4c372db3e9a8fcf2648057a05f094109ef1d9a34dfc5ccfee74e4d1c84be04bda71c9a76708c557cdbeab26f7cccc8ef9fa782f52a1619f5538d1fc66f11976c114f75cc6b0cbe6d8953233e66045d994fe6a8bd6a0a32c40454c522fd7a418a870204815f1d217848395182edccfc800f175539a7e9bb4adf976329b02c8738f4a4d010b91a5eccfb3adec4503e37e0ffddf20fbf0a12f3050f090899afeb38ba1df8084b52a840d2ba1a234a7435008c9fca4ee32cef95ecc43dbc589a8316c97ba250284a6ed89eb97cd92fb4f5abad667ffe7b3efe9be782b2ee7f65fda4c0ae3829c25e9d8318ec45a37711836fe7842e3e388363c1c88fb78bc4fec17ac5d09490bcc999b4f73a8e0105b931e4124c471ab1588ed63aad9d97ac295dcf5e3d8ac1aebd07a591d61d2d24afab0a4457831068272393627ddcb2a2200ddc40bd958f8ea653b7579cbfa74594d5801ab31de1f76aecd8a084d02f7ef84894e62431304d3164d46564cd14a1c79132d2bbab3ff4262aa825a2f22d659c1b5698e06a87bc567f30fc2292172af580b0ba83677ea1c4bf56e8eabd5afb0592541cee925fa64ca0b7af2e18117233cb03901dbc4a60021f6d9c96354e06cda78b462f8d26e61bf63a5438b6a645c979319233785a310daa388dc18d66c6d850b5e19f55adffd577adb2e245e4951ff92c6b94408988899387386957b3bec746b08893b351ad7496576f300bee99e9d3365936c5a9b93689d753cde9285017640975e06890f0ae03dddc2fd08b18a4bc10cdd3f806db2475dc4eeb840a67bb460be1f22166b8ac06a2b0b1375dfd3c0e56e4871ed323daa20aef613b9019fe3bd32665c59067d64f96cf3f1b080aa622d689644b13a69c62d5fafbd05d108857445ba7205fbefe2f634a4693be06130dabf6f4e7b92fd9cef003231d4c8d77fbbba817de71bc56060ca20640ffe893d08a5e5ff9e3dcacacac4f0d62553c488c47f39b0c0f83d55f9d3f0a2fef0a986f625196019af210990d0050bb35232906f386d9d479ec807dddc1854fc85dc0f0ee7c2bea27fd24b1e32e5e3ad2b235ea39d61f40330d3d29ce09b7769e8c8f52bb014b5edd3c00b38c9d990eca58e4a96a5d478b337c214747d75add011c943b4e67b5d90474b07be872ad20dd3fb90a5fdeb6cdb2e6877241f25414c50d0afe1e7820dc9415897736bd02504ff0043b79b7c701d0f7640f628fb37cb613a9ef97cda6737cb829bb0bdc63933a5ce2fa9f0eb6d38fd0c0793ad93c675b23522fd2ef3f32bd41bc0e16c7b2de0cc8beecb027496b7a5d7e5b527578c5421f9f3949146ce25cab865083475c93002afbec2d4c0ef4ad8d2c31c4a22248e39451f39ccb9333442dd6aba3b41b6f99c5591a03c250ef2014ca158fa60a0439d2087d88a5c0637c29f4f9b52c13d0ef2100deb25d593908cf8112ad384dd955a4369ebfd28b626de951bb66610a5ba7e13c2bc53659e8ec7aca5389d9cb835b2384e015402fe03318cbe7b2ae906ae5f3db48fe9075d3ba42321d946915b898b1168ef79250e0cc0b55fd0f5206985c53fd0c102c694bf28c15e42a21773eb1e0ca458aa2b2fbbbfc842f4b85a5beb6505f1964f120b772737a9a0156ae64f1af6745fb44be6c945385a17bea96f800ae849416f807a6a24974ffcc65e1f6eede82f90f92aa5aaa86453ff43d3fce0e143c7cc45adc917ed9a16287dff73a540c413ac55aff450df40e75b30212de33bec8f52a5c1481af8d1592212ef46b3dbd9c1e31003b8eacbeadfd37278fa0c014afc4e84b4f4353fa881adf5684fb0399b287cac46d1c370c7c15ea7b4aaa4a1a4ccf989e998c5bf626cd3ac81c87453ba2e27c0b6c166bac446529031778ebb05ad6bd8433e934e00ed30d86e0e58d4f101b256fd3432583929918c18af918e3a9e3f24851921c471ee5dc5c672958b45a3f3809a4b2b1e9815cc734c2160dcfe5fe1df06aa17e0e347078825b34c68df7125db96dd8b16ad7f260de3dba8fd492e92a088f895ec0e38796f9e081b8b9f69cf07d1efde685ae81a0704946d3fafe7a2b6e55370d19036c46b6b7d99d0f79741c81e9040a5fea3fade77942e276db73a9cc8d82fa9320633347c5574813dc9f8972823f2200ca8401feac7f8c24af37e25809e5a815d616de4c7a1c3d80555878210981637310efbcba9c3c976ff2bd3a93dcb82c33a87b36625345e67e4b2fba406d95838eb4c1a74f49f48e9e2d8cf5de1c942d3d4e77b2f94a075ace55a9aad2736e52e02a2a402e55288ffb205a26d06bb9de3bf404446e76f84a0852b24c99d8597d9875e9a80530e9f8c806fc7831afe83facf1af9c0a220e7f03f0d976607a6cef91c310343dd9f5e29c24a871fac306a921214201c3acea8745ac136a33c292c1c2555b92ae4b99fb311a8522837ffb70bc0d68939897c753d81627197d93711a5c56a0e439e14dad0bb5657ad01cdfe0ca74f52dca4e14e70949a5c0fe6a97315cac1bac1efb89ff2fa729dea2584ff129b7650fe356e670926ae32218b35914121328ca4157e648181b25354d7c92846a827ab5b79995559e0a68997a3de17d1d5e302549f27a30a4e708aaef63fea39b0f7b35e5c8369a058d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"87e49bc2a0b1fd09abb950b4fb5946bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
