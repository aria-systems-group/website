<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ca9a5ee0b5802c619b1f135ed36c1690507a0682e2a718657d8947f7f35accc8b9c35a25e88ab48a50c0ac464a7e004f00022bb689ce79eb5d0ef048d1a27f2a388759572ebaf2fc19e658d11b1c61bbe31fe91ee7bb3313b933490566e3a85d5ecf3156ad670dac43ba03453e749a8f2f9f48954dc81849bdac3e42bbab4a8fb9cf1f284f158ec469b9ab892cf2cbe7cab8dfc401aa088f478e542c936f0101597feaa7eec2d721e6428600b96487dbc7c182e83f19cff1468babd6b321bc1dd925bd1d1a10f90330c484a9cadcf11a0826f29f984f8b4e57514e7466e47bf16f1bfd7242ebce9f1a48bae115f8735e17f459d03bfa9fa74d925b3c3130157a00868afab1c0907dd5f207193c8b915d849be85a0948afff3c3bf49f24de115cc73d0c818fc80ba54d54afb436d758ef970fef05d3a3c232b4606732318521edb634a25e01864e1513709c3014c6dd340691b722cf574a0fa7ec47a767ffda0ced8e47a302a24938965708509bc75cb82cb20dfa892c3b78b9d97742e59f3402dd7f8a1b9630cadf3392ca687db3e65be29589c8698f86c0472ac34cab79b39e62c2f121e4d4e0c88e35bd710bb2e57f123a67e1906e0bd8b35a8962ba0435bc4fc8a82d28c0affec241f41e56c41c203efdc1803ceffbeb100574e6050b0443ea7c574700ea31c0a67e1f116742660035c38a05a5c7bfc3a03f16d7f1887bbd2ab565cdd0238eefc070be4b7e207cf1df8efb107ff02889cc8835a6ce49c012c9bbefb4c8dc4010b6381bcdb7567d2d62d4880b0cc07cff48c1825ab616848be9bb12e6d8a25b2747587cd80b4814e3aaf867cde4caa17a53f135a605f3630cf4bbe4bfb422471d75fcdcdfaf3c7883816eb558bfc59336a9818b4cd642bd54943e1a7fd30d280a600dada6e64627873c9a7b84741cc469de7b7ad56cacc3f9f69a3ef1b232a0c4e87568309e3352f4dfb13aaa510a2b6a71f5954a616d39fedf7e0f5c58fd98fafe0774f1beb8205b50b6d5262ab642da56b9d2419c69f7480a705bc7503ff2b757f6bc237182b9d455cde3087584ee8514f6347bb835b0dbaea669020b66e444800639aca4aac29dfd71a359acc3ab02079d4b95f4788cb99ecdc72c3af8f066017fd5e597e2878499ffbf0839104b56b59c60084b6634e25723fce23603ce0f380b4a6787702a2b996bddb0f2ccc42d54cb67b1315220e72503761d16cb5a770bc8b3310332a9edc776fb3c7262c9147392dd2d30996c25b36f4d136cdc0694b065435d02d13e72a798e758b1179ce7ba892e8211da8c2d83adec8c5b2d60a336f00dc5c607e359f5bee69bcd11f5e8e3108d1fc44fb3e2e9d4e0088aa28f9d717cd74511f6eeef306f1f7f7b3c0cfa85ad859943d58651057433e2e540a750d9462c29032401fbbb186d330d033afb0497de72b1b89dfae3a6df313022413addc7eaaa7fff7cbed00780ab380133ac6113e970d6630161e3b79cdb3873868f75fc11d108c8eddb58b3530d24d597861917fbf6f2dfb196c6b80c4b8edc2708198d66ceeecfad5661c30b3fd8f58a36ab844341e81640531edbdc38262d5dfd9941361c5104227d8b8f95faedbf69465b3a1d089efabbd7eda7c34f2311db568fc240b2c02439bef433253bbdf706e075f191b141fe8180c2488159de1fe2d8f057d1cbf3dfb68d15ee28692c524c0d8fc275ba040b23c093d15f6f4d94f3a9d60e7a290abca8be523440e9d48dafc865e86f5f765641bb626478a6fdbadaaaecc58d4a07f080cdb0d5455be60652584471afb29dac4e298ba6b63d0949ad096590fe28256a8e6f8bbf7f3e8597d53e642b14377cbcab5259029debbcf57263ab76153c0d328afa21b348b6de1346d258848de44d75019d4f840789988a2f0436e3daab871a73b67114ffb2500d52c26f2b8ffc36d9cf2c238fed5b541809d0cc3e2f8cf23f99ef4e3217a4ea171c568b5a4a6bc2a6589af55a7a6f079f3a9712a981b31f32b99271a27d6318be47915fbc331febb8429378084e7ca6139b4fff3000aecedce173398655426c846f7650ad17d85f6fae9dabcbd38327f328844d7e4bde93b67d0539d65855532a4ce35344aef6959e5fb695e774906faa4c1f70dfce4bb6f1f51c02ed2c970af3861389ea18f744d9553634263d020221649b591c722b3f0fe4d300d282c48a3f25e347c08bd89ec3f6f58cb04050a9176a6a866005325519753efc5683f57dcebdb4142c232a5fee94179357cc66b1d468338941a13203bac0816125ac1fa491c1280a2ebe1686d953a70521fed808ef65a9a6f8f931ae0a0f61d0d92f513ae3d47db702689f711199c7339f3950e71db5624b9d8a5242158f79f7fd16be74bca9aa23693eae9c8bc080fa8f59f318c35f44dc6b1b249ca6725f0dbab27b908662686bf63f61c5bb4201b47ba3c27bafffc84f5ab0e62a70af70e76a8711d9de46e39b5d96aaec470c2a22f98891ce25c3c7e57f478cb14a983e4d3ab549914b197eea4d8521c31790d5c02f8be30e34595ad66afd74dc52937fea8276b5e14de53b05caaa46e088d930e6bb1610e8c5db1b9341805b9a29351595b92cdee1adc2831c5746ea66266709ebe9d16b9f87b8eeb35e543e915c2dbc5921aceedc195095eb24cbeae07af65a1c2c8c1371926cc5e5b9864f53e7cfe6adc3e95d9c43ff6d383493493046e9fde5e727fdd294e75b3c0d6aa5ffa9dfe6633a9ab8d19af50b0979b785259490453d4e961ba4a3c55f3553798cb8342861f9997a65e347e17685f2337220abe86504fc87419fcd92299eec47067eecd273ac7a62933fe3b3b1d113b26b3f6b7f36f8525eaea8a153a936d6ab859d5fe79d4f0b41763c5634990e7202edc48ebc4621ea6951e9acccca6a6ea5b552736170dcfdadf75f9df214e4d0a47b821341c31974e39f0a03b70517bf73864b206b5ddb6957b293866138f5508f863a0d135edee44d0e68eadb12bc1dff5eef28fce1d1e4660d5343c0ca413b5617cd390a154460802dff5d15faf2434a92f1fffabd8373651bf51d7a45c1df4e63858e108e44a3bdf34be2d4055fffeb03fa08ab0fe4af3dbfcfac634f9772b9e2a2024945a9a48fadf8101bdf1238403009436728e8e5b87f693661e3cc488a8e50bf5a89e9081e22465f0b40e92c723ab0a7dffbd7462d56cc8200664f9e6bdcaafe17be4d731125a8e3be68408968b5f6c2ed71ebd3553cb768caa7a38a2a4f0a92efa6508958a5112db3e3410309a3a957065509652890c680586a3a6103b65fa2a32293254db74fa5c462d19a2e65793a1216453298c52699795cdc4ae4b8d7351258cb2813d78045afff75fa370ea6c8064f9aa38b8895c67f00354484d9e60951d1f0bb9808e7de851d1a2f1ac81fee3739b0726e3c1aabab71776745c3a946f49ac1353f841251e55e02863322de14257d53aee1e58776f0cc81892b40d351329de4fe3da728ba7304efaf93bb9bb7ce841d9e2b2c70e591dd00e02ac0ae1d5cef4a3384189a7329c419e47cd1e6b9695e2e776efc0616b3c72ca46964cf9f3d5a1afb6bf8ac5bcbf1a2ca2e72d8f373ab389ad4f53a4d37371ecb94627cff8d65ddaf8a4587460fc011040242d9385add49e3d41814983ef377c65fa9110ca0542497132552ac7697e21be08a3b5bac844791c707d4e81df36b6c21328fa8cf44c17c53d0c44ae7722afd5d2df3180ebdcc3436c3b800fb0bb306185ff4f22c7aa8f98deca8d36a0197b5b7b66ba2ba2af492cbfce45eb42470a42ddada3928aa67e3b60b4648b697a46d86abd217942950d0582ae8da1be6669f567b853f0c54d41a1e3601fe92b2c653cf26f5b402df446d96deadac802f1fbd9ac82ea34f3a6760a886b8d993c24fe3fecf89e6aecaa82c06db031b47272f3efa121af94653ec0bfbedb52781eacb320070137ea71c1e961c70bb264bdeee111aa4887492403efdb621efa468a4ad71d21cd4929c3404eef6f87ccdb03b5292e011ca92b2343708355e601d47046661c5d69b6f40d85fc631631e8d4bc048480c5625d9931cfbe6c337d14a6b932d72aab02363ecf490560e7e53c728d77949d786716832772dd12eab5d22b888564cc59bbdee47e1c0c815e872f1f7aa709c5ecaa99f72a87ddce87d7a723f701cafaf3e1815db47d5390554def0c40e158f3e508a3da76d4a6acb9ca6164ac4cbeb9f79ed63c469b1e39e9170d4b884733fb8b36051d6c9a826d35d0578e0f38bc88c002ae4e43053e324bdaad8f2fcbe5843fcb407edd5c70006f3d39c3b2c62b894f051d7e83dad91634ee130025ae0f12142b5897ab5c49e7a2be82213fa1dfd9913cd6ce32fef3346043ec0061833c688f1976100a33710d5a200ce5dd4c7282b5437a9abcfe9cdce7aa7c64beace2cc972369ef4f6bf3e30d1a7bba7627137542bc8f73acf57bc04ab4293195671babc3f9050a98225634b8a38acf2a6af5cc44f0752f28bd00adc0462054d0f69a51db518da40159288d9b1b48c199738cb48e719991e21884aa40872f6538af4191b8e6509982d946607e4517dc55c6f29b740903561b6ce91f602a0f4a016d6675eb9689372ae8fdd879c7cedaa2e0223c69b0877ca4bbd544130e949d03f9bc15974e5f734889e6d1fb16d66a4d56c9e2f1d34e5fb491caaf913214aa9bbae2b060f2f4042b662f24cca83b9227a178e456ff8c8d2f1a4a7be786096425b7f89f82f4cbbafa36583e4b6cc93d9a79d138ddb4b03f6cd6d45de6595dc11b6d30db246a6850a8b9ca80f4db882f73ab2500c5964a2b2f3e6610882e19030283246be38a202ba495d829f7dc6960bd5f474d7bd13a200d159155ec6eb4b085ecdd9c819f03d28ea70c423fa9268c3f53dfb5873738c054b659b491e1d93cb410c03873c25602fcc09b62f43f921bb7ace1291be2a06242e1c5a77f70333b03c821f7940e13c437058b7f6c357d7c82526462f7045560c0d6e75244cd26d38ddf965cf9e167417af59201dede2dd4702e02f5e34ea01e13f9bdf57d3007473e15d4a81fffb33c87bf26b8c93fa0a9157c63a28298f8ab94823cb5ed700cb7e9c03b56a26eba19db3039d62b9a53d5895483c4116d2ac04f9addbed68e8d88feff2dfd2b9f73a08b3e0d5dfbb8153d651cfb725bc2bf04d28fa5c341c2a6895615fe2e2d78f7162585ff6b7b4b4d0054f4507c29a5688b27cd8758ed53278e6e1ee19e586c8c04ec454fa3cb23336c289dbdce4912a8d907e512b139500707f30ff03ff14da0331b4a9a2795155125fab8f0faf7d1d03ed958039f3ad46b45f9b0d3c0b60ca3e2cfab5568e276c4c8e0edba943cd81ecac5a9dc9da6af723e39a130203bf0d3b8a99eb2ee59b1c4178e50074d6112802f854e587b97371cbaf8cb0c9ca55733266312823d75ec1536127c6871a4527af48d9e3a738dccb8814fc4bec4c167e2fdefdf2fccf79867fa2ffed2ec2e3fec5cac98cce4f057ffa9ef24dd05982d4e2b41e1422b2fea39ca1ddccc42158677e4a3efe9838241cb7d2eeca8172cb59653fc4e87ee7feea93631861fcb79deda23fb2882119b4c10f3105301cbbbadab2d5fa6e4e49781ba6745cc0b9332179761ca3afaab630296232b5660624443e1c73e4e5ddf98bfe042a4dc90ca27b6564aab2be54f697c6f8f8037aa4071446865dbdd9dabfa46e1e9d2af8764d0c6443895631db548fcef4b6fa5ed848bd7b5a49220868153b8de0797979afa03eae94dc5ed834ebd44d8a8c8d557251cb6951c82e992181658d3a6f4c2084c2c92f10cca76870e2cace03a39b913a8af096c1cbb78aaac3c5757a800a5b62b2131e0bd1758800f76085f90845254389e5dd8b743d190c3bd071dfa396a8f178662acf65ef46c5cf4d06f5b6fdbf731fb7659ef51ab580798f96d8f2c1dacf3a9d675286b0577f928717132148cf5e8765398bbde09510dddac6bd21707d4c93e5b87f188fd6223fa33a155eb0ac2c8f7639d18133b27cde000dd5c918bc89b3844297d8b8536d4d954904bfba48f3e8ae50ec2f73fb19b5b9c54f4f70d67f30336fab151ec946ab0bbeaa40075eeb1a26f4c641b66d9ec0e0ca7d77da4c7ef743c608948ab61420f8d43b351806a5ebb18d761749d7a3f142d8158d6d1575e6b51232b1ebe6a551b9ce97188e200213cd180fd5d9143cdaa6865c8eb0a36daf743c82833277a5d9689a11ed28f9f1ec692ccc230b2f64a957b116858cb7d4425ddbe12b58ac0c86cf72e1762d5a7f85fe7d8d1c0946d0c3d8dac4dbdb7e61c6a0644f09987f1a53b703cd4c4a6e780d4b0d40b8f95262af21cbff55dc4e7585632f531aa7f0b28c4ad2fa4041024d2d90d20eaef1cf9fd492f05969e46a710b78c186a944d92eaa9b37e9c29655944ffb602c7b17c077f1e05994ff4c510b8b76b8b6321c842ad19a35e4c555c2ab6166057514822dc67c137468dbf6b539a376f6d5a0ff6a1e71d6119115d9ae52132f83aca7fd7220aa0e9d1efea028212a1b9ff4495e293ebe4925324bbf30ee63582ad255e288498494a687b9788d33427ec34297f7056948059097da79ed04e20d8c847b59abd86fb07f97456184dced454bf89a3bae9b3e16e3857ec9cf45f015064ed2db34224dffe85d4c3d8d553973fd74f567c27a91cb42c83da860498b8f113972aa8ae9341869f78ef1a0d8034de4fd85c4655e77164f13f14ae367ddf94a8427dfd5c5bd5006317e32dd215a5a6a1503d2b3e53cf559f3f6c5a993f1f413969e5630e5b049e033b66833f95dc28da4c9b9e3bed91528f44acd27afdaac505b2fc9f2eb6dad62fb9720647b0710c3bf1f066bd841790d31982d67193c624807016669c8a8bfa26d3aca08774a48888f0cf4d99c1940053353202a001e6db5cbaecbd1434f4d25ca17ab815deb374a2eddca0e65e3fa06fd02fc97c08d72b25b7e7e1153ab9d90217de408ffb0ca23aef39f41bea70eab65bc4746c4b8a5cf7af28919df04e425d8ce9bc15e0b135ccc8f5a2c540bc13f3ef737a27ef0eef359b86095d714cb4d448b5b85e653f2370a26d8385b37f44ecf63af52847682a3ff94a33a5ee790853f9ccdf2e5525f1624726c66d97bdea90267392d89ac4f75dbb070f6dbe98ede009d3418f1ffc6b316ea63ff4cf10c02064c9cd6db4a37f990cbab05a15a8a6474ca12bde6114e8d03d6334ed68f86860b86f4986d2ae8020e60904b2b257a7597a5f6ff3281d3bac9ed2f78f92ceb783704dc799049cd7cbbea737854e2ff5f7d520a4ccf44031d21629bb00bad6b12e128a76c4bed27231f032b622ffaffe23218da3ab8b7ea7bc9749bf910eace16e62d8000864d98fccd43de77928c9561124b95ae4b761ba09491df41176bd479bc57d2d4840d05b80b66ac097e3fe44962484a5f3f2bad7cb3f37e580473756e68ec53d98f32598fd7957dc94f5c7cfcb46d1cafbecf62c766930cf37b334377b932c60ac956bc58383605b0ee514009ed022ee26ba73167b05cd9562abb92ee14c657494ecce0b037e737b0da5a91cc2865d21f22f23c5525ca74743d476a2d57e8a43952d91a27300ffaec09ec472621a82b2b448a9020257f0626946f2067f2107dfe587acd8e6a5fb9016b9afb8b50867a47c9ae81f23c466b4ccd69aa3ea89fc193f06472b54c478cdec1c52a237d6e2e501690951cfbf57c9bf6b8915d26a6c8617b9f6c612cad1a359a832742feebe15f1dfbc4f54e0bbcd7c1caa24199a1014c88c9d0212a3cc910921e2a848cc59d36b426732659606c7b38516415953681a8f1dfed4752e2a4a5ee37b6f8b7add5291809abbe705cda304eb084c39c1a3859d396da2fe7de745bc9576beb8c3ec5b42c85e88a4738dcb38e812c9fda40b10d21269231e73c2b1fdb8c5db6bd6ba4051dfe6c309ff23a4fa11f42dfd3b08b2d2366ee956e83b4ec2a203c2f0b319e68d54e5a2872a335e0810d7cb56c24c5c42916416b2582b410eb803679df54944f921f59728754168408dc978e36ffaecc387eb0ff77fc87c9a720a47c0e5200d717cc74d3e6e88e32913e2ca155663fe525d2fcc00a120642d34075c399db31435f30b82db4a80535a4349a6a3691c4492d902af006c210800b74c4ceef171918728b2c33af30af13d68d3928f0ccfcaaf77a21e1b48148553b85cf369250d6130f6c9cef62c1579d800c92da142c1cfe5d8138c4ae7eda11b4efa93b1766d723334d241b6b0c6228de46e522e4800ae525852d6bf2dc904a5f99c5113019224a074a1c73122cb40aca627bfea405284ebdd348960c45f737d379ca3e42d85caf133f234480fbc0cfbc40078ab6d3e9af0533889da8636b2bda6ffce01ee9cf2245b2eecb5316d1064c57b9d3318c79f572581a641a1e816ddf18528cf60805d9fbcf5c65531ed9400a9bbf148a7295c64f3f24b60eee74bed4c4952c0d4495f136ba4758e50d1c95ada97772689dc7e1ee58a12acca8e2a280fb5a16c0f369bb1c3c8a3f905a55d141e5a58576284633d109612e39100490b03807a6a6ac42a9f3f9f380d788800abe699eeec1c9e922be610335cc6d29bfcc5d98b1e0ae4b9df9419ead63c8744d6e401b9af7af7c0a88e578bcca1984730a38c9ce5bd0eb1b80486a8c714d5a2bbf77f4e5b88ec8bddf22f2d766cf82c6c5415be0ae8973a24873135a5954fa5f3598515e53974c94a938f64ae8f9250cc7198f3cab0d5ed95c9cc7c729dc341296210f048a015e48f17345f3b13f3a6123e4b2e54b6f46b153a3d09b2df4dfc025a19bd0ef466802bb0bc1b689554a5f782c846b1d656c7b121d0a34d6b4258c25ced50578a7ad76556cbb23ee600297428b59df3b75d957810d761c8c560a4b985fffe8fa83e773ba2732370f2cc360b56982c594d98eedbfeaf20191838ef6c98007b8774fb0faf09ed547453ff0af5a5b96a260eb670db16142faf0e52f92c9fc63ad8f6dfd79be172aa13bffa027f75a75bc285b484336abfcb5e7b8253cb3e140b3b3855560784c7193fa39ec0c46114326cdf5b07340ee9af7ab2b03d406b6f2b87341362fc984578654d6b91693f99c676bd16a6a67e0eb19cbca1dd3a90dd50a79b659202196d93bc9c7c45b91b2bff1c3996b0ab10b42c19f1921ca44bc0c7a4bdaabb5a8303b5c094c7c1fadf2036bab2f064dcfa5b62d61ca443122d65ab3c91549b406a8f2d19888158ed1f8fe3b9930173357510d31dfc80077632b45a67a4c54c616702bc071495422b4554776ac64f09623b752740941f92d3da3c249d175c87bc9ee6d94d73060106dc00b91b5d7b1aa852a04fb3624e4ca50b37bae73ba0eacffd053b4a5b17fb5eefe639850856edb15719b8c56d4bd7e2e9a0b8764be20b0b3a26250670dfcb5f2cf4ff704cf056ee74c91355c1f682d35e70cebf53f2de81706eedb3759b769b0893930e2f27062878924e8daebb01187a951a54d312faa4cd88877dec14782d6e88374266ff6694a7e3402365454e4eb9b172bb4f56974a928e759671d68bb8ab55b745d354520a430043b7a89438977f72973b0a9a11fa1e7c971e885d488e3cd731f9a6ef7090c9b520828075232393133de0800af2af816a6703ca32e6a391386fe2c8349d1ae4d3660900a3f3a5f16d1a85915219c7f3fdf025c37e7a091cae40ac9048a6c2094ce9186574bfe42111280547cdbb13a5c66637cc9589b03ad625db8079d59088c164d0f5aa080d2d64d15cc0904071f6792131c7e69105ac69c7c5dc9eb7ec3b4e290374754413828193c0ba4675a80a48c92539c4a547815ab877aeaeaa50e4ca31652029b2e620c881c9ba27d8026f5a6e09c88e136556f25967a3d7b27337b57d50d49be043fb68f5da6e3e58cd0f13168a791d9d548722f79b7c31bd8b8aed513dbbfa2580f7c689b7b877348c256753a9dc7485f6d2c5642dcd00316706eb8a32288c5e4cecfd5c279dbcfdedf99bf321d5056c5dd117e66471004777cc06ced779a824b4d888f2c40586286c72b2be8f8679de3ff4bd3fc7b06e09c009b9e433533db1452271994b306651c5253461b72635b7d20220da8f9b535288d772db709c9fee9c2e83325d51fba931b14647333def1667dc81667d27f5e35dc6187a56e235e2d907aeaf886e0f82d9ca064aaa9c958a80fdafdcba94d7e14202ccb320c40ae3e1600d67cd4a64ece4b06d2c725b1d36aa0d21d8ad8df218d6fc53c707ba6c5aa3bc9b5304feef49e468ca97daf3969b40d7bcb0f5f3dababeac424712e189a6535b2e9e1c52effa9a012a3eb630f024c234a9fa6f2888f89aa05deff0eacf4ac592a8d30a3f5bac06ad6881aaf4761700fe883fc7356f41e3cd6a07fa1becf7338d1ef623def24435aa8d231e477e3b3e087165e162217d1ba967cc62eaa4e5c5d5bdb5554eace165cdc30d1f92e50ae2836960419d5041d1528a75f4a205a38cb43fb5232a3020cd87f31117b36994cfc72252e4c1fdb951143c77a20e50680e4f30f8676bccbc2404a10579b55d8970c3b97d32cd5ca5c6652cf77202fbb5768d1acfb93cbd2932079fa8c19ac930e95e483487d6d308a8e5ff952fd795c10d3400319bf67c8c18c45132135968d375a49cf834b79186df79cae338b573c09b54a90a7cdcd477e554de84909af6da4d4970f83234d876e07b722e35215436388e87f20d1adadfddca84883c065903e007f863f9046b6f7fe6f1e3d373ca1dc51c33cf14b5bd82ae17d6445f9c004aff13d29f8bc4ea87f8a4fbf4d9d54588f53b8b3b0e24c4f1143d4c472bb6c5cbc6f2f2867aa51f24a0f6016b38f6a93a1903c8e66d766498344bb3bf960e764ac72d982714ebc1cbf33f48b6aae83e5bf596afe9e47365853a5305a985160ac41e8ec810c39475cc2b176dd7cec2efe96d069cb4e831c73449e8960899a65bd8f4c6b773c183a3f9e8e6403c2619356fb7fc687c6cbc1dde75a9640013742795785347a72dbefd1a5a3332a1c039f169e4621ae303f523d03333864059834bc29d7607c7385c969c268d692c61db850e388b416686f6d2d3112deb27212acbce3590b803aef5e26b7550aed815fc65dbcaf2e7f31178397b2e3ae4d7aed6f91423c93350d0f3bba49e6639f6d56ac1dbf1c07a3b7f4a6c20b6cb592cd1c82509a895f628e1000da06bd89520419f138e77a4435f926da4306093618fc7151fe99e4ec2e5b908b6e2eae1c57b01a6327ab532da5a2a4f00b6a8b5af0e8f6421c8b7afafcf71f3f4db73a350ec299443aed949c24a46efd182b3f6f3ecb4d5cb2e599aca4a9369ea299afe0a88525d870fa6cdf489be8cae718becb7b475e43b4a06bda6447785157c0bc63087a6f82d538edbb3883665ee8663bad2743666ee27e226d657baef8db3746d8cba3a3b07266a57dacc63a0f320f8d392e616ce587d8b2bc64f38747a65f8cd8cfa26e5c0d3764bb37ede3b00ee6cebd60080df9040ef4c6736aea0b9718b6efcf1fe5d776ffdcafe51a589df19d4a137d9bb79c4dda8ef43b18317f1688929bc6aeff20fc22063adfd951f79ee05fd85bac65c185b52521cf135707b7a6116837df39e4460be1fbc42722191b9be8c69ac39cbd12a0efd1d3904fc89aaf2270246c394a5e3ae4b4dee53e5aeac073d389a130c9b835388afa48f849b0bea07fb126fc076c36262186fcc441cab408cd2f528cdf02aa1aa1b819d2e75b9f628668516c163ac4e5493ba7e49a3e65adec5c25db37f8fd9c2f9331a4cd77ef0c78e011910ae1c13b4a0be3bdcaa48b9f0cf818b978b39a330235f08156237ee1d389b9eee0daea786272ec7594273ba35c5bad984b055bb4faed8032f1fcb7564da7a040af530e607bda7ac156293d1032d6f03198e191f9afa725ca2c37a4ab5116a21f7673b5e8681f572a8ca74233478e8b9d0848d339318f40575a44ecb5117c8287c9c2272d5abcfa15c2452358b279f46e4e703afbf403ada4944c136f5d37c17993184693687ba268c62362c1cf4e2b526503dade374e517bc2e0fb6ce91cadb34d783b49080b43514db5a68958f0e55de15bd361f12f06d202e5844751c10db76b0be72974b9670244f4f6cc36fbfe972979918c5c04474731cc22cf2541ebefa04ecac92bcc5f8279c4bbf4743bdcfaddda22018645c4d19fe137a96873c1d9b8987cb6ea3fb8bd47860bfe7433d2b77a69f56bcbc69d09bc21e8d7021d538e6144ec57a5226a74ad6822baf8ee8dcbf678827e180bbc4486e715a672dfa99d5e300de3b5171514df0dd4c574666c842a8b161b7e2ca595eb7c44d7e6a1172e50b5f646ff551ef0ece1a81749a165edbc6dda0d6ca750dc6abe08b5744c986a0f8c19aed7802bac52d9e4bb6e06cb714b62692230d6a04a93d5dd45c01d41da8160f83d202b9a983b182ec30a1daac1d7b51dd6ac199d76a5b4c2a518111b5e454f455de721d424e62e152dca7e1c43041597a3136aeec29be88fb4ce1c7f4071b9deea4370df56773aa7f9ed938be4b13a00bd8d52502ca86ad1aaa6df4f12ab78af5fad1a50c2004787b867eaab1da0a170af73af4dd08c0d27756f78832612edc4b6df27a96cf3257a3e45286508fb0e8cb8cc9783d2dd1c886e292a989b0c850f78e165d03286cd0cf27e8b8e4a5304c597865998c268c2893f96e3e8318cd7099835b10ec40ed4fa136d64ccd112a22c3f69bdf277a91fb94fca6b4c234da36d3884b8e84a28709e45b9f0f1b4768581c6f2111f26e07261d970a1b37cb62058462c451abf42d898a3a735ad0b0a151df670f5436074a00e22408f731fe09e867b790f11b245630f642bd03f9e436deeef14a9cece338c49ab4af5ee1fe075723f97e6399cd063794a85eac37f42da9c2b1f94912a77fb8ac89e1258259d7a064aec078e038d31428c92080047c55778230594afbacf09e01e3c07493e824057941684be5fadad5dd9cda7bdfd787667a0eac6ef8e06d7318487ca9e5183c5f456b9004abf8ba07da0bd998dc513d4c18bc5a913c0a95aa4d525baf19953777027f627f09279d84223cdc88700f63741a15ff59ab2c52be5044454c3290bcff690922ff6ebee00272e8bef8e63f02b005fa56cbedcfa921f6ae0b120d2705b7269519dd262d85b2b05282d856bbf8f0362989649e673c455a673f396135b0faa235bd27c18689c7bc5f12d7c84304ca30d9addd7bef75261fbf0bdff66e3106273e181aa16d75fe513b973273d04c11647d514f4339fdff5ceb4c4e6da92812a95f04c5c469038a18bf9d9e3cfefd51fa93f26a99593102151f463dc54e950f46aab440a972a840031e160831d667d6576935457a90f8d678a46de65bcb7e5201cba9f4fb12244574c55504bdd6efa476e3c4e4335345fb3f360a9ced4bd1a4c565019abba7c34c1fa90e2dc24c1fe22b2666a36c8db5238955f5588453d913a110957996f35ea6839eba621344be55d3d4e0e839bc352f5c9b4b5ffecef67203e3b37bd5613341869d62bdcafb2afbeefbf10da88321a72ee08a21e2470a8a239a2be92559be2abd92f2879dbea4b757fc37821c6d5edc08a90623ce058101edf582996a50a018d9303416cc7df9215c08ecabb8e3950e9d57a9a28677c5675604d5f47b9941f7c3fcdf757465672c0cfd3ce936fe2b3f5f23712a89bd253836beaf037860024402057e684580dca32284079491b5effa04ddab84e56c066496580e945bb11e321f77dc8a3978873ed693b6172832f33c16e232861107147875437896e357aefd5c08ae80365993c53197bb3489c9a99c2d7f47837f1f061e862764f846f8fccd1ebe479e55c2496771f22bca04cdc347de5abb47af6f40ea4fdfb4057947bf8b394af24f8fba65ffa1d4e40f2fd827e823d356b1d9c42de3ff6958db1f78d0c4a3d256516fd968402dcb0c53bc67b86b9056a78cf48f7ab88eeee0639b303f8225ca84ee34118b373a7316b27139efeb449c93ef79758e43c91fde9fc2d25c568a6dac6d223ca2bf29289aaab1c5bc70c378d4a23803672b70a2925a25a61b31e2215b2a3a3897871d638c7e8163b3a071deb66bccbcc45f6b1046fabef08b6747261e3fbb9f747f2238de9222244e539f8d2f691aeffe362f17111c4c92a932454fd078728e4146d742fd3f1bbd588ae75f7dabc4735809832f2efc7dc49fd233845720dabcd2c118821b9271dbd73fc66a3a4bbcf449f33b369334d1d11bdcac569da62c53c3938743592c895d414416c2041ee9832dd7e48af3f0613e3bd35653ac23e2d49d9e2e088471877029f11fb3de7c936938a2598c08a3f4c23b4e9a63cb45da5be8710ccc5c46673db6ef47cf7a06e4b6b50dd4caadcf31bed747ca702744515687892376466189ebd1724dd32622c992e0eb6c06551aeb00101201483702cde2bd67bc65dd6b8962de93aa924e953cda3e43a2ea261bd113b1b971b3ca42ffcaf361037b2d296f169669d43ec373c60a697cf37b63d364f6cc4be689d1c454769f02dbef189ce0040b5874d4ab494e809b8d58b66b912afd4de5268c91611b67115bf1521919d9baa90180d9f97cdb3caef5d5f68cfef2d25dc55b41167b9d8cf0c7ecfbebd2935e603dabcc8f6ea341c006756d14d9a292461dfcd95719451240ba3018dcae63b3b25b569780eeb4c408aabf83f124c23c7245820a05ae6f4e37fcf1e090601c0a0eebfbb922cfd89ef21221359525e463a4a1229fd29da05f58e02ec0b5b0490a985e3f5f0018526405b2ac5fc4aeba7a3b1d7add65fc1e8766dd0dc5282b5fcf531c6d4486007a41fd7f2318475c647855f930122dc5a125539fec1521f70fae696d04e0d0b6807db328422a6c0938981194971bd25475896fab6064987a7f1ec4d9048393f6f6aa0882f35915b78f3d0b1f055497b41090d15c353185121ec24ae9542a0835202ef82c689ff10d112f46819585a2e89c55ca37023058632fedb765a81be4455140b1f6f5b87c1bffa759b53878c310b4a90011f5a242dc49ce63388184c6f9fc1c9e8207a4a2662ccf025b1788499b6f1c3d30eab4577d17c58d8b6c2764bbcc205b936fab2fcc4674040133a4b02177725b583783a179059ad35071dce715708be4f39f80657076656cc3a1ac24c3cfe9b11b81f5001cc8c2762a9c367421fe7edaf1935169b034e53e453ccb6c4deb0522af863495e172a011ba5f64e992c047cdc13e3693405273e30dd6e0fa75fea55333dfbe1f0fcbdcaac3866f3c7fbe91b99b8c7bd90a70ab39fc9c2a353c7f326e9c90dd507537b9f009adca46f92ee7fbb0e263e9edbc8d00dbde7d9aa8486553d8c00613306542976dcc2aa56e44b0da986e45543d0ad8d3249a7b4660ef128df76fb7176fec853a0410fc579f22068a84ce679423a0e985589d4c2803157905db8d0d98d73c0c69e446994ab7a5a0644ca3fbf2cbda7ae7e0d15a5ed04f46d2cfca5e9ea826aaf42fefede77d97dd29ae911a42a20b2a41b0b549971a1f7b7d20a9aa34bcbc1fb5fae2b8911d3538960437cc8e09fc03d342351841db08db2c5dfb30e47bd8cc8d16de4a99f81f2652d51b9db91dd3d96003aae0efa5577004a61ec380648e60eb5eae1a86dfd52a78b9ed59542d52fc256abafd07f2f7c5c77315af0b38b2f5728f35191d93affadd725beefe86130bd59fc00eae8882f5a99ad713b56daff9cfd5e3cfe15bc8d660e9e0586ddb5703ce6fd0c02436650bc58d0908fa4b06b89f09d87bd4b9887f5ade72042200f78a5d9f89eede860d750e6a33f291df0c3a973aebb059987d04e71fe946c85eee1dd834e40ef94e8f7adf9a9c9433e463971065e80bc64711e04bbf40fa93861f883bc319a8dfa5eb40589f08a11265022a825d6578be4cf3605ce266107d4f2ddd5bebb365100a9a090eae269386d4a3c164e940938fcbffffaaf9ea68d0c1a388e3e582dd273365a0ba1de6c96e8bd755fe8708f31399a8f266e4a4521c6c889d8e3348cc15755702727336a73078d52cdfeb127a235f6ebf50eb624562d38c317f6d8abc354379175dab160e37949332602751bb02724c7b304f51c1a2cec6007088e8b72a826c9502cfe655bfb550217191b27b070028799fc253767e3bb6372effb03690e60ebbcb9fe71fcd661d939e326cf94c4192a6a52e20a6071a33a882a8d6cc737d29b47375c529b963d6d398c61ae2bb00de50c58b164efe2bb0a33209a08e170f5d927c23b1324e0b77e44c06d5a7000029e77cf7662f8c44242088e369aa82d82ff163e535a742b7323bca4674a28f7880f773a93c4b975fa743fb0a6ba931bfb655b81f181b69f0b1ffd99e6d74c0806468d8a437389d2127d5599d33869c18fbd4d0ed854a3f4a398e8f4826ac9b1f4f0c7fa40de2b9fbb4782f09451b318f320be1e3ba42639f77bb12d306b9a7caf97454849583761768ee3bd742fe5ffd916aaad66ba9afbf88773129b2921ea1f1c46f4d6d133d9bcc5cf8d4eb083e107f767e8c30b100719d545a02ce1952d121559d738559dc00ff0e4b38f2bbadd19784e254b745feb873146d7ca536ba79d9cda173c27d6b1cb4d5f33c73f172d14bd501e57a385c43446dc16cc895110845c2abc3b14fee28a5b029d440fa2dda50ed767da56dd3ee4abc9561436b151c525728da4d68802212422d9007b495705ff5bcc55fa78bddb9e97ff75379cd057ed8c7049ac9f5ed94db87ddd17ac7370bfc6b46cf9dc55cc7b805f8e307cb9476ada0490033b6963335c72355217580702f5fa51b5947e797997b0f2bea58606bceb2faae5f3191682bc3afcf6c9c97936dd011171e55fc86e9936394813abd5f23382d81a8391752383da82336992ce0a100094381e9b8660001880dad78fa8b114a82b9f9c08031ce642502704e91cf0ed9c0ccedc16ab58fa9e5cbca833402036e3ac9de32fa1113fda07231b9cd1d59beff0258ddc5e93eb91a694e2ad5876d4d7066cc244f44333bd1ddb197799c1c60be43e0d9342ad083ca7679808276395ad1e0e830e8023609336a226a1db028e5ba5e7840d9efa0d715e25a35289f689e55035413802d428d903d7ce27c9b295f6fd551ccd580e681ab80128da8a56bdf39fbec8b8236df98ab6c818f6b695fa9f3335db6c1c02d12f7842802db7fc9b588ccba71475dbb824e890a82f30b8224dda716a36988b566dd5e3573f13b822a11ca71c791701dede8abdce4f43e1284045409285dab27db368bf9c5f98102fe66a4c68fc76aa2f2a2789cbe50fc68ad7b733653099872b2fe992ca1269acf478901fb2a0f42e214e5bc1467c3af975ec22be6af93fa06994da9132d085b26a30603ff76ce4a1c99f15c659a0b634b04aed3ce3ce0a6dc7544f6ed1a7f103ee8c08a12c00666be393333de1c41bcdec9974aa91cc52a5ff862ab99a9ad9bb9ae1f071ceac44c0c4b37f0478ab882c047afde695c83c3b316cd05e61a07e9099ddbee50f5b0ae4da37c613767c3555c13fb648462880af32ecd56ea712c298bc458cf37c463f093b6eb3c804f03682d06ed35b2b28227e46cb3b5e499adc0b1d12f8a87c2d64f1f4298b299b476ca13f1b41c0ffc5212be115e3a212def7d4b836095cdde9661340bbe684eee17cc4aacfafca3e45be7be5d35850ad705aade0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"73a71f13e0bde47cb1e692bb25f2f545"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
